/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ "../node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js");

const AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi);

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ "../node_modules/@supabase/auth-js/dist/module/GoTrueClient.js");

const AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__["default"];
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient);

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GoTrueAdminApi)
/* harmony export */ });
/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ "../node_modules/@supabase/auth-js/dist/module/lib/fetch.js");
/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ "../node_modules/@supabase/auth-js/dist/module/lib/helpers.js");
/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ "../node_modules/@supabase/auth-js/dist/module/lib/errors.js");
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



class GoTrueAdminApi {
  constructor({
    url = '',
    headers = {},
    fetch
  }) {
    this.url = url;
    this.headers = headers;
    this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);
    this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    };
  }
  /**
   * Removes a logged-in session.
   * @param jwt A valid, logged-in JWT.
   * @param scope The logout sope.
   */
  async signOut(jwt, scope = 'global') {
    try {
      await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/logout?scope=${scope}`, {
        headers: this.headers,
        jwt,
        noResolveJson: true
      });
      return {
        data: null,
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Sends an invite link to an email address.
   * @param email The email address of the user.
   * @param options Additional options to be included when inviting.
   */
  async inviteUserByEmail(email, options = {}) {
    try {
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/invite`, {
        body: {
          email,
          data: options.data
        },
        headers: this.headers,
        redirectTo: options.redirectTo,
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Generates email links and OTPs to be sent via a custom email provider.
   * @param email The user's email.
   * @param options.password User password. For signup only.
   * @param options.data Optional user metadata. For signup only.
   * @param options.redirectTo The redirect url which should be appended to the generated link
   */
  async generateLink(params) {
    try {
      const {
          options
        } = params,
        rest = __rest(params, ["options"]);
      const body = Object.assign(Object.assign({}, rest), options);
      if ('newEmail' in rest) {
        // replace newEmail with new_email in request body
        body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;
        delete body['newEmail'];
      }
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/generate_link`, {
        body: body,
        headers: this.headers,
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,
        redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            properties: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  // User Admin API
  /**
   * Creates a new user.
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async createUser(attributes) {
    try {
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'POST', `${this.url}/admin/users`, {
        body: attributes,
        headers: this.headers,
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Get a list of users.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.
   */
  async listUsers(params) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const pagination = {
        nextPage: null,
        lastPage: 0,
        total: 0
      };
      const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users`, {
        headers: this.headers,
        noResolveJson: true,
        query: {
          page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '',
          per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''
        },
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse
      });
      if (response.error) throw response.error;
      const users = await response.json();
      const total = (_e = response.headers.get('x-total-count')) !== null && _e !== void 0 ? _e : 0;
      const links = (_g = (_f = response.headers.get('link')) === null || _f === void 0 ? void 0 : _f.split(',')) !== null && _g !== void 0 ? _g : [];
      if (links.length > 0) {
        links.forEach(link => {
          const page = parseInt(link.split(';')[0].split('=')[1].substring(0, 1));
          const rel = JSON.parse(link.split(';')[1].split('=')[1]);
          pagination[`${rel}Page`] = page;
        });
        pagination.total = parseInt(total);
      }
      return {
        data: Object.assign(Object.assign({}, users), pagination),
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            users: []
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Get user by id.
   *
   * @param uid The user's unique identifier
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async getUserById(uid) {
    try {
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users/${uid}`, {
        headers: this.headers,
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Updates the user data.
   *
   * @param attributes The data you want to update.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async updateUserById(uid, attributes) {
    try {
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'PUT', `${this.url}/admin/users/${uid}`, {
        body: attributes,
        headers: this.headers,
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Delete a user. Requires a `service_role` key.
   *
   * @param id The user id you want to remove.
   * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.
   * Defaults to false for backward compatibility.
   *
   * This function should only be called on a server. Never expose your `service_role` key in the browser.
   */
  async deleteUser(id, shouldSoftDelete = false) {
    try {
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${id}`, {
        headers: this.headers,
        body: {
          should_soft_delete: shouldSoftDelete
        },
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  async _listFactors(params) {
    try {
      const {
        data,
        error
      } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'GET', `${this.url}/admin/users/${params.userId}/factors`, {
        headers: this.headers,
        xform: factors => {
          return {
            data: {
              factors
            },
            error: null
          };
        }
      });
      return {
        data,
        error
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  async _deleteFactor(params) {
    try {
      const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, 'DELETE', `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {
        headers: this.headers
      });
      return {
        data,
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ GoTrueClient)
/* harmony export */ });
/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ "../node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js");
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ "../node_modules/@supabase/auth-js/dist/module/lib/constants.js");
/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ "../node_modules/@supabase/auth-js/dist/module/lib/errors.js");
/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ "../node_modules/@supabase/auth-js/dist/module/lib/fetch.js");
/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ "../node_modules/@supabase/auth-js/dist/module/lib/helpers.js");
/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ "../node_modules/@supabase/auth-js/dist/module/lib/local-storage.js");
/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/polyfills */ "../node_modules/@supabase/auth-js/dist/module/lib/polyfills.js");
/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/version */ "../node_modules/@supabase/auth-js/dist/module/lib/version.js");
/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/locks */ "../node_modules/@supabase/auth-js/dist/module/lib/locks.js");
/* harmony import */ var _lib_base64url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/base64url */ "../node_modules/@supabase/auth-js/dist/module/lib/base64url.js");










(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_6__.polyfillGlobalThis)(); // Make "globalThis" available
const DEFAULT_OPTIONS = {
  url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,
  storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,
  flowType: 'implicit',
  debug: false,
  hasCustomAuthorizationHeader: false
};
async function lockNoOp(name, acquireTimeout, fn) {
  return await fn();
}
class GoTrueClient {
  /**
   * Create a new client for use in the browser.
   */
  constructor(options) {
    var _a, _b;
    this.memoryStorage = null;
    this.stateChangeEmitters = new Map();
    this.autoRefreshTicker = null;
    this.visibilityChangedCallback = null;
    this.refreshingDeferred = null;
    /**
     * Keeps track of the async client initialization.
     * When null or not yet resolved the auth state is `unknown`
     * Once resolved the the auth state is known and it's save to call any further client methods.
     * Keep extra care to never reject or throw uncaught errors
     */
    this.initializePromise = null;
    this.detectSessionInUrl = true;
    this.hasCustomAuthorizationHeader = false;
    this.suppressGetSessionWarning = false;
    this.lockAcquired = false;
    this.pendingInLock = [];
    /**
     * Used to broadcast state change events to other tabs listening.
     */
    this.broadcastChannel = null;
    this.logger = console.log;
    this.instanceID = GoTrueClient.nextInstanceID;
    GoTrueClient.nextInstanceID += 1;
    if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {
      console.warn('Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.');
    }
    const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);
    this.logDebugMessages = !!settings.debug;
    if (typeof settings.debug === 'function') {
      this.logger = settings.debug;
    }
    this.persistSession = settings.persistSession;
    this.storageKey = settings.storageKey;
    this.autoRefreshToken = settings.autoRefreshToken;
    this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__["default"]({
      url: settings.url,
      headers: settings.headers,
      fetch: settings.fetch
    });
    this.url = settings.url;
    this.headers = settings.headers;
    this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);
    this.lock = settings.lock || lockNoOp;
    this.detectSessionInUrl = settings.detectSessionInUrl;
    this.flowType = settings.flowType;
    this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;
    if (settings.lock) {
      this.lock = settings.lock;
    } else if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) {
      this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_8__.navigatorLock;
    } else {
      this.lock = lockNoOp;
    }
    this.jwks = {
      keys: []
    };
    this.jwks_cached_at = Number.MIN_SAFE_INTEGER;
    this.mfa = {
      verify: this._verify.bind(this),
      enroll: this._enroll.bind(this),
      unenroll: this._unenroll.bind(this),
      challenge: this._challenge.bind(this),
      listFactors: this._listFactors.bind(this),
      challengeAndVerify: this._challengeAndVerify.bind(this),
      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
    };
    if (this.persistSession) {
      if (settings.storage) {
        this.storage = settings.storage;
      } else {
        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {
          this.storage = _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.localStorageAdapter;
        } else {
          this.memoryStorage = {};
          this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);
        }
      }
    } else {
      this.memoryStorage = {};
      this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);
    }
    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);
      } catch (e) {
        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);
      }
      (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener('message', async event => {
        this._debug('received broadcast notification from other tab or client', event);
        await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages
      });
    }
    this.initialize();
  }
  _debug(...args) {
    if (this.logDebugMessages) {
      this.logger(`GoTrueClient@${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_7__.version}) ${new Date().toISOString()}`, ...args);
    }
    return this;
  }
  /**
   * Initializes the client session either from the url or from storage.
   * This method is automatically called when instantiating the client, but should also be called
   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).
   */
  async initialize() {
    if (this.initializePromise) {
      return await this.initializePromise;
    }
    this.initializePromise = (async () => {
      return await this._acquireLock(-1, async () => {
        return await this._initialize();
      });
    })();
    return await this.initializePromise;
  }
  /**
   * IMPORTANT:
   * 1. Never throw in this method, as it is called from the constructor
   * 2. Never return a session from this method as it would be cached over
   *    the whole lifetime of the client
   */
  async _initialize() {
    var _a;
    try {
      const params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);
      let callbackUrlType = 'none';
      if (this._isImplicitGrantCallback(params)) {
        callbackUrlType = 'implicit';
      } else if (await this._isPKCECallback(params)) {
        callbackUrlType = 'pkce';
      }
      /**
       * Attempt to get the session from the URL only if these conditions are fulfilled
       *
       * Note: If the URL isn't one of the callback url types (implicit or pkce),
       * then there could be an existing session so we don't want to prematurely remove it
       */
      if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== 'none') {
        const {
          data,
          error
        } = await this._getSessionFromURL(params, callbackUrlType);
        if (error) {
          this._debug('#_initialize()', 'error detecting session from URL', error);
          if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {
            const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;
            if (errorCode === 'identity_already_exists' || errorCode === 'identity_not_found' || errorCode === 'single_identity_not_deletable') {
              return {
                error
              };
            }
          }
          // failed login attempt via url,
          // remove old session as in verifyOtp, signUp and signInWith*
          await this._removeSession();
          return {
            error
          };
        }
        const {
          session,
          redirectType
        } = data;
        this._debug('#_initialize()', 'detected session in URL', session, 'redirect type', redirectType);
        await this._saveSession(session);
        setTimeout(async () => {
          if (redirectType === 'recovery') {
            await this._notifyAllSubscribers('PASSWORD_RECOVERY', session);
          } else {
            await this._notifyAllSubscribers('SIGNED_IN', session);
          }
        }, 0);
        return {
          error: null
        };
      }
      // no login attempt via callback url try to recover session from storage
      await this._recoverAndRefresh();
      return {
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          error
        };
      }
      return {
        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError('Unexpected error during initialization', error)
      };
    } finally {
      await this._handleVisibilityChange();
      this._debug('#_initialize()', 'end');
    }
  }
  /**
   * Creates a new anonymous user.
   *
   * @returns A session where the is_anonymous claim in the access token JWT set to true
   */
  async signInAnonymously(credentials) {
    var _a, _b, _c;
    try {
      const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {
        headers: this.headers,
        body: {
          data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},
          gotrue_meta_security: {
            captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken
          }
        },
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse
      });
      const {
        data,
        error
      } = res;
      if (error || !data) {
        return {
          data: {
            user: null,
            session: null
          },
          error: error
        };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', session);
      }
      return {
        data: {
          user,
          session
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Creates a new user.
   *
   * Be aware that if a user account exists in the system you may get back an
   * error message that attempts to hide this information from the user.
   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.
   *
   * @returns A logged-in session if the server has "autoconfirm" ON
   * @returns A user if the server has "autoconfirm" OFF
   */
  async signUp(credentials) {
    var _a, _b, _c;
    try {
      let res;
      if ('email' in credentials) {
        const {
          email,
          password,
          options
        } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === 'pkce') {
          ;
          [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);
        }
        res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: {
            email,
            password,
            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse
        });
      } else if ('phone' in credentials) {
        const {
          phone,
          password,
          options
        } = credentials;
        res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone,
            password,
            data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},
            channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : 'sms',
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse
        });
      } else {
        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
      }
      const {
        data,
        error
      } = res;
      if (error || !data) {
        return {
          data: {
            user: null,
            session: null
          },
          error: error
        };
      }
      const session = data.session;
      const user = data.user;
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', session);
      }
      return {
        data: {
          user,
          session
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user with an email and password or phone and password.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or that the
   * email/phone and password combination is wrong or that the account can only
   * be accessed via social login.
   */
  async signInWithPassword(credentials) {
    try {
      let res;
      if ('email' in credentials) {
        const {
          email,
          password,
          options
        } = credentials;
        res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email,
            password,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword
        });
      } else if ('phone' in credentials) {
        const {
          phone,
          password,
          options
        } = credentials;
        res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone,
            password,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword
        });
      } else {
        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a password');
      }
      const {
        data,
        error
      } = res;
      if (error) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      } else if (!data || !data.session || !data.user) {
        return {
          data: {
            user: null,
            session: null
          },
          error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', data.session);
      }
      return {
        data: Object.assign({
          user: data.user,
          session: data.session
        }, data.weak_password ? {
          weakPassword: data.weak_password
        } : null),
        error
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in an existing user via a third-party provider.
   * This method supports the PKCE flow.
   */
  async signInWithOAuth(credentials) {
    var _a, _b, _c, _d;
    return await this._handleProviderSignIn(credentials.provider, {
      redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
      scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
      queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
      skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect
    });
  }
  /**
   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.
   */
  async exchangeCodeForSession(authCode) {
    await this.initializePromise;
    return this._acquireLock(-1, async () => {
      return this._exchangeCodeForSession(authCode);
    });
  }
  async _exchangeCodeForSession(authCode) {
    const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
    const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : '').split('/');
    try {
      const {
        data,
        error
      } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: authCode,
          code_verifier: codeVerifier
        },
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse
      });
      await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
      if (error) {
        throw error;
      }
      if (!data || !data.session || !data.user) {
        return {
          data: {
            user: null,
            session: null,
            redirectType: null
          },
          error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', data.session);
      }
      return {
        data: Object.assign(Object.assign({}, data), {
          redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null
        }),
        error
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null,
            redirectType: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Allows signing in with an OIDC ID token. The authentication provider used
   * should be enabled and configured.
   */
  async signInWithIdToken(credentials) {
    try {
      const {
        options,
        provider,
        token,
        access_token,
        nonce
      } = credentials;
      const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider,
          id_token: token,
          access_token,
          nonce,
          gotrue_meta_security: {
            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
          }
        },
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse
      });
      const {
        data,
        error
      } = res;
      if (error) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      } else if (!data || !data.session || !data.user) {
        return {
          data: {
            user: null,
            session: null
          },
          error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()
        };
      }
      if (data.session) {
        await this._saveSession(data.session);
        await this._notifyAllSubscribers('SIGNED_IN', data.session);
      }
      return {
        data,
        error
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in a user using magiclink or a one-time password (OTP).
   *
   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.
   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.
   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.
   *
   * Be aware that you may get back an error message that will not distinguish
   * between the cases where the account does not exist or, that the account
   * can only be accessed via social login.
   *
   * Do note that you will need to configure a Whatsapp sender on Twilio
   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp
   * channel is not supported on other providers
   * at this time.
   * This method supports PKCE when an email is passed.
   */
  async signInWithOtp(credentials) {
    var _a, _b, _c, _d, _e;
    try {
      if ('email' in credentials) {
        const {
          email,
          options
        } = credentials;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === 'pkce') {
          ;
          [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);
        }
        const {
          error
        } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email,
            data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},
            create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            },
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      if ('phone' in credentials) {
        const {
          phone,
          options
        } = credentials;
        const {
          data,
          error
        } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone,
            data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},
            create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            },
            channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : 'sms'
          }
        });
        return {
          data: {
            user: null,
            session: null,
            messageId: data === null || data === void 0 ? void 0 : data.message_id
          },
          error
        };
      }
      throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number.');
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Log in a user given a User supplied OTP or TokenHash received through mobile or email.
   */
  async verifyOtp(params) {
    var _a, _b;
    try {
      let redirectTo = undefined;
      let captchaToken = undefined;
      if ('options' in params) {
        redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;
        captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;
      }
      const {
        data,
        error
      } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, params), {
          gotrue_meta_security: {
            captcha_token: captchaToken
          }
        }),
        redirectTo,
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse
      });
      if (error) {
        throw error;
      }
      if (!data) {
        throw new Error('An error occurred on token verification.');
      }
      const session = data.session;
      const user = data.user;
      if (session === null || session === void 0 ? void 0 : session.access_token) {
        await this._saveSession(session);
        await this._notifyAllSubscribers(params.type == 'recovery' ? 'PASSWORD_RECOVERY' : 'SIGNED_IN', session);
      }
      return {
        data: {
          user,
          session
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Attempts a single-sign on using an enterprise Identity Provider. A
   * successful SSO attempt will redirect the current page to the identity
   * provider authorization page. The redirect URL is implementation and SSO
   * protocol specific.
   *
   * You can use it by providing a SSO domain. Typically you can extract this
   * domain by asking users for their email address. If this domain is
   * registered on the Auth instance the redirect will use that organization's
   * currently active SSO Identity Provider for the login.
   *
   * If you have built an organization-specific login page, you can use the
   * organization's SSO Identity Provider UUID directly instead.
   */
  async signInWithSSO(params) {
    var _a, _b, _c;
    try {
      let codeChallenge = null;
      let codeChallengeMethod = null;
      if (this.flowType === 'pkce') {
        ;
        [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);
      }
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {
          provider_id: params.providerId
        } : null), 'domain' in params ? {
          domain: params.domain
        } : null), {
          redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined
        }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {
          gotrue_meta_security: {
            captcha_token: params.options.captchaToken
          }
        } : null), {
          skip_http_redirect: true,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod
        }),
        headers: this.headers,
        xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Sends a reauthentication OTP to the user's email or phone number.
   * Requires the user to be signed-in.
   */
  async reauthenticate() {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._reauthenticate();
    });
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async result => {
        const {
          data: {
            session
          },
          error: sessionError
        } = result;
        if (sessionError) throw sessionError;
        if (!session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();
        const {
          error
        } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: session.access_token
        });
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.
   */
  async resend(credentials) {
    try {
      const endpoint = `${this.url}/resend`;
      if ('email' in credentials) {
        const {
          email,
          type,
          options
        } = credentials;
        const {
          error
        } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', endpoint, {
          headers: this.headers,
          body: {
            email,
            type,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          },
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo
        });
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      } else if ('phone' in credentials) {
        const {
          phone,
          type,
          options
        } = credentials;
        const {
          data,
          error
        } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', endpoint, {
          headers: this.headers,
          body: {
            phone,
            type,
            gotrue_meta_security: {
              captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken
            }
          }
        });
        return {
          data: {
            user: null,
            session: null,
            messageId: data === null || data === void 0 ? void 0 : data.message_id
          },
          error
        };
      }
      throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError('You must provide either an email or phone number and a type');
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Returns the session, refreshing it if necessary.
   *
   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.
   *
   * **IMPORTANT:** This method loads values directly from the storage attached
   * to the client. If that storage is based on request cookies for example,
   * the values in it may not be authentic and therefore it's strongly advised
   * against using this method and its results in such circumstances. A warning
   * will be emitted if this is detected. Use {@link #getUser()} instead.
   */
  async getSession() {
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return this._useSession(async result => {
        return result;
      });
    });
    return result;
  }
  /**
   * Acquires a global lock based on the storage key.
   */
  async _acquireLock(acquireTimeout, fn) {
    this._debug('#_acquireLock', 'begin', acquireTimeout);
    try {
      if (this.lockAcquired) {
        const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();
        const result = (async () => {
          await last;
          return await fn();
        })();
        this.pendingInLock.push((async () => {
          try {
            await result;
          } catch (e) {
            // we just care if it finished
          }
        })());
        return result;
      }
      return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async () => {
        this._debug('#_acquireLock', 'lock acquired for storage key', this.storageKey);
        try {
          this.lockAcquired = true;
          const result = fn();
          this.pendingInLock.push((async () => {
            try {
              await result;
            } catch (e) {
              // we just care if it finished
            }
          })());
          await result;
          // keep draining the queue until there's nothing to wait on
          while (this.pendingInLock.length) {
            const waitOn = [...this.pendingInLock];
            await Promise.all(waitOn);
            this.pendingInLock.splice(0, waitOn.length);
          }
          return await result;
        } finally {
          this._debug('#_acquireLock', 'lock released for storage key', this.storageKey);
          this.lockAcquired = false;
        }
      });
    } finally {
      this._debug('#_acquireLock', 'end');
    }
  }
  /**
   * Use instead of {@link #getSession} inside the library. It is
   * semantically usually what you want, as getting a session involves some
   * processing afterwards that requires only one client operating on the
   * session at once across multiple tabs or processes.
   */
  async _useSession(fn) {
    this._debug('#_useSession', 'begin');
    try {
      // the use of __loadSession here is the only correct use of the function!
      const result = await this.__loadSession();
      return await fn(result);
    } finally {
      this._debug('#_useSession', 'end');
    }
  }
  /**
   * NEVER USE DIRECTLY!
   *
   * Always use {@link #_useSession}.
   */
  async __loadSession() {
    this._debug('#__loadSession()', 'begin');
    if (!this.lockAcquired) {
      this._debug('#__loadSession()', 'used outside of an acquired lock!', new Error().stack);
    }
    try {
      let currentSession = null;
      const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);
      this._debug('#getSession()', 'session from storage', maybeSession);
      if (maybeSession !== null) {
        if (this._isValidSession(maybeSession)) {
          currentSession = maybeSession;
        } else {
          this._debug('#getSession()', 'session from storage is not valid');
          await this._removeSession();
        }
      }
      if (!currentSession) {
        return {
          data: {
            session: null
          },
          error: null
        };
      }
      // A session is considered expired before the access token _actually_
      // expires. When the autoRefreshToken option is off (or when the tab is
      // in the background), very eager users of getSession() -- like
      // realtime-js -- might send a valid JWT which will expire by the time it
      // reaches the server.
      const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS : false;
      this._debug('#__loadSession()', `session has${hasExpired ? '' : ' not'} expired`, 'expires_at', currentSession.expires_at);
      if (!hasExpired) {
        if (this.storage.isServer) {
          let suppressWarning = this.suppressGetSessionWarning;
          const proxySession = new Proxy(currentSession, {
            get: (target, prop, receiver) => {
              if (!suppressWarning && prop === 'user') {
                // only show warning when the user object is being accessed from the server
                console.warn('Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.');
                suppressWarning = true; // keeps this proxy instance from logging additional warnings
                this.suppressGetSessionWarning = true; // keeps this client's future proxy instances from warning
              }
              return Reflect.get(target, prop, receiver);
            }
          });
          currentSession = proxySession;
        }
        return {
          data: {
            session: currentSession
          },
          error: null
        };
      }
      const {
        session,
        error
      } = await this._callRefreshToken(currentSession.refresh_token);
      if (error) {
        return {
          data: {
            session: null
          },
          error
        };
      }
      return {
        data: {
          session
        },
        error: null
      };
    } finally {
      this._debug('#__loadSession()', 'end');
    }
  }
  /**
   * Gets the current user details if there is an existing session. This method
   * performs a network request to the Supabase Auth server, so the returned
   * value is authentic and can be used to base authorization rules on.
   *
   * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.
   */
  async getUser(jwt) {
    if (jwt) {
      return await this._getUser(jwt);
    }
    await this.initializePromise;
    const result = await this._acquireLock(-1, async () => {
      return await this._getUser();
    });
    return result;
  }
  async _getUser(jwt) {
    try {
      if (jwt) {
        return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/user`, {
          headers: this.headers,
          jwt: jwt,
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse
        });
      }
      return await this._useSession(async result => {
        var _a, _b, _c;
        const {
          data,
          error
        } = result;
        if (error) {
          throw error;
        }
        // returns an error if there is no access_token or custom authorization header
        if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {
          return {
            data: {
              user: null
            },
            error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()
          };
        }
        return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/user`, {
          headers: this.headers,
          jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse
        });
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {
          // JWT contains a `session_id` which does not correspond to an active
          // session in the database, indicating the user is signed out.
          await this._removeSession();
          await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
        }
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Updates user data for a logged in user.
   */
  async updateUser(attributes, options = {}) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._updateUser(attributes, options);
    });
  }
  async _updateUser(attributes, options = {}) {
    try {
      return await this._useSession(async result => {
        const {
          data: sessionData,
          error: sessionError
        } = result;
        if (sessionError) {
          throw sessionError;
        }
        if (!sessionData.session) {
          throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();
        }
        const session = sessionData.session;
        let codeChallenge = null;
        let codeChallengeMethod = null;
        if (this.flowType === 'pkce' && attributes.email != null) {
          ;
          [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);
        }
        const {
          data,
          error: userError
        } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'PUT', `${this.url}/user`, {
          headers: this.headers,
          redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,
          body: Object.assign(Object.assign({}, attributes), {
            code_challenge: codeChallenge,
            code_challenge_method: codeChallengeMethod
          }),
          jwt: session.access_token,
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse
        });
        if (userError) throw userError;
        session.user = data.user;
        await this._saveSession(session);
        await this._notifyAllSubscribers('USER_UPDATED', session);
        return {
          data: {
            user: session.user
          },
          error: null
        };
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.
   * If the refresh token or access token in the current session is invalid, an error will be thrown.
   * @param currentSession The current session that minimally contains an access token and refresh token.
   */
  async setSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._setSession(currentSession);
    });
  }
  async _setSession(currentSession) {
    try {
      if (!currentSession.access_token || !currentSession.refresh_token) {
        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();
      }
      const timeNow = Date.now() / 1000;
      let expiresAt = timeNow;
      let hasExpired = true;
      let session = null;
      const {
        payload
      } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(currentSession.access_token);
      if (payload.exp) {
        expiresAt = payload.exp;
        hasExpired = expiresAt <= timeNow;
      }
      if (hasExpired) {
        const {
          session: refreshedSession,
          error
        } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return {
            data: {
              user: null,
              session: null
            },
            error: error
          };
        }
        if (!refreshedSession) {
          return {
            data: {
              user: null,
              session: null
            },
            error: null
          };
        }
        session = refreshedSession;
      } else {
        const {
          data,
          error
        } = await this._getUser(currentSession.access_token);
        if (error) {
          throw error;
        }
        session = {
          access_token: currentSession.access_token,
          refresh_token: currentSession.refresh_token,
          user: data.user,
          token_type: 'bearer',
          expires_in: expiresAt - timeNow,
          expires_at: expiresAt
        };
        await this._saveSession(session);
        await this._notifyAllSubscribers('SIGNED_IN', session);
      }
      return {
        data: {
          user: session.user,
          session
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            session: null,
            user: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Returns a new session, regardless of expiry status.
   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().
   * If the current session's refresh token is invalid, an error will be thrown.
   * @param currentSession The current session. If passed in, it must contain a refresh token.
   */
  async refreshSession(currentSession) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._refreshSession(currentSession);
    });
  }
  async _refreshSession(currentSession) {
    try {
      return await this._useSession(async result => {
        var _a;
        if (!currentSession) {
          const {
            data,
            error
          } = result;
          if (error) {
            throw error;
          }
          currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;
        }
        if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {
          throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();
        }
        const {
          session,
          error
        } = await this._callRefreshToken(currentSession.refresh_token);
        if (error) {
          return {
            data: {
              user: null,
              session: null
            },
            error: error
          };
        }
        if (!session) {
          return {
            data: {
              user: null,
              session: null
            },
            error: null
          };
        }
        return {
          data: {
            user: session.user,
            session
          },
          error: null
        };
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            user: null,
            session: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Gets the session data from a URL string
   */
  async _getSessionFromURL(params, callbackUrlType) {
    try {
      if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('No browser detected.');
      // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.
      if (params.error || params.error_description || params.error_code) {
        // The error class returned implies that the redirect is from an implicit grant flow
        // but it could also be from a redirect error from a PKCE flow.
        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || 'Error in URL with unspecified error_description', {
          error: params.error || 'unspecified_error',
          code: params.error_code || 'unspecified_code'
        });
      }
      // Checks for mismatches between the flowType initialised in the client and the URL parameters
      switch (callbackUrlType) {
        case 'implicit':
          if (this.flowType === 'pkce') {
            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');
          }
          break;
        case 'pkce':
          if (this.flowType === 'implicit') {
            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');
          }
          break;
        default:
        // there's no mismatch so we continue
      }
      // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange
      if (callbackUrlType === 'pkce') {
        this._debug('#_initialize()', 'begin', 'is PKCE flow', true);
        if (!params.code) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError('No code detected.');
        const {
          data,
          error
        } = await this._exchangeCodeForSession(params.code);
        if (error) throw error;
        const url = new URL(window.location.href);
        url.searchParams.delete('code');
        window.history.replaceState(window.history.state, '', url.toString());
        return {
          data: {
            session: data.session,
            redirectType: null
          },
          error: null
        };
      }
      const {
        provider_token,
        provider_refresh_token,
        access_token,
        refresh_token,
        expires_in,
        expires_at,
        token_type
      } = params;
      if (!access_token || !expires_in || !refresh_token || !token_type) {
        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError('No session defined in URL');
      }
      const timeNow = Math.round(Date.now() / 1000);
      const expiresIn = parseInt(expires_in);
      let expiresAt = timeNow + expiresIn;
      if (expires_at) {
        expiresAt = parseInt(expires_at);
      }
      const actuallyExpiresIn = expiresAt - timeNow;
      if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {
        console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);
      }
      const issuedAt = expiresAt - expiresIn;
      if (timeNow - issuedAt >= 120) {
        console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale', issuedAt, expiresAt, timeNow);
      } else if (timeNow - issuedAt < 0) {
        console.warn('@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew', issuedAt, expiresAt, timeNow);
      }
      const {
        data,
        error
      } = await this._getUser(access_token);
      if (error) throw error;
      const session = {
        provider_token,
        provider_refresh_token,
        access_token,
        expires_in: expiresIn,
        expires_at: expiresAt,
        refresh_token,
        token_type,
        user: data.user
      };
      // Remove tokens from URL
      window.location.hash = '';
      this._debug('#_getSessionFromURL()', 'clearing window.location.hash');
      return {
        data: {
          session,
          redirectType: params.type
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            session: null,
            redirectType: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)
   */
  _isImplicitGrantCallback(params) {
    return Boolean(params.access_token || params.error_description);
  }
  /**
   * Checks if the current URL and backing storage contain parameters given by a PKCE flow
   */
  async _isPKCECallback(params) {
    const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
    return !!(params.code && currentStorageContent);
  }
  /**
   * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `"SIGNED_OUT"` event.
   *
   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.
   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.
   *
   * If using `others` scope, no `SIGNED_OUT` event is fired!
   */
  async signOut(options = {
    scope: 'global'
  }) {
    await this.initializePromise;
    return await this._acquireLock(-1, async () => {
      return await this._signOut(options);
    });
  }
  async _signOut({
    scope
  } = {
    scope: 'global'
  }) {
    return await this._useSession(async result => {
      var _a;
      const {
        data,
        error: sessionError
      } = result;
      if (sessionError) {
        return {
          error: sessionError
        };
      }
      const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;
      if (accessToken) {
        const {
          error
        } = await this.admin.signOut(accessToken, scope);
        if (error) {
          // ignore 404s since user might not exist anymore
          // ignore 401s since an invalid or expired JWT should sign out the current session
          if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {
            return {
              error
            };
          }
        }
      }
      if (scope !== 'others') {
        await this._removeSession();
        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);
      }
      return {
        error: null
      };
    });
  }
  /**
   * Receive a notification every time an auth event happens.
   * @param callback A callback function to be invoked when an auth event happens.
   */
  onAuthStateChange(callback) {
    const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.uuid)();
    const subscription = {
      id,
      callback,
      unsubscribe: () => {
        this._debug('#unsubscribe()', 'state change callback with id removed', id);
        this.stateChangeEmitters.delete(id);
      }
    };
    this._debug('#onAuthStateChange()', 'registered callback with id', id);
    this.stateChangeEmitters.set(id, subscription);
    (async () => {
      await this.initializePromise;
      await this._acquireLock(-1, async () => {
        this._emitInitialSession(id);
      });
    })();
    return {
      data: {
        subscription
      }
    };
  }
  async _emitInitialSession(id) {
    return await this._useSession(async result => {
      var _a, _b;
      try {
        const {
          data: {
            session
          },
          error
        } = result;
        if (error) throw error;
        await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session));
        this._debug('INITIAL_SESSION', 'callback id', id, 'session', session);
      } catch (err) {
        await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null));
        this._debug('INITIAL_SESSION', 'callback id', id, 'error', err);
        console.error(err);
      }
    });
  }
  /**
   * Sends a password reset request to an email address. This method supports the PKCE flow.
   *
   * @param email The email address of the user.
   * @param options.redirectTo The URL to send the user to after they click the password reset link.
   * @param options.captchaToken Verification token received when the user completes the captcha on the site.
   */
  async resetPasswordForEmail(email, options = {}) {
    let codeChallenge = null;
    let codeChallengeMethod = null;
    if (this.flowType === 'pkce') {
      ;
      [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery
      );
    }
    try {
      return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/recover`, {
        body: {
          email,
          code_challenge: codeChallenge,
          code_challenge_method: codeChallengeMethod,
          gotrue_meta_security: {
            captcha_token: options.captchaToken
          }
        },
        headers: this.headers,
        redirectTo: options.redirectTo
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Gets all the identities linked to a user.
   */
  async getUserIdentities() {
    var _a;
    try {
      const {
        data,
        error
      } = await this.getUser();
      if (error) throw error;
      return {
        data: {
          identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Links an oauth identity to an existing user.
   * This method supports the PKCE flow.
   */
  async linkIdentity(credentials) {
    var _a;
    try {
      const {
        data,
        error
      } = await this._useSession(async result => {
        var _a, _b, _c, _d, _e;
        const {
          data,
          error
        } = result;
        if (error) throw error;
        const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {
          redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,
          scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,
          queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,
          skipBrowserRedirect: true
        });
        return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', url, {
          headers: this.headers,
          jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined
        });
      });
      if (error) throw error;
      if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {
        window.location.assign(data === null || data === void 0 ? void 0 : data.url);
      }
      return {
        data: {
          provider: credentials.provider,
          url: data === null || data === void 0 ? void 0 : data.url
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            provider: credentials.provider,
            url: null
          },
          error
        };
      }
      throw error;
    }
  }
  /**
   * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.
   */
  async unlinkIdentity(identity) {
    try {
      return await this._useSession(async result => {
        var _a, _b;
        const {
          data,
          error
        } = result;
        if (error) {
          throw error;
        }
        return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'DELETE', `${this.url}/user/identities/${identity.identity_id}`, {
          headers: this.headers,
          jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined
        });
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * Generates a new JWT.
   * @param refreshToken A valid refresh token that was returned on login.
   */
  async _refreshAccessToken(refreshToken) {
    const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, 'begin');
    try {
      const startedAt = Date.now();
      // will attempt to refresh the token with exponential backoff
      return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async attempt => {
        if (attempt > 0) {
          await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...
        }
        this._debug(debugName, 'refreshing attempt', attempt);
        return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {
          body: {
            refresh_token: refreshToken
          },
          headers: this.headers,
          xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse
        });
      }, (attempt, error) => {
        const nextBackOffInterval = 200 * Math.pow(2, attempt);
        return error && (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) &&
        // retryable only if the request can be sent before the backoff overflows the tick duration
        Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS;
      });
    } catch (error) {
      this._debug(debugName, 'error', error);
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: {
            session: null,
            user: null
          },
          error
        };
      }
      throw error;
    } finally {
      this._debug(debugName, 'end');
    }
  }
  _isValidSession(maybeSession) {
    const isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;
    return isValidSession;
  }
  async _handleProviderSignIn(provider, options) {
    const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {
      redirectTo: options.redirectTo,
      scopes: options.scopes,
      queryParams: options.queryParams
    });
    this._debug('#_handleProviderSignIn()', 'provider', provider, 'options', options, 'url', url);
    // try to open on the browser
    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {
      window.location.assign(url);
    }
    return {
      data: {
        provider,
        url
      },
      error: null
    };
  }
  /**
   * Recovers the session from LocalStorage and refreshes the token
   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.
   */
  async _recoverAndRefresh() {
    var _a;
    const debugName = '#_recoverAndRefresh()';
    this._debug(debugName, 'begin');
    try {
      const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);
      this._debug(debugName, 'session from storage', currentSession);
      if (!this._isValidSession(currentSession)) {
        this._debug(debugName, 'session is not valid');
        if (currentSession !== null) {
          await this._removeSession();
        }
        return;
      }
      const expiresWithMargin = ((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;
      this._debug(debugName, `session has${expiresWithMargin ? '' : ' not'} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS}s`);
      if (expiresWithMargin) {
        if (this.autoRefreshToken && currentSession.refresh_token) {
          const {
            error
          } = await this._callRefreshToken(currentSession.refresh_token);
          if (error) {
            console.error(error);
            if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {
              this._debug(debugName, 'refresh failed with a non-retryable error, removing the session', error);
              await this._removeSession();
            }
          }
        }
      } else {
        // no need to persist currentSession again, as we just loaded it from
        // local storage; persisting it again may overwrite a value saved by
        // another client with access to the same local storage
        await this._notifyAllSubscribers('SIGNED_IN', currentSession);
      }
    } catch (err) {
      this._debug(debugName, 'error', err);
      console.error(err);
      return;
    } finally {
      this._debug(debugName, 'end');
    }
  }
  async _callRefreshToken(refreshToken) {
    var _a, _b;
    if (!refreshToken) {
      throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();
    }
    // refreshing is already in progress
    if (this.refreshingDeferred) {
      return this.refreshingDeferred.promise;
    }
    const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;
    this._debug(debugName, 'begin');
    try {
      this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();
      const {
        data,
        error
      } = await this._refreshAccessToken(refreshToken);
      if (error) throw error;
      if (!data.session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();
      await this._saveSession(data.session);
      await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);
      const result = {
        session: data.session,
        error: null
      };
      this.refreshingDeferred.resolve(result);
      return result;
    } catch (error) {
      this._debug(debugName, 'error', error);
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        const result = {
          session: null,
          error
        };
        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {
          await this._removeSession();
        }
        (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);
        return result;
      }
      (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);
      throw error;
    } finally {
      this.refreshingDeferred = null;
      this._debug(debugName, 'end');
    }
  }
  async _notifyAllSubscribers(event, session, broadcast = true) {
    const debugName = `#_notifyAllSubscribers(${event})`;
    this._debug(debugName, 'begin', session, `broadcast = ${broadcast}`);
    try {
      if (this.broadcastChannel && broadcast) {
        this.broadcastChannel.postMessage({
          event,
          session
        });
      }
      const errors = [];
      const promises = Array.from(this.stateChangeEmitters.values()).map(async x => {
        try {
          await x.callback(event, session);
        } catch (e) {
          errors.push(e);
        }
      });
      await Promise.all(promises);
      if (errors.length > 0) {
        for (let i = 0; i < errors.length; i += 1) {
          console.error(errors[i]);
        }
        throw errors[0];
      }
    } finally {
      this._debug(debugName, 'end');
    }
  }
  /**
   * set currentSession and currentUser
   * process to _startAutoRefreshToken if possible
   */
  async _saveSession(session) {
    this._debug('#_saveSession()', session);
    // _saveSession is always called whenever a new session has been acquired
    // so we can safely suppress the warning returned by future getSession calls
    this.suppressGetSessionWarning = true;
    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, session);
  }
  async _removeSession() {
    this._debug('#_removeSession()');
    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);
    await this._notifyAllSubscribers('SIGNED_OUT', null);
  }
  /**
   * Removes any registered visibilitychange callback.
   *
   * {@see #startAutoRefresh}
   * {@see #stopAutoRefresh}
   */
  _removeVisibilityChangedCallback() {
    this._debug('#_removeVisibilityChangedCallback()');
    const callback = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {
        window.removeEventListener('visibilitychange', callback);
      }
    } catch (e) {
      console.error('removing visibilitychange callback failed', e);
    }
  }
  /**
   * This is the private implementation of {@link #startAutoRefresh}. Use this
   * within the library.
   */
  async _startAutoRefresh() {
    await this._stopAutoRefresh();
    this._debug('#_startAutoRefresh()');
    const ticker = setInterval(() => this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);
    this.autoRefreshTicker = ticker;
    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {
      // ticker is a NodeJS Timeout object that has an `unref` method
      // https://nodejs.org/api/timers.html#timeoutunref
      // When auto refresh is used in NodeJS (like for testing) the
      // `setInterval` is preventing the process from being marked as
      // finished and tests run endlessly. This can be prevented by calling
      // `unref()` on the returned object.
      ticker.unref();
      // @ts-expect-error TS has no context of Deno
    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {
      // similar like for NodeJS, but with the Deno API
      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer
      // @ts-expect-error TS has no context of Deno
      Deno.unrefTimer(ticker);
    }
    // run the tick immediately, but in the next pass of the event loop so that
    // #_initialize can be allowed to complete without recursively waiting on
    // itself
    setTimeout(async () => {
      await this.initializePromise;
      await this._autoRefreshTokenTick();
    }, 0);
  }
  /**
   * This is the private implementation of {@link #stopAutoRefresh}. Use this
   * within the library.
   */
  async _stopAutoRefresh() {
    this._debug('#_stopAutoRefresh()');
    const ticker = this.autoRefreshTicker;
    this.autoRefreshTicker = null;
    if (ticker) {
      clearInterval(ticker);
    }
  }
  /**
   * Starts an auto-refresh process in the background. The session is checked
   * every few seconds. Close to the time of expiration a process is started to
   * refresh the session. If refreshing fails it will be retried for as long as
   * necessary.
   *
   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need
   * to call this function, it will be called for you.
   *
   * On browsers the refresh process works only when the tab/window is in the
   * foreground to conserve resources as well as prevent race conditions and
   * flooding auth with requests. If you call this method any managed
   * visibility change callback will be removed and you must manage visibility
   * changes on your own.
   *
   * On non-browser platforms the refresh process works *continuously* in the
   * background, which may not be desirable. You should hook into your
   * platform's foreground indication mechanism and call these methods
   * appropriately to conserve resources.
   *
   * {@see #stopAutoRefresh}
   */
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._startAutoRefresh();
  }
  /**
   * Stops an active auto refresh process running in the background (if any).
   *
   * If you call this method any managed visibility change callback will be
   * removed and you must manage visibility changes on your own.
   *
   * See {@link #startAutoRefresh} for more details.
   */
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback();
    await this._stopAutoRefresh();
  }
  /**
   * Runs the auto refresh token tick.
   */
  async _autoRefreshTokenTick() {
    this._debug('#_autoRefreshTokenTick()', 'begin');
    try {
      await this._acquireLock(0, async () => {
        try {
          const now = Date.now();
          try {
            return await this._useSession(async result => {
              const {
                data: {
                  session
                }
              } = result;
              if (!session || !session.refresh_token || !session.expires_at) {
                this._debug('#_autoRefreshTokenTick()', 'no session');
                return;
              }
              // session will expire in this many ticks (or has already expired if <= 0)
              const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);
              this._debug('#_autoRefreshTokenTick()', `access token expires in ${expiresInTicks} ticks, a tick lasts ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD} ticks`);
              if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {
                await this._callRefreshToken(session.refresh_token);
              }
            });
          } catch (e) {
            console.error('Auto refresh tick failed with error. This is likely a transient error.', e);
          }
        } finally {
          this._debug('#_autoRefreshTokenTick()', 'end');
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_8__.LockAcquireTimeoutError) {
        this._debug('auto refresh token tick lock not available');
      } else {
        throw e;
      }
    }
  }
  /**
   * Registers callbacks on the browser / platform, which in-turn run
   * algorithms when the browser window/tab are in foreground. On non-browser
   * platforms it assumes always foreground.
   */
  async _handleVisibilityChange() {
    this._debug('#_handleVisibilityChange()');
    if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {
      if (this.autoRefreshToken) {
        // in non-browser environments the refresh token ticker runs always
        this.startAutoRefresh();
      }
      return false;
    }
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false);
      window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);
      // now immediately call the visbility changed callback to setup with the
      // current visbility state
      await this._onVisibilityChanged(true); // initial call
    } catch (error) {
      console.error('_handleVisibilityChange', error);
    }
  }
  /**
   * Callback registered with `window.addEventListener('visibilitychange')`.
   */
  async _onVisibilityChanged(calledFromInitialize) {
    const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;
    this._debug(methodName, 'visibilityState', document.visibilityState);
    if (document.visibilityState === 'visible') {
      if (this.autoRefreshToken) {
        // in browser environments the refresh token ticker runs only on focused tabs
        // which prevents race conditions
        this._startAutoRefresh();
      }
      if (!calledFromInitialize) {
        // called when the visibility has changed, i.e. the browser
        // transitioned from hidden -> visible so we need to see if the session
        // should be recovered immediately... but to do that we need to acquire
        // the lock first asynchronously
        await this.initializePromise;
        await this._acquireLock(-1, async () => {
          if (document.visibilityState !== 'visible') {
            this._debug(methodName, 'acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting');
            // visibility has changed while waiting for the lock, abort
            return;
          }
          // recover the session
          await this._recoverAndRefresh();
        });
      }
    } else if (document.visibilityState === 'hidden') {
      if (this.autoRefreshToken) {
        this._stopAutoRefresh();
      }
    }
  }
  /**
   * Generates the relevant login URL for a third-party provider.
   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.
   * @param options.scopes A space-separated list of scopes granted to the OAuth application.
   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.
   */
  async _getUrlForProvider(url, provider, options) {
    const urlParams = [`provider=${encodeURIComponent(provider)}`];
    if (options === null || options === void 0 ? void 0 : options.redirectTo) {
      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);
    }
    if (options === null || options === void 0 ? void 0 : options.scopes) {
      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);
    }
    if (this.flowType === 'pkce') {
      const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);
      const flowParams = new URLSearchParams({
        code_challenge: `${encodeURIComponent(codeChallenge)}`,
        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`
      });
      urlParams.push(flowParams.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.queryParams) {
      const query = new URLSearchParams(options.queryParams);
      urlParams.push(query.toString());
    }
    if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {
      urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);
    }
    return `${url}?${urlParams.join('&')}`;
  }
  async _unenroll(params) {
    try {
      return await this._useSession(async result => {
        var _a;
        const {
          data: sessionData,
          error: sessionError
        } = result;
        if (sessionError) {
          return {
            data: null,
            error: sessionError
          };
        }
        return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {
          headers: this.headers,
          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
        });
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  async _enroll(params) {
    try {
      return await this._useSession(async result => {
        var _a, _b;
        const {
          data: sessionData,
          error: sessionError
        } = result;
        if (sessionError) {
          return {
            data: null,
            error: sessionError
          };
        }
        const body = Object.assign({
          friendly_name: params.friendlyName,
          factor_type: params.factorType
        }, params.factorType === 'phone' ? {
          phone: params.phone
        } : {
          issuer: params.issuer
        });
        const {
          data,
          error
        } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors`, {
          body,
          headers: this.headers,
          jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
        });
        if (error) {
          return {
            data: null,
            error
          };
        }
        if (params.factorType === 'totp' && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {
          data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;
        }
        return {
          data,
          error: null
        };
      });
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
  /**
   * {@see GoTrueMFAApi#verify}
   */
  async _verify(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async result => {
          var _a;
          const {
            data: sessionData,
            error: sessionError
          } = result;
          if (sessionError) {
            return {
              data: null,
              error: sessionError
            };
          }
          const {
            data,
            error
          } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/verify`, {
            body: {
              code: params.code,
              challenge_id: params.challengeId
            },
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
          });
          if (error) {
            return {
              data: null,
              error
            };
          }
          await this._saveSession(Object.assign({
            expires_at: Math.round(Date.now() / 1000) + data.expires_in
          }, data));
          await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);
          return {
            data,
            error
          };
        });
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challenge}
   */
  async _challenge(params) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async result => {
          var _a;
          const {
            data: sessionData,
            error: sessionError
          } = result;
          if (sessionError) {
            return {
              data: null,
              error: sessionError
            };
          }
          return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'POST', `${this.url}/factors/${params.factorId}/challenge`, {
            body: {
              channel: params.channel
            },
            headers: this.headers,
            jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token
          });
        });
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * {@see GoTrueMFAApi#challengeAndVerify}
   */
  async _challengeAndVerify(params) {
    // both _challenge and _verify independently acquire the lock, so no need
    // to acquire it here
    const {
      data: challengeData,
      error: challengeError
    } = await this._challenge({
      factorId: params.factorId
    });
    if (challengeError) {
      return {
        data: null,
        error: challengeError
      };
    }
    return await this._verify({
      factorId: params.factorId,
      challengeId: challengeData.id,
      code: params.code
    });
  }
  /**
   * {@see GoTrueMFAApi#listFactors}
   */
  async _listFactors() {
    // use #getUser instead of #_getUser as the former acquires a lock
    const {
      data: {
        user
      },
      error: userError
    } = await this.getUser();
    if (userError) {
      return {
        data: null,
        error: userError
      };
    }
    const factors = (user === null || user === void 0 ? void 0 : user.factors) || [];
    const totp = factors.filter(factor => factor.factor_type === 'totp' && factor.status === 'verified');
    const phone = factors.filter(factor => factor.factor_type === 'phone' && factor.status === 'verified');
    return {
      data: {
        all: factors,
        totp,
        phone
      },
      error: null
    };
  }
  /**
   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}
   */
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => {
      return await this._useSession(async result => {
        var _a, _b;
        const {
          data: {
            session
          },
          error: sessionError
        } = result;
        if (sessionError) {
          return {
            data: null,
            error: sessionError
          };
        }
        if (!session) {
          return {
            data: {
              currentLevel: null,
              nextLevel: null,
              currentAuthenticationMethods: []
            },
            error: null
          };
        }
        const {
          payload
        } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(session.access_token);
        let currentLevel = null;
        if (payload.aal) {
          currentLevel = payload.aal;
        }
        let nextLevel = currentLevel;
        const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(factor => factor.status === 'verified')) !== null && _b !== void 0 ? _b : [];
        if (verifiedFactors.length > 0) {
          nextLevel = 'aal2';
        }
        const currentAuthenticationMethods = payload.amr || [];
        return {
          data: {
            currentLevel,
            nextLevel,
            currentAuthenticationMethods
          },
          error: null
        };
      });
    });
  }
  async fetchJwk(kid, jwks = {
    keys: []
  }) {
    // try fetching from the supplied jwks
    let jwk = jwks.keys.find(key => key.kid === kid);
    if (jwk) {
      return jwk;
    }
    // try fetching from cache
    jwk = this.jwks.keys.find(key => key.kid === kid);
    // jwk exists and jwks isn't stale
    if (jwk && this.jwks_cached_at + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.JWKS_TTL > Date.now()) {
      return jwk;
    }
    // jwk isn't cached in memory so we need to fetch it from the well-known endpoint
    const {
      data,
      error
    } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, 'GET', `${this.url}/.well-known/jwks.json`, {
      headers: this.headers
    });
    if (error) {
      throw error;
    }
    if (!data.keys || data.keys.length === 0) {
      throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError('JWKS is empty');
    }
    this.jwks = data;
    this.jwks_cached_at = Date.now();
    // Find the signing key
    jwk = data.keys.find(key => key.kid === kid);
    if (!jwk) {
      throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError('No matching signing key found in JWKS');
    }
    return jwk;
  }
  /**
   * @experimental This method may change in future versions.
   * @description Gets the claims from a JWT. If the JWT is symmetric JWTs, it will call getUser() to verify against the server. If the JWT is asymmetric, it will be verified against the JWKS using the WebCrypto API.
   */
  async getClaims(jwt, jwks = {
    keys: []
  }) {
    try {
      let token = jwt;
      if (!token) {
        const {
          data,
          error
        } = await this.getSession();
        if (error || !data.session) {
          return {
            data: null,
            error
          };
        }
        token = data.session.access_token;
      }
      const {
        header,
        payload,
        signature,
        raw: {
          header: rawHeader,
          payload: rawPayload
        }
      } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(token);
      // Reject expired JWTs
      (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.validateExp)(payload.exp);
      // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()
      if (!header.kid || header.alg === 'HS256' || !('crypto' in globalThis && 'subtle' in globalThis.crypto)) {
        const {
          error
        } = await this.getUser(token);
        if (error) {
          throw error;
        }
        // getUser succeeds so the claims in the JWT can be trusted
        return {
          data: {
            claims: payload,
            header,
            signature
          },
          error: null
        };
      }
      const algorithm = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getAlgorithm)(header.alg);
      const signingKey = await this.fetchJwk(header.kid, jwks);
      // Convert JWK to CryptoKey
      const publicKey = await crypto.subtle.importKey('jwk', signingKey, algorithm, true, ['verify']);
      // Verify the signature
      const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.stringToUint8Array)(`${rawHeader}.${rawPayload}`));
      if (!isValid) {
        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError('Invalid JWT signature');
      }
      // If verification succeeds, decode and return claims
      return {
        data: {
          claims: payload,
          header,
          signature
        },
        error: null
      };
    } catch (error) {
      if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {
        return {
          data: null,
          error
        };
      }
      throw error;
    }
  }
}
GoTrueClient.nextInstanceID = 0;

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/index.js":
/*!**************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),
/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),
/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),
/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),
/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidJwtError),
/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),
/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),
/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),
/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),
/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),
/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),
/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),
/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),
/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),
/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),
/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),
/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),
/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),
/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),
/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),
/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock)
/* harmony export */ });
/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ "../node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js");
/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ "../node_modules/@supabase/auth-js/dist/module/GoTrueClient.js");
/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ "../node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js");
/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ "../node_modules/@supabase/auth-js/dist/module/AuthClient.js");
/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ "../node_modules/@supabase/auth-js/dist/module/lib/types.js");
/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ "../node_modules/@supabase/auth-js/dist/module/lib/errors.js");
/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ "../node_modules/@supabase/auth-js/dist/module/lib/locks.js");









/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/base64url.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/base64url.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64UrlToUint8Array: () => (/* binding */ base64UrlToUint8Array),
/* harmony export */   byteFromBase64URL: () => (/* binding */ byteFromBase64URL),
/* harmony export */   byteToBase64URL: () => (/* binding */ byteToBase64URL),
/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),
/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),
/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),
/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),
/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8),
/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array)
/* harmony export */ });
/**
 * Avoid modifying this file. It's part of
 * https://github.com/supabase-community/base64url-js.  Submit all fixes on
 * that repo!
 */
/**
 * An array of characters that encode 6 bits into a Base64-URL alphabet
 * character.
 */
const TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');
/**
 * An array of characters that can appear in a Base64-URL encoded string but
 * should be ignored.
 */
const IGNORE_BASE64URL = ' \t\n\r='.split('');
/**
 * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2
 * used to skip the character, or if -1 used to error out.
 */
const FROM_BASE64URL = (() => {
  const charMap = new Array(128);
  for (let i = 0; i < charMap.length; i += 1) {
    charMap[i] = -1;
  }
  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {
    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;
  }
  for (let i = 0; i < TO_BASE64URL.length; i += 1) {
    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;
  }
  return charMap;
})();
/**
 * Converts a byte to a Base64-URL string.
 *
 * @param byte The byte to convert, or null to flush at the end of the byte sequence.
 * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.
 * @param emit A function called with the next Base64 character when ready.
 */
function byteToBase64URL(byte, state, emit) {
  if (byte !== null) {
    state.queue = state.queue << 8 | byte;
    state.queuedBits += 8;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  } else if (state.queuedBits > 0) {
    state.queue = state.queue << 6 - state.queuedBits;
    state.queuedBits = 6;
    while (state.queuedBits >= 6) {
      const pos = state.queue >> state.queuedBits - 6 & 63;
      emit(TO_BASE64URL[pos]);
      state.queuedBits -= 6;
    }
  }
}
/**
 * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.
 *
 * @param charCode The char code of the JavaScript string.
 * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.
 * @param emit A function called with the next byte.
 */
function byteFromBase64URL(charCode, state, emit) {
  const bits = FROM_BASE64URL[charCode];
  if (bits > -1) {
    // valid Base64-URL character
    state.queue = state.queue << 6 | bits;
    state.queuedBits += 6;
    while (state.queuedBits >= 8) {
      emit(state.queue >> state.queuedBits - 8 & 0xff);
      state.queuedBits -= 8;
    }
  } else if (bits === -2) {
    // ignore spaces, tabs, newlines, =
    return;
  } else {
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(charCode)}"`);
  }
}
/**
 * Converts a JavaScript string (which may include any valid character) into a
 * Base64-URL encoded string. The string is first encoded in UTF-8 which is
 * then encoded as Base64-URL.
 *
 * @param str The string to convert.
 */
function stringToBase64URL(str) {
  const base64 = [];
  const emitter = char => {
    base64.push(char);
  };
  const state = {
    queue: 0,
    queuedBits: 0
  };
  stringToUTF8(str, byte => {
    byteToBase64URL(byte, state, emitter);
  });
  byteToBase64URL(null, state, emitter);
  return base64.join('');
}
/**
 * Converts a Base64-URL encoded string into a JavaScript string. It is assumed
 * that the underlying string has been encoded as UTF-8.
 *
 * @param str The Base64-URL encoded string.
 */
function stringFromBase64URL(str) {
  const conv = [];
  const utf8Emit = codepoint => {
    conv.push(String.fromCodePoint(codepoint));
  };
  const utf8State = {
    utf8seq: 0,
    codepoint: 0
  };
  const b64State = {
    queue: 0,
    queuedBits: 0
  };
  const byteEmit = byte => {
    stringFromUTF8(byte, utf8State, utf8Emit);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);
  }
  return conv.join('');
}
/**
 * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.
 *
 * @param codepoint The Unicode codepoint.
 * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.
 */
function codepointToUTF8(codepoint, emit) {
  if (codepoint <= 0x7f) {
    emit(codepoint);
    return;
  } else if (codepoint <= 0x7ff) {
    emit(0xc0 | codepoint >> 6);
    emit(0x80 | codepoint & 0x3f);
    return;
  } else if (codepoint <= 0xffff) {
    emit(0xe0 | codepoint >> 12);
    emit(0x80 | codepoint >> 6 & 0x3f);
    emit(0x80 | codepoint & 0x3f);
    return;
  } else if (codepoint <= 0x10ffff) {
    emit(0xf0 | codepoint >> 18);
    emit(0x80 | codepoint >> 12 & 0x3f);
    emit(0x80 | codepoint >> 6 & 0x3f);
    emit(0x80 | codepoint & 0x3f);
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);
}
/**
 * Converts a JavaScript string to a sequence of UTF-8 bytes.
 *
 * @param str  The string to convert to UTF-8.
 * @param emit Function which will be called for each UTF-8 byte of the string.
 */
function stringToUTF8(str, emit) {
  for (let i = 0; i < str.length; i += 1) {
    let codepoint = str.charCodeAt(i);
    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {
      // most UTF-16 codepoints are Unicode codepoints, except values in this
      // range where the next UTF-16 codepoint needs to be combined with the
      // current one to get the Unicode codepoint
      const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;
      const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;
      codepoint = (lowSurrogate | highSurrogate) + 0x10000;
      i += 1;
    }
    codepointToUTF8(codepoint, emit);
  }
}
/**
 * Converts a UTF-8 byte to a Unicode codepoint.
 *
 * @param byte  The UTF-8 byte next in the sequence.
 * @param state The shared state between consecutive UTF-8 bytes in the
 *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.
 * @param emit  Function which will be called for each codepoint.
 */
function stringFromUTF8(byte, state, emit) {
  if (state.utf8seq === 0) {
    if (byte <= 0x7f) {
      emit(byte);
      return;
    }
    // count the number of 1 leading bits until you reach 0
    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {
      if ((byte >> 7 - leadingBit & 1) === 0) {
        state.utf8seq = leadingBit;
        break;
      }
    }
    if (state.utf8seq === 2) {
      state.codepoint = byte & 31;
    } else if (state.utf8seq === 3) {
      state.codepoint = byte & 15;
    } else if (state.utf8seq === 4) {
      state.codepoint = byte & 7;
    } else {
      throw new Error('Invalid UTF-8 sequence');
    }
    state.utf8seq -= 1;
  } else if (state.utf8seq > 0) {
    if (byte <= 0x7f) {
      throw new Error('Invalid UTF-8 sequence');
    }
    state.codepoint = state.codepoint << 6 | byte & 63;
    state.utf8seq -= 1;
    if (state.utf8seq === 0) {
      emit(state.codepoint);
    }
  }
}
/**
 * Helper functions to convert different types of strings to Uint8Array
 */
function base64UrlToUint8Array(str) {
  const result = [];
  const state = {
    queue: 0,
    queuedBits: 0
  };
  const onByte = byte => {
    result.push(byte);
  };
  for (let i = 0; i < str.length; i += 1) {
    byteFromBase64URL(str.charCodeAt(i), state, onByte);
  }
  return new Uint8Array(result);
}
function stringToUint8Array(str) {
  const result = [];
  stringToUTF8(str, byte => result.push(byte));
  return new Uint8Array(result);
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),
/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),
/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),
/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: () => (/* binding */ AUTO_REFRESH_TICK_DURATION_MS),
/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: () => (/* binding */ AUTO_REFRESH_TICK_THRESHOLD),
/* harmony export */   BASE64URL_REGEX: () => (/* binding */ BASE64URL_REGEX),
/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),
/* harmony export */   EXPIRY_MARGIN_MS: () => (/* binding */ EXPIRY_MARGIN_MS),
/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),
/* harmony export */   JWKS_TTL: () => (/* binding */ JWKS_TTL),
/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),
/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ "../node_modules/@supabase/auth-js/dist/module/lib/version.js");

/** Current session will be checked for refresh at this interval. */
const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;
/**
 * A token refresh will be attempted this many ticks before the current session expires. */
const AUTO_REFRESH_TICK_THRESHOLD = 3;
/*
 * Earliest time before an access token expires that the session should be refreshed.
 */
const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;
const GOTRUE_URL = 'http://localhost:9999';
const STORAGE_KEY = 'supabase.auth.token';
const AUDIENCE = '';
const DEFAULT_HEADERS = {
  'X-Client-Info': `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`
};
const NETWORK_FAILURE = {
  MAX_RETRIES: 10,
  RETRY_INTERVAL: 2 // in deciseconds
};
const API_VERSION_HEADER_NAME = 'X-Supabase-Api-Version';
const API_VERSIONS = {
  '2024-01-01': {
    timestamp: Date.parse('2024-01-01T00:00:00.0Z'),
    name: '2024-01-01'
  }
};
const BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;
const JWKS_TTL = 600000; // 10 minutes

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),
/* harmony export */   AuthError: () => (/* binding */ AuthError),
/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),
/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),
/* harmony export */   AuthInvalidJwtError: () => (/* binding */ AuthInvalidJwtError),
/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),
/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),
/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),
/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),
/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),
/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),
/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),
/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),
/* harmony export */   isAuthError: () => (/* binding */ isAuthError),
/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),
/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),
/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),
/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)
/* harmony export */ });
class AuthError extends Error {
  constructor(message, status, code) {
    super(message);
    this.__isAuthError = true;
    this.name = 'AuthError';
    this.status = status;
    this.code = code;
  }
}
function isAuthError(error) {
  return typeof error === 'object' && error !== null && '__isAuthError' in error;
}
class AuthApiError extends AuthError {
  constructor(message, status, code) {
    super(message, status, code);
    this.name = 'AuthApiError';
    this.status = status;
    this.code = code;
  }
}
function isAuthApiError(error) {
  return isAuthError(error) && error.name === 'AuthApiError';
}
class AuthUnknownError extends AuthError {
  constructor(message, originalError) {
    super(message);
    this.name = 'AuthUnknownError';
    this.originalError = originalError;
  }
}
class CustomAuthError extends AuthError {
  constructor(message, name, status, code) {
    super(message, status, code);
    this.name = name;
    this.status = status;
  }
}
class AuthSessionMissingError extends CustomAuthError {
  constructor() {
    super('Auth session missing!', 'AuthSessionMissingError', 400, undefined);
  }
}
function isAuthSessionMissingError(error) {
  return isAuthError(error) && error.name === 'AuthSessionMissingError';
}
class AuthInvalidTokenResponseError extends CustomAuthError {
  constructor() {
    super('Auth session or user missing', 'AuthInvalidTokenResponseError', 500, undefined);
  }
}
class AuthInvalidCredentialsError extends CustomAuthError {
  constructor(message) {
    super(message, 'AuthInvalidCredentialsError', 400, undefined);
  }
}
class AuthImplicitGrantRedirectError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, 'AuthImplicitGrantRedirectError', 500, undefined);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
function isAuthImplicitGrantRedirectError(error) {
  return isAuthError(error) && error.name === 'AuthImplicitGrantRedirectError';
}
class AuthPKCEGrantCodeExchangeError extends CustomAuthError {
  constructor(message, details = null) {
    super(message, 'AuthPKCEGrantCodeExchangeError', 500, undefined);
    this.details = null;
    this.details = details;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    };
  }
}
class AuthRetryableFetchError extends CustomAuthError {
  constructor(message, status) {
    super(message, 'AuthRetryableFetchError', status, undefined);
  }
}
function isAuthRetryableFetchError(error) {
  return isAuthError(error) && error.name === 'AuthRetryableFetchError';
}
/**
 * This error is thrown on certain methods when the password used is deemed
 * weak. Inspect the reasons to identify what password strength rules are
 * inadequate.
 */
class AuthWeakPasswordError extends CustomAuthError {
  constructor(message, status, reasons) {
    super(message, 'AuthWeakPasswordError', status, 'weak_password');
    this.reasons = reasons;
  }
}
function isAuthWeakPasswordError(error) {
  return isAuthError(error) && error.name === 'AuthWeakPasswordError';
}
class AuthInvalidJwtError extends CustomAuthError {
  constructor(message) {
    super(message, 'AuthInvalidJwtError', 400, 'invalid_jwt');
  }
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!******************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),
/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),
/* harmony export */   _request: () => (/* binding */ _request),
/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),
/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),
/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),
/* harmony export */   _userResponse: () => (/* binding */ _userResponse),
/* harmony export */   handleError: () => (/* binding */ handleError)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "../node_modules/@supabase/auth-js/dist/module/lib/constants.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ "../node_modules/@supabase/auth-js/dist/module/lib/helpers.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ "../node_modules/@supabase/auth-js/dist/module/lib/errors.js");
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};



const _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const NETWORK_ERROR_CODES = [502, 503, 504];
async function handleError(error) {
  var _a;
  if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);
  }
  if (NETWORK_ERROR_CODES.includes(error.status)) {
    // status in 500...599 range - server had an error, request might be retryed.
    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);
  }
  let data;
  try {
    data = await error.json();
  } catch (e) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);
  }
  let errorCode = undefined;
  const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);
  if (responseAPIVersion && responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS['2024-01-01'].timestamp && typeof data === 'object' && data && typeof data.code === 'string') {
    errorCode = data.code;
  } else if (typeof data === 'object' && data && typeof data.error_code === 'string') {
    errorCode = data.error_code;
  }
  if (!errorCode) {
    // Legacy support for weak password errors, when there were no error codes
    if (typeof data === 'object' && data && typeof data.weak_password === 'object' && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);
    }
  } else if (errorCode === 'weak_password') {
    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);
  } else if (errorCode === 'session_not_found') {
    // The `session_id` inside the JWT does not correspond to a row in the
    // `sessions` table. This usually means the user has signed out, has been
    // deleted, or their session has somehow been terminated.
    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();
  }
  throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);
}
const _getRequestParams = (method, options, parameters, body) => {
  const params = {
    method,
    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
  };
  if (method === 'GET') {
    return params;
  }
  params.headers = Object.assign({
    'Content-Type': 'application/json;charset=UTF-8'
  }, options === null || options === void 0 ? void 0 : options.headers);
  params.body = JSON.stringify(body);
  return Object.assign(Object.assign({}, params), parameters);
};
async function _request(fetcher, method, url, options) {
  var _a;
  const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);
  if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {
    headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS['2024-01-01'].name;
  }
  if (options === null || options === void 0 ? void 0 : options.jwt) {
    headers['Authorization'] = `Bearer ${options.jwt}`;
  }
  const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};
  if (options === null || options === void 0 ? void 0 : options.redirectTo) {
    qs['redirect_to'] = options.redirectTo;
  }
  const queryString = Object.keys(qs).length ? '?' + new URLSearchParams(qs).toString() : '';
  const data = await _handleRequest(fetcher, method, url + queryString, {
    headers,
    noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson
  }, {}, options === null || options === void 0 ? void 0 : options.body);
  return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {
    data: Object.assign({}, data),
    error: null
  };
}
async function _handleRequest(fetcher, method, url, options, parameters, body) {
  const requestParams = _getRequestParams(method, options, parameters, body);
  let result;
  try {
    result = await fetcher(url, Object.assign({}, requestParams));
  } catch (e) {
    console.error(e);
    // fetch failed, likely due to a network or CORS error
    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);
  }
  if (!result.ok) {
    await handleError(result);
  }
  if (options === null || options === void 0 ? void 0 : options.noResolveJson) {
    return result;
  }
  try {
    return await result.json();
  } catch (e) {
    await handleError(e);
  }
}
function _sessionResponse(data) {
  var _a;
  let session = null;
  if (hasSession(data)) {
    session = Object.assign({}, data);
    if (!data.expires_at) {
      session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);
    }
  }
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return {
    data: {
      session,
      user
    },
    error: null
  };
}
function _sessionResponsePassword(data) {
  const response = _sessionResponse(data);
  if (!response.error && data.weak_password && typeof data.weak_password === 'object' && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === 'string' && data.weak_password.reasons.reduce((a, i) => a && typeof i === 'string', true)) {
    response.data.weak_password = data.weak_password;
  }
  return response;
}
function _userResponse(data) {
  var _a;
  const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;
  return {
    data: {
      user
    },
    error: null
  };
}
function _ssoResponse(data) {
  return {
    data,
    error: null
  };
}
function _generateLinkResponse(data) {
  const {
      action_link,
      email_otp,
      hashed_token,
      redirect_to,
      verification_type
    } = data,
    rest = __rest(data, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]);
  const properties = {
    action_link,
    email_otp,
    hashed_token,
    redirect_to,
    verification_type
  };
  const user = Object.assign({}, rest);
  return {
    data: {
      properties,
      user
    },
    error: null
  };
}
function _noResolveJsonResponse(data) {
  return data;
}
/**
 * hasSession checks if the response object contains a valid session
 * @param data A response object
 * @returns true if a session is in the response
 */
function hasSession(data) {
  return data.access_token && data.refresh_token && data.expires_in;
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Deferred: () => (/* binding */ Deferred),
/* harmony export */   decodeJWT: () => (/* binding */ decodeJWT),
/* harmony export */   expiresAt: () => (/* binding */ expiresAt),
/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),
/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),
/* harmony export */   getAlgorithm: () => (/* binding */ getAlgorithm),
/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),
/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),
/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),
/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),
/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),
/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),
/* harmony export */   retryable: () => (/* binding */ retryable),
/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),
/* harmony export */   sleep: () => (/* binding */ sleep),
/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),
/* harmony export */   uuid: () => (/* binding */ uuid),
/* harmony export */   validateExp: () => (/* binding */ validateExp)
/* harmony export */ });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "../node_modules/@supabase/auth-js/dist/module/lib/constants.js");
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ "../node_modules/@supabase/auth-js/dist/module/lib/errors.js");
/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url */ "../node_modules/@supabase/auth-js/dist/module/lib/base64url.js");



function expiresAt(expiresIn) {
  const timeNow = Math.round(Date.now() / 1000);
  return timeNow + expiresIn;
}
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    const r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
const isBrowser = () => typeof window !== 'undefined' && typeof document !== 'undefined';
const localStorageWriteTests = {
  tested: false,
  writable: false
};
/**
 * Checks whether localStorage is supported on this browser.
 */
const supportsLocalStorage = () => {
  if (!isBrowser()) {
    return false;
  }
  try {
    if (typeof globalThis.localStorage !== 'object') {
      return false;
    }
  } catch (e) {
    // DOM exception when accessing `localStorage`
    return false;
  }
  if (localStorageWriteTests.tested) {
    return localStorageWriteTests.writable;
  }
  const randomKey = `lswt-${Math.random()}${Math.random()}`;
  try {
    globalThis.localStorage.setItem(randomKey, randomKey);
    globalThis.localStorage.removeItem(randomKey);
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = true;
  } catch (e) {
    // localStorage can't be written to
    // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document
    localStorageWriteTests.tested = true;
    localStorageWriteTests.writable = false;
  }
  return localStorageWriteTests.writable;
};
/**
 * Extracts parameters encoded in the URL both in the query and fragment.
 */
function parseParametersFromURL(href) {
  const result = {};
  const url = new URL(href);
  if (url.hash && url.hash[0] === '#') {
    try {
      const hashSearchParams = new URLSearchParams(url.hash.substring(1));
      hashSearchParams.forEach((value, key) => {
        result[key] = value;
      });
    } catch (e) {
      // hash is not a query string
    }
  }
  // search parameters take precedence over hash parameters
  url.searchParams.forEach((value, key) => {
    result[key] = value;
  });
  return result;
}
const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ "../node_modules/@supabase/node-fetch/browser.js")).then(({
      default: fetch
    }) => fetch(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const looksLikeFetchResponse = maybeResponse => {
  return typeof maybeResponse === 'object' && maybeResponse !== null && 'status' in maybeResponse && 'ok' in maybeResponse && 'json' in maybeResponse && typeof maybeResponse.json === 'function';
};
// Storage helpers
const setItemAsync = async (storage, key, data) => {
  await storage.setItem(key, JSON.stringify(data));
};
const getItemAsync = async (storage, key) => {
  const value = await storage.getItem(key);
  if (!value) {
    return null;
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
};
const removeItemAsync = async (storage, key) => {
  await storage.removeItem(key);
};
/**
 * A deferred represents some asynchronous work that is not yet finished, which
 * may or may not culminate in a value.
 * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts
 */
class Deferred {
  constructor() {
    // eslint-disable-next-line @typescript-eslint/no-extra-semi
    ;
    this.promise = new Deferred.promiseConstructor((res, rej) => {
      // eslint-disable-next-line @typescript-eslint/no-extra-semi
      ;
      this.resolve = res;
      this.reject = rej;
    });
  }
}
Deferred.promiseConstructor = Promise;
function decodeJWT(token) {
  const parts = token.split('.');
  if (parts.length !== 3) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError('Invalid JWT structure');
  }
  // Regex checks for base64url format
  for (let i = 0; i < parts.length; i++) {
    if (!_constants__WEBPACK_IMPORTED_MODULE_0__.BASE64URL_REGEX.test(parts[i])) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError('JWT not in base64url format');
    }
  }
  const data = {
    // using base64url lib
    header: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[0])),
    payload: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[1])),
    signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_2__.base64UrlToUint8Array)(parts[2]),
    raw: {
      header: parts[0],
      payload: parts[1]
    }
  };
  return data;
}
/**
 * Creates a promise that resolves to null after some time.
 */
async function sleep(time) {
  return await new Promise(accept => {
    setTimeout(() => accept(null), time);
  });
}
/**
 * Converts the provided async function into a retryable function. Each result
 * or thrown error is sent to the isRetryable function which should return true
 * if the function should run again.
 */
function retryable(fn, isRetryable) {
  const promise = new Promise((accept, reject) => {
    // eslint-disable-next-line @typescript-eslint/no-extra-semi
    ;
    (async () => {
      for (let attempt = 0; attempt < Infinity; attempt++) {
        try {
          const result = await fn(attempt);
          if (!isRetryable(attempt, null, result)) {
            accept(result);
            return;
          }
        } catch (e) {
          if (!isRetryable(attempt, e)) {
            reject(e);
            return;
          }
        }
      }
    })();
  });
  return promise;
}
function dec2hex(dec) {
  return ('0' + dec.toString(16)).substr(-2);
}
// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs
function generatePKCEVerifier() {
  const verifierLength = 56;
  const array = new Uint32Array(verifierLength);
  if (typeof crypto === 'undefined') {
    const charSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
    const charSetLen = charSet.length;
    let verifier = '';
    for (let i = 0; i < verifierLength; i++) {
      verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));
    }
    return verifier;
  }
  crypto.getRandomValues(array);
  return Array.from(array, dec2hex).join('');
}
async function sha256(randomString) {
  const encoder = new TextEncoder();
  const encodedData = encoder.encode(randomString);
  const hash = await crypto.subtle.digest('SHA-256', encodedData);
  const bytes = new Uint8Array(hash);
  return Array.from(bytes).map(c => String.fromCharCode(c)).join('');
}
async function generatePKCEChallenge(verifier) {
  const hasCryptoSupport = typeof crypto !== 'undefined' && typeof crypto.subtle !== 'undefined' && typeof TextEncoder !== 'undefined';
  if (!hasCryptoSupport) {
    console.warn('WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.');
    return verifier;
  }
  const hashed = await sha256(verifier);
  return btoa(hashed).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
async function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {
  const codeVerifier = generatePKCEVerifier();
  let storedCodeVerifier = codeVerifier;
  if (isPasswordRecovery) {
    storedCodeVerifier += '/PASSWORD_RECOVERY';
  }
  await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);
  const codeChallenge = await generatePKCEChallenge(codeVerifier);
  const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';
  return [codeChallenge, codeChallengeMethod];
}
/** Parses the API version which is 2YYY-MM-DD. */
const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function parseResponseAPIVersion(response) {
  const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);
  if (!apiVersion) {
    return null;
  }
  if (!apiVersion.match(API_VERSION_REGEX)) {
    return null;
  }
  try {
    const date = new Date(`${apiVersion}T00:00:00.0Z`);
    return date;
  } catch (e) {
    return null;
  }
}
function validateExp(exp) {
  if (!exp) {
    throw new Error('Missing exp claim');
  }
  const timeNow = Math.floor(Date.now() / 1000);
  if (exp <= timeNow) {
    throw new Error('JWT has expired');
  }
}
function getAlgorithm(alg) {
  switch (alg) {
    case 'RS256':
      return {
        name: 'RSASSA-PKCS1-v1_5',
        hash: {
          name: 'SHA-256'
        }
      };
    case 'ES256':
      return {
        name: 'ECDSA',
        namedCurve: 'P-256',
        hash: {
          name: 'SHA-256'
        }
      };
    default:
      throw new Error('Invalid alg claim');
  }
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   localStorageAdapter: () => (/* binding */ localStorageAdapter),
/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "../node_modules/@supabase/auth-js/dist/module/lib/helpers.js");

/**
 * Provides safe access to the globalThis.localStorage property.
 */
const localStorageAdapter = {
  getItem: key => {
    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {
      return null;
    }
    return globalThis.localStorage.getItem(key);
  },
  setItem: (key, value) => {
    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {
      return;
    }
    globalThis.localStorage.setItem(key, value);
  },
  removeItem: key => {
    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)()) {
      return;
    }
    globalThis.localStorage.removeItem(key);
  }
};
/**
 * Returns a localStorage-like object that stores the key-value pairs in
 * memory.
 */
function memoryLocalStorageAdapter(store = {}) {
  return {
    getItem: key => {
      return store[key] || null;
    },
    setItem: (key, value) => {
      store[key] = value;
    },
    removeItem: key => {
      delete store[key];
    }
  };
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!******************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),
/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),
/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),
/* harmony export */   internals: () => (/* binding */ internals),
/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),
/* harmony export */   processLock: () => (/* binding */ processLock)
/* harmony export */ });
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "../node_modules/@supabase/auth-js/dist/module/lib/helpers.js");

/**
 * @experimental
 */
const internals = {
  /**
   * @experimental
   */
  debug: !!(globalThis && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true')
};
/**
 * An error thrown when a lock cannot be acquired after some amount of time.
 *
 * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.
 */
class LockAcquireTimeoutError extends Error {
  constructor(message) {
    super(message);
    this.isAcquireTimeout = true;
  }
}
class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}
class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}
/**
 * Implements a global exclusive lock using the Navigator LockManager API. It
 * is available on all browsers released after 2022-03-15 with Safari being the
 * last one to release support. If the API is not available, this function will
 * throw. Make sure you check availablility before configuring {@link
 * GoTrueClient}.
 *
 * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`
 * local storage item to `true`.
 *
 * Internals:
 *
 * Since the LockManager API does not preserve stack traces for the async
 * function passed in the `request` method, a trick is used where acquiring the
 * lock releases a previously started promise to run the operation in the `fn`
 * function. The lock waits for that promise to finish (with or without error),
 * while the function will finally wait for the result anyway.
 *
 * @param name Name of the lock to be acquired.
 * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if
 *                       the lock can't be acquired without waiting. If positive, the lock acquire
 *                       will time out after so many milliseconds. An error is
 *                       a timeout if it has `isAcquireTimeout` set to true.
 * @param fn The operation to run once the lock is acquired.
 */
async function navigatorLock(name, acquireTimeout, fn) {
  if (internals.debug) {
    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout);
  }
  const abortController = new globalThis.AbortController();
  if (acquireTimeout > 0) {
    setTimeout(() => {
      abortController.abort();
      if (internals.debug) {
        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name);
      }
    }, acquireTimeout);
  }
  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request
  // Wrapping navigator.locks.request() with a plain Promise is done as some
  // libraries like zone.js patch the Promise object to track the execution
  // context. However, it appears that most browsers use an internal promise
  // implementation when using the navigator.locks.request() API causing them
  // to lose context and emit confusing log messages or break certain features.
  // This wrapping is believed to help zone.js track the execution context
  // better.
  return await Promise.resolve().then(() => globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {
    mode: 'exclusive',
    ifAvailable: true
  } : {
    mode: 'exclusive',
    signal: abortController.signal
  }, async lock => {
    if (lock) {
      if (internals.debug) {
        console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name);
      }
      try {
        return await fn();
      } finally {
        if (internals.debug) {
          console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name);
        }
      }
    } else {
      if (acquireTimeout === 0) {
        if (internals.debug) {
          console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name);
        }
        throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock "${name}" immediately failed`);
      } else {
        if (internals.debug) {
          try {
            const result = await globalThis.navigator.locks.query();
            console.log('@supabase/gotrue-js: Navigator LockManager state', JSON.stringify(result, null, '  '));
          } catch (e) {
            console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state', e);
          }
        }
        // Browser is not following the Navigator LockManager spec, it
        // returned a null lock when we didn't use ifAvailable. So we can
        // pretend the lock is acquired in the name of backward compatibility
        // and user experience and just run the function.
        console.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');
        return await fn();
      }
    }
  }));
}
const PROCESS_LOCKS = {};
/**
 * Implements a global exclusive lock that works only in the current process.
 * Useful for environments like React Native or other non-browser
 * single-process (i.e. no concept of "tabs") environments.
 *
 * Use {@link #navigatorLock} in browser environments.
 *
 * @param name Name of the lock to be acquired.
 * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if
 *                       the lock can't be acquired without waiting. If positive, the lock acquire
 *                       will time out after so many milliseconds. An error is
 *                       a timeout if it has `isAcquireTimeout` set to true.
 * @param fn The operation to run once the lock is acquired.
 */
async function processLock(name, acquireTimeout, fn) {
  var _a;
  const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();
  const currentOperation = Promise.race([previousOperation.catch(() => {
    // ignore error of previous operation that we're waiting to finish
    return null;
  }), acquireTimeout >= 0 ? new Promise((_, reject) => {
    setTimeout(() => {
      reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name "${name}" timed out`));
    }, acquireTimeout);
  }) : null].filter(x => x)).catch(e => {
    if (e && e.isAcquireTimeout) {
      throw e;
    }
    return null;
  }).then(async () => {
    // previous operations finished and we didn't get a race on the acquire
    // timeout, so the current operation can finally start
    return await fn();
  });
  PROCESS_LOCKS[name] = currentOperation.catch(async e => {
    if (e && e.isAcquireTimeout) {
      // if the current operation timed out, it doesn't mean that the previous
      // operation finished, so we need contnue waiting for it to finish
      await previousOperation;
      return null;
    }
    throw e;
  });
  // finally wait for the current operation to finish successfully, with an
  // error or with an acquire timeout error
  return await currentOperation;
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)
/* harmony export */ });
/**
 * https://mathiasbynens.be/notes/globalthis
 */
function polyfillGlobalThis() {
  if (typeof globalThis === 'object') return;
  try {
    Object.defineProperty(Object.prototype, '__magic__', {
      get: function () {
        return this;
      },
      configurable: true
    });
    // @ts-expect-error 'Allow access to magic'
    __magic__.globalThis = __magic__;
    // @ts-expect-error 'Allow access to magic'
    delete Object.prototype.__magic__;
  } catch (e) {
    if (typeof self !== 'undefined') {
      // @ts-expect-error 'Allow access to globals'
      self.globalThis = self;
    }
  }
}

/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!******************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);


/***/ }),

/***/ "../node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!********************************************************************!*\
  !*** ../node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
const version = '2.69.1';

/***/ }),

/***/ "../node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FunctionsClient: () => (/* binding */ FunctionsClient)
/* harmony export */ });
/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ "../node_modules/@supabase/functions-js/dist/module/helper.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ "../node_modules/@supabase/functions-js/dist/module/types.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};


class FunctionsClient {
  constructor(url, {
    headers = {},
    customFetch,
    region = _types__WEBPACK_IMPORTED_MODULE_0__.FunctionRegion.Any
  } = {}) {
    this.url = url;
    this.headers = headers;
    this.region = region;
    this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(customFetch);
  }
  /**
   * Updates the authorization header
   * @param token - the new jwt token sent in the authorisation header
   */
  setAuth(token) {
    this.headers.Authorization = `Bearer ${token}`;
  }
  /**
   * Invokes a function
   * @param functionName - The name of the Function to invoke.
   * @param options - Options for invoking the Function.
   */
  invoke(functionName, options = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const {
          headers,
          method,
          body: functionArgs
        } = options;
        let _headers = {};
        let {
          region
        } = options;
        if (!region) {
          region = this.region;
        }
        if (region && region !== 'any') {
          _headers['x-region'] = region;
        }
        let body;
        if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, 'Content-Type') || !headers)) {
          if (typeof Blob !== 'undefined' && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {
            // will work for File as File inherits Blob
            // also works for ArrayBuffer as it is the same underlying structure as a Blob
            _headers['Content-Type'] = 'application/octet-stream';
            body = functionArgs;
          } else if (typeof functionArgs === 'string') {
            // plain string
            _headers['Content-Type'] = 'text/plain';
            body = functionArgs;
          } else if (typeof FormData !== 'undefined' && functionArgs instanceof FormData) {
            // don't set content-type headers
            // Request will automatically add the right boundary value
            body = functionArgs;
          } else {
            // default, assume this is JSON
            _headers['Content-Type'] = 'application/json';
            body = JSON.stringify(functionArgs);
          }
        }
        const response = yield this.fetch(`${this.url}/${functionName}`, {
          method: method || 'POST',
          // headers priority is (high to low):
          // 1. invoke-level headers
          // 2. client-level headers
          // 3. default Content-Type header
          headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),
          body
        }).catch(fetchError => {
          throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(fetchError);
        });
        const isRelayError = response.headers.get('x-relay-error');
        if (isRelayError && isRelayError === 'true') {
          throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError(response);
        }
        if (!response.ok) {
          throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError(response);
        }
        let responseType = ((_a = response.headers.get('Content-Type')) !== null && _a !== void 0 ? _a : 'text/plain').split(';')[0].trim();
        let data;
        if (responseType === 'application/json') {
          data = yield response.json();
        } else if (responseType === 'application/octet-stream') {
          data = yield response.blob();
        } else if (responseType === 'text/event-stream') {
          data = response;
        } else if (responseType === 'multipart/form-data') {
          data = yield response.formData();
        } else {
          // default to text
          data = yield response.text();
        }
        return {
          data,
          error: null
        };
      } catch (error) {
        return {
          data: null,
          error
        };
      }
    });
  }
}

/***/ }),

/***/ "../node_modules/@supabase/functions-js/dist/module/helper.js":
/*!********************************************************************!*\
  !*** ../node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch)
/* harmony export */ });
const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ "../node_modules/@supabase/node-fetch/browser.js")).then(({
      default: fetch
    }) => fetch(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};

/***/ }),

/***/ "../node_modules/@supabase/functions-js/dist/module/types.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@supabase/functions-js/dist/module/types.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FunctionRegion: () => (/* binding */ FunctionRegion),
/* harmony export */   FunctionsError: () => (/* binding */ FunctionsError),
/* harmony export */   FunctionsFetchError: () => (/* binding */ FunctionsFetchError),
/* harmony export */   FunctionsHttpError: () => (/* binding */ FunctionsHttpError),
/* harmony export */   FunctionsRelayError: () => (/* binding */ FunctionsRelayError)
/* harmony export */ });
class FunctionsError extends Error {
  constructor(message, name = 'FunctionsError', context) {
    super(message);
    this.name = name;
    this.context = context;
  }
}
class FunctionsFetchError extends FunctionsError {
  constructor(context) {
    super('Failed to send a request to the Edge Function', 'FunctionsFetchError', context);
  }
}
class FunctionsRelayError extends FunctionsError {
  constructor(context) {
    super('Relay Error invoking the Edge Function', 'FunctionsRelayError', context);
  }
}
class FunctionsHttpError extends FunctionsError {
  constructor(context) {
    super('Edge Function returned a non-2xx status code', 'FunctionsHttpError', context);
  }
}
// Define the enum for the 'region' property
var FunctionRegion;
(function (FunctionRegion) {
  FunctionRegion["Any"] = "any";
  FunctionRegion["ApNortheast1"] = "ap-northeast-1";
  FunctionRegion["ApNortheast2"] = "ap-northeast-2";
  FunctionRegion["ApSouth1"] = "ap-south-1";
  FunctionRegion["ApSoutheast1"] = "ap-southeast-1";
  FunctionRegion["ApSoutheast2"] = "ap-southeast-2";
  FunctionRegion["CaCentral1"] = "ca-central-1";
  FunctionRegion["EuCentral1"] = "eu-central-1";
  FunctionRegion["EuWest1"] = "eu-west-1";
  FunctionRegion["EuWest2"] = "eu-west-2";
  FunctionRegion["EuWest3"] = "eu-west-3";
  FunctionRegion["SaEast1"] = "sa-east-1";
  FunctionRegion["UsEast1"] = "us-east-1";
  FunctionRegion["UsWest1"] = "us-west-1";
  FunctionRegion["UsWest2"] = "us-west-2";
})(FunctionRegion || (FunctionRegion = {}));

/***/ }),

/***/ "../node_modules/@supabase/node-fetch/browser.js":
/*!*******************************************************!*\
  !*** ../node_modules/@supabase/node-fetch/browser.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Headers: () => (/* binding */ Headers),
/* harmony export */   Request: () => (/* binding */ Request),
/* harmony export */   Response: () => (/* binding */ Response),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fetch: () => (/* binding */ fetch)
/* harmony export */ });


// ref: https://github.com/tc39/proposal-global
var getGlobal = function () {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof __webpack_require__.g !== 'undefined') {
    return __webpack_require__.g;
  }
  throw new Error('unable to locate global object');
};
var globalObject = getGlobal();
const fetch = globalObject.fetch;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (globalObject.fetch.bind(globalObject));
const Headers = globalObject.Headers;
const Request = globalObject.Request;
const Response = globalObject.Response;

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
// @ts-ignore
const node_fetch_1 = __importDefault(__webpack_require__(/*! @supabase/node-fetch */ "../node_modules/@supabase/node-fetch/browser.js"));
const PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"));
class PostgrestBuilder {
  constructor(builder) {
    this.shouldThrowOnError = false;
    this.method = builder.method;
    this.url = builder.url;
    this.headers = builder.headers;
    this.schema = builder.schema;
    this.body = builder.body;
    this.shouldThrowOnError = builder.shouldThrowOnError;
    this.signal = builder.signal;
    this.isMaybeSingle = builder.isMaybeSingle;
    if (builder.fetch) {
      this.fetch = builder.fetch;
    } else if (typeof fetch === 'undefined') {
      this.fetch = node_fetch_1.default;
    } else {
      this.fetch = fetch;
    }
  }
  /**
   * If there's an error with the query, throwOnError will reject the promise by
   * throwing the error instead of returning it as part of a successful response.
   *
   * {@link https://github.com/supabase/supabase-js/issues/92}
   */
  throwOnError() {
    this.shouldThrowOnError = true;
    return this;
  }
  /**
   * Set an HTTP header for the request.
   */
  setHeader(name, value) {
    this.headers = Object.assign({}, this.headers);
    this.headers[name] = value;
    return this;
  }
  then(onfulfilled, onrejected) {
    // https://postgrest.org/en/stable/api.html#switching-schemas
    if (this.schema === undefined) {
      // skip
    } else if (['GET', 'HEAD'].includes(this.method)) {
      this.headers['Accept-Profile'] = this.schema;
    } else {
      this.headers['Content-Profile'] = this.schema;
    }
    if (this.method !== 'GET' && this.method !== 'HEAD') {
      this.headers['Content-Type'] = 'application/json';
    }
    // NOTE: Invoke w/o `this` to avoid illegal invocation error.
    // https://github.com/supabase/postgrest-js/pull/247
    const _fetch = this.fetch;
    let res = _fetch(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal
    }).then(async res => {
      var _a, _b, _c;
      let error = null;
      let data = null;
      let count = null;
      let status = res.status;
      let statusText = res.statusText;
      if (res.ok) {
        if (this.method !== 'HEAD') {
          const body = await res.text();
          if (body === '') {
            // Prefer: return=minimal
          } else if (this.headers['Accept'] === 'text/csv') {
            data = body;
          } else if (this.headers['Accept'] && this.headers['Accept'].includes('application/vnd.pgrst.plan+text')) {
            data = body;
          } else {
            data = JSON.parse(body);
          }
        }
        const countHeader = (_a = this.headers['Prefer']) === null || _a === void 0 ? void 0 : _a.match(/count=(exact|planned|estimated)/);
        const contentRange = (_b = res.headers.get('content-range')) === null || _b === void 0 ? void 0 : _b.split('/');
        if (countHeader && contentRange && contentRange.length > 1) {
          count = parseInt(contentRange[1]);
        }
        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {
          if (data.length > 1) {
            error = {
              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553
              code: 'PGRST116',
              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,
              hint: null,
              message: 'JSON object requested, multiple (or no) rows returned'
            };
            data = null;
            count = null;
            status = 406;
            statusText = 'Not Acceptable';
          } else if (data.length === 1) {
            data = data[0];
          } else {
            data = null;
          }
        }
      } else {
        const body = await res.text();
        try {
          error = JSON.parse(body);
          // Workaround for https://github.com/supabase/postgrest-js/issues/295
          if (Array.isArray(error) && res.status === 404) {
            data = [];
            error = null;
            status = 200;
            statusText = 'OK';
          }
        } catch (_d) {
          // Workaround for https://github.com/supabase/postgrest-js/issues/295
          if (res.status === 404 && body === '') {
            status = 204;
            statusText = 'No Content';
          } else {
            error = {
              message: body
            };
          }
        }
        if (error && this.isMaybeSingle && ((_c = error === null || error === void 0 ? void 0 : error.details) === null || _c === void 0 ? void 0 : _c.includes('0 rows'))) {
          error = null;
          status = 200;
          statusText = 'OK';
        }
        if (error && this.shouldThrowOnError) {
          throw new PostgrestError_1.default(error);
        }
      }
      const postgrestResponse = {
        error,
        data,
        count,
        status,
        statusText
      };
      return postgrestResponse;
    });
    if (!this.shouldThrowOnError) {
      res = res.catch(fetchError => {
        var _a, _b, _c;
        return {
          error: {
            message: `${(_a = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a !== void 0 ? _a : 'FetchError'}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,
            details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : ''}`,
            hint: '',
            code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : ''}`
          },
          data: null,
          count: null,
          status: 0,
          statusText: ''
        };
      });
    }
    return res.then(onfulfilled, onrejected);
  }
  /**
   * Override the type of the returned `data`.
   *
   * @typeParam NewResult - The new result type to override with
   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
   */
  returns() {
    /* istanbul ignore next */
    return this;
  }
  /**
   * Override the type of the returned `data` field in the response.
   *
   * @typeParam NewResult - The new type to cast the response data to
   * @typeParam Options - Optional type configuration (defaults to { merge: true })
   * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)
   * @example
   * ```typescript
   * // Merge with existing types (default behavior)
   * const query = supabase
   *   .from('users')
   *   .select()
   *   .overrideTypes<{ custom_field: string }>()
   *
   * // Replace existing types completely
   * const replaceQuery = supabase
   *   .from('users')
   *   .select()
   *   .overrideTypes<{ id: number; name: string }, { merge: false }>()
   * ```
   * @returns A PostgrestBuilder instance with the new type
   */
  overrideTypes() {
    return this;
  }
}
exports["default"] = PostgrestBuilder;

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js"));
const PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"));
const constants_1 = __webpack_require__(/*! ./constants */ "../node_modules/@supabase/postgrest-js/dist/cjs/constants.js");
/**
 * PostgREST client.
 *
 * @typeParam Database - Types for the schema from the [type
 * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)
 *
 * @typeParam SchemaName - Postgres schema to switch to. Must be a string
 * literal, the same one passed to the constructor. If the schema is not
 * `"public"`, this must be supplied manually.
 */
class PostgrestClient {
  // TODO: Add back shouldThrowOnError once we figure out the typings
  /**
   * Creates a PostgREST client.
   *
   * @param url - URL of the PostgREST endpoint
   * @param options - Named parameters
   * @param options.headers - Custom headers
   * @param options.schema - Postgres schema to switch to
   * @param options.fetch - Custom fetch
   */
  constructor(url, {
    headers = {},
    schema,
    fetch
  } = {}) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, constants_1.DEFAULT_HEADERS), headers);
    this.schemaName = schema;
    this.fetch = fetch;
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    const url = new URL(`${this.url}/${relation}`);
    return new PostgrestQueryBuilder_1.default(url, {
      headers: Object.assign({}, this.headers),
      schema: this.schemaName,
      fetch: this.fetch
    });
  }
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return new PostgrestClient(this.url, {
      headers: this.headers,
      schema,
      fetch: this.fetch
    });
  }
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, {
    head = false,
    get = false,
    count
  } = {}) {
    let method;
    const url = new URL(`${this.url}/rpc/${fn}`);
    let body;
    if (head || get) {
      method = head ? 'HEAD' : 'GET';
      Object.entries(args)
      // params with undefined value needs to be filtered out, otherwise it'll
      // show up as `?param=undefined`
      .filter(([_, value]) => value !== undefined)
      // array values need special syntax
      .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`]).forEach(([name, value]) => {
        url.searchParams.append(name, value);
      });
    } else {
      method = 'POST';
      body = args;
    }
    const headers = Object.assign({}, this.headers);
    if (count) {
      headers['Prefer'] = `count=${count}`;
    }
    return new PostgrestFilterBuilder_1.default({
      method,
      url,
      headers,
      schema: this.schemaName,
      body,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
}
exports["default"] = PostgrestClient;

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
/**
 * Error format
 *
 * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}
 */
class PostgrestError extends Error {
  constructor(context) {
    super(context.message);
    this.name = 'PostgrestError';
    this.details = context.details;
    this.hint = context.hint;
    this.code = context.code;
  }
}
exports["default"] = PostgrestError;

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js"));
class PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {
  /**
   * Match only rows where `column` is equal to `value`.
   *
   * To check if the value of `column` is NULL, you should use `.is()` instead.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  eq(column, value) {
    this.url.searchParams.append(column, `eq.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is not equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  neq(column, value) {
    this.url.searchParams.append(column, `neq.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is greater than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gt(column, value) {
    this.url.searchParams.append(column, `gt.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is greater than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  gte(column, value) {
    this.url.searchParams.append(column, `gte.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is less than `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lt(column, value) {
    this.url.searchParams.append(column, `lt.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is less than or equal to `value`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  lte(column, value) {
    this.url.searchParams.append(column, `lte.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-sensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  like(column, pattern) {
    this.url.searchParams.append(column, `like.${pattern}`);
    return this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAllOf(column, patterns) {
    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-sensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  likeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches `pattern` case-insensitively.
   *
   * @param column - The column to filter on
   * @param pattern - The pattern to match with
   */
  ilike(column, pattern) {
    this.url.searchParams.append(column, `ilike.${pattern}`);
    return this;
  }
  /**
   * Match only rows where `column` matches all of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAllOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` matches any of `patterns` case-insensitively.
   *
   * @param column - The column to filter on
   * @param patterns - The patterns to match with
   */
  ilikeAnyOf(column, patterns) {
    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`);
    return this;
  }
  /**
   * Match only rows where `column` IS `value`.
   *
   * For non-boolean columns, this is only relevant for checking if the value of
   * `column` is NULL by setting `value` to `null`.
   *
   * For boolean columns, you can also set `value` to `true` or `false` and it
   * will behave the same way as `.eq()`.
   *
   * @param column - The column to filter on
   * @param value - The value to filter with
   */
  is(column, value) {
    this.url.searchParams.append(column, `is.${value}`);
    return this;
  }
  /**
   * Match only rows where `column` is included in the `values` array.
   *
   * @param column - The column to filter on
   * @param values - The values array to filter with
   */
  in(column, values) {
    const cleanedValues = Array.from(new Set(values)).map(s => {
      // handle postgrest reserved characters
      // https://postgrest.org/en/v7.0.0/api.html#reserved-characters
      if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `"${s}"`;else return `${s}`;
    }).join(',');
    this.url.searchParams.append(column, `in.(${cleanedValues})`);
    return this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * `column` contains every element appearing in `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  contains(column, value) {
    if (typeof value === 'string') {
      // range types can be inclusive '[', ']' or exclusive '(', ')' so just
      // keep it simple and accept a string
      this.url.searchParams.append(column, `cs.${value}`);
    } else if (Array.isArray(value)) {
      // array
      this.url.searchParams.append(column, `cs.{${value.join(',')}}`);
    } else {
      // json
      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);
    }
    return this;
  }
  /**
   * Only relevant for jsonb, array, and range columns. Match only rows where
   * every element appearing in `column` is contained by `value`.
   *
   * @param column - The jsonb, array, or range column to filter on
   * @param value - The jsonb, array, or range value to filter with
   */
  containedBy(column, value) {
    if (typeof value === 'string') {
      // range
      this.url.searchParams.append(column, `cd.${value}`);
    } else if (Array.isArray(value)) {
      // array
      this.url.searchParams.append(column, `cd.{${value.join(',')}}`);
    } else {
      // json
      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);
    }
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is greater than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGt(column, range) {
    this.url.searchParams.append(column, `sr.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or greater than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeGte(column, range) {
    this.url.searchParams.append(column, `nxl.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is less than any element in `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLt(column, range) {
    this.url.searchParams.append(column, `sl.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where every element in
   * `column` is either contained in `range` or less than any element in
   * `range`.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeLte(column, range) {
    this.url.searchParams.append(column, `nxr.${range}`);
    return this;
  }
  /**
   * Only relevant for range columns. Match only rows where `column` is
   * mutually exclusive to `range` and there can be no element between the two
   * ranges.
   *
   * @param column - The range column to filter on
   * @param range - The range to filter with
   */
  rangeAdjacent(column, range) {
    this.url.searchParams.append(column, `adj.${range}`);
    return this;
  }
  /**
   * Only relevant for array and range columns. Match only rows where
   * `column` and `value` have an element in common.
   *
   * @param column - The array or range column to filter on
   * @param value - The array or range value to filter with
   */
  overlaps(column, value) {
    if (typeof value === 'string') {
      // range
      this.url.searchParams.append(column, `ov.${value}`);
    } else {
      // array
      this.url.searchParams.append(column, `ov.{${value.join(',')}}`);
    }
    return this;
  }
  /**
   * Only relevant for text and tsvector columns. Match only rows where
   * `column` matches the query string in `query`.
   *
   * @param column - The text or tsvector column to filter on
   * @param query - The query text to match with
   * @param options - Named parameters
   * @param options.config - The text search configuration to use
   * @param options.type - Change how the `query` text is interpreted
   */
  textSearch(column, query, {
    config,
    type
  } = {}) {
    let typePart = '';
    if (type === 'plain') {
      typePart = 'pl';
    } else if (type === 'phrase') {
      typePart = 'ph';
    } else if (type === 'websearch') {
      typePart = 'w';
    }
    const configPart = config === undefined ? '' : `(${config})`;
    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);
    return this;
  }
  /**
   * Match only rows where each column in `query` keys is equal to its
   * associated value. Shorthand for multiple `.eq()`s.
   *
   * @param query - The object to filter with, with column names as keys mapped
   * to their filter values
   */
  match(query) {
    Object.entries(query).forEach(([column, value]) => {
      this.url.searchParams.append(column, `eq.${value}`);
    });
    return this;
  }
  /**
   * Match only rows which doesn't satisfy the filter.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to be negated to filter with, following
   * PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  not(column, operator, value) {
    this.url.searchParams.append(column, `not.${operator}.${value}`);
    return this;
  }
  /**
   * Match only rows which satisfy at least one of the filters.
   *
   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure it's properly sanitized.
   *
   * It's currently not possible to do an `.or()` filter across multiple tables.
   *
   * @param filters - The filters to use, following PostgREST syntax
   * @param options - Named parameters
   * @param options.referencedTable - Set this to filter on referenced tables
   * instead of the parent table
   * @param options.foreignTable - Deprecated, use `referencedTable` instead
   */
  or(filters, {
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const key = referencedTable ? `${referencedTable}.or` : 'or';
    this.url.searchParams.append(key, `(${filters})`);
    return this;
  }
  /**
   * Match only rows which satisfy the filter. This is an escape hatch - you
   * should use the specific filter methods wherever possible.
   *
   * Unlike most filters, `opearator` and `value` are used as-is and need to
   * follow [PostgREST
   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need
   * to make sure they are properly sanitized.
   *
   * @param column - The column to filter on
   * @param operator - The operator to filter with, following PostgREST syntax
   * @param value - The value to filter with, following PostgREST syntax
   */
  filter(column, operator, value) {
    this.url.searchParams.append(column, `${operator}.${value}`);
    return this;
  }
}
exports["default"] = PostgrestFilterBuilder;

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"));
class PostgrestQueryBuilder {
  constructor(url, {
    headers = {},
    schema,
    fetch
  }) {
    this.url = url;
    this.headers = headers;
    this.schema = schema;
    this.fetch = fetch;
  }
  /**
   * Perform a SELECT query on the table or view.
   *
   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`
   *
   * @param options - Named parameters
   *
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   *
   * @param options.count - Count algorithm to use to count rows in the table or view.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  select(columns, {
    head = false,
    count
  } = {}) {
    const method = head ? 'HEAD' : 'GET';
    // Remove whitespaces except when quoted
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {
      if (/\s/.test(c) && !quoted) {
        return '';
      }
      if (c === '"') {
        quoted = !quoted;
      }
      return c;
    }).join('');
    this.url.searchParams.set('select', cleanedColumns);
    if (count) {
      this.headers['Prefer'] = `count=${count}`;
    }
    return new PostgrestFilterBuilder_1.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an INSERT into the table or view.
   *
   * By default, inserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to insert. Pass an object to insert a single row
   * or an array to insert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count inserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. Only applies for bulk
   * inserts.
   */
  insert(values, {
    count,
    defaultToNull = true
  } = {}) {
    const method = 'POST';
    const prefersHeaders = [];
    if (this.headers['Prefer']) {
      prefersHeaders.push(this.headers['Prefer']);
    }
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    if (!defaultToNull) {
      prefersHeaders.push('missing=default');
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    if (Array.isArray(values)) {
      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map(column => `"${column}"`);
        this.url.searchParams.set('columns', uniqueColumns.join(','));
      }
    }
    return new PostgrestFilterBuilder_1.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an UPSERT on the table or view. Depending on the column(s) passed
   * to `onConflict`, `.upsert()` allows you to perform the equivalent of
   * `.insert()` if a row with the corresponding `onConflict` columns doesn't
   * exist, or if it does exist, perform an alternative action depending on
   * `ignoreDuplicates`.
   *
   * By default, upserted rows are not returned. To return it, chain the call
   * with `.select()`.
   *
   * @param values - The values to upsert with. Pass an object to upsert a
   * single row or an array to upsert multiple rows.
   *
   * @param options - Named parameters
   *
   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how
   * duplicate rows are determined. Two rows are duplicates if all the
   * `onConflict` columns are equal.
   *
   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If
   * `false`, duplicate rows are merged with existing rows.
   *
   * @param options.count - Count algorithm to use to count upserted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   *
   * @param options.defaultToNull - Make missing fields default to `null`.
   * Otherwise, use the default value for the column. This only applies when
   * inserting new rows, not when merging with existing rows under
   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.
   */
  upsert(values, {
    onConflict,
    ignoreDuplicates = false,
    count,
    defaultToNull = true
  } = {}) {
    const method = 'POST';
    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`];
    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict);
    if (this.headers['Prefer']) {
      prefersHeaders.push(this.headers['Prefer']);
    }
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    if (!defaultToNull) {
      prefersHeaders.push('missing=default');
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    if (Array.isArray(values)) {
      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), []);
      if (columns.length > 0) {
        const uniqueColumns = [...new Set(columns)].map(column => `"${column}"`);
        this.url.searchParams.set('columns', uniqueColumns.join(','));
      }
    }
    return new PostgrestFilterBuilder_1.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform an UPDATE on the table or view.
   *
   * By default, updated rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param values - The values to update with
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count updated rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  update(values, {
    count
  } = {}) {
    const method = 'PATCH';
    const prefersHeaders = [];
    if (this.headers['Prefer']) {
      prefersHeaders.push(this.headers['Prefer']);
    }
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    return new PostgrestFilterBuilder_1.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: values,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
  /**
   * Perform a DELETE on the table or view.
   *
   * By default, deleted rows are not returned. To return it, chain the call
   * with `.select()` after filters.
   *
   * @param options - Named parameters
   *
   * @param options.count - Count algorithm to use to count deleted rows.
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  delete({
    count
  } = {}) {
    const method = 'DELETE';
    const prefersHeaders = [];
    if (count) {
      prefersHeaders.push(`count=${count}`);
    }
    if (this.headers['Prefer']) {
      prefersHeaders.unshift(this.headers['Prefer']);
    }
    this.headers['Prefer'] = prefersHeaders.join(',');
    return new PostgrestFilterBuilder_1.default({
      method,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: false
    });
  }
}
exports["default"] = PostgrestQueryBuilder;

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
const PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"));
class PostgrestTransformBuilder extends PostgrestBuilder_1.default {
  /**
   * Perform a SELECT on the query result.
   *
   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not
   * return modified rows. By calling this method, modified rows are returned in
   * `data`.
   *
   * @param columns - The columns to retrieve, separated by commas
   */
  select(columns) {
    // Remove whitespaces except when quoted
    let quoted = false;
    const cleanedColumns = (columns !== null && columns !== void 0 ? columns : '*').split('').map(c => {
      if (/\s/.test(c) && !quoted) {
        return '';
      }
      if (c === '"') {
        quoted = !quoted;
      }
      return c;
    }).join('');
    this.url.searchParams.set('select', cleanedColumns);
    if (this.headers['Prefer']) {
      this.headers['Prefer'] += ',';
    }
    this.headers['Prefer'] += 'return=representation';
    return this;
  }
  /**
   * Order the query result by `column`.
   *
   * You can call this method multiple times to order by multiple columns.
   *
   * You can order referenced tables, but it only affects the ordering of the
   * parent table if you use `!inner` in the query.
   *
   * @param column - The column to order by
   * @param options - Named parameters
   * @param options.ascending - If `true`, the result will be in ascending order
   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,
   * `null`s appear last.
   * @param options.referencedTable - Set this to order a referenced table by
   * its columns
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  order(column, {
    ascending = true,
    nullsFirst,
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const key = referencedTable ? `${referencedTable}.order` : 'order';
    const existingOrder = this.url.searchParams.get(key);
    this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'}`);
    return this;
  }
  /**
   * Limit the query result by `count`.
   *
   * @param count - The maximum number of rows to return
   * @param options - Named parameters
   * @param options.referencedTable - Set this to limit rows of referenced
   * tables instead of the parent table
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  limit(count, {
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;
    this.url.searchParams.set(key, `${count}`);
    return this;
  }
  /**
   * Limit the query result by starting at an offset `from` and ending at the offset `to`.
   * Only records within this range are returned.
   * This respects the query order and if there is no order clause the range could behave unexpectedly.
   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third
   * and fourth rows of the query.
   *
   * @param from - The starting index from which to limit the result
   * @param to - The last index to which to limit the result
   * @param options - Named parameters
   * @param options.referencedTable - Set this to limit rows of referenced
   * tables instead of the parent table
   * @param options.foreignTable - Deprecated, use `options.referencedTable`
   * instead
   */
  range(from, to, {
    foreignTable,
    referencedTable = foreignTable
  } = {}) {
    const keyOffset = typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`;
    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`;
    this.url.searchParams.set(keyOffset, `${from}`);
    // Range is inclusive, so add 1
    this.url.searchParams.set(keyLimit, `${to - from + 1}`);
    return this;
  }
  /**
   * Set the AbortSignal for the fetch request.
   *
   * @param signal - The AbortSignal to use for the fetch request
   */
  abortSignal(signal) {
    this.signal = signal;
    return this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be one row (e.g. using `.limit(1)`), otherwise this
   * returns an error.
   */
  single() {
    this.headers['Accept'] = 'application/vnd.pgrst.object+json';
    return this;
  }
  /**
   * Return `data` as a single object instead of an array of objects.
   *
   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise
   * this returns an error.
   */
  maybeSingle() {
    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361
    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`
    if (this.method === 'GET') {
      this.headers['Accept'] = 'application/json';
    } else {
      this.headers['Accept'] = 'application/vnd.pgrst.object+json';
    }
    this.isMaybeSingle = true;
    return this;
  }
  /**
   * Return `data` as a string in CSV format.
   */
  csv() {
    this.headers['Accept'] = 'text/csv';
    return this;
  }
  /**
   * Return `data` as an object in [GeoJSON](https://geojson.org) format.
   */
  geojson() {
    this.headers['Accept'] = 'application/geo+json';
    return this;
  }
  /**
   * Return `data` as the EXPLAIN plan for the query.
   *
   * You need to enable the
   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)
   * setting before using this method.
   *
   * @param options - Named parameters
   *
   * @param options.analyze - If `true`, the query will be executed and the
   * actual run time will be returned
   *
   * @param options.verbose - If `true`, the query identifier will be returned
   * and `data` will include the output columns of the query
   *
   * @param options.settings - If `true`, include information on configuration
   * parameters that affect query planning
   *
   * @param options.buffers - If `true`, include information on buffer usage
   *
   * @param options.wal - If `true`, include information on WAL record generation
   *
   * @param options.format - The format of the output, can be `"text"` (default)
   * or `"json"`
   */
  explain({
    analyze = false,
    verbose = false,
    settings = false,
    buffers = false,
    wal = false,
    format = 'text'
  } = {}) {
    var _a;
    const options = [analyze ? 'analyze' : null, verbose ? 'verbose' : null, settings ? 'settings' : null, buffers ? 'buffers' : null, wal ? 'wal' : null].filter(Boolean).join('|');
    // An Accept header can carry multiple media types but postgrest-js always sends one
    const forMediatype = (_a = this.headers['Accept']) !== null && _a !== void 0 ? _a : 'application/json';
    this.headers['Accept'] = `application/vnd.pgrst.plan+${format}; for="${forMediatype}"; options=${options};`;
    if (format === 'json') return this;else return this;
  }
  /**
   * Rollback the query.
   *
   * `data` will still be returned, but the query is not committed.
   */
  rollback() {
    var _a;
    if (((_a = this.headers['Prefer']) !== null && _a !== void 0 ? _a : '').trim().length > 0) {
      this.headers['Prefer'] += ',tx=rollback';
    } else {
      this.headers['Prefer'] = 'tx=rollback';
    }
    return this;
  }
  /**
   * Override the type of the returned `data`.
   *
   * @typeParam NewResult - The new result type to override with
   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead
   */
  returns() {
    return this;
  }
}
exports["default"] = PostgrestTransformBuilder;

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/constants.js":
/*!********************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/constants.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DEFAULT_HEADERS = void 0;
const version_1 = __webpack_require__(/*! ./version */ "../node_modules/@supabase/postgrest-js/dist/cjs/version.js");
exports.DEFAULT_HEADERS = {
  'X-Client-Info': `postgrest-js/${version_1.version}`
};

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/index.js":
/*!****************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;
// Always update wrapper.mjs when updating this file.
const PostgrestClient_1 = __importDefault(__webpack_require__(/*! ./PostgrestClient */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js"));
exports.PostgrestClient = PostgrestClient_1.default;
const PostgrestQueryBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js"));
exports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;
const PostgrestFilterBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js"));
exports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;
const PostgrestTransformBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js"));
exports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;
const PostgrestBuilder_1 = __importDefault(__webpack_require__(/*! ./PostgrestBuilder */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js"));
exports.PostgrestBuilder = PostgrestBuilder_1.default;
const PostgrestError_1 = __importDefault(__webpack_require__(/*! ./PostgrestError */ "../node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js"));
exports.PostgrestError = PostgrestError_1.default;
exports["default"] = {
  PostgrestClient: PostgrestClient_1.default,
  PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,
  PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,
  PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,
  PostgrestBuilder: PostgrestBuilder_1.default,
  PostgrestError: PostgrestError_1.default
};

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/cjs/version.js":
/*!******************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/cjs/version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.version = void 0;
exports.version = '0.0.0-automated';

/***/ }),

/***/ "../node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs":
/*!*******************************************************************!*\
  !*** ../node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),
/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),
/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),
/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),
/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),
/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cjs/index.js */ "../node_modules/@supabase/postgrest-js/dist/cjs/index.js");

const {
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
} = _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__;


// compatibility with CJS output
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  PostgrestClient,
  PostgrestQueryBuilder,
  PostgrestFilterBuilder,
  PostgrestTransformBuilder,
  PostgrestBuilder,
  PostgrestError
});

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* binding */ REALTIME_CHANNEL_STATES),
/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* binding */ REALTIME_LISTEN_TYPES),
/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),
/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* binding */ REALTIME_SUBSCRIBE_STATES),
/* harmony export */   "default": () => (/* binding */ RealtimeChannel)
/* harmony export */ });
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ "../node_modules/@supabase/realtime-js/dist/module/lib/constants.js");
/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ "../node_modules/@supabase/realtime-js/dist/module/lib/push.js");
/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ "../node_modules/@supabase/realtime-js/dist/module/lib/timer.js");
/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ "../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js");
/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ "../node_modules/@supabase/realtime-js/dist/module/lib/transformers.js");






var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;
(function (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["ALL"] = "*";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["INSERT"] = "INSERT";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["UPDATE"] = "UPDATE";
  REALTIME_POSTGRES_CHANGES_LISTEN_EVENT["DELETE"] = "DELETE";
})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));
var REALTIME_LISTEN_TYPES;
(function (REALTIME_LISTEN_TYPES) {
  REALTIME_LISTEN_TYPES["BROADCAST"] = "broadcast";
  REALTIME_LISTEN_TYPES["PRESENCE"] = "presence";
  REALTIME_LISTEN_TYPES["POSTGRES_CHANGES"] = "postgres_changes";
  REALTIME_LISTEN_TYPES["SYSTEM"] = "system";
})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));
var REALTIME_SUBSCRIBE_STATES;
(function (REALTIME_SUBSCRIBE_STATES) {
  REALTIME_SUBSCRIBE_STATES["SUBSCRIBED"] = "SUBSCRIBED";
  REALTIME_SUBSCRIBE_STATES["TIMED_OUT"] = "TIMED_OUT";
  REALTIME_SUBSCRIBE_STATES["CLOSED"] = "CLOSED";
  REALTIME_SUBSCRIBE_STATES["CHANNEL_ERROR"] = "CHANNEL_ERROR";
})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));
const REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;
/** A channel is the basic building block of Realtime
 * and narrows the scope of data flow to subscribed clients.
 * You can think of a channel as a chatroom where participants are able to see who's online
 * and send and receive messages.
 */
class RealtimeChannel {
  constructor(/** Topic name can be any string. */
  topic, params = {
    config: {}
  }, socket) {
    this.topic = topic;
    this.params = params;
    this.socket = socket;
    this.bindings = {};
    this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;
    this.joinedOnce = false;
    this.pushBuffer = [];
    this.subTopic = topic.replace(/^realtime:/i, '');
    this.params.config = Object.assign({
      broadcast: {
        ack: false,
        self: false
      },
      presence: {
        key: ''
      },
      private: false
    }, params.config);
    this.timeout = this.socket.timeout;
    this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__["default"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);
    this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__["default"](() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs);
    this.joinPush.receive('ok', () => {
      this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;
      this.rejoinTimer.reset();
      this.pushBuffer.forEach(pushEvent => pushEvent.send());
      this.pushBuffer = [];
    });
    this._onClose(() => {
      this.rejoinTimer.reset();
      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`);
      this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;
      this.socket._remove(this);
    });
    this._onError(reason => {
      if (this._isLeaving() || this._isClosed()) {
        return;
      }
      this.socket.log('channel', `error ${this.topic}`, reason);
      this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this.joinPush.receive('timeout', () => {
      if (!this._isJoining()) {
        return;
      }
      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout);
      this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;
      this.rejoinTimer.scheduleTimeout();
    });
    this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref) => {
      this._trigger(this._replyEventName(ref), payload);
    });
    this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__["default"](this);
    this.broadcastEndpointURL = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint) + '/api/broadcast';
    this.private = this.params.config.private || false;
  }
  /** Subscribe registers your client with the server */
  subscribe(callback, timeout = this.timeout) {
    var _a, _b;
    if (!this.socket.isConnected()) {
      this.socket.connect();
    }
    if (this.joinedOnce) {
      throw `tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance`;
    } else {
      const {
        config: {
          broadcast,
          presence,
          private: isPrivate
        }
      } = this.params;
      this._onError(e => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));
      this._onClose(() => callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));
      const accessTokenPayload = {};
      const config = {
        broadcast,
        presence,
        postgres_changes: (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map(r => r.filter)) !== null && _b !== void 0 ? _b : [],
        private: isPrivate
      };
      if (this.socket.accessTokenValue) {
        accessTokenPayload.access_token = this.socket.accessTokenValue;
      }
      this.updateJoinPayload(Object.assign({
        config
      }, accessTokenPayload));
      this.joinedOnce = true;
      this._rejoin(timeout);
      this.joinPush.receive('ok', async ({
        postgres_changes
      }) => {
        var _a;
        this.socket.setAuth();
        if (postgres_changes === undefined) {
          callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        } else {
          const clientPostgresBindings = this.bindings.postgres_changes;
          const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;
          const newPostgresBindings = [];
          for (let i = 0; i < bindingsLen; i++) {
            const clientPostgresBinding = clientPostgresBindings[i];
            const {
              filter: {
                event,
                schema,
                table,
                filter
              }
            } = clientPostgresBinding;
            const serverPostgresFilter = postgres_changes && postgres_changes[i];
            if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {
              newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {
                id: serverPostgresFilter.id
              }));
            } else {
              this.unsubscribe();
              callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error('mismatch between server and client bindings for postgres changes'));
              return;
            }
          }
          this.bindings.postgres_changes = newPostgresBindings;
          callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);
          return;
        }
      }).receive('error', error => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(', ') || 'error')));
        return;
      }).receive('timeout', () => {
        callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);
        return;
      });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(payload, opts = {}) {
    return await this.send({
      type: 'presence',
      event: 'track',
      payload
    }, opts.timeout || this.timeout);
  }
  async untrack(opts = {}) {
    return await this.send({
      type: 'presence',
      event: 'untrack'
    }, opts);
  }
  on(type, filter, callback) {
    return this._on(type, filter, callback);
  }
  /**
   * Sends a message into the channel.
   *
   * @param args Arguments to send to channel
   * @param args.type The type of event to send
   * @param args.event The name of the event being sent
   * @param args.payload Payload to be sent
   * @param opts Options to be used during the send process
   */
  async send(args, opts = {}) {
    var _a, _b;
    if (!this._canPush() && args.type === 'broadcast') {
      const {
        event,
        payload: endpoint_payload
      } = args;
      const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : '';
      const options = {
        method: 'POST',
        headers: {
          Authorization: authorization,
          apikey: this.socket.apiKey ? this.socket.apiKey : '',
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          messages: [{
            topic: this.subTopic,
            event,
            payload: endpoint_payload,
            private: this.private
          }]
        })
      };
      try {
        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);
        await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());
        return response.ok ? 'ok' : 'error';
      } catch (error) {
        if (error.name === 'AbortError') {
          return 'timed out';
        } else {
          return 'error';
        }
      }
    } else {
      return new Promise(resolve => {
        var _a, _b, _c;
        const push = this._push(args.type, args, opts.timeout || this.timeout);
        if (args.type === 'broadcast' && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {
          resolve('ok');
        }
        push.receive('ok', () => resolve('ok'));
        push.receive('error', () => resolve('error'));
        push.receive('timeout', () => resolve('timed out'));
      });
    }
  }
  updateJoinPayload(payload) {
    this.joinPush.updatePayload(payload);
  }
  /**
   * Leaves the channel.
   *
   * Unsubscribes from server events, and instructs channel to terminate on server.
   * Triggers onClose() hooks.
   *
   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:
   * channel.unsubscribe().receive("ok", () => alert("left!") )
   */
  unsubscribe(timeout = this.timeout) {
    this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;
    const onClose = () => {
      this.socket.log('channel', `leave ${this.topic}`);
      this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, 'leave', this._joinRef());
    };
    this.rejoinTimer.reset();
    // Destroy joinPush to avoid connection timeouts during unscription phase
    this.joinPush.destroy();
    return new Promise(resolve => {
      const leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__["default"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);
      leavePush.receive('ok', () => {
        onClose();
        resolve('ok');
      }).receive('timeout', () => {
        onClose();
        resolve('timed out');
      }).receive('error', () => {
        resolve('error');
      });
      leavePush.send();
      if (!this._canPush()) {
        leavePush.trigger('ok', {});
      }
    });
  }
  /** @internal */
  async _fetchWithTimeout(url, options, timeout) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {
      signal: controller.signal
    }));
    clearTimeout(id);
    return response;
  }
  /** @internal */
  _push(event, payload, timeout = this.timeout) {
    if (!this.joinedOnce) {
      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    }
    let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__["default"](this, event, payload, timeout);
    if (this._canPush()) {
      pushEvent.send();
    } else {
      pushEvent.startTimeout();
      this.pushBuffer.push(pushEvent);
    }
    return pushEvent;
  }
  /**
   * Overridable message hook
   *
   * Receives all events for specialized message handling before dispatching to the channel callbacks.
   * Must return the payload, modified or unmodified.
   *
   * @internal
   */
  _onMessage(_event, payload, _ref) {
    return payload;
  }
  /** @internal */
  _isMember(topic) {
    return this.topic === topic;
  }
  /** @internal */
  _joinRef() {
    return this.joinPush.ref;
  }
  /** @internal */
  _trigger(type, payload, ref) {
    var _a, _b;
    const typeLower = type.toLocaleLowerCase();
    const {
      close,
      error,
      leave,
      join
    } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;
    const events = [close, error, leave, join];
    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {
      return;
    }
    let handledPayload = this._onMessage(typeLower, payload, ref);
    if (payload && !handledPayload) {
      throw 'channel onMessage callbacks must return the payload, modified or unmodified';
    }
    if (['insert', 'update', 'delete'].includes(typeLower)) {
      (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter(bind => {
        var _a, _b, _c;
        return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === '*' || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;
      }).map(bind => bind.callback(handledPayload, ref));
    } else {
      (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter(bind => {
        var _a, _b, _c, _d, _e, _f;
        if (['broadcast', 'presence', 'postgres_changes'].includes(typeLower)) {
          if ('id' in bind) {
            const bindId = bind.id;
            const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;
            return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === '*' || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));
          } else {
            const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();
            return bindEvent === '*' || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());
          }
        } else {
          return bind.type.toLocaleLowerCase() === typeLower;
        }
      }).map(bind => {
        if (typeof handledPayload === 'object' && 'ids' in handledPayload) {
          const postgresChanges = handledPayload.data;
          const {
            schema,
            table,
            commit_timestamp,
            type,
            errors
          } = postgresChanges;
          const enrichedPayload = {
            schema: schema,
            table: table,
            commit_timestamp: commit_timestamp,
            eventType: type,
            new: {},
            old: {},
            errors: errors
          };
          handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));
        }
        bind.callback(handledPayload, ref);
      });
    }
  }
  /** @internal */
  _isClosed() {
    return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;
  }
  /** @internal */
  _isJoined() {
    return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;
  }
  /** @internal */
  _isJoining() {
    return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;
  }
  /** @internal */
  _isLeaving() {
    return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;
  }
  /** @internal */
  _replyEventName(ref) {
    return `chan_reply_${ref}`;
  }
  /** @internal */
  _on(type, filter, callback) {
    const typeLower = type.toLocaleLowerCase();
    const binding = {
      type: typeLower,
      filter: filter,
      callback: callback
    };
    if (this.bindings[typeLower]) {
      this.bindings[typeLower].push(binding);
    } else {
      this.bindings[typeLower] = [binding];
    }
    return this;
  }
  /** @internal */
  _off(type, filter) {
    const typeLower = type.toLocaleLowerCase();
    this.bindings[typeLower] = this.bindings[typeLower].filter(bind => {
      var _a;
      return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));
    });
    return this;
  }
  /** @internal */
  static isEqual(obj1, obj2) {
    if (Object.keys(obj1).length !== Object.keys(obj2).length) {
      return false;
    }
    for (const k in obj1) {
      if (obj1[k] !== obj2[k]) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout();
    if (this.socket.isConnected()) {
      this._rejoin();
    }
  }
  /**
   * Registers a callback that will be executed when the channel closes.
   *
   * @internal
   */
  _onClose(callback) {
    this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);
  }
  /**
   * Registers a callback that will be executed when the channel encounteres an error.
   *
   * @internal
   */
  _onError(callback) {
    this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, reason => callback(reason));
  }
  /**
   * Returns `true` if the socket is connected and the channel has been joined.
   *
   * @internal
   */
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  /** @internal */
  _rejoin(timeout = this.timeout) {
    if (this._isLeaving()) {
      return;
    }
    this.socket._leaveOpenTopic(this.topic);
    this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;
    this.joinPush.resend(timeout);
  }
  /** @internal */
  _getPayloadRecords(payload) {
    const records = {
      new: {},
      old: {}
    };
    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {
      records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);
    }
    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {
      records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);
    }
    return records;
  }
}

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RealtimeClient)
/* harmony export */ });
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ "../node_modules/@supabase/realtime-js/dist/module/lib/constants.js");
/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/serializer */ "../node_modules/@supabase/realtime-js/dist/module/lib/serializer.js");
/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ "../node_modules/@supabase/realtime-js/dist/module/lib/timer.js");
/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/transformers */ "../node_modules/@supabase/realtime-js/dist/module/lib/transformers.js");
/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RealtimeChannel */ "../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js");





const noop = () => {};
const NATIVE_WEBSOCKET_AVAILABLE = typeof WebSocket !== 'undefined';
const WORKER_SCRIPT = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class RealtimeClient {
  /**
   * Initializes the Socket.
   *
   * @param endPoint The string WebSocket endpoint, ie, "ws://example.com/socket", "wss://example.com", "/socket" (inherited host & protocol)
   * @param httpEndpoint The string HTTP endpoint, ie, "https://example.com", "/" (inherited host & protocol)
   * @param options.transport The Websocket Transport, for example WebSocket.
   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.
   * @param options.params The optional params to pass when connecting.
   * @param options.headers The optional headers to pass when connecting.
   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.
   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))
   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.
   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.
   * @param options.worker Use Web Worker to set a side flow. Defaults to false.
   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.
   */
  constructor(endPoint, options) {
    var _a;
    this.accessTokenValue = null;
    this.apiKey = null;
    this.channels = [];
    this.endPoint = '';
    this.httpEndpoint = '';
    this.headers = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS;
    this.params = {};
    this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT;
    this.heartbeatIntervalMs = 30000;
    this.heartbeatTimer = undefined;
    this.pendingHeartbeatRef = null;
    this.ref = 0;
    this.logger = noop;
    this.conn = null;
    this.sendBuffer = [];
    this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_1__["default"]();
    this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    };
    this.accessToken = null;
    /**
     * Use either custom fetch, if provided, or default fetch to make HTTP requests
     *
     * @internal
     */
    this._resolveFetch = customFetch => {
      let _fetch;
      if (customFetch) {
        _fetch = customFetch;
      } else if (typeof fetch === 'undefined') {
        _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ "../node_modules/@supabase/node-fetch/browser.js")).then(({
          default: fetch
        }) => fetch(...args));
      } else {
        _fetch = fetch;
      }
      return (...args) => _fetch(...args);
    };
    this.endPoint = `${endPoint}/${_lib_constants__WEBPACK_IMPORTED_MODULE_0__.TRANSPORTS.websocket}`;
    this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_3__.httpEndpointURL)(endPoint);
    if (options === null || options === void 0 ? void 0 : options.transport) {
      this.transport = options.transport;
    } else {
      this.transport = null;
    }
    if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;
    if (options === null || options === void 0 ? void 0 : options.headers) this.headers = Object.assign(Object.assign({}, this.headers), options.headers);
    if (options === null || options === void 0 ? void 0 : options.timeout) this.timeout = options.timeout;
    if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;
    if (options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) this.heartbeatIntervalMs = options.heartbeatIntervalMs;
    const accessTokenValue = (_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey;
    if (accessTokenValue) {
      this.accessTokenValue = accessTokenValue;
      this.apiKey = accessTokenValue;
    }
    this.reconnectAfterMs = (options === null || options === void 0 ? void 0 : options.reconnectAfterMs) ? options.reconnectAfterMs : tries => {
      return [1000, 2000, 5000, 10000][tries - 1] || 10000;
    };
    this.encode = (options === null || options === void 0 ? void 0 : options.encode) ? options.encode : (payload, callback) => {
      return callback(JSON.stringify(payload));
    };
    this.decode = (options === null || options === void 0 ? void 0 : options.decode) ? options.decode : this.serializer.decode.bind(this.serializer);
    this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__["default"](async () => {
      this.disconnect();
      this.connect();
    }, this.reconnectAfterMs);
    this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);
    if (options === null || options === void 0 ? void 0 : options.worker) {
      if (typeof window !== 'undefined' && !window.Worker) {
        throw new Error('Web Worker is not supported');
      }
      this.worker = (options === null || options === void 0 ? void 0 : options.worker) || false;
      this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;
    }
    this.accessToken = (options === null || options === void 0 ? void 0 : options.accessToken) || null;
  }
  /**
   * Connects the socket, unless already connected.
   */
  connect() {
    if (this.conn) {
      return;
    }
    if (this.transport) {
      this.conn = new this.transport(this.endpointURL(), undefined, {
        headers: this.headers
      });
      return;
    }
    if (NATIVE_WEBSOCKET_AVAILABLE) {
      this.conn = new WebSocket(this.endpointURL());
      this.setupConnection();
      return;
    }
    this.conn = new WSWebSocketDummy(this.endpointURL(), undefined, {
      close: () => {
        this.conn = null;
      }
    });
    __webpack_require__.e(/*! import() */ "node_modules_ws_browser_js").then(__webpack_require__.t.bind(__webpack_require__, /*! ws */ "../node_modules/ws/browser.js", 23)).then(({
      default: WS
    }) => {
      this.conn = new WS(this.endpointURL(), undefined, {
        headers: this.headers
      });
      this.setupConnection();
    });
  }
  /**
   * Returns the URL of the websocket.
   * @returns string The URL of the websocket.
   */
  endpointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, {
      vsn: _lib_constants__WEBPACK_IMPORTED_MODULE_0__.VSN
    }));
  }
  /**
   * Disconnects the socket.
   *
   * @param code A numeric status code to send on disconnect.
   * @param reason A custom reason for the disconnect.
   */
  disconnect(code, reason) {
    if (this.conn) {
      this.conn.onclose = function () {}; // noop
      if (code) {
        this.conn.close(code, reason !== null && reason !== void 0 ? reason : '');
      } else {
        this.conn.close();
      }
      this.conn = null;
      // remove open handles
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.reconnectTimer.reset();
    }
  }
  /**
   * Returns all created channels
   */
  getChannels() {
    return this.channels;
  }
  /**
   * Unsubscribes and removes a single channel
   * @param channel A RealtimeChannel instance
   */
  async removeChannel(channel) {
    const status = await channel.unsubscribe();
    if (this.channels.length === 0) {
      this.disconnect();
    }
    return status;
  }
  /**
   * Unsubscribes and removes all channels
   */
  async removeAllChannels() {
    const values_1 = await Promise.all(this.channels.map(channel => channel.unsubscribe()));
    this.disconnect();
    return values_1;
  }
  /**
   * Logs the message.
   *
   * For customized logging, `this.logger` can be overridden.
   */
  log(kind, msg, data) {
    this.logger(kind, msg, data);
  }
  /**
   * Returns the current state of the socket.
   */
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.connecting:
        return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Connecting;
      case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.open:
        return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Open;
      case _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.closing:
        return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Closing;
      default:
        return _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Closed;
    }
  }
  /**
   * Returns `true` is the connection is open.
   */
  isConnected() {
    return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CONNECTION_STATE.Open;
  }
  channel(topic, params = {
    config: {}
  }) {
    const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_4__["default"](`realtime:${topic}`, params, this);
    this.channels.push(chan);
    return chan;
  }
  /**
   * Push out a message if the socket is connected.
   *
   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.
   */
  push(data) {
    const {
      topic,
      event,
      payload,
      ref
    } = data;
    const callback = () => {
      this.encode(data, result => {
        var _a;
        (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);
      });
    };
    this.log('push', `${topic} ${event} (${ref})`, payload);
    if (this.isConnected()) {
      callback();
    } else {
      this.sendBuffer.push(callback);
    }
  }
  /**
   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.
   *
   * If param is null it will use the `accessToken` callback function or the token set on the client.
   *
   * On callback used, it will set the value of the token internal to the client.
   *
   * @param token A JWT string to override the token set on the client.
   */
  async setAuth(token = null) {
    let tokenToSend = token || this.accessToken && (await this.accessToken()) || this.accessTokenValue;
    if (tokenToSend) {
      let parsed = null;
      try {
        parsed = JSON.parse(atob(tokenToSend.split('.')[1]));
      } catch (_error) {}
      if (parsed && parsed.exp) {
        let now = Math.floor(Date.now() / 1000);
        let valid = now - parsed.exp < 0;
        if (!valid) {
          this.log('auth', `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
          return Promise.reject(`InvalidJWTToken: Invalid value for JWT claim "exp" with value ${parsed.exp}`);
        }
      }
      this.accessTokenValue = tokenToSend;
      this.channels.forEach(channel => {
        tokenToSend && channel.updateJoinPayload({
          access_token: tokenToSend
        });
        if (channel.joinedOnce && channel._isJoined()) {
          channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.access_token, {
            access_token: tokenToSend
          });
        }
      });
    }
  }
  /**
   * Sends a heartbeat message if the socket is connected.
   */
  async sendHeartbeat() {
    var _a;
    if (!this.isConnected()) {
      return;
    }
    if (this.pendingHeartbeatRef) {
      this.pendingHeartbeatRef = null;
      this.log('transport', 'heartbeat timeout. Attempting to re-establish connection');
      (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.WS_CLOSE_NORMAL, 'hearbeat timeout');
      return;
    }
    this.pendingHeartbeatRef = this._makeRef();
    this.push({
      topic: 'phoenix',
      event: 'heartbeat',
      payload: {},
      ref: this.pendingHeartbeatRef
    });
    this.setAuth();
  }
  /**
   * Flushes send buffer
   */
  flushSendBuffer() {
    if (this.isConnected() && this.sendBuffer.length > 0) {
      this.sendBuffer.forEach(callback => callback());
      this.sendBuffer = [];
    }
  }
  /**
   * Return the next message ref, accounting for overflows
   *
   * @internal
   */
  _makeRef() {
    let newRef = this.ref + 1;
    if (newRef === this.ref) {
      this.ref = 0;
    } else {
      this.ref = newRef;
    }
    return this.ref.toString();
  }
  /**
   * Unsubscribe from channels with the specified topic.
   *
   * @internal
   */
  _leaveOpenTopic(topic) {
    let dupChannel = this.channels.find(c => c.topic === topic && (c._isJoined() || c._isJoining()));
    if (dupChannel) {
      this.log('transport', `leaving duplicate topic "${topic}"`);
      dupChannel.unsubscribe();
    }
  }
  /**
   * Removes a subscription from the socket.
   *
   * @param channel An open subscription.
   *
   * @internal
   */
  _remove(channel) {
    this.channels = this.channels.filter(c => c._joinRef() !== channel._joinRef());
  }
  /**
   * Sets up connection handlers.
   *
   * @internal
   */
  setupConnection() {
    if (this.conn) {
      this.conn.binaryType = 'arraybuffer';
      this.conn.onopen = () => this._onConnOpen();
      this.conn.onerror = error => this._onConnError(error);
      this.conn.onmessage = event => this._onConnMessage(event);
      this.conn.onclose = event => this._onConnClose(event);
    }
  }
  /** @internal */
  _onConnMessage(rawMessage) {
    this.decode(rawMessage.data, msg => {
      let {
        topic,
        event,
        payload,
        ref
      } = msg;
      if (ref && ref === this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null;
      }
      this.log('receive', `${payload.status || ''} ${topic} ${event} ${ref && '(' + ref + ')' || ''}`, payload);
      this.channels.filter(channel => channel._isMember(topic)).forEach(channel => channel._trigger(event, payload, ref));
      this.stateChangeCallbacks.message.forEach(callback => callback(msg));
    });
  }
  /** @internal */
  async _onConnOpen() {
    this.log('transport', `connected to ${this.endpointURL()}`);
    this.flushSendBuffer();
    this.reconnectTimer.reset();
    if (!this.worker) {
      this.heartbeatTimer && clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = setInterval(() => this.sendHeartbeat(), this.heartbeatIntervalMs);
    } else {
      if (this.workerUrl) {
        this.log('worker', `starting worker for from ${this.workerUrl}`);
      } else {
        this.log('worker', `starting default worker`);
      }
      const objectUrl = this._workerObjectUrl(this.workerUrl);
      this.workerRef = new Worker(objectUrl);
      this.workerRef.onerror = error => {
        this.log('worker', 'worker error', error.message);
        this.workerRef.terminate();
      };
      this.workerRef.onmessage = event => {
        if (event.data.event === 'keepAlive') {
          this.sendHeartbeat();
        }
      };
      this.workerRef.postMessage({
        event: 'start',
        interval: this.heartbeatIntervalMs
      });
    }
    this.stateChangeCallbacks.open.forEach(callback => callback());
  }
  /** @internal */
  _onConnClose(event) {
    this.log('transport', 'close', event);
    this._triggerChanError();
    this.heartbeatTimer && clearInterval(this.heartbeatTimer);
    this.reconnectTimer.scheduleTimeout();
    this.stateChangeCallbacks.close.forEach(callback => callback(event));
  }
  /** @internal */
  _onConnError(error) {
    this.log('transport', error.message);
    this._triggerChanError();
    this.stateChangeCallbacks.error.forEach(callback => callback(error));
  }
  /** @internal */
  _triggerChanError() {
    this.channels.forEach(channel => channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error));
  }
  /** @internal */
  _appendParams(url, params) {
    if (Object.keys(params).length === 0) {
      return url;
    }
    const prefix = url.match(/\?/) ? '&' : '?';
    const query = new URLSearchParams(params);
    return `${url}${prefix}${query}`;
  }
  _workerObjectUrl(url) {
    let result_url;
    if (url) {
      result_url = url;
    } else {
      const blob = new Blob([WORKER_SCRIPT], {
        type: 'application/javascript'
      });
      result_url = URL.createObjectURL(blob);
    }
    return result_url;
  }
}
class WSWebSocketDummy {
  constructor(address, _protocols, options) {
    this.binaryType = 'arraybuffer';
    this.onclose = () => {};
    this.onerror = () => {};
    this.onmessage = () => {};
    this.onopen = () => {};
    this.readyState = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.SOCKET_STATES.connecting;
    this.send = () => {};
    this.url = null;
    this.url = address;
    this.close = options.close;
  }
}

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* binding */ REALTIME_PRESENCE_LISTEN_EVENTS),
/* harmony export */   "default": () => (/* binding */ RealtimePresence)
/* harmony export */ });
/*
  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js
  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md
*/
var REALTIME_PRESENCE_LISTEN_EVENTS;
(function (REALTIME_PRESENCE_LISTEN_EVENTS) {
  REALTIME_PRESENCE_LISTEN_EVENTS["SYNC"] = "sync";
  REALTIME_PRESENCE_LISTEN_EVENTS["JOIN"] = "join";
  REALTIME_PRESENCE_LISTEN_EVENTS["LEAVE"] = "leave";
})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));
class RealtimePresence {
  /**
   * Initializes the Presence.
   *
   * @param channel - The RealtimeChannel
   * @param opts - The options,
   *        for example `{events: {state: 'state', diff: 'diff'}}`
   */
  constructor(channel, opts) {
    this.channel = channel;
    this.state = {};
    this.pendingDiffs = [];
    this.joinRef = null;
    this.caller = {
      onJoin: () => {},
      onLeave: () => {},
      onSync: () => {}
    };
    const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {
      state: 'presence_state',
      diff: 'presence_diff'
    };
    this.channel._on(events.state, {}, newState => {
      const {
        onJoin,
        onLeave,
        onSync
      } = this.caller;
      this.joinRef = this.channel._joinRef();
      this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);
      this.pendingDiffs.forEach(diff => {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
      });
      this.pendingDiffs = [];
      onSync();
    });
    this.channel._on(events.diff, {}, diff => {
      const {
        onJoin,
        onLeave,
        onSync
      } = this.caller;
      if (this.inPendingSyncState()) {
        this.pendingDiffs.push(diff);
      } else {
        this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);
        onSync();
      }
    });
    this.onJoin((key, currentPresences, newPresences) => {
      this.channel._trigger('presence', {
        event: 'join',
        key,
        currentPresences,
        newPresences
      });
    });
    this.onLeave((key, currentPresences, leftPresences) => {
      this.channel._trigger('presence', {
        event: 'leave',
        key,
        currentPresences,
        leftPresences
      });
    });
    this.onSync(() => {
      this.channel._trigger('presence', {
        event: 'sync'
      });
    });
  }
  /**
   * Used to sync the list of presences on the server with the
   * client's state.
   *
   * An optional `onJoin` and `onLeave` callback can be provided to
   * react to changes in the client's local presences across
   * disconnects and reconnects with the server.
   *
   * @internal
   */
  static syncState(currentState, newState, onJoin, onLeave) {
    const state = this.cloneDeep(currentState);
    const transformedState = this.transformState(newState);
    const joins = {};
    const leaves = {};
    this.map(state, (key, presences) => {
      if (!transformedState[key]) {
        leaves[key] = presences;
      }
    });
    this.map(transformedState, (key, newPresences) => {
      const currentPresences = state[key];
      if (currentPresences) {
        const newPresenceRefs = newPresences.map(m => m.presence_ref);
        const curPresenceRefs = currentPresences.map(m => m.presence_ref);
        const joinedPresences = newPresences.filter(m => curPresenceRefs.indexOf(m.presence_ref) < 0);
        const leftPresences = currentPresences.filter(m => newPresenceRefs.indexOf(m.presence_ref) < 0);
        if (joinedPresences.length > 0) {
          joins[key] = joinedPresences;
        }
        if (leftPresences.length > 0) {
          leaves[key] = leftPresences;
        }
      } else {
        joins[key] = newPresences;
      }
    });
    return this.syncDiff(state, {
      joins,
      leaves
    }, onJoin, onLeave);
  }
  /**
   * Used to sync a diff of presence join and leave events from the
   * server, as they happen.
   *
   * Like `syncState`, `syncDiff` accepts optional `onJoin` and
   * `onLeave` callbacks to react to a user joining or leaving from a
   * device.
   *
   * @internal
   */
  static syncDiff(state, diff, onJoin, onLeave) {
    const {
      joins,
      leaves
    } = {
      joins: this.transformState(diff.joins),
      leaves: this.transformState(diff.leaves)
    };
    if (!onJoin) {
      onJoin = () => {};
    }
    if (!onLeave) {
      onLeave = () => {};
    }
    this.map(joins, (key, newPresences) => {
      var _a;
      const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];
      state[key] = this.cloneDeep(newPresences);
      if (currentPresences.length > 0) {
        const joinedPresenceRefs = state[key].map(m => m.presence_ref);
        const curPresences = currentPresences.filter(m => joinedPresenceRefs.indexOf(m.presence_ref) < 0);
        state[key].unshift(...curPresences);
      }
      onJoin(key, currentPresences, newPresences);
    });
    this.map(leaves, (key, leftPresences) => {
      let currentPresences = state[key];
      if (!currentPresences) return;
      const presenceRefsToRemove = leftPresences.map(m => m.presence_ref);
      currentPresences = currentPresences.filter(m => presenceRefsToRemove.indexOf(m.presence_ref) < 0);
      state[key] = currentPresences;
      onLeave(key, currentPresences, leftPresences);
      if (currentPresences.length === 0) delete state[key];
    });
    return state;
  }
  /** @internal */
  static map(obj, func) {
    return Object.getOwnPropertyNames(obj).map(key => func(key, obj[key]));
  }
  /**
   * Remove 'metas' key
   * Change 'phx_ref' to 'presence_ref'
   * Remove 'phx_ref' and 'phx_ref_prev'
   *
   * @example
   * // returns {
   *  abc123: [
   *    { presence_ref: '2', user_id: 1 },
   *    { presence_ref: '3', user_id: 2 }
   *  ]
   * }
   * RealtimePresence.transformState({
   *  abc123: {
   *    metas: [
   *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },
   *      { phx_ref: '3', user_id: 2 }
   *    ]
   *  }
   * })
   *
   * @internal
   */
  static transformState(state) {
    state = this.cloneDeep(state);
    return Object.getOwnPropertyNames(state).reduce((newState, key) => {
      const presences = state[key];
      if ('metas' in presences) {
        newState[key] = presences.metas.map(presence => {
          presence['presence_ref'] = presence['phx_ref'];
          delete presence['phx_ref'];
          delete presence['phx_ref_prev'];
          return presence;
        });
      } else {
        newState[key] = presences;
      }
      return newState;
    }, {});
  }
  /** @internal */
  static cloneDeep(obj) {
    return JSON.parse(JSON.stringify(obj));
  }
  /** @internal */
  onJoin(callback) {
    this.caller.onJoin = callback;
  }
  /** @internal */
  onLeave(callback) {
    this.caller.onLeave = callback;
  }
  /** @internal */
  onSync(callback) {
    this.caller.onSync = callback;
  }
  /** @internal */
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),
/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),
/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),
/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),
/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),
/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   RealtimeClient: () => (/* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   RealtimePresence: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__["default"])
/* harmony export */ });
/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ "../node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js");
/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ "../node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js");
/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ "../node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js");





/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CHANNEL_EVENTS: () => (/* binding */ CHANNEL_EVENTS),
/* harmony export */   CHANNEL_STATES: () => (/* binding */ CHANNEL_STATES),
/* harmony export */   CONNECTION_STATE: () => (/* binding */ CONNECTION_STATE),
/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),
/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),
/* harmony export */   SOCKET_STATES: () => (/* binding */ SOCKET_STATES),
/* harmony export */   TRANSPORTS: () => (/* binding */ TRANSPORTS),
/* harmony export */   VSN: () => (/* binding */ VSN),
/* harmony export */   WS_CLOSE_NORMAL: () => (/* binding */ WS_CLOSE_NORMAL)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ "../node_modules/@supabase/realtime-js/dist/module/lib/version.js");

const DEFAULT_HEADERS = {
  'X-Client-Info': `realtime-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`
};
const VSN = '1.0.0';
const DEFAULT_TIMEOUT = 10000;
const WS_CLOSE_NORMAL = 1000;
var SOCKET_STATES;
(function (SOCKET_STATES) {
  SOCKET_STATES[SOCKET_STATES["connecting"] = 0] = "connecting";
  SOCKET_STATES[SOCKET_STATES["open"] = 1] = "open";
  SOCKET_STATES[SOCKET_STATES["closing"] = 2] = "closing";
  SOCKET_STATES[SOCKET_STATES["closed"] = 3] = "closed";
})(SOCKET_STATES || (SOCKET_STATES = {}));
var CHANNEL_STATES;
(function (CHANNEL_STATES) {
  CHANNEL_STATES["closed"] = "closed";
  CHANNEL_STATES["errored"] = "errored";
  CHANNEL_STATES["joined"] = "joined";
  CHANNEL_STATES["joining"] = "joining";
  CHANNEL_STATES["leaving"] = "leaving";
})(CHANNEL_STATES || (CHANNEL_STATES = {}));
var CHANNEL_EVENTS;
(function (CHANNEL_EVENTS) {
  CHANNEL_EVENTS["close"] = "phx_close";
  CHANNEL_EVENTS["error"] = "phx_error";
  CHANNEL_EVENTS["join"] = "phx_join";
  CHANNEL_EVENTS["reply"] = "phx_reply";
  CHANNEL_EVENTS["leave"] = "phx_leave";
  CHANNEL_EVENTS["access_token"] = "access_token";
})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));
var TRANSPORTS;
(function (TRANSPORTS) {
  TRANSPORTS["websocket"] = "websocket";
})(TRANSPORTS || (TRANSPORTS = {}));
var CONNECTION_STATE;
(function (CONNECTION_STATE) {
  CONNECTION_STATE["Connecting"] = "connecting";
  CONNECTION_STATE["Open"] = "open";
  CONNECTION_STATE["Closing"] = "closing";
  CONNECTION_STATE["Closed"] = "closed";
})(CONNECTION_STATE || (CONNECTION_STATE = {}));

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Push)
/* harmony export */ });
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ "../node_modules/@supabase/realtime-js/dist/module/lib/constants.js");

class Push {
  /**
   * Initializes the Push
   *
   * @param channel The Channel
   * @param event The event, for example `"phx_join"`
   * @param payload The payload, for example `{user_id: 123}`
   * @param timeout The push timeout in milliseconds
   */
  constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT) {
    this.channel = channel;
    this.event = event;
    this.payload = payload;
    this.timeout = timeout;
    this.sent = false;
    this.timeoutTimer = undefined;
    this.ref = '';
    this.receivedResp = null;
    this.recHooks = [];
    this.refEvent = null;
  }
  resend(timeout) {
    this.timeout = timeout;
    this._cancelRefEvent();
    this.ref = '';
    this.refEvent = null;
    this.receivedResp = null;
    this.sent = false;
    this.send();
  }
  send() {
    if (this._hasReceived('timeout')) {
      return;
    }
    this.startTimeout();
    this.sent = true;
    this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    });
  }
  updatePayload(payload) {
    this.payload = Object.assign(Object.assign({}, this.payload), payload);
  }
  receive(status, callback) {
    var _a;
    if (this._hasReceived(status)) {
      callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);
    }
    this.recHooks.push({
      status,
      callback
    });
    return this;
  }
  startTimeout() {
    if (this.timeoutTimer) {
      return;
    }
    this.ref = this.channel.socket._makeRef();
    this.refEvent = this.channel._replyEventName(this.ref);
    const callback = payload => {
      this._cancelRefEvent();
      this._cancelTimeout();
      this.receivedResp = payload;
      this._matchReceive(payload);
    };
    this.channel._on(this.refEvent, {}, callback);
    this.timeoutTimer = setTimeout(() => {
      this.trigger('timeout', {});
    }, this.timeout);
  }
  trigger(status, response) {
    if (this.refEvent) this.channel._trigger(this.refEvent, {
      status,
      response
    });
  }
  destroy() {
    this._cancelRefEvent();
    this._cancelTimeout();
  }
  _cancelRefEvent() {
    if (!this.refEvent) {
      return;
    }
    this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = undefined;
  }
  _matchReceive({
    status,
    response
  }) {
    this.recHooks.filter(h => h.status === status).forEach(h => h.callback(response));
  }
  _hasReceived(status) {
    return this.receivedResp && this.receivedResp.status === status;
  }
}

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Serializer)
/* harmony export */ });
// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe
// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md
class Serializer {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(rawPayload, callback) {
    if (rawPayload.constructor === ArrayBuffer) {
      return callback(this._binaryDecode(rawPayload));
    }
    if (typeof rawPayload === 'string') {
      return callback(JSON.parse(rawPayload));
    }
    return callback({});
  }
  _binaryDecode(buffer) {
    const view = new DataView(buffer);
    const decoder = new TextDecoder();
    return this._decodeBroadcast(buffer, view, decoder);
  }
  _decodeBroadcast(buffer, view, decoder) {
    const topicSize = view.getUint8(1);
    const eventSize = view.getUint8(2);
    let offset = this.HEADER_LENGTH + 2;
    const topic = decoder.decode(buffer.slice(offset, offset + topicSize));
    offset = offset + topicSize;
    const event = decoder.decode(buffer.slice(offset, offset + eventSize));
    offset = offset + eventSize;
    const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));
    return {
      ref: null,
      topic: topic,
      event: event,
      payload: data
    };
  }
}

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Timer)
/* harmony export */ });
/**
 * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.
 *
 * @example
 *    let reconnectTimer = new Timer(() => this.connect(), function(tries){
 *      return [1000, 5000, 10000][tries - 1] || 10000
 *    })
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 *    reconnectTimer.scheduleTimeout() // fires after 5000
 *    reconnectTimer.reset()
 *    reconnectTimer.scheduleTimeout() // fires after 1000
 */
class Timer {
  constructor(callback, timerCalc) {
    this.callback = callback;
    this.timerCalc = timerCalc;
    this.timer = undefined;
    this.tries = 0;
    this.callback = callback;
    this.timerCalc = timerCalc;
  }
  reset() {
    this.tries = 0;
    clearTimeout(this.timer);
  }
  // Cancels any previous scheduleTimeout and schedules callback
  scheduleTimeout() {
    clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this.tries = this.tries + 1;
      this.callback();
    }, this.timerCalc(this.tries + 1));
  }
}

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!*****************************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PostgresTypes: () => (/* binding */ PostgresTypes),
/* harmony export */   convertCell: () => (/* binding */ convertCell),
/* harmony export */   convertChangeData: () => (/* binding */ convertChangeData),
/* harmony export */   convertColumn: () => (/* binding */ convertColumn),
/* harmony export */   httpEndpointURL: () => (/* binding */ httpEndpointURL),
/* harmony export */   toArray: () => (/* binding */ toArray),
/* harmony export */   toBoolean: () => (/* binding */ toBoolean),
/* harmony export */   toJson: () => (/* binding */ toJson),
/* harmony export */   toNumber: () => (/* binding */ toNumber),
/* harmony export */   toTimestampString: () => (/* binding */ toTimestampString)
/* harmony export */ });
/**
 * Helpers to convert the change Payload into native JS types.
 */
// Adapted from epgsql (src/epgsql_binary.erl), this module licensed under
// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE
var PostgresTypes;
(function (PostgresTypes) {
  PostgresTypes["abstime"] = "abstime";
  PostgresTypes["bool"] = "bool";
  PostgresTypes["date"] = "date";
  PostgresTypes["daterange"] = "daterange";
  PostgresTypes["float4"] = "float4";
  PostgresTypes["float8"] = "float8";
  PostgresTypes["int2"] = "int2";
  PostgresTypes["int4"] = "int4";
  PostgresTypes["int4range"] = "int4range";
  PostgresTypes["int8"] = "int8";
  PostgresTypes["int8range"] = "int8range";
  PostgresTypes["json"] = "json";
  PostgresTypes["jsonb"] = "jsonb";
  PostgresTypes["money"] = "money";
  PostgresTypes["numeric"] = "numeric";
  PostgresTypes["oid"] = "oid";
  PostgresTypes["reltime"] = "reltime";
  PostgresTypes["text"] = "text";
  PostgresTypes["time"] = "time";
  PostgresTypes["timestamp"] = "timestamp";
  PostgresTypes["timestamptz"] = "timestamptz";
  PostgresTypes["timetz"] = "timetz";
  PostgresTypes["tsrange"] = "tsrange";
  PostgresTypes["tstzrange"] = "tstzrange";
})(PostgresTypes || (PostgresTypes = {}));
/**
 * Takes an array of columns and an object of string values then converts each string value
 * to its mapped type.
 *
 * @param {{name: String, type: String}[]} columns
 * @param {Object} record
 * @param {Object} options The map of various options that can be applied to the mapper
 * @param {Array} options.skipTypes The array of types that should not be converted
 *
 * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})
 * //=>{ first_name: 'Paul', age: 33 }
 */
const convertChangeData = (columns, record, options = {}) => {
  var _a;
  const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];
  return Object.keys(record).reduce((acc, rec_key) => {
    acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);
    return acc;
  }, {});
};
/**
 * Converts the value of an individual column.
 *
 * @param {String} columnName The column that you want to convert
 * @param {{name: String, type: String}[]} columns All of the columns
 * @param {Object} record The map of string values
 * @param {Array} skipTypes An array of types that should not be converted
 * @return {object} Useless information
 *
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])
 * //=> 33
 * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])
 * //=> "33"
 */
const convertColumn = (columnName, columns, record, skipTypes) => {
  const column = columns.find(x => x.name === columnName);
  const colType = column === null || column === void 0 ? void 0 : column.type;
  const value = record[columnName];
  if (colType && !skipTypes.includes(colType)) {
    return convertCell(colType, value);
  }
  return noop(value);
};
/**
 * If the value of the cell is `null`, returns null.
 * Otherwise converts the string value to the correct type.
 * @param {String} type A postgres column type
 * @param {String} value The cell value
 *
 * @example convertCell('bool', 't')
 * //=> true
 * @example convertCell('int8', '10')
 * //=> 10
 * @example convertCell('_int4', '{1,2,3,4}')
 * //=> [1,2,3,4]
 */
const convertCell = (type, value) => {
  // if data type is an array
  if (type.charAt(0) === '_') {
    const dataType = type.slice(1, type.length);
    return toArray(value, dataType);
  }
  // If not null, convert to correct type.
  switch (type) {
    case PostgresTypes.bool:
      return toBoolean(value);
    case PostgresTypes.float4:
    case PostgresTypes.float8:
    case PostgresTypes.int2:
    case PostgresTypes.int4:
    case PostgresTypes.int8:
    case PostgresTypes.numeric:
    case PostgresTypes.oid:
      return toNumber(value);
    case PostgresTypes.json:
    case PostgresTypes.jsonb:
      return toJson(value);
    case PostgresTypes.timestamp:
      return toTimestampString(value);
    // Format to be consistent with PostgREST
    case PostgresTypes.abstime: // To allow users to cast it based on Timezone
    case PostgresTypes.date: // To allow users to cast it based on Timezone
    case PostgresTypes.daterange:
    case PostgresTypes.int4range:
    case PostgresTypes.int8range:
    case PostgresTypes.money:
    case PostgresTypes.reltime: // To allow users to cast it based on Timezone
    case PostgresTypes.text:
    case PostgresTypes.time: // To allow users to cast it based on Timezone
    case PostgresTypes.timestamptz: // To allow users to cast it based on Timezone
    case PostgresTypes.timetz: // To allow users to cast it based on Timezone
    case PostgresTypes.tsrange:
    case PostgresTypes.tstzrange:
      return noop(value);
    default:
      // Return the value for remaining types
      return noop(value);
  }
};
const noop = value => {
  return value;
};
const toBoolean = value => {
  switch (value) {
    case 't':
      return true;
    case 'f':
      return false;
    default:
      return value;
  }
};
const toNumber = value => {
  if (typeof value === 'string') {
    const parsedValue = parseFloat(value);
    if (!Number.isNaN(parsedValue)) {
      return parsedValue;
    }
  }
  return value;
};
const toJson = value => {
  if (typeof value === 'string') {
    try {
      return JSON.parse(value);
    } catch (error) {
      console.log(`JSON parse error: ${error}`);
      return value;
    }
  }
  return value;
};
/**
 * Converts a Postgres Array into a native JS array
 *
 * @example toArray('{}', 'int4')
 * //=> []
 * @example toArray('{"[2021-01-01,2021-12-31)","(2021-01-01,2021-12-32]"}', 'daterange')
 * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']
 * @example toArray([1,2,3,4], 'int4')
 * //=> [1,2,3,4]
 */
const toArray = (value, type) => {
  if (typeof value !== 'string') {
    return value;
  }
  const lastIdx = value.length - 1;
  const closeBrace = value[lastIdx];
  const openBrace = value[0];
  // Confirm value is a Postgres array by checking curly brackets
  if (openBrace === '{' && closeBrace === '}') {
    let arr;
    const valTrim = value.slice(1, lastIdx);
    // TODO: find a better solution to separate Postgres array data
    try {
      arr = JSON.parse('[' + valTrim + ']');
    } catch (_) {
      // WARNING: splitting on comma does not cover all edge cases
      arr = valTrim ? valTrim.split(',') : [];
    }
    return arr.map(val => convertCell(type, val));
  }
  return value;
};
/**
 * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'
 * See https://github.com/supabase/supabase/issues/18
 *
 * @example toTimestampString('2019-09-10 00:00:00')
 * //=> '2019-09-10T00:00:00'
 */
const toTimestampString = value => {
  if (typeof value === 'string') {
    return value.replace(' ', 'T');
  }
  return value;
};
const httpEndpointURL = socketUrl => {
  let url = socketUrl;
  url = url.replace(/^ws/i, 'http');
  url = url.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, '');
  return url.replace(/\/+$/, '');
};

/***/ }),

/***/ "../node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!************************************************************************!*\
  !*** ../node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
const version = '2.11.2';

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/StorageClient.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/StorageClient.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StorageClient: () => (/* binding */ StorageClient)
/* harmony export */ });
/* harmony import */ var _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packages/StorageFileApi */ "../node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js");
/* harmony import */ var _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packages/StorageBucketApi */ "../node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js");


class StorageClient extends _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(url, headers = {}, fetch) {
    super(url, headers, fetch);
  }
  /**
   * Perform file operation in a bucket.
   *
   * @param id The bucket id to operate on.
   */
  from(id) {
    return new _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__["default"](this.url, this.headers, id, this.fetch);
  }
}

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ "../node_modules/@supabase/storage-js/dist/module/lib/version.js");

const DEFAULT_HEADERS = {
  'X-Client-Info': `storage-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`
};

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/lib/errors.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/lib/errors.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),
/* harmony export */   StorageError: () => (/* binding */ StorageError),
/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),
/* harmony export */   isStorageError: () => (/* binding */ isStorageError)
/* harmony export */ });
class StorageError extends Error {
  constructor(message) {
    super(message);
    this.__isStorageError = true;
    this.name = 'StorageError';
  }
}
function isStorageError(error) {
  return typeof error === 'object' && error !== null && '__isStorageError' in error;
}
class StorageApiError extends StorageError {
  constructor(message, status) {
    super(message);
    this.name = 'StorageApiError';
    this.status = status;
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    };
  }
}
class StorageUnknownError extends StorageError {
  constructor(message, originalError) {
    super(message);
    this.name = 'StorageUnknownError';
    this.originalError = originalError;
  }
}

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/lib/fetch.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/lib/fetch.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   get: () => (/* binding */ get),
/* harmony export */   head: () => (/* binding */ head),
/* harmony export */   post: () => (/* binding */ post),
/* harmony export */   put: () => (/* binding */ put),
/* harmony export */   remove: () => (/* binding */ remove)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ "../node_modules/@supabase/storage-js/dist/module/lib/errors.js");
/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ "../node_modules/@supabase/storage-js/dist/module/lib/helpers.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};


const _getErrorMessage = err => err.msg || err.message || err.error_description || err.error || JSON.stringify(err);
const handleError = (error, reject, options) => __awaiter(void 0, void 0, void 0, function* () {
  const Res = yield (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveResponse)();
  if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {
    error.json().then(err => {
      reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageApiError(_getErrorMessage(err), error.status || 500));
    }).catch(err => {
      reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(err), err));
    });
  } else {
    reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError(_getErrorMessage(error), error));
  }
});
const _getRequestParams = (method, options, parameters, body) => {
  const params = {
    method,
    headers: (options === null || options === void 0 ? void 0 : options.headers) || {}
  };
  if (method === 'GET') {
    return params;
  }
  params.headers = Object.assign({
    'Content-Type': 'application/json'
  }, options === null || options === void 0 ? void 0 : options.headers);
  if (body) {
    params.body = JSON.stringify(body);
  }
  return Object.assign(Object.assign({}, params), parameters);
};
function _handleRequest(fetcher, method, url, options, parameters, body) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
      fetcher(url, _getRequestParams(method, options, parameters, body)).then(result => {
        if (!result.ok) throw result;
        if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;
        return result.json();
      }).then(data => resolve(data)).catch(error => handleError(error, reject, options));
    });
  });
}
function get(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'GET', url, options, parameters);
  });
}
function post(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'POST', url, options, parameters, body);
  });
}
function put(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'PUT', url, options, parameters, body);
  });
}
function head(fetcher, url, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'HEAD', url, Object.assign(Object.assign({}, options), {
      noResolveJson: true
    }), parameters);
  });
}
function remove(fetcher, url, body, options, parameters) {
  return __awaiter(this, void 0, void 0, function* () {
    return _handleRequest(fetcher, 'DELETE', url, options, parameters, body);
  });
}

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/lib/helpers.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/lib/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   recursiveToCamel: () => (/* binding */ recursiveToCamel),
/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),
/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse)
/* harmony export */ });
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = (...args) => Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ "../node_modules/@supabase/node-fetch/browser.js")).then(({
      default: fetch
    }) => fetch(...args));
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveResponse = () => __awaiter(void 0, void 0, void 0, function* () {
  if (typeof Response === 'undefined') {
    // @ts-ignore
    return (yield Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! @supabase/node-fetch */ "../node_modules/@supabase/node-fetch/browser.js"))).Response;
  }
  return Response;
});
const recursiveToCamel = item => {
  if (Array.isArray(item)) {
    return item.map(el => recursiveToCamel(el));
  } else if (typeof item === 'function' || item !== Object(item)) {
    return item;
  }
  const result = {};
  Object.entries(item).forEach(([key, value]) => {
    const newKey = key.replace(/([-_][a-z])/gi, c => c.toUpperCase().replace(/[-_]/g, ''));
    result[newKey] = recursiveToCamel(value);
  });
  return result;
};

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
// generated by genversion
const version = '2.7.1';

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js":
/*!*************************************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StorageBucketApi)
/* harmony export */ });
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ "../node_modules/@supabase/storage-js/dist/module/lib/constants.js");
/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/errors */ "../node_modules/@supabase/storage-js/dist/module/lib/errors.js");
/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ "../node_modules/@supabase/storage-js/dist/module/lib/fetch.js");
/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/helpers */ "../node_modules/@supabase/storage-js/dist/module/lib/helpers.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};




class StorageBucketApi {
  constructor(url, headers = {}, fetch) {
    this.url = url;
    this.headers = Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);
    this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);
  }
  /**
   * Retrieves the details of all Storage buckets within an existing project.
   */
  listBuckets() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket`, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing Storage bucket.
   *
   * @param id The unique identifier of the bucket you would like to retrieve.
   */
  getBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/bucket/${id}`, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a new Storage bucket
   *
   * @param id A unique identifier for the bucket you are creating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   * @returns newly created bucket id
   */
  createBucket(id, options = {
    public: false
  }) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Updates a Storage bucket
   *
   * @param id A unique identifier for the bucket you are updating.
   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.
   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.
   * The global file size limit takes precedence over this value.
   * The default value is null, which doesn't set a per bucket file size limit.
   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.
   * The default value is null, which allows files with all mime types to be uploaded.
   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.
   */
  updateBucket(id, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.put)(this.fetch, `${this.url}/bucket/${id}`, {
          id,
          name: id,
          public: options.public,
          file_size_limit: options.fileSizeLimit,
          allowed_mime_types: options.allowedMimeTypes
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Removes all objects inside a single bucket.
   *
   * @param id The unique identifier of the bucket you would like to empty.
   */
  emptyBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.
   * You must first `empty()` the bucket.
   *
   * @param id The unique identifier of the bucket you would like to delete.
   */
  deleteBucket(id) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
}

/***/ }),

/***/ "../node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ StorageFileApi)
/* harmony export */ });
/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/errors */ "../node_modules/@supabase/storage-js/dist/module/lib/errors.js");
/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ "../node_modules/@supabase/storage-js/dist/module/lib/fetch.js");
/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/helpers */ "../node_modules/@supabase/storage-js/dist/module/lib/helpers.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};



const DEFAULT_SEARCH_OPTIONS = {
  limit: 100,
  offset: 0,
  sortBy: {
    column: 'name',
    order: 'asc'
  }
};
const DEFAULT_FILE_OPTIONS = {
  cacheControl: '3600',
  contentType: 'text/plain;charset=UTF-8',
  upsert: false
};
class StorageFileApi {
  constructor(url, headers = {}, bucketId, fetch) {
    this.url = url;
    this.headers = headers;
    this.bucketId = bucketId;
    this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveFetch)(fetch);
  }
  /**
   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.
   *
   * @param method HTTP method.
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadOrUpdate(method, path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let body;
        const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);
        let headers = Object.assign(Object.assign({}, this.headers), method === 'POST' && {
          'x-upsert': String(options.upsert)
        });
        const metadata = options.metadata;
        if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {
          body = new FormData();
          body.append('cacheControl', options.cacheControl);
          if (metadata) {
            body.append('metadata', this.encodeMetadata(metadata));
          }
          body.append('', fileBody);
        } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {
          body = fileBody;
          body.append('cacheControl', options.cacheControl);
          if (metadata) {
            body.append('metadata', this.encodeMetadata(metadata));
          }
        } else {
          body = fileBody;
          headers['cache-control'] = `max-age=${options.cacheControl}`;
          headers['content-type'] = options.contentType;
          if (metadata) {
            headers['x-metadata'] = this.toBase64(this.encodeMetadata(metadata));
          }
        }
        if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {
          headers = Object.assign(Object.assign({}, headers), fileOptions.headers);
        }
        const cleanPath = this._removeEmptyFolders(path);
        const _path = this._getFinalPath(cleanPath);
        const res = yield this.fetch(`${this.url}/object/${_path}`, Object.assign({
          method,
          body: body,
          headers
        }, (options === null || options === void 0 ? void 0 : options.duplex) ? {
          duplex: options.duplex
        } : {}));
        const data = yield res.json();
        if (res.ok) {
          return {
            data: {
              path: cleanPath,
              id: data.Id,
              fullPath: data.Key
            },
            error: null
          };
        } else {
          const error = data;
          return {
            data: null,
            error
          };
        }
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Uploads a file to an existing bucket.
   *
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  upload(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate('POST', path, fileBody, fileOptions);
    });
  }
  /**
   * Upload a file with a token generated from `createSignedUploadUrl`.
   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.
   * @param token The token generated from `createSignedUploadUrl`
   * @param fileBody The body of the file to be stored in the bucket.
   */
  uploadToSignedUrl(path, token, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      const cleanPath = this._removeEmptyFolders(path);
      const _path = this._getFinalPath(cleanPath);
      const url = new URL(this.url + `/object/upload/sign/${_path}`);
      url.searchParams.set('token', token);
      try {
        let body;
        const options = Object.assign({
          upsert: DEFAULT_FILE_OPTIONS.upsert
        }, fileOptions);
        const headers = Object.assign(Object.assign({}, this.headers), {
          'x-upsert': String(options.upsert)
        });
        if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {
          body = new FormData();
          body.append('cacheControl', options.cacheControl);
          body.append('', fileBody);
        } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {
          body = fileBody;
          body.append('cacheControl', options.cacheControl);
        } else {
          body = fileBody;
          headers['cache-control'] = `max-age=${options.cacheControl}`;
          headers['content-type'] = options.contentType;
        }
        const res = yield this.fetch(url.toString(), {
          method: 'PUT',
          body: body,
          headers
        });
        const data = yield res.json();
        if (res.ok) {
          return {
            data: {
              path: cleanPath,
              fullPath: data.Key
            },
            error: null
          };
        } else {
          const error = data;
          return {
            data: null,
            error
          };
        }
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed upload URL.
   * Signed upload URLs can be used to upload files to the bucket without further authentication.
   * They are valid for 2 hours.
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.
   */
  createSignedUploadUrl(path, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        const headers = Object.assign({}, this.headers);
        if (options === null || options === void 0 ? void 0 : options.upsert) {
          headers['x-upsert'] = 'true';
        }
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, {
          headers
        });
        const url = new URL(this.url + data.url);
        const token = url.searchParams.get('token');
        if (!token) {
          throw new _lib_errors__WEBPACK_IMPORTED_MODULE_1__.StorageError('No token returned by API');
        }
        return {
          data: {
            signedUrl: url.toString(),
            path,
            token
          },
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Replaces an existing file at the specified path with a new one.
   *
   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.
   * @param fileBody The body of the file to be stored in the bucket.
   */
  update(path, fileBody, fileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.uploadOrUpdate('PUT', path, fileBody, fileOptions);
    });
  }
  /**
   * Moves an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.
   * @param options The destination options.
   */
  move(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/move`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Copies an existing file to a new path in the same bucket.
   *
   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.
   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.
   * @param options The destination options.
   */
  copy(fromPath, toPath, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/copy`, {
          bucketId: this.bucketId,
          sourceKey: fromPath,
          destinationKey: toPath,
          destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket
        }, {
          headers: this.headers
        });
        return {
          data: {
            path: data.Key
          },
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param path The file path, including the current file name. For example `folder/image.png`.
   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  createSignedUrl(path, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let _path = this._getFinalPath(path);
        let data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({
          expiresIn
        }, (options === null || options === void 0 ? void 0 : options.transform) ? {
          transform: options.transform
        } : {}), {
          headers: this.headers
        });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? '' : options.download}` : '';
        const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);
        data = {
          signedUrl
        };
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.
   *
   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.
   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.
   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   */
  createSignedUrls(paths, expiresIn, options) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
          expiresIn,
          paths
        }, {
          headers: this.headers
        });
        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? '' : options.download}` : '';
        return {
          data: data.map(datum => Object.assign(Object.assign({}, datum), {
            signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null
          })),
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.
   *
   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.
   * @param options.transform Transform the asset before serving it to the client.
   */
  download(path, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';
      const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object';
      const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
      const queryString = transformationQuery ? `?${transformationQuery}` : '';
      try {
        const _path = this._getFinalPath(path);
        const res = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {
          headers: this.headers,
          noResolveJson: true
        });
        const data = yield res.blob();
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Retrieves the details of an existing file.
   * @param path
   */
  info(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/object/info/${_path}`, {
          headers: this.headers
        });
        return {
          data: (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.recursiveToCamel)(data),
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Checks the existence of a file.
   * @param path
   */
  exists(path) {
    return __awaiter(this, void 0, void 0, function* () {
      const _path = this._getFinalPath(path);
      try {
        yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.head)(this.fetch, `${this.url}/object/${_path}`, {
          headers: this.headers
        });
        return {
          data: true,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error) && error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_1__.StorageUnknownError) {
          const originalError = error.originalError;
          if ([400, 404].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {
            return {
              data: false,
              error
            };
          }
        }
        throw error;
      }
    });
  }
  /**
   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.
   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.
   *
   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.
   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.
   * @param options.transform Transform the asset before serving it to the client.
   */
  getPublicUrl(path, options) {
    const _path = this._getFinalPath(path);
    const _queryString = [];
    const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? '' : options.download}` : '';
    if (downloadQueryParam !== '') {
      _queryString.push(downloadQueryParam);
    }
    const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== 'undefined';
    const renderPath = wantsTransformation ? 'render/image' : 'object';
    const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});
    if (transformationQuery !== '') {
      _queryString.push(transformationQuery);
    }
    let queryString = _queryString.join('&');
    if (queryString !== '') {
      queryString = `?${queryString}`;
    }
    return {
      data: {
        publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)
      }
    };
  }
  /**
   * Deletes files within the same bucket
   *
   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].
   */
  remove(paths) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, {
          prefixes: paths
        }, {
          headers: this.headers
        });
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  /**
   * Get file metadata
   * @param id the file id to retrieve metadata
   */
  // async getMetadata(
  //   id: string
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Update file metadata
   * @param id the file id to update metadata
   * @param meta the new file metadata
   */
  // async updateMetadata(
  //   id: string,
  //   meta: Metadata
  // ): Promise<
  //   | {
  //       data: Metadata
  //       error: null
  //     }
  //   | {
  //       data: null
  //       error: StorageError
  //     }
  // > {
  //   try {
  //     const data = await post(
  //       this.fetch,
  //       `${this.url}/metadata/${id}`,
  //       { ...meta },
  //       { headers: this.headers }
  //     )
  //     return { data, error: null }
  //   } catch (error) {
  //     if (isStorageError(error)) {
  //       return { data: null, error }
  //     }
  //     throw error
  //   }
  // }
  /**
   * Lists all the files within a bucket.
   * @param path The folder path.
   */
  list(path, options, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {
          prefix: path || ''
        });
        const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, {
          headers: this.headers
        }, parameters);
        return {
          data,
          error: null
        };
      } catch (error) {
        if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {
          return {
            data: null,
            error
          };
        }
        throw error;
      }
    });
  }
  encodeMetadata(metadata) {
    return JSON.stringify(metadata);
  }
  toBase64(data) {
    if (typeof Buffer !== 'undefined') {
      return Buffer.from(data).toString('base64');
    }
    return btoa(data);
  }
  _getFinalPath(path) {
    return `${this.bucketId}/${path}`;
  }
  _removeEmptyFolders(path) {
    return path.replace(/^\/|\/$/g, '').replace(/\/+/g, '/');
  }
  transformOptsToQueryString(transform) {
    const params = [];
    if (transform.width) {
      params.push(`width=${transform.width}`);
    }
    if (transform.height) {
      params.push(`height=${transform.height}`);
    }
    if (transform.resize) {
      params.push(`resize=${transform.resize}`);
    }
    if (transform.format) {
      params.push(`format=${transform.format}`);
    }
    if (transform.quality) {
      params.push(`quality=${transform.quality}`);
    }
    return params.join('&');
  }
}

/***/ }),

/***/ "../node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SupabaseClient)
/* harmony export */ });
/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/functions-js */ "../node_modules/@supabase/functions-js/dist/module/FunctionsClient.js");
/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ "../node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs");
/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ "../node_modules/@supabase/realtime-js/dist/module/index.js");
/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @supabase/storage-js */ "../node_modules/@supabase/storage-js/dist/module/StorageClient.js");
/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/constants */ "../node_modules/@supabase/supabase-js/dist/module/lib/constants.js");
/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/fetch */ "../node_modules/@supabase/supabase-js/dist/module/lib/fetch.js");
/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/helpers */ "../node_modules/@supabase/supabase-js/dist/module/lib/helpers.js");
/* harmony import */ var _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/SupabaseAuthClient */ "../node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};








/**
 * Supabase Client.
 *
 * An isomorphic Javascript client for interacting with Postgres.
 */
class SupabaseClient {
  /**
   * Create a new client for use in the browser.
   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.
   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.
   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.
   * @param options.auth.autoRefreshToken Set to "true" if you want to automatically refresh the token before expiring.
   * @param options.auth.persistSession Set to "true" if you want to automatically save the user session into local storage.
   * @param options.auth.detectSessionInUrl Set to "true" if you want to automatically detects OAuth grants in the URL and signs in the user.
   * @param options.realtime Options passed along to realtime-js constructor.
   * @param options.global.fetch A custom fetch implementation.
   * @param options.global.headers Any additional headers to send with each network request.
   */
  constructor(supabaseUrl, supabaseKey, options) {
    var _a, _b, _c;
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    if (!supabaseUrl) throw new Error('supabaseUrl is required.');
    if (!supabaseKey) throw new Error('supabaseKey is required.');
    const _supabaseUrl = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.stripTrailingSlash)(supabaseUrl);
    this.realtimeUrl = `${_supabaseUrl}/realtime/v1`.replace(/^http/i, 'ws');
    this.authUrl = `${_supabaseUrl}/auth/v1`;
    this.storageUrl = `${_supabaseUrl}/storage/v1`;
    this.functionsUrl = `${_supabaseUrl}/functions/v1`;
    // default storage key uses the supabase project ref as a namespace
    const defaultStorageKey = `sb-${new URL(this.authUrl).hostname.split('.')[0]}-auth-token`;
    const DEFAULTS = {
      db: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_DB_OPTIONS,
      realtime: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_REALTIME_OPTIONS,
      auth: Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_AUTH_OPTIONS), {
        storageKey: defaultStorageKey
      }),
      global: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_GLOBAL_OPTIONS
    };
    const settings = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);
    this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';
    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};
    if (!settings.accessToken) {
      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);
    } else {
      this.accessToken = settings.accessToken;
      this.auth = new Proxy({}, {
        get: (_, prop) => {
          throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);
        }
      });
    }
    this.fetch = (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_4__.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);
    this.realtime = this._initRealtimeClient(Object.assign({
      headers: this.headers,
      accessToken: this._getAccessToken.bind(this)
    }, settings.realtime));
    this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(`${_supabaseUrl}/rest/v1`, {
      headers: this.headers,
      schema: settings.db.schema,
      fetch: this.fetch
    });
    if (!settings.accessToken) {
      this._listenForAuthEvents();
    }
  }
  /**
   * Supabase Functions allows you to deploy and invoke edge functions.
   */
  get functions() {
    return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_5__.FunctionsClient(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    });
  }
  /**
   * Supabase Storage allows you to manage user-generated content, such as photos or videos.
   */
  get storage() {
    return new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_6__.StorageClient(this.storageUrl, this.headers, this.fetch);
  }
  /**
   * Perform a query on a table or a view.
   *
   * @param relation - The table or view name to query
   */
  from(relation) {
    return this.rest.from(relation);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.schema
  /**
   * Select a schema to query or perform an function (rpc) call.
   *
   * The schema needs to be on the list of exposed schemas inside Supabase.
   *
   * @param schema - The schema to query
   */
  schema(schema) {
    return this.rest.schema(schema);
  }
  // NOTE: signatures must be kept in sync with PostgrestClient.rpc
  /**
   * Perform a function call.
   *
   * @param fn - The function name to call
   * @param args - The arguments to pass to the function call
   * @param options - Named parameters
   * @param options.head - When set to `true`, `data` will not be returned.
   * Useful if you only need the count.
   * @param options.get - When set to `true`, the function will be called with
   * read-only access mode.
   * @param options.count - Count algorithm to use to count rows returned by the
   * function. Only applicable for [set-returning
   * functions](https://www.postgresql.org/docs/current/functions-srf.html).
   *
   * `"exact"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the
   * hood.
   *
   * `"planned"`: Approximated but fast count algorithm. Uses the Postgres
   * statistics under the hood.
   *
   * `"estimated"`: Uses exact count for low numbers and planned count for high
   * numbers.
   */
  rpc(fn, args = {}, options = {}) {
    return this.rest.rpc(fn, args, options);
  }
  /**
   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.
   *
   * @param {string} name - The name of the Realtime channel.
   * @param {Object} opts - The options to pass to the Realtime channel.
   *
   */
  channel(name, opts = {
    config: {}
  }) {
    return this.realtime.channel(name, opts);
  }
  /**
   * Returns all Realtime channels.
   */
  getChannels() {
    return this.realtime.getChannels();
  }
  /**
   * Unsubscribes and removes Realtime channel from Realtime client.
   *
   * @param {RealtimeChannel} channel - The name of the Realtime channel.
   *
   */
  removeChannel(channel) {
    return this.realtime.removeChannel(channel);
  }
  /**
   * Unsubscribes and removes all Realtime channels from Realtime client.
   */
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      if (this.accessToken) {
        return yield this.accessToken();
      }
      const {
        data
      } = yield this.auth.getSession();
      return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : null;
    });
  }
  _initSupabaseAuthClient({
    autoRefreshToken,
    persistSession,
    detectSessionInUrl,
    storage,
    storageKey,
    flowType,
    lock,
    debug
  }, headers, fetch) {
    const authHeaders = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__.SupabaseAuthClient({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, authHeaders), headers),
      storageKey: storageKey,
      autoRefreshToken,
      persistSession,
      detectSessionInUrl,
      storage,
      flowType,
      lock,
      debug,
      fetch,
      // auth checks if there is a custom authorizaiton header using this flag
      // so it knows whether to return an error when getUser is called with no session
      hasCustomAuthorizationHeader: 'Authorization' in this.headers
    });
  }
  _initRealtimeClient(options) {
    return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl, Object.assign(Object.assign({}, options), {
      params: Object.assign({
        apikey: this.supabaseKey
      }, options === null || options === void 0 ? void 0 : options.params)
    }));
  }
  _listenForAuthEvents() {
    let data = this.auth.onAuthStateChange((event, session) => {
      this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);
    });
    return data;
  }
  _handleTokenChanged(event, source, token) {
    if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {
      this.changedAccessToken = token;
    } else if (event === 'SIGNED_OUT') {
      this.realtime.setAuth();
      if (source == 'STORAGE') this.auth.signOut();
      this.changedAccessToken = undefined;
    }
  }
}

/***/ }),

/***/ "../node_modules/@supabase/supabase-js/dist/module/index.js":
/*!******************************************************************!*\
  !*** ../node_modules/@supabase/supabase-js/dist/module/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthAdminApi),
/* harmony export */   AuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthApiError),
/* harmony export */   AuthClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient),
/* harmony export */   AuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthError),
/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthImplicitGrantRedirectError),
/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidCredentialsError),
/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidJwtError),
/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidTokenResponseError),
/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthPKCEGrantCodeExchangeError),
/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthRetryableFetchError),
/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthSessionMissingError),
/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthUnknownError),
/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthWeakPasswordError),
/* harmony export */   CustomAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.CustomAuthError),
/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionRegion),
/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsError),
/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsFetchError),
/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsHttpError),
/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsRelayError),
/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueAdminApi),
/* harmony export */   GoTrueClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueClient),
/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.NavigatorLockAcquireTimeoutError),
/* harmony export */   PostgrestError: () => (/* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__.PostgrestError),
/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_CHANNEL_STATES),
/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_LISTEN_TYPES),
/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),
/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_PRESENCE_LISTEN_EVENTS),
/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_SUBSCRIBE_STATES),
/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeChannel),
/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeClient),
/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimePresence),
/* harmony export */   SupabaseClient: () => (/* reexport safe */ _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   createClient: () => (/* binding */ createClient),
/* harmony export */   isAuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthApiError),
/* harmony export */   isAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthError),
/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthImplicitGrantRedirectError),
/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthRetryableFetchError),
/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthSessionMissingError),
/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthWeakPasswordError),
/* harmony export */   lockInternals: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.lockInternals),
/* harmony export */   navigatorLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.navigatorLock)
/* harmony export */ });
/* harmony import */ var _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SupabaseClient */ "../node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js");
/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ "../node_modules/@supabase/auth-js/dist/module/index.js");
/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/postgrest-js */ "../node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs");
/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/functions-js */ "../node_modules/@supabase/functions-js/dist/module/types.js");
/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/realtime-js */ "../node_modules/@supabase/realtime-js/dist/module/index.js");






/**
 * Creates a new Supabase Client.
 */
const createClient = (supabaseUrl, supabaseKey, options) => {
  return new _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__["default"](supabaseUrl, supabaseKey, options);
};

/***/ }),

/***/ "../node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SupabaseAuthClient: () => (/* binding */ SupabaseAuthClient)
/* harmony export */ });
/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ "../node_modules/@supabase/auth-js/dist/module/index.js");

class SupabaseAuthClient extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient {
  constructor(options) {
    super(options);
  }
}

/***/ }),

/***/ "../node_modules/@supabase/supabase-js/dist/module/lib/constants.js":
/*!**************************************************************************!*\
  !*** ../node_modules/@supabase/supabase-js/dist/module/lib/constants.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_AUTH_OPTIONS: () => (/* binding */ DEFAULT_AUTH_OPTIONS),
/* harmony export */   DEFAULT_DB_OPTIONS: () => (/* binding */ DEFAULT_DB_OPTIONS),
/* harmony export */   DEFAULT_GLOBAL_OPTIONS: () => (/* binding */ DEFAULT_GLOBAL_OPTIONS),
/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),
/* harmony export */   DEFAULT_REALTIME_OPTIONS: () => (/* binding */ DEFAULT_REALTIME_OPTIONS)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ "../node_modules/@supabase/supabase-js/dist/module/lib/version.js");

let JS_ENV = '';
// @ts-ignore
if (typeof Deno !== 'undefined') {
  JS_ENV = 'deno';
} else if (typeof document !== 'undefined') {
  JS_ENV = 'web';
} else if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
  JS_ENV = 'react-native';
} else {
  JS_ENV = 'node';
}
const DEFAULT_HEADERS = {
  'X-Client-Info': `supabase-js-${JS_ENV}/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`
};
const DEFAULT_GLOBAL_OPTIONS = {
  headers: DEFAULT_HEADERS
};
const DEFAULT_DB_OPTIONS = {
  schema: 'public'
};
const DEFAULT_AUTH_OPTIONS = {
  autoRefreshToken: true,
  persistSession: true,
  detectSessionInUrl: true,
  flowType: 'implicit'
};
const DEFAULT_REALTIME_OPTIONS = {};

/***/ }),

/***/ "../node_modules/@supabase/supabase-js/dist/module/lib/fetch.js":
/*!**********************************************************************!*\
  !*** ../node_modules/@supabase/supabase-js/dist/module/lib/fetch.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fetchWithAuth: () => (/* binding */ fetchWithAuth),
/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),
/* harmony export */   resolveHeadersConstructor: () => (/* binding */ resolveHeadersConstructor)
/* harmony export */ });
/* harmony import */ var _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/node-fetch */ "../node_modules/@supabase/node-fetch/browser.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
// @ts-ignore

const resolveFetch = customFetch => {
  let _fetch;
  if (customFetch) {
    _fetch = customFetch;
  } else if (typeof fetch === 'undefined') {
    _fetch = _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__["default"];
  } else {
    _fetch = fetch;
  }
  return (...args) => _fetch(...args);
};
const resolveHeadersConstructor = () => {
  if (typeof Headers === 'undefined') {
    return _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__.Headers;
  }
  return Headers;
};
const fetchWithAuth = (supabaseKey, getAccessToken, customFetch) => {
  const fetch = resolveFetch(customFetch);
  const HeadersConstructor = resolveHeadersConstructor();
  return (input, init) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const accessToken = (_a = yield getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;
    let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);
    if (!headers.has('apikey')) {
      headers.set('apikey', supabaseKey);
    }
    if (!headers.has('Authorization')) {
      headers.set('Authorization', `Bearer ${accessToken}`);
    }
    return fetch(input, Object.assign(Object.assign({}, init), {
      headers
    }));
  });
};

/***/ }),

/***/ "../node_modules/@supabase/supabase-js/dist/module/lib/helpers.js":
/*!************************************************************************!*\
  !*** ../node_modules/@supabase/supabase-js/dist/module/lib/helpers.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applySettingDefaults: () => (/* binding */ applySettingDefaults),
/* harmony export */   isBrowser: () => (/* binding */ isBrowser),
/* harmony export */   stripTrailingSlash: () => (/* binding */ stripTrailingSlash),
/* harmony export */   uuid: () => (/* binding */ uuid)
/* harmony export */ });
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function uuid() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
      v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}
function stripTrailingSlash(url) {
  return url.replace(/\/$/, '');
}
const isBrowser = () => typeof window !== 'undefined';
function applySettingDefaults(options, defaults) {
  const {
    db: dbOptions,
    auth: authOptions,
    realtime: realtimeOptions,
    global: globalOptions
  } = options;
  const {
    db: DEFAULT_DB_OPTIONS,
    auth: DEFAULT_AUTH_OPTIONS,
    realtime: DEFAULT_REALTIME_OPTIONS,
    global: DEFAULT_GLOBAL_OPTIONS
  } = defaults;
  const result = {
    db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),
    auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),
    realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),
    global: Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions),
    accessToken: () => __awaiter(this, void 0, void 0, function* () {
      return '';
    })
  };
  if (options.accessToken) {
    result.accessToken = options.accessToken;
  } else {
    // hack around Required<>
    delete result.accessToken;
  }
  return result;
}

/***/ }),

/***/ "../node_modules/@supabase/supabase-js/dist/module/lib/version.js":
/*!************************************************************************!*\
  !*** ../node_modules/@supabase/supabase-js/dist/module/lib/version.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   version: () => (/* binding */ version)
/* harmony export */ });
const version = '2.49.4';

/***/ }),

/***/ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/client/ReactRefreshEntry.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pmmmwh/react-refresh-webpack-plugin/client/ReactRefreshEntry.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/* global __react_refresh_library__ */

const safeThis = __webpack_require__(/*! core-js-pure/features/global-this */ "./node_modules/core-js-pure/features/global-this.js");
const RefreshRuntime = __webpack_require__(/*! react-refresh/runtime */ "./node_modules/react-refresh/runtime.js");
if (true) {
  if (typeof safeThis !== 'undefined') {
    var $RefreshInjected$ = '__reactRefreshInjected';
    // Namespace the injected flag (if necessary) for monorepo compatibility
    if (false) {}

    // Only inject the runtime if it hasn't been injected
    if (!safeThis[$RefreshInjected$]) {
      // Inject refresh runtime into global scope
      RefreshRuntime.injectIntoGlobalHook(safeThis);

      // Mark the runtime as injected to prevent double-injection
      safeThis[$RefreshInjected$] = true;
    }
  }
}

/***/ }),

/***/ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global __webpack_require__ */
var Refresh = __webpack_require__(/*! react-refresh/runtime */ "./node_modules/react-refresh/runtime.js");

/**
 * Extracts exports from a webpack module object.
 * @param {string} moduleId A Webpack module ID.
 * @returns {*} An exports object from the module.
 */
function getModuleExports(moduleId) {
  if (typeof moduleId === 'undefined') {
    // `moduleId` is unavailable, which indicates that this module is not in the cache,
    // which means we won't be able to capture any exports,
    // and thus they cannot be refreshed safely.
    // These are likely runtime or dynamically generated modules.
    return {};
  }
  var maybeModule = __webpack_require__.c[moduleId];
  if (typeof maybeModule === 'undefined') {
    // `moduleId` is available but the module in cache is unavailable,
    // which indicates the module is somehow corrupted (e.g. broken Webpacak `module` globals).
    // We will warn the user (as this is likely a mistake) and assume they cannot be refreshed.
    console.warn('[React Refresh] Failed to get exports for module: ' + moduleId + '.');
    return {};
  }
  var exportsOrPromise = maybeModule.exports;
  if (typeof Promise !== 'undefined' && exportsOrPromise instanceof Promise) {
    return exportsOrPromise.then(function (exports) {
      return exports;
    });
  }
  return exportsOrPromise;
}

/**
 * Calculates the signature of a React refresh boundary.
 * If this signature changes, it's unsafe to accept the boundary.
 *
 * This implementation is based on the one in [Metro](https://github.com/facebook/metro/blob/907d6af22ac6ebe58572be418e9253a90665ecbd/packages/metro/src/lib/polyfills/require.js#L795-L816).
 * @param {*} moduleExports A Webpack module exports object.
 * @returns {string[]} A React refresh boundary signature array.
 */
function getReactRefreshBoundarySignature(moduleExports) {
  var signature = [];
  signature.push(Refresh.getFamilyByType(moduleExports));
  if (moduleExports == null || typeof moduleExports !== 'object') {
    // Exit if we can't iterate over exports.
    return signature;
  }
  for (var key in moduleExports) {
    if (key === '__esModule') {
      continue;
    }
    signature.push(key);
    signature.push(Refresh.getFamilyByType(moduleExports[key]));
  }
  return signature;
}

/**
 * Creates a data object to be retained across refreshes.
 * This object should not transtively reference previous exports,
 * which can form infinite chain of objects across refreshes, which can pressure RAM.
 *
 * @param {*} moduleExports A Webpack module exports object.
 * @returns {*} A React refresh boundary signature array.
 */
function getWebpackHotData(moduleExports) {
  return {
    signature: getReactRefreshBoundarySignature(moduleExports),
    isReactRefreshBoundary: isReactRefreshBoundary(moduleExports)
  };
}

/**
 * Creates a helper that performs a delayed React refresh.
 * @returns {function(function(): void): void} A debounced React refresh function.
 */
function createDebounceUpdate() {
  /**
   * A cached setTimeout handler.
   * @type {number | undefined}
   */
  var refreshTimeout;

  /**
   * Performs react refresh on a delay and clears the error overlay.
   * @param {function(): void} callback
   * @returns {void}
   */
  function enqueueUpdate(callback) {
    if (typeof refreshTimeout === 'undefined') {
      refreshTimeout = setTimeout(function () {
        refreshTimeout = undefined;
        Refresh.performReactRefresh();
        callback();
      }, 30);
    }
  }
  return enqueueUpdate;
}

/**
 * Checks if all exports are likely a React component.
 *
 * This implementation is based on the one in [Metro](https://github.com/facebook/metro/blob/febdba2383113c88296c61e28e4ef6a7f4939fda/packages/metro/src/lib/polyfills/require.js#L748-L774).
 * @param {*} moduleExports A Webpack module exports object.
 * @returns {boolean} Whether the exports are React component like.
 */
function isReactRefreshBoundary(moduleExports) {
  if (Refresh.isLikelyComponentType(moduleExports)) {
    return true;
  }
  if (moduleExports === undefined || moduleExports === null || typeof moduleExports !== 'object') {
    // Exit if we can't iterate over exports.
    return false;
  }
  var hasExports = false;
  var areAllExportsComponents = true;
  for (var key in moduleExports) {
    hasExports = true;

    // This is the ES Module indicator flag
    if (key === '__esModule') {
      continue;
    }

    // We can (and have to) safely execute getters here,
    // as Webpack manually assigns harmony exports to getters,
    // without any side-effects attached.
    // Ref: https://github.com/webpack/webpack/blob/b93048643fe74de2a6931755911da1212df55897/lib/MainTemplate.js#L281
    var exportValue = moduleExports[key];
    if (!Refresh.isLikelyComponentType(exportValue)) {
      areAllExportsComponents = false;
    }
  }
  return hasExports && areAllExportsComponents;
}

/**
 * Checks if exports are likely a React component and registers them.
 *
 * This implementation is based on the one in [Metro](https://github.com/facebook/metro/blob/febdba2383113c88296c61e28e4ef6a7f4939fda/packages/metro/src/lib/polyfills/require.js#L818-L835).
 * @param {*} moduleExports A Webpack module exports object.
 * @param {string} moduleId A Webpack module ID.
 * @returns {void}
 */
function registerExportsForReactRefresh(moduleExports, moduleId) {
  if (Refresh.isLikelyComponentType(moduleExports)) {
    // Register module.exports if it is likely a component
    Refresh.register(moduleExports, moduleId + ' %exports%');
  }
  if (moduleExports === undefined || moduleExports === null || typeof moduleExports !== 'object') {
    // Exit if we can't iterate over the exports.
    return;
  }
  for (var key in moduleExports) {
    // Skip registering the ES Module indicator
    if (key === '__esModule') {
      continue;
    }
    var exportValue = moduleExports[key];
    if (Refresh.isLikelyComponentType(exportValue)) {
      var typeID = moduleId + ' %exports% ' + key;
      Refresh.register(exportValue, typeID);
    }
  }
}

/**
 * Compares previous and next module objects to check for mutated boundaries.
 *
 * This implementation is based on the one in [Metro](https://github.com/facebook/metro/blob/907d6af22ac6ebe58572be418e9253a90665ecbd/packages/metro/src/lib/polyfills/require.js#L776-L792).
 * @param {*} prevSignature The signature of the current Webpack module exports object.
 * @param {*} nextSignature The signature of the next Webpack module exports object.
 * @returns {boolean} Whether the React refresh boundary should be invalidated.
 */
function shouldInvalidateReactRefreshBoundary(prevSignature, nextSignature) {
  if (prevSignature.length !== nextSignature.length) {
    return true;
  }
  for (var i = 0; i < nextSignature.length; i += 1) {
    if (prevSignature[i] !== nextSignature[i]) {
      return true;
    }
  }
  return false;
}
var enqueueUpdate = createDebounceUpdate();
function executeRuntime(moduleExports, moduleId, webpackHot, refreshOverlay, isTest) {
  registerExportsForReactRefresh(moduleExports, moduleId);
  if (webpackHot) {
    var isHotUpdate = !!webpackHot.data;
    var prevData;
    if (isHotUpdate) {
      prevData = webpackHot.data.prevData;
    }
    if (isReactRefreshBoundary(moduleExports)) {
      webpackHot.dispose(
      /**
       * A callback to performs a full refresh if React has unrecoverable errors,
       * and also caches the to-be-disposed module.
       * @param {*} data A hot module data object from Webpack HMR.
       * @returns {void}
       */
      function hotDisposeCallback(data) {
        // We have to mutate the data object to get data registered and cached
        data.prevData = getWebpackHotData(moduleExports);
      });
      webpackHot.accept(
      /**
       * An error handler to allow self-recovering behaviours.
       * @param {Error} error An error occurred during evaluation of a module.
       * @returns {void}
       */
      function hotErrorHandler(error) {
        if (typeof refreshOverlay !== 'undefined' && refreshOverlay) {
          refreshOverlay.handleRuntimeError(error);
        }
        if (typeof isTest !== 'undefined' && isTest) {
          if (window.onHotAcceptError) {
            window.onHotAcceptError(error.message);
          }
        }
        __webpack_require__.c[moduleId].hot.accept(hotErrorHandler);
      });
      if (isHotUpdate) {
        if (prevData && prevData.isReactRefreshBoundary && shouldInvalidateReactRefreshBoundary(prevData.signature, getReactRefreshBoundarySignature(moduleExports))) {
          webpackHot.invalidate();
        } else {
          enqueueUpdate(
          /**
           * A function to dismiss the error overlay after performing React refresh.
           * @returns {void}
           */
          function updateCallback() {
            if (typeof refreshOverlay !== 'undefined' && refreshOverlay) {
              refreshOverlay.clearRuntimeErrors();
            }
          });
        }
      }
    } else {
      if (isHotUpdate && typeof prevData !== 'undefined') {
        webpackHot.invalidate();
      }
    }
  }
}
module.exports = Object.freeze({
  enqueueUpdate: enqueueUpdate,
  executeRuntime: executeRuntime,
  getModuleExports: getModuleExports,
  isReactRefreshBoundary: isReactRefreshBoundary,
  registerExportsForReactRefresh: registerExportsForReactRefresh
});

/***/ }),

/***/ "./node_modules/ansi-html-community/index.js":
/*!***************************************************!*\
  !*** ./node_modules/ansi-html-community/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


module.exports = ansiHTML;

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/;
var _defColors = {
  reset: ['fff', '000'],
  // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
};
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
};
var _openTags = {
  '1': 'font-weight:bold',
  // bold
  '2': 'opacity:0.5',
  // dim
  '3': '<i>',
  // italic
  '4': '<u>',
  // underscore
  '8': 'display:none',
  // hidden
  '9': '<del>' // delete
};
var _closeTags = {
  '23': '</i>',
  // reset italic
  '24': '</u>',
  // reset underscore
  '29': '</del>' // reset delete
};
[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>';
});

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML(text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text;
  }

  // Cache opened sequence.
  var ansiCodes = [];
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)m/g, function (match, seq) {
    var ot = _openTags[seq];
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) {
        // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop();
        return '</span>';
      }
      // Open tag.
      ansiCodes.push(seq);
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">';
    }
    var ct = _closeTags[seq];
    if (ct) {
      // Pop sequence
      ansiCodes.pop();
      return ct;
    }
    return '';
  });

  // Make sure tags are closed.
  var l = ansiCodes.length;
  l > 0 && (ret += Array(l + 1).join('</span>'));
  return ret;
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.');
  }
  var _finalColors = {};
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null;
    if (!hex) {
      _finalColors[key] = _defColors[key];
      continue;
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex];
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string';
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000');
      }
      var defHexColor = _defColors[key];
      if (!hex[0]) {
        hex[0] = defHexColor[0];
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]];
        hex.push(defHexColor[1]);
      }
      hex = hex.slice(0, 2);
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000');
    }
    _finalColors[key] = hex;
  }
  _setTags(_finalColors);
};

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors);
};

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {};
if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () {
      return _openTags;
    }
  });
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () {
      return _closeTags;
    }
  });
} else {
  ansiHTML.tags.open = _openTags;
  ansiHTML.tags.close = _closeTags;
}
function _setTags(colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1];
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0];
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey;
  for (var code in _styles) {
    var color = _styles[code];
    var oriColor = colors[color] || '000';
    _openTags[code] = 'color:#' + oriColor;
    code = parseInt(code);
    _openTags[(code + 10).toString()] = 'background:#' + oriColor;
  }
}
ansiHTML.reset();

/***/ }),

/***/ "./node_modules/bent/src/browser.js":
/*!******************************************!*\
  !*** ./node_modules/bent/src/browser.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* global fetch, btoa, Headers */
const core = __webpack_require__(/*! ./core */ "./node_modules/bent/src/core.js");
class StatusError extends Error {
  constructor(res, ...params) {
    super(...params);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, StatusError);
    }
    this.name = 'StatusError';
    this.message = res.statusMessage;
    this.statusCode = res.status;
    this.res = res;
    this.json = res.json.bind(res);
    this.text = res.text.bind(res);
    this.arrayBuffer = res.arrayBuffer.bind(res);
    let buffer;
    const get = () => {
      if (!buffer) buffer = this.arrayBuffer();
      return buffer;
    };
    Object.defineProperty(this, 'responseBody', {
      get
    });
    // match Node.js headers object
    this.headers = {};
    for (const [key, value] of res.headers.entries()) {
      this.headers[key.toLowerCase()] = value;
    }
  }
}
const mkrequest = (statusCodes, method, encoding, headers, baseurl) => async (_url, body, _headers = {}) => {
  _url = baseurl + (_url || '');
  let parsed = new URL(_url);
  if (!headers) headers = {};
  if (parsed.username) {
    headers.Authorization = 'Basic ' + btoa(parsed.username + ':' + parsed.password);
    parsed = new URL(parsed.protocol + '//' + parsed.host + parsed.pathname + parsed.search);
  }
  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') {
    throw new Error(`Unknown protocol, ${parsed.protocol}`);
  }
  if (body) {
    if (body instanceof ArrayBuffer || ArrayBuffer.isView(body) || typeof body === 'string') {
      // noop
    } else if (typeof body === 'object') {
      body = JSON.stringify(body);
      headers['Content-Type'] = 'application/json';
    } else {
      throw new Error('Unknown body type.');
    }
  }
  _headers = new Headers({
    ...(headers || {}),
    ..._headers
  });
  const resp = await fetch(parsed, {
    method,
    headers: _headers,
    body
  });
  resp.statusCode = resp.status;
  if (!statusCodes.has(resp.status)) {
    throw new StatusError(resp);
  }
  if (encoding === 'json') return resp.json();else if (encoding === 'buffer') return resp.arrayBuffer();else if (encoding === 'string') return resp.text();else return resp;
};
module.exports = core(mkrequest);

/***/ }),

/***/ "./node_modules/bent/src/core.js":
/*!***************************************!*\
  !*** ./node_modules/bent/src/core.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


const encodings = new Set(['json', 'buffer', 'string']);
module.exports = mkrequest => (...args) => {
  const statusCodes = new Set();
  let method;
  let encoding;
  let headers;
  let baseurl = '';
  args.forEach(arg => {
    if (typeof arg === 'string') {
      if (arg.toUpperCase() === arg) {
        if (method) {
          const msg = `Can't set method to ${arg}, already set to ${method}.`;
          throw new Error(msg);
        } else {
          method = arg;
        }
      } else if (arg.startsWith('http:') || arg.startsWith('https:')) {
        baseurl = arg;
      } else {
        if (encodings.has(arg)) {
          encoding = arg;
        } else {
          throw new Error(`Unknown encoding, ${arg}`);
        }
      }
    } else if (typeof arg === 'number') {
      statusCodes.add(arg);
    } else if (typeof arg === 'object') {
      if (Array.isArray(arg) || arg instanceof Set) {
        arg.forEach(code => statusCodes.add(code));
      } else {
        if (headers) {
          throw new Error('Cannot set headers twice.');
        }
        headers = arg;
      }
    } else {
      throw new Error(`Unknown type: ${typeof arg}`);
    }
  });
  if (!method) method = 'GET';
  if (statusCodes.size === 0) {
    statusCodes.add(200);
  }
  return mkrequest(statusCodes, method, encoding, headers, baseurl);
};

/***/ }),

/***/ "./node_modules/core-js-pure/actual/global-this.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/actual/global-this.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var parent = __webpack_require__(/*! ../stable/global-this */ "./node_modules/core-js-pure/stable/global-this.js");
module.exports = parent;

/***/ }),

/***/ "./node_modules/core-js-pure/es/global-this.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/es/global-this.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


__webpack_require__(/*! ../modules/es.global-this */ "./node_modules/core-js-pure/modules/es.global-this.js");
module.exports = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");

/***/ }),

/***/ "./node_modules/core-js-pure/features/global-this.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/features/global-this.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! ../full/global-this */ "./node_modules/core-js-pure/full/global-this.js");

/***/ }),

/***/ "./node_modules/core-js-pure/full/global-this.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/full/global-this.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// TODO: remove from `core-js@4`
__webpack_require__(/*! ../modules/esnext.global-this */ "./node_modules/core-js-pure/modules/esnext.global-this.js");
var parent = __webpack_require__(/*! ../actual/global-this */ "./node_modules/core-js-pure/actual/global-this.js");
module.exports = parent;

/***/ }),

/***/ "./node_modules/core-js-pure/internals/a-callable.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/a-callable.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var tryToString = __webpack_require__(/*! ../internals/try-to-string */ "./node_modules/core-js-pure/internals/try-to-string.js");
var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw new $TypeError(tryToString(argument) + ' is not a function');
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/an-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/an-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw new $TypeError($String(argument) + ' is not an object');
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/classof-raw.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/classof-raw.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);
module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-non-enumerable-property.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js-pure/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/create-property-descriptor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/create-property-descriptor.js ***!
  \***************************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/define-global-property.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/define-global-property.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;
module.exports = function (key, value) {
  try {
    defineProperty(globalThis, key, {
      value: value,
      configurable: true,
      writable: true
    });
  } catch (error) {
    globalThis[key] = value;
  }
  return value;
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/descriptors.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/descriptors.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, {
    get: function () {
      return 7;
    }
  })[1] !== 7;
});

/***/ }),

/***/ "./node_modules/core-js-pure/internals/document-create-element.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/document-create-element.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var document = globalThis.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/environment-user-agent.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/environment-user-agent.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var navigator = globalThis.navigator;
var userAgent = navigator && navigator.userAgent;
module.exports = userAgent ? String(userAgent) : '';

/***/ }),

/***/ "./node_modules/core-js-pure/internals/environment-v8-version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/environment-v8-version.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var userAgent = __webpack_require__(/*! ../internals/environment-user-agent */ "./node_modules/core-js-pure/internals/environment-user-agent.js");
var process = globalThis.process;
var Deno = globalThis.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}
module.exports = version;

/***/ }),

/***/ "./node_modules/core-js-pure/internals/export.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/export.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var apply = __webpack_require__(/*! ../internals/function-apply */ "./node_modules/core-js-pure/internals/function-apply.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var getOwnPropertyDescriptor = (__webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js").f);
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js-pure/internals/is-forced.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var bind = __webpack_require__(/*! ../internals/function-bind-context */ "./node_modules/core-js-pure/internals/function-bind-context.js");
var createNonEnumerableProperty = __webpack_require__(/*! ../internals/create-non-enumerable-property */ "./node_modules/core-js-pure/internals/create-non-enumerable-property.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
// add debugging info
__webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");
var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0:
          return new NativeConstructor();
        case 1:
          return new NativeConstructor(a);
        case 2:
          return new NativeConstructor(a, b);
      }
      return new NativeConstructor(a, b, c);
    }
    return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;
  var nativeSource = GLOBAL ? globalThis : STATIC ? globalThis[TARGET] : globalThis[TARGET] && globalThis[TARGET].prototype;
  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;
  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
    targetProperty = target[key];
    if (USE_NATIVE) if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source[key];
    if (!FORCED && !PROTO && typeof targetProperty == typeof sourceProperty) continue;

    // bind methods to global for calling from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, globalThis);
    // wrap global constructors for prevent changes in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }
    createNonEnumerableProperty(target, key, resultProperty);
    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/fails.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/fails.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-apply.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-apply.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");
var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-function-prototype-bind, es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});

/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-bind-context.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-bind-context.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this-clause */ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js");
var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");
var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");
var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function /* ...args */
  () {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-bind-native.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-bind-native.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = function () {/* empty */}.bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});

/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-call.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-call.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");
var call = Function.prototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this-clause.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this-clause.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/function-uncurry-this.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/function-uncurry-this.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var NATIVE_BIND = __webpack_require__(/*! ../internals/function-bind-native */ "./node_modules/core-js-pure/internals/function-bind-native.js");
var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
// eslint-disable-next-line es/no-function-prototype-bind -- safe
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-built-in.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-built-in.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js-pure/internals/path.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};
module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(globalThis[namespace]) : path[namespace] && path[namespace][method] || globalThis[namespace] && globalThis[namespace][method];
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/get-method.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/get-method.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var aCallable = __webpack_require__(/*! ../internals/a-callable */ "./node_modules/core-js-pure/internals/a-callable.js");
var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/global-this.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/global-this.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var check = function (it) {
  return it && it.Math === Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
// eslint-disable-next-line es/no-global-this -- safe
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) ||
// eslint-disable-next-line no-restricted-globals -- safe
check(typeof self == 'object' && self) || check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) || check(typeof this == 'object' && this) ||
// eslint-disable-next-line no-new-func -- fallback
function () {
  return this;
}() || Function('return this')();

/***/ }),

/***/ "./node_modules/core-js-pure/internals/has-own-property.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/has-own-property.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js-pure/internals/to-object.js");
var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/ie8-dom-define.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/ie8-dom-define.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js-pure/internals/document-create-element.js");

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () {
      return 7;
    }
  }).a !== 7;
});

/***/ }),

/***/ "./node_modules/core-js-pure/internals/indexed-object.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/indexed-object.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js-pure/internals/classof-raw.js");
var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) === 'String' ? split(it, '') : $Object(it);
} : $Object;

/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-callable.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-callable.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
var documentAll = typeof document == 'object' && document.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
module.exports = typeof documentAll == 'undefined' && documentAll !== undefined ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-forced.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-forced.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var replacement = /#|\.prototype\./;
var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
};
var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};
var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-null-or-undefined.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-null-or-undefined.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
module.exports = function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-pure.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-pure.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


module.exports = true;

/***/ }),

/***/ "./node_modules/core-js-pure/internals/is-symbol.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/is-symbol.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js-pure/internals/get-built-in.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isPrototypeOf = __webpack_require__(/*! ../internals/object-is-prototype-of */ "./node_modules/core-js-pure/internals/object-is-prototype-of.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js");
var $Object = Object;
module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-define-property.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-define-property.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js-pure/internals/ie8-dom-define.js");
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(/*! ../internals/v8-prototype-define-bug */ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js-pure/internals/an-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");
var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) {/* empty */}
  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-get-own-property-descriptor.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js-pure/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js-pure/internals/to-indexed-object.js");
var toPropertyKey = __webpack_require__(/*! ../internals/to-property-key */ "./node_modules/core-js-pure/internals/to-property-key.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js-pure/internals/ie8-dom-define.js");

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) {/* empty */}
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-is-prototype-of.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-is-prototype-of.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
module.exports = uncurryThis({}.isPrototypeOf);

/***/ }),

/***/ "./node_modules/core-js-pure/internals/object-property-is-enumerable.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/object-property-is-enumerable.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({
  1: 2
}, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;

/***/ }),

/***/ "./node_modules/core-js-pure/internals/ordinary-to-primitive.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/ordinary-to-primitive.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var isCallable = __webpack_require__(/*! ../internals/is-callable */ "./node_modules/core-js-pure/internals/is-callable.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw new $TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/path.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/path.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


module.exports = {};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/require-object-coercible.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/require-object-coercible.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isNullOrUndefined = __webpack_require__(/*! ../internals/is-null-or-undefined */ "./node_modules/core-js-pure/internals/is-null-or-undefined.js");
var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
  return it;
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared-store.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared-store.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js-pure/internals/is-pure.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var defineGlobalProperty = __webpack_require__(/*! ../internals/define-global-property */ "./node_modules/core-js-pure/internals/define-global-property.js");
var SHARED = '__core-js_shared__';
var store = module.exports = globalThis[SHARED] || defineGlobalProperty(SHARED, {});
(store.versions || (store.versions = [])).push({
  version: '3.41.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2014-2025 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.41.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});

/***/ }),

/***/ "./node_modules/core-js-pure/internals/shared.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js-pure/internals/shared.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var store = __webpack_require__(/*! ../internals/shared-store */ "./node_modules/core-js-pure/internals/shared-store.js");
module.exports = function (key, value) {
  return store[key] || (store[key] = value || {});
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/symbol-constructor-detection.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(/*! ../internals/environment-v8-version */ "./node_modules/core-js-pure/internals/environment-v8-version.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var $String = globalThis.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol('symbol detection');
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});

/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-indexed-object.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-indexed-object.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js-pure/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");
module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-object.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js-pure/internals/require-object-coercible.js");
var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-primitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-primitive.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = __webpack_require__(/*! ../internals/function-call */ "./node_modules/core-js-pure/internals/function-call.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js-pure/internals/is-object.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");
var getMethod = __webpack_require__(/*! ../internals/get-method */ "./node_modules/core-js-pure/internals/get-method.js");
var ordinaryToPrimitive = __webpack_require__(/*! ../internals/ordinary-to-primitive */ "./node_modules/core-js-pure/internals/ordinary-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js-pure/internals/well-known-symbol.js");
var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw new $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/to-property-key.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/to-property-key.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js-pure/internals/to-primitive.js");
var isSymbol = __webpack_require__(/*! ../internals/is-symbol */ "./node_modules/core-js-pure/internals/is-symbol.js");

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/try-to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/try-to-string.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


var $String = String;
module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/uid.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js-pure/internals/uid.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var uncurryThis = __webpack_require__(/*! ../internals/function-uncurry-this */ "./node_modules/core-js-pure/internals/function-uncurry-this.js");
var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);
module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};

/***/ }),

/***/ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/use-symbol-as-uid.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';

/***/ }),

/***/ "./node_modules/core-js-pure/internals/v8-prototype-define-bug.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/v8-prototype-define-bug.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js-pure/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js-pure/internals/fails.js");

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () {/* empty */}, 'prototype', {
    value: 42,
    writable: false
  }).prototype !== 42;
});

/***/ }),

/***/ "./node_modules/core-js-pure/internals/well-known-symbol.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js-pure/internals/well-known-symbol.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js-pure/internals/shared.js");
var hasOwn = __webpack_require__(/*! ../internals/has-own-property */ "./node_modules/core-js-pure/internals/has-own-property.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js-pure/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/symbol-constructor-detection */ "./node_modules/core-js-pure/internals/symbol-constructor-detection.js");
var USE_SYMBOL_AS_UID = __webpack_require__(/*! ../internals/use-symbol-as-uid */ "./node_modules/core-js-pure/internals/use-symbol-as-uid.js");
var Symbol = globalThis.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;
module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name) ? Symbol[name] : createWellKnownSymbol('Symbol.' + name);
  }
  return WellKnownSymbolsStore[name];
};

/***/ }),

/***/ "./node_modules/core-js-pure/modules/es.global-this.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/es.global-this.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js-pure/internals/export.js");
var globalThis = __webpack_require__(/*! ../internals/global-this */ "./node_modules/core-js-pure/internals/global-this.js");

// `globalThis` object
// https://tc39.es/ecma262/#sec-globalthis
$({
  global: true,
  forced: globalThis.globalThis !== globalThis
}, {
  globalThis: globalThis
});

/***/ }),

/***/ "./node_modules/core-js-pure/modules/esnext.global-this.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js-pure/modules/esnext.global-this.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// TODO: Remove from `core-js@4`
__webpack_require__(/*! ../modules/es.global-this */ "./node_modules/core-js-pure/modules/es.global-this.js");

/***/ }),

/***/ "./node_modules/core-js-pure/stable/global-this.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js-pure/stable/global-this.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var parent = __webpack_require__(/*! ../es/global-this */ "./node_modules/core-js-pure/es/global-this.js");
module.exports = parent;

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/ChatPage.css":
/*!********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/ChatPage.css ***!
  \********************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap);"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.chat-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  font-family: 'Inter', sans-serif;
  background-color: #040121;
  color: #E6EDF3;
}

.chat-header {
  display: flex;
  align-items: center;
  color: white;
  padding: 16px;
}

.chat-header-left,
.chat-header-right {
  display: flex;
  align-items: center;
  width: 200px;
}

.chat-header-left {
  justify-content: flex-start;
}

.chat-header-right {
  justify-content: flex-end;
}

.chat-header-center {
  flex: 1 1;
  display: flex;
  justify-content: center;
}

.chat-title {
  font-size: 24px;
  margin: 0;
}

.info-button {
  background-color: rgba(115, 114, 133, 0.392);
  color: #ffffff;
  border: 1px solid #ffffff17;
  border-radius: 50%;
  width: 35px;
  height: 35px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.info-button:hover {
  background-color: rgba(115, 114, 133, 0.6);
  color: white;
}

.messages-container {
  flex: 1 1;
  padding: 16px;
  overflow-y: auto;
  background-color: #040121;
  max-width: 800px;
  margin: 0 auto;
  width: 100%;
}

.message {
  max-width: 80%;
  margin-bottom: 16px;
  padding: 10px;
  border-radius: 10px;
  clear: both;
  display: inline-block;
  width: fit-content;
  word-break: break-word;
}

.user-message {
  background-color: rgba(115, 114, 133, 0.392);
  color: #C9D1D9;
  margin-left: auto;
  float: right;
  margin-top: 8px;
}

.bot-message {
  background-color: transparent;
  color: #C9D1D9;
  margin-right: auto;
  float: left;
  margin-top: 8px;
  animation: slideIn 0.3s ease-out forwards;
}

.message-content {
  display: inline-block;
  width: fit-content;
  max-width: 100%;
}

.message-content p {
  margin: 0;
  white-space: pre-wrap;
  word-wrap: break-word;
  overflow-wrap: break-word;
}

.input-container {
  padding: 12px 20px;
  background-color: rgba(51, 49, 61, 0.334);
  display: flex;
  align-items: center;
  gap: 10px;
  border: 1px solid #ffffff17;
  max-width: 800px;
  width: 100%;
  margin: 0 auto 20px auto;
  border-radius: 14px;
  transition: all 0.3s ease;
}

.input-container.initial-position {
  position: fixed;
  top: 50%;
  left: 50%;
  height: 90px;
  transform: translate(-50%, -50%);
  margin: 0;
  max-width: 800px;
  width: 100%;
}

.input-container.moved {
  position: relative;
  top: auto;
  left: auto;
  transform: none;
  margin: 0 auto 50px auto;
}

.copilot-logo {
  width: 24px;
  height: 24px;
  margin-right: 8px;
  cursor: pointer;
  position: relative;
}

.copilot-tooltip {
  position: absolute;
  left: 40px;
  top: 50%;
  transform: translateY(-50%);
  background-color: rgba(115, 114, 133, 0.95);
  color: #E6EDF3;
  padding: 12px 16px;
  border-radius: 8px;
  font-size: 14px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  border: 1px solid #ffffff17;
  z-index: 1000;
  display: none;
}

.copilot-logo:hover .copilot-tooltip {
  display: block;
}

.copilot-tooltip ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.copilot-tooltip li {
  margin-bottom: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.copilot-tooltip li:last-child {
  margin-bottom: 0;
}

.message-input {
  flex: 1 1;
  padding: 10px 15px;
  background-color: #040121;
  border: 1px solid #1a0b4d00;
  border-radius: 6px;
  color: #C9D1D9;
  font-size: 14px;
  min-height: 40px;
}

.message-input::placeholder {
  color: #8B949E;
}

.send-button,
.voice-button,
.feedback-button {
  padding: 10px 15px;
  background-color: #040121;
  color: #C9D1D9;
  border: 1px solid #1a0b4d00;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  min-width: 45px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.send-button:hover,
.voice-button:hover,
.feedback-button:hover {
  background-color: #1A0B4D;
}

.voice-button {
  position: relative;
  overflow: visible;
}

.voice-button.listening {
  background-color: rgba(255, 0, 0, 0.2);
  color: #ff4444;
  border-color: #ff4444;
}

.voice-button.listening::before {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translate(-50%, 10px);
  width: 8px;
  height: 8px;
  background-color: #ff4444;
  border-radius: 50%;
  animation: blink 1s ease-in-out infinite;
}

.voice-button.listening::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translate(-50%, 10px);
  width: 100%;
  height: 100%;
  background: radial-gradient(circle, rgba(255, 68, 68, 0.2) 0%, transparent 70%);
  animation: pulse 1.5s ease-out infinite;
}

@keyframes pulse {
  0% {
    transform: translate(-50%, 10px) scale(0.8);
    opacity: 0.8;
  }
  100% {
    transform: translate(-50%, 10px) scale(2);
    opacity: 0;
  }
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

.popup-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 10;
}

.popup {
  position: fixed;
  top: 20%;
  left: 50%;
  transform: translateX(-50%);
  background: #040121;
  border: 1px solid #ffffff17;
  padding: 24px;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.2);
  z-index: 20;
  max-width: 400px;
  text-align: left;
  color: #ffffff;
}

.popup h3 {
  margin-top: 0;
  color: #ffffff;
  font-size: 20px;
  margin-bottom: 16px;
}

.popup ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.popup li {
  margin-bottom: 12px;
  color: #ffffff;
  line-height: 1.5;
}

.popup-close-button {
  margin-top: 20px;
  background-color: rgba(115, 114, 133, 0.6);
  color: white;
  padding: 8px 14px;
  border: 1px solid #ffffff17;
  border-radius: 6px;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.popup-close-button:hover {
  background-color: rgba(115, 114, 133, 0.8);
}

.scenario-title {
  font-size: 20px;
  font-weight: bold;
  color: #ffffff;
  margin-left: 16px;
}

.mute-button {
  background-color: rgba(115, 114, 133, 0.392);
  border: 1px solid #ffffff17;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  font-size: 18px;
  cursor: pointer;
  margin-right: 8px;
  transition: background-color 0.2s ease;
}

.mute-button:hover {
  background-color: rgba(115, 114, 133, 0.6);
}

.mute-button.muted {
  background-color: #ffd4d4;
  border-color: #ff6666;
}

.info-button-container {
  position: relative;
  display: inline-block;
}

.info-tooltip {
  position: absolute;
  right: 50px;
  top: 50%;
  transform: translateY(-50%);
  background-color: rgba(115, 114, 133, 0.95);
  color: #E6EDF3;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 14px;
  white-space: nowrap;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  border: 1px solid #ffffff17;
  opacity: 0;
  animation: fadeInOut 5s ease-in-out forwards;
  pointer-events: none;
}

.info-tooltip::after {
  content: '';
  position: absolute;
  right: -6px;
  top: 50%;
  transform: translateY(-50%);
  border-width: 6px 0 6px 6px;
  border-style: solid;
  border-color: transparent transparent transparent rgba(115, 114, 133, 0.95);
}

@keyframes fadeInOut {
  0% { opacity: 0; }
  10% { opacity: 1; }
  80% { opacity: 1; }
  100% { opacity: 0; }
}

.welcome-message {
  background-color: transparent;
  color: #E6EDF3;
  margin: 20px auto;
  font-size: 15px;
  line-height: 1.5;
  padding: 12px 16px;
  max-width: 80%;
  text-align: center;
  float: none;
  display: block;
  position: relative;
}

.welcome-info-button {
  background-color: rgba(115, 114, 133, 0.392);
  color: #ffffff;
  border: 1px solid #ffffff17;
  border-radius: 50%;
  width: 34px;
  height: 34px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  font-weight: bold;
  cursor: pointer;
  margin-left: 12px;
  vertical-align: middle;
  transition: all 0.2s ease;
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4),
              0 0 0 3px rgba(255, 255, 255, 0.15);
  animation: vibrate 1s ease-in-out infinite;
  position: relative;
  z-index: 1;
}

.welcome-info-button:hover {
  background-color: rgba(115, 114, 133, 0.6);
  transform: scale(1.1);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5),
              0 0 0 3px rgba(255, 255, 255, 0.25);
  animation: none;
}

@keyframes vibrate {
  0% { transform: rotate(0deg) translateY(0); }
  25% { transform: rotate(-3deg) translateY(-2px); }
  50% { transform: rotate(0deg) translateY(0); }
  75% { transform: rotate(3deg) translateY(-2px); }
  100% { transform: rotate(0deg) translateY(0); }
}

.typing-indicator {
  display: flex;
  align-items: center;
  gap: 4px;
  color: #C9D1D9;
  font-size: 14px;
  padding: 10px;
  border-radius: 10px;
  background-color: transparent;
  width: fit-content;
}

.typing-text {
  margin-right: 4px;
}

.typing-dots {
  display: inline-block;
  width: 24px;
  text-align: left;
}

.typing-dots::after {
  content: '.';
  animation: typingDots 1.5s infinite;
}

@keyframes typingDots {
  0% { content: '.'; }
  33% { content: '..'; }
  66% { content: '...'; }
  100% { content: '.'; }
}

@keyframes slideIn {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.conversation-ended-message {
  flex: 1 1;
  text-align: center;
  color: #C9D1D9;
  font-size: 14px;
  padding: 10px;
  background-color: rgba(115, 114, 133, 0.2);
  border-radius: 6px;
  margin: 0 10px;
}

.feedback-button {
  padding: 10px 15px;
  background-color: #040121;
  color: #C9D1D9;
  border: 1px solid #1a0b4d00;
  border-radius: 6px;
  cursor: pointer;
  font-size: 13px;
  min-width: 45px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s ease;
}

.feedback-button:hover {
  background-color: #1A0B4D;
}

.notification-container {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.notification-banner {
  background-color: rgba(115, 114, 133, 0.95);
  color: #E6EDF3;
  padding: 12px 20px;
  border-radius: 8px;
  border: 1px solid #ffffff17;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  display: flex;
  align-items: center;
  gap: 10px;
  min-width: 300px;
  max-width: 400px;
  animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-out 4.7s forwards;
}

.notification-banner.success {
  background-color: rgba(46, 160, 140, 0.95);
}

.notification-banner.info {
  background-color: rgba(23, 162, 184, 0.95);
}

.notification-banner.warning {
  background-color: rgba(255, 193, 7, 0.95);
}

.notification-icon {
  font-size: 1.2rem;
}

.notification-message {
  flex: 1 1;
  font-size: 0.9rem;
  line-height: 1.4;
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }
  to {
    opacity: 0;
  }
}

.message.bot-message[data-welcome="true"] {
  background-color: transparent;
  color: #E6EDF3;
  margin: 20px auto;
  font-size: 15px;
  line-height: 1.5;
  padding: 12px 16px;
  border-radius: 10px;
  border: 1px solid #ffffff17;
  max-width: 80%;
  text-align: center;
  float: none;
  display: block;
}`, "",{"version":3,"sources":["webpack://./src/components/ChatPage.css"],"names":[],"mappings":"AAEA;EACE,aAAa;EACb,sBAAsB;EACtB,aAAa;EACb,gCAAgC;EAChC,yBAAyB;EACzB,cAAc;AAChB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,YAAY;EACZ,aAAa;AACf;;AAEA;;EAEE,aAAa;EACb,mBAAmB;EACnB,YAAY;AACd;;AAEA;EACE,2BAA2B;AAC7B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,SAAO;EACP,aAAa;EACb,uBAAuB;AACzB;;AAEA;EACE,eAAe;EACf,SAAS;AACX;;AAEA;EACE,4CAA4C;EAC5C,cAAc;EACd,2BAA2B;EAC3B,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,eAAe;EACf,eAAe;EACf,sCAAsC;AACxC;;AAEA;EACE,0CAA0C;EAC1C,YAAY;AACd;;AAEA;EACE,SAAO;EACP,aAAa;EACb,gBAAgB;EAChB,yBAAyB;EACzB,gBAAgB;EAChB,cAAc;EACd,WAAW;AACb;;AAEA;EACE,cAAc;EACd,mBAAmB;EACnB,aAAa;EACb,mBAAmB;EACnB,WAAW;EACX,qBAAqB;EACrB,kBAAkB;EAClB,sBAAsB;AACxB;;AAEA;EACE,4CAA4C;EAC5C,cAAc;EACd,iBAAiB;EACjB,YAAY;EACZ,eAAe;AACjB;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,kBAAkB;EAClB,WAAW;EACX,eAAe;EACf,yCAAyC;AAC3C;;AAEA;EACE,qBAAqB;EACrB,kBAAkB;EAClB,eAAe;AACjB;;AAEA;EACE,SAAS;EACT,qBAAqB;EACrB,qBAAqB;EACrB,yBAAyB;AAC3B;;AAEA;EACE,kBAAkB;EAClB,yCAAyC;EACzC,aAAa;EACb,mBAAmB;EACnB,SAAS;EACT,2BAA2B;EAC3B,gBAAgB;EAChB,WAAW;EACX,wBAAwB;EACxB,mBAAmB;EACnB,yBAAyB;AAC3B;;AAEA;EACE,eAAe;EACf,QAAQ;EACR,SAAS;EACT,YAAY;EACZ,gCAAgC;EAChC,SAAS;EACT,gBAAgB;EAChB,WAAW;AACb;;AAEA;EACE,kBAAkB;EAClB,SAAS;EACT,UAAU;EACV,eAAe;EACf,wBAAwB;AAC1B;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,iBAAiB;EACjB,eAAe;EACf,kBAAkB;AACpB;;AAEA;EACE,kBAAkB;EAClB,UAAU;EACV,QAAQ;EACR,2BAA2B;EAC3B,2CAA2C;EAC3C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,eAAe;EACf,mBAAmB;EACnB,wCAAwC;EACxC,2BAA2B;EAC3B,aAAa;EACb,aAAa;AACf;;AAEA;EACE,cAAc;AAChB;;AAEA;EACE,gBAAgB;EAChB,UAAU;EACV,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,aAAa;EACb,mBAAmB;EACnB,QAAQ;AACV;;AAEA;EACE,gBAAgB;AAClB;;AAEA;EACE,SAAO;EACP,kBAAkB;EAClB,yBAAyB;EACzB,2BAA2B;EAC3B,kBAAkB;EAClB,cAAc;EACd,eAAe;EACf,gBAAgB;AAClB;;AAEA;EACE,cAAc;AAChB;;AAEA;;;EAGE,kBAAkB;EAClB,yBAAyB;EACzB,cAAc;EACd,2BAA2B;EAC3B,kBAAkB;EAClB,eAAe;EACf,eAAe;EACf,eAAe;EACf,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;AACzB;;AAEA;;;EAGE,yBAAyB;AAC3B;;AAEA;EACE,kBAAkB;EAClB,iBAAiB;AACnB;;AAEA;EACE,sCAAsC;EACtC,cAAc;EACd,qBAAqB;AACvB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,SAAS;EACT,gCAAgC;EAChC,UAAU;EACV,WAAW;EACX,yBAAyB;EACzB,kBAAkB;EAClB,wCAAwC;AAC1C;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,SAAS;EACT,SAAS;EACT,gCAAgC;EAChC,WAAW;EACX,YAAY;EACZ,+EAA+E;EAC/E,uCAAuC;AACzC;;AAEA;EACE;IACE,2CAA2C;IAC3C,YAAY;EACd;EACA;IACE,yCAAyC;IACzC,UAAU;EACZ;AACF;;AAEA;EACE,WAAW,UAAU,EAAE;EACvB,MAAM,YAAY,EAAE;AACtB;;AAEA;EACE,eAAe;EACf,MAAM;EACN,OAAO;EACP,WAAW;EACX,YAAY;EACZ,2BAA2B;EAC3B,WAAW;AACb;;AAEA;EACE,eAAe;EACf,QAAQ;EACR,SAAS;EACT,2BAA2B;EAC3B,mBAAmB;EACnB,2BAA2B;EAC3B,aAAa;EACb,kBAAkB;EAClB,sCAAsC;EACtC,WAAW;EACX,gBAAgB;EAChB,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,aAAa;EACb,cAAc;EACd,eAAe;EACf,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;EAChB,UAAU;EACV,SAAS;AACX;;AAEA;EACE,mBAAmB;EACnB,cAAc;EACd,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,0CAA0C;EAC1C,YAAY;EACZ,iBAAiB;EACjB,2BAA2B;EAC3B,kBAAkB;EAClB,eAAe;EACf,sCAAsC;AACxC;;AAEA;EACE,0CAA0C;AAC5C;;AAEA;EACE,eAAe;EACf,iBAAiB;EACjB,cAAc;EACd,iBAAiB;AACnB;;AAEA;EACE,4CAA4C;EAC5C,2BAA2B;EAC3B,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,eAAe;EACf,eAAe;EACf,iBAAiB;EACjB,sCAAsC;AACxC;;AAEA;EACE,0CAA0C;AAC5C;;AAEA;EACE,yBAAyB;EACzB,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,qBAAqB;AACvB;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,2BAA2B;EAC3B,2CAA2C;EAC3C,cAAc;EACd,iBAAiB;EACjB,kBAAkB;EAClB,eAAe;EACf,mBAAmB;EACnB,wCAAwC;EACxC,2BAA2B;EAC3B,UAAU;EACV,4CAA4C;EAC5C,oBAAoB;AACtB;;AAEA;EACE,WAAW;EACX,kBAAkB;EAClB,WAAW;EACX,QAAQ;EACR,2BAA2B;EAC3B,2BAA2B;EAC3B,mBAAmB;EACnB,2EAA2E;AAC7E;;AAEA;EACE,KAAK,UAAU,EAAE;EACjB,MAAM,UAAU,EAAE;EAClB,MAAM,UAAU,EAAE;EAClB,OAAO,UAAU,EAAE;AACrB;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,iBAAiB;EACjB,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB,cAAc;EACd,kBAAkB;EAClB,WAAW;EACX,cAAc;EACd,kBAAkB;AACpB;;AAEA;EACE,4CAA4C;EAC5C,cAAc;EACd,2BAA2B;EAC3B,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,oBAAoB;EACpB,mBAAmB;EACnB,uBAAuB;EACvB,eAAe;EACf,iBAAiB;EACjB,eAAe;EACf,iBAAiB;EACjB,sBAAsB;EACtB,yBAAyB;EACzB;iDAC+C;EAC/C,0CAA0C;EAC1C,kBAAkB;EAClB,UAAU;AACZ;;AAEA;EACE,0CAA0C;EAC1C,qBAAqB;EACrB;iDAC+C;EAC/C,eAAe;AACjB;;AAEA;EACE,KAAK,qCAAqC,EAAE;EAC5C,MAAM,yCAAyC,EAAE;EACjD,MAAM,qCAAqC,EAAE;EAC7C,MAAM,wCAAwC,EAAE;EAChD,OAAO,qCAAqC,EAAE;AAChD;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,QAAQ;EACR,cAAc;EACd,eAAe;EACf,aAAa;EACb,mBAAmB;EACnB,6BAA6B;EAC7B,kBAAkB;AACpB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,qBAAqB;EACrB,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,YAAY;EACZ,mCAAmC;AACrC;;AAEA;EACE,KAAK,YAAY,EAAE;EACnB,MAAM,aAAa,EAAE;EACrB,MAAM,cAAc,EAAE;EACtB,OAAO,YAAY,EAAE;AACvB;;AAEA;EACE;IACE,UAAU;IACV,4BAA4B;EAC9B;EACA;IACE,UAAU;IACV,wBAAwB;EAC1B;AACF;;AAEA;EACE,SAAO;EACP,kBAAkB;EAClB,cAAc;EACd,eAAe;EACf,aAAa;EACb,0CAA0C;EAC1C,kBAAkB;EAClB,cAAc;AAChB;;AAEA;EACE,kBAAkB;EAClB,yBAAyB;EACzB,cAAc;EACd,2BAA2B;EAC3B,kBAAkB;EAClB,eAAe;EACf,eAAe;EACf,eAAe;EACf,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,sCAAsC;AACxC;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,eAAe;EACf,SAAS;EACT,WAAW;EACX,aAAa;EACb,aAAa;EACb,sBAAsB;EACtB,SAAS;AACX;;AAEA;EACE,2CAA2C;EAC3C,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,2BAA2B;EAC3B,yCAAyC;EACzC,aAAa;EACb,mBAAmB;EACnB,SAAS;EACT,gBAAgB;EAChB,gBAAgB;EAChB,0EAA0E;AAC5E;;AAEA;EACE,0CAA0C;AAC5C;;AAEA;EACE,0CAA0C;AAC5C;;AAEA;EACE,yCAAyC;AAC3C;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,SAAO;EACP,iBAAiB;EACjB,gBAAgB;AAClB;;AAEA;EACE;IACE,2BAA2B;IAC3B,UAAU;EACZ;EACA;IACE,wBAAwB;IACxB,UAAU;EACZ;AACF;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE,6BAA6B;EAC7B,cAAc;EACd,iBAAiB;EACjB,eAAe;EACf,gBAAgB;EAChB,kBAAkB;EAClB,mBAAmB;EACnB,2BAA2B;EAC3B,cAAc;EACd,kBAAkB;EAClB,WAAW;EACX,cAAc;AAChB","sourcesContent":["@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');\n\n.chat-container {\n  display: flex;\n  flex-direction: column;\n  height: 100vh;\n  font-family: 'Inter', sans-serif;\n  background-color: #040121;\n  color: #E6EDF3;\n}\n\n.chat-header {\n  display: flex;\n  align-items: center;\n  color: white;\n  padding: 16px;\n}\n\n.chat-header-left,\n.chat-header-right {\n  display: flex;\n  align-items: center;\n  width: 200px;\n}\n\n.chat-header-left {\n  justify-content: flex-start;\n}\n\n.chat-header-right {\n  justify-content: flex-end;\n}\n\n.chat-header-center {\n  flex: 1;\n  display: flex;\n  justify-content: center;\n}\n\n.chat-title {\n  font-size: 24px;\n  margin: 0;\n}\n\n.info-button {\n  background-color: rgba(115, 114, 133, 0.392);\n  color: #ffffff;\n  border: 1px solid #ffffff17;\n  border-radius: 50%;\n  width: 35px;\n  height: 35px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 20px;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n}\n\n.info-button:hover {\n  background-color: rgba(115, 114, 133, 0.6);\n  color: white;\n}\n\n.messages-container {\n  flex: 1;\n  padding: 16px;\n  overflow-y: auto;\n  background-color: #040121;\n  max-width: 800px;\n  margin: 0 auto;\n  width: 100%;\n}\n\n.message {\n  max-width: 80%;\n  margin-bottom: 16px;\n  padding: 10px;\n  border-radius: 10px;\n  clear: both;\n  display: inline-block;\n  width: fit-content;\n  word-break: break-word;\n}\n\n.user-message {\n  background-color: rgba(115, 114, 133, 0.392);\n  color: #C9D1D9;\n  margin-left: auto;\n  float: right;\n  margin-top: 8px;\n}\n\n.bot-message {\n  background-color: transparent;\n  color: #C9D1D9;\n  margin-right: auto;\n  float: left;\n  margin-top: 8px;\n  animation: slideIn 0.3s ease-out forwards;\n}\n\n.message-content {\n  display: inline-block;\n  width: fit-content;\n  max-width: 100%;\n}\n\n.message-content p {\n  margin: 0;\n  white-space: pre-wrap;\n  word-wrap: break-word;\n  overflow-wrap: break-word;\n}\n\n.input-container {\n  padding: 12px 20px;\n  background-color: rgba(51, 49, 61, 0.334);\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  border: 1px solid #ffffff17;\n  max-width: 800px;\n  width: 100%;\n  margin: 0 auto 20px auto;\n  border-radius: 14px;\n  transition: all 0.3s ease;\n}\n\n.input-container.initial-position {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  height: 90px;\n  transform: translate(-50%, -50%);\n  margin: 0;\n  max-width: 800px;\n  width: 100%;\n}\n\n.input-container.moved {\n  position: relative;\n  top: auto;\n  left: auto;\n  transform: none;\n  margin: 0 auto 50px auto;\n}\n\n.copilot-logo {\n  width: 24px;\n  height: 24px;\n  margin-right: 8px;\n  cursor: pointer;\n  position: relative;\n}\n\n.copilot-tooltip {\n  position: absolute;\n  left: 40px;\n  top: 50%;\n  transform: translateY(-50%);\n  background-color: rgba(115, 114, 133, 0.95);\n  color: #E6EDF3;\n  padding: 12px 16px;\n  border-radius: 8px;\n  font-size: 14px;\n  white-space: nowrap;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n  border: 1px solid #ffffff17;\n  z-index: 1000;\n  display: none;\n}\n\n.copilot-logo:hover .copilot-tooltip {\n  display: block;\n}\n\n.copilot-tooltip ul {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.copilot-tooltip li {\n  margin-bottom: 8px;\n  display: flex;\n  align-items: center;\n  gap: 8px;\n}\n\n.copilot-tooltip li:last-child {\n  margin-bottom: 0;\n}\n\n.message-input {\n  flex: 1;\n  padding: 10px 15px;\n  background-color: #040121;\n  border: 1px solid #1a0b4d00;\n  border-radius: 6px;\n  color: #C9D1D9;\n  font-size: 14px;\n  min-height: 40px;\n}\n\n.message-input::placeholder {\n  color: #8B949E;\n}\n\n.send-button,\n.voice-button,\n.feedback-button {\n  padding: 10px 15px;\n  background-color: #040121;\n  color: #C9D1D9;\n  border: 1px solid #1a0b4d00;\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 13px;\n  min-width: 45px;\n  height: 40px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.send-button:hover,\n.voice-button:hover,\n.feedback-button:hover {\n  background-color: #1A0B4D;\n}\n\n.voice-button {\n  position: relative;\n  overflow: visible;\n}\n\n.voice-button.listening {\n  background-color: rgba(255, 0, 0, 0.2);\n  color: #ff4444;\n  border-color: #ff4444;\n}\n\n.voice-button.listening::before {\n  content: '';\n  position: absolute;\n  top: 100%;\n  left: 50%;\n  transform: translate(-50%, 10px);\n  width: 8px;\n  height: 8px;\n  background-color: #ff4444;\n  border-radius: 50%;\n  animation: blink 1s ease-in-out infinite;\n}\n\n.voice-button.listening::after {\n  content: '';\n  position: absolute;\n  top: 100%;\n  left: 50%;\n  transform: translate(-50%, 10px);\n  width: 100%;\n  height: 100%;\n  background: radial-gradient(circle, rgba(255, 68, 68, 0.2) 0%, transparent 70%);\n  animation: pulse 1.5s ease-out infinite;\n}\n\n@keyframes pulse {\n  0% {\n    transform: translate(-50%, 10px) scale(0.8);\n    opacity: 0.8;\n  }\n  100% {\n    transform: translate(-50%, 10px) scale(2);\n    opacity: 0;\n  }\n}\n\n@keyframes blink {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.3; }\n}\n\n.popup-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0,0,0,0.7);\n  z-index: 10;\n}\n\n.popup {\n  position: fixed;\n  top: 20%;\n  left: 50%;\n  transform: translateX(-50%);\n  background: #040121;\n  border: 1px solid #ffffff17;\n  padding: 24px;\n  border-radius: 8px;\n  box-shadow: 0 4px 20px rgba(0,0,0,0.2);\n  z-index: 20;\n  max-width: 400px;\n  text-align: left;\n  color: #ffffff;\n}\n\n.popup h3 {\n  margin-top: 0;\n  color: #ffffff;\n  font-size: 20px;\n  margin-bottom: 16px;\n}\n\n.popup ul {\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.popup li {\n  margin-bottom: 12px;\n  color: #ffffff;\n  line-height: 1.5;\n}\n\n.popup-close-button {\n  margin-top: 20px;\n  background-color: rgba(115, 114, 133, 0.6);\n  color: white;\n  padding: 8px 14px;\n  border: 1px solid #ffffff17;\n  border-radius: 6px;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n}\n\n.popup-close-button:hover {\n  background-color: rgba(115, 114, 133, 0.8);\n}\n\n.scenario-title {\n  font-size: 20px;\n  font-weight: bold;\n  color: #ffffff;\n  margin-left: 16px;\n}\n\n.mute-button {\n  background-color: rgba(115, 114, 133, 0.392);\n  border: 1px solid #ffffff17;\n  border-radius: 50%;\n  width: 36px;\n  height: 36px;\n  font-size: 18px;\n  cursor: pointer;\n  margin-right: 8px;\n  transition: background-color 0.2s ease;\n}\n\n.mute-button:hover {\n  background-color: rgba(115, 114, 133, 0.6);\n}\n\n.mute-button.muted {\n  background-color: #ffd4d4;\n  border-color: #ff6666;\n}\n\n.info-button-container {\n  position: relative;\n  display: inline-block;\n}\n\n.info-tooltip {\n  position: absolute;\n  right: 50px;\n  top: 50%;\n  transform: translateY(-50%);\n  background-color: rgba(115, 114, 133, 0.95);\n  color: #E6EDF3;\n  padding: 8px 12px;\n  border-radius: 8px;\n  font-size: 14px;\n  white-space: nowrap;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n  border: 1px solid #ffffff17;\n  opacity: 0;\n  animation: fadeInOut 5s ease-in-out forwards;\n  pointer-events: none;\n}\n\n.info-tooltip::after {\n  content: '';\n  position: absolute;\n  right: -6px;\n  top: 50%;\n  transform: translateY(-50%);\n  border-width: 6px 0 6px 6px;\n  border-style: solid;\n  border-color: transparent transparent transparent rgba(115, 114, 133, 0.95);\n}\n\n@keyframes fadeInOut {\n  0% { opacity: 0; }\n  10% { opacity: 1; }\n  80% { opacity: 1; }\n  100% { opacity: 0; }\n}\n\n.welcome-message {\n  background-color: transparent;\n  color: #E6EDF3;\n  margin: 20px auto;\n  font-size: 15px;\n  line-height: 1.5;\n  padding: 12px 16px;\n  max-width: 80%;\n  text-align: center;\n  float: none;\n  display: block;\n  position: relative;\n}\n\n.welcome-info-button {\n  background-color: rgba(115, 114, 133, 0.392);\n  color: #ffffff;\n  border: 1px solid #ffffff17;\n  border-radius: 50%;\n  width: 34px;\n  height: 34px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 18px;\n  font-weight: bold;\n  cursor: pointer;\n  margin-left: 12px;\n  vertical-align: middle;\n  transition: all 0.2s ease;\n  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.4),\n              0 0 0 3px rgba(255, 255, 255, 0.15);\n  animation: vibrate 1s ease-in-out infinite;\n  position: relative;\n  z-index: 1;\n}\n\n.welcome-info-button:hover {\n  background-color: rgba(115, 114, 133, 0.6);\n  transform: scale(1.1);\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5),\n              0 0 0 3px rgba(255, 255, 255, 0.25);\n  animation: none;\n}\n\n@keyframes vibrate {\n  0% { transform: rotate(0deg) translateY(0); }\n  25% { transform: rotate(-3deg) translateY(-2px); }\n  50% { transform: rotate(0deg) translateY(0); }\n  75% { transform: rotate(3deg) translateY(-2px); }\n  100% { transform: rotate(0deg) translateY(0); }\n}\n\n.typing-indicator {\n  display: flex;\n  align-items: center;\n  gap: 4px;\n  color: #C9D1D9;\n  font-size: 14px;\n  padding: 10px;\n  border-radius: 10px;\n  background-color: transparent;\n  width: fit-content;\n}\n\n.typing-text {\n  margin-right: 4px;\n}\n\n.typing-dots {\n  display: inline-block;\n  width: 24px;\n  text-align: left;\n}\n\n.typing-dots::after {\n  content: '.';\n  animation: typingDots 1.5s infinite;\n}\n\n@keyframes typingDots {\n  0% { content: '.'; }\n  33% { content: '..'; }\n  66% { content: '...'; }\n  100% { content: '.'; }\n}\n\n@keyframes slideIn {\n  from {\n    opacity: 0;\n    transform: translateX(-20px);\n  }\n  to {\n    opacity: 1;\n    transform: translateX(0);\n  }\n}\n\n.conversation-ended-message {\n  flex: 1;\n  text-align: center;\n  color: #C9D1D9;\n  font-size: 14px;\n  padding: 10px;\n  background-color: rgba(115, 114, 133, 0.2);\n  border-radius: 6px;\n  margin: 0 10px;\n}\n\n.feedback-button {\n  padding: 10px 15px;\n  background-color: #040121;\n  color: #C9D1D9;\n  border: 1px solid #1a0b4d00;\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 13px;\n  min-width: 45px;\n  height: 40px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transition: background-color 0.2s ease;\n}\n\n.feedback-button:hover {\n  background-color: #1A0B4D;\n}\n\n.notification-container {\n  position: fixed;\n  top: 20px;\n  right: 20px;\n  z-index: 1000;\n  display: flex;\n  flex-direction: column;\n  gap: 10px;\n}\n\n.notification-banner {\n  background-color: rgba(115, 114, 133, 0.95);\n  color: #E6EDF3;\n  padding: 12px 20px;\n  border-radius: 8px;\n  border: 1px solid #ffffff17;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  min-width: 300px;\n  max-width: 400px;\n  animation: slideInRight 0.3s ease-out, fadeOut 0.3s ease-out 4.7s forwards;\n}\n\n.notification-banner.success {\n  background-color: rgba(46, 160, 140, 0.95);\n}\n\n.notification-banner.info {\n  background-color: rgba(23, 162, 184, 0.95);\n}\n\n.notification-banner.warning {\n  background-color: rgba(255, 193, 7, 0.95);\n}\n\n.notification-icon {\n  font-size: 1.2rem;\n}\n\n.notification-message {\n  flex: 1;\n  font-size: 0.9rem;\n  line-height: 1.4;\n}\n\n@keyframes slideInRight {\n  from {\n    transform: translateX(100%);\n    opacity: 0;\n  }\n  to {\n    transform: translateX(0);\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.message.bot-message[data-welcome=\"true\"] {\n  background-color: transparent;\n  color: #E6EDF3;\n  margin: 20px auto;\n  font-size: 15px;\n  line-height: 1.5;\n  padding: 12px 16px;\n  border-radius: 10px;\n  border: 1px solid #ffffff17;\n  max-width: 80%;\n  text-align: center;\n  float: none;\n  display: block;\n}"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/FeedbackPage.css":
/*!************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/FeedbackPage.css ***!
  \************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `body {
  background-color: #040121;
  margin: 0;
  padding: 0;
}

.feedback-page {
  max-width: 900px;
  margin: 40px auto;
  text-align: left;
  padding: 2rem;
  background-color: rgba(115, 114, 133, 0.392);
  border-radius: 16px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
  font-family: 'Inter', sans-serif;
  color: #E6EDF3;
  border: 1px solid #ffffff17;
}

.feedback-header {
  text-align: center;
  margin-bottom: 2rem;
}

.feedback-header h1 {
  color: #E6EDF3;
  font-size: 2.2rem;
  margin-bottom: 0.5rem;
}

.feedback-intro {
  color: #C9D1D9;
  font-size: 1.1rem;
  max-width: 80%;
  margin: 0 auto;
}

/* Score Card Styles */
.feedback-score-card {
  background: rgba(115, 114, 133, 0.392);
  color: #E6EDF3;
  border-radius: 12px;
  padding: 1.5rem;
  margin-bottom: 2rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  border: 1px solid #ffffff17;
}

.score-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.score-header h2 {
  margin: 0;
  font-size: 1.6rem;
  font-weight: 500;
}

.score-emoji {
  font-size: 2.2rem;
}

.score-content {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.score-value {
  display: flex;
  align-items: baseline;
}

.score-number {
  font-size: 3.5rem;
  font-weight: bold;
  line-height: 1;
}

.score-max {
  font-size: 1.4rem;
  opacity: 0.8;
  margin-left: 4px;
}

.score-message {
  font-size: 1.2rem;
  max-width: 60%;
  margin: 0;
}

/* Metrics Cards */
.metrics-cards {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.metric-card {
  background-color: rgba(115, 114, 133, 0.392);
  border-radius: 10px;
  padding: 1rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  transition: transform 0.2s ease;
  border: 1px solid #ffffff17;
}

.metric-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.metric-name {
  font-weight: 600;
  color: #E6EDF3;
  margin-bottom: 0.75rem;
}

.metric-value-container {
  position: relative;
  height: 24px;
  background-color: #040121;
  border-radius: 12px;
  overflow: hidden;
}

.metric-bar {
  height: 100%;
  background: #281e70;
  border-radius: 12px;
  transition: width 0.8s cubic-bezier(0.16, 1, 0.3, 1);
}

.metric-number {
  color: #E6EDF3;
  font-size: 0.9rem;
}

/* Feedback Cards Styles */
.feedback-sections {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
  margin-bottom: 2rem;
}

.feedback-card {
  background-color: rgba(115, 114, 133, 0.5);
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s ease;
  border: 1px solid #ffffff17;
}

.feedback-card:hover {
  transform: translateY(-5px);
}

.card-header {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
}

.card-icon {
  font-size: 1.6rem;
  margin-right: 10px;
}

.feedback-card h3 {
  margin: 0;
  font-size: 1.25rem;
  color: #E6EDF3;
}

.feedback-list {
  list-style-type: none;
  padding: 0;
  margin: 0;
}

.feedback-list li {
  margin-bottom: 12px;
  padding-left: 20px;
  position: relative;
  font-size: 0.95rem;
  line-height: 1.4;
  color: #C9D1D9;
}

.feedback-list li:before {
  content: "•";
  color: #281e70;
  position: absolute;
  left: 0;
  font-weight: bold;
}

.feedback-list li a {
  color: #E6EDF3;
  text-decoration: none;
  transition: color 0.2s ease;
}

.feedback-list li a:hover {
  color: #ffffff;
  text-decoration: underline;
}

/* Card Color Variations */
.strength-card,
.suggestion-card,
.issue-card,
.training-card {
  border: 1px solid #ffffff17;
}

/* Action Buttons */
.feedback-actions {
  display: flex;
  justify-content: center;
  gap: 1.5rem;
  margin-top: 2rem;
}

.action-button {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 0.75rem 1.5rem;
  border-radius: 28px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  border: none;
  outline: none;
  min-width: 180px;
}

.button-icon {
  margin-right: 8px;
  font-size: 1.2rem;
}

.chat-button {
  background-color: rgba(115, 114, 133, 0.392);
  color: #E6EDF3;
  border: 1px solid #ffffff17;
}

.chat-button:hover {
  background-color: #281e70;
  transform: scale(1.03);
}

.home-button {
  background-color: rgba(115, 114, 133, 0.392);
  color: #E6EDF3;
  border: 1px solid #ffffff17;
}

.home-button:hover {
  background-color: #281e70;
  transform: scale(1.03);
}

/* Loading State */
.feedback-loading {
  text-align: center;
  padding: 60px 20px;
  background-color: #040121;
  color: #E6EDF3;
  border-radius: 16px;
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
  max-width: 600px;
  margin: 80px auto;
  border: 1px solid #ffffff17;
}

.feedback-loading p {
  margin-top: 16px;
  font-size: 1.2rem;
  color: #C9D1D9;
}

.spinner {
  border: 4px solid #040121;
  border-top: 4px solid #281e70;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 0 auto 24px;
}

.loading-facts {
  margin-top: 40px;
  padding: 20px;
  background-color: rgba(115, 114, 133, 0.392);
  border-radius: 10px;
  max-width: 400px;
  margin-left: auto;
  margin-right: auto;
  border: 1px solid #ffffff17;
}

.loading-facts h4 {
  color: #E6EDF3;
  margin-top: 0;
  margin-bottom: 10px;
}

.loading-facts p {
  font-size: 1rem;
  margin: 0;
  color: #C9D1D9;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Error State */
.feedback-error {
  text-align: center;
  padding: 40px;
  background-color: rgba(115, 114, 133, 0.392);
  color: #E6EDF3;
  border-radius: 8px;
  max-width: 600px;
  margin: 80px auto;
  font-size: 1.1rem;
  border: 1px solid #ffffff17;
}

/* Responsive Adjustments */
@media (max-width: 768px) {
  .feedback-page {
    padding: 1.5rem;
    margin: 20px auto;
  }
  
  .score-content {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .score-message {
    max-width: 100%;
    margin-top: 1rem;
  }
  
  .feedback-sections {
    grid-template-columns: 1fr;
  }
  
  .metrics-cards {
    grid-template-columns: 1fr;
  }
  
  .feedback-actions {
    flex-direction: column;
    gap: 1rem;
  }
  
  .action-button {
    width: 100%;
  }
}

.custom-score-indicator {
  color: #281e70;
  margin-left: 5px;
  font-size: 1.2rem;
  vertical-align: super;
}

.custom-score-note {
  display: block;
  margin-top: 8px;
  font-size: 0.85rem;
  color: #C9D1D9;
  font-style: italic;
}
`, "",{"version":3,"sources":["webpack://./src/components/FeedbackPage.css"],"names":[],"mappings":"AAAA;EACE,yBAAyB;EACzB,SAAS;EACT,UAAU;AACZ;;AAEA;EACE,gBAAgB;EAChB,iBAAiB;EACjB,gBAAgB;EAChB,aAAa;EACb,4CAA4C;EAC5C,mBAAmB;EACnB,yCAAyC;EACzC,gCAAgC;EAChC,cAAc;EACd,2BAA2B;AAC7B;;AAEA;EACE,kBAAkB;EAClB,mBAAmB;AACrB;;AAEA;EACE,cAAc;EACd,iBAAiB;EACjB,qBAAqB;AACvB;;AAEA;EACE,cAAc;EACd,iBAAiB;EACjB,cAAc;EACd,cAAc;AAChB;;AAEA,sBAAsB;AACtB;EACE,sCAAsC;EACtC,cAAc;EACd,mBAAmB;EACnB,eAAe;EACf,mBAAmB;EACnB,yCAAyC;EACzC,2BAA2B;AAC7B;;AAEA;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;EACnB,mBAAmB;AACrB;;AAEA;EACE,SAAS;EACT,iBAAiB;EACjB,gBAAgB;AAClB;;AAEA;EACE,iBAAiB;AACnB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,8BAA8B;AAChC;;AAEA;EACE,aAAa;EACb,qBAAqB;AACvB;;AAEA;EACE,iBAAiB;EACjB,iBAAiB;EACjB,cAAc;AAChB;;AAEA;EACE,iBAAiB;EACjB,YAAY;EACZ,gBAAgB;AAClB;;AAEA;EACE,iBAAiB;EACjB,cAAc;EACd,SAAS;AACX;;AAEA,kBAAkB;AAClB;EACE,aAAa;EACb,4DAA4D;EAC5D,SAAS;EACT,mBAAmB;AACrB;;AAEA;EACE,4CAA4C;EAC5C,mBAAmB;EACnB,aAAa;EACb,wCAAwC;EACxC,+BAA+B;EAC/B,2BAA2B;AAC7B;;AAEA;EACE,2BAA2B;EAC3B,yCAAyC;AAC3C;;AAEA;EACE,gBAAgB;EAChB,cAAc;EACd,sBAAsB;AACxB;;AAEA;EACE,kBAAkB;EAClB,YAAY;EACZ,yBAAyB;EACzB,mBAAmB;EACnB,gBAAgB;AAClB;;AAEA;EACE,YAAY;EACZ,mBAAmB;EACnB,mBAAmB;EACnB,oDAAoD;AACtD;;AAEA;EACE,cAAc;EACd,iBAAiB;AACnB;;AAEA,0BAA0B;AAC1B;EACE,aAAa;EACb,2DAA2D;EAC3D,WAAW;EACX,mBAAmB;AACrB;;AAEA;EACE,0CAA0C;EAC1C,mBAAmB;EACnB,eAAe;EACf,yCAAyC;EACzC,+BAA+B;EAC/B,2BAA2B;AAC7B;;AAEA;EACE,2BAA2B;AAC7B;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,mBAAmB;AACrB;;AAEA;EACE,iBAAiB;EACjB,kBAAkB;AACpB;;AAEA;EACE,SAAS;EACT,kBAAkB;EAClB,cAAc;AAChB;;AAEA;EACE,qBAAqB;EACrB,UAAU;EACV,SAAS;AACX;;AAEA;EACE,mBAAmB;EACnB,kBAAkB;EAClB,kBAAkB;EAClB,kBAAkB;EAClB,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,YAAY;EACZ,cAAc;EACd,kBAAkB;EAClB,OAAO;EACP,iBAAiB;AACnB;;AAEA;EACE,cAAc;EACd,qBAAqB;EACrB,2BAA2B;AAC7B;;AAEA;EACE,cAAc;EACd,0BAA0B;AAC5B;;AAEA,0BAA0B;AAC1B;;;;EAIE,2BAA2B;AAC7B;;AAEA,mBAAmB;AACnB;EACE,aAAa;EACb,uBAAuB;EACvB,WAAW;EACX,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,uBAAuB;EACvB,mBAAmB;EACnB,eAAe;EACf,gBAAgB;EAChB,eAAe;EACf,yBAAyB;EACzB,YAAY;EACZ,aAAa;EACb,gBAAgB;AAClB;;AAEA;EACE,iBAAiB;EACjB,iBAAiB;AACnB;;AAEA;EACE,4CAA4C;EAC5C,cAAc;EACd,2BAA2B;AAC7B;;AAEA;EACE,yBAAyB;EACzB,sBAAsB;AACxB;;AAEA;EACE,4CAA4C;EAC5C,cAAc;EACd,2BAA2B;AAC7B;;AAEA;EACE,yBAAyB;EACzB,sBAAsB;AACxB;;AAEA,kBAAkB;AAClB;EACE,kBAAkB;EAClB,kBAAkB;EAClB,yBAAyB;EACzB,cAAc;EACd,mBAAmB;EACnB,0CAA0C;EAC1C,gBAAgB;EAChB,iBAAiB;EACjB,2BAA2B;AAC7B;;AAEA;EACE,gBAAgB;EAChB,iBAAiB;EACjB,cAAc;AAChB;;AAEA;EACE,yBAAyB;EACzB,6BAA6B;EAC7B,kBAAkB;EAClB,WAAW;EACX,YAAY;EACZ,kCAAkC;EAClC,mBAAmB;AACrB;;AAEA;EACE,gBAAgB;EAChB,aAAa;EACb,4CAA4C;EAC5C,mBAAmB;EACnB,gBAAgB;EAChB,iBAAiB;EACjB,kBAAkB;EAClB,2BAA2B;AAC7B;;AAEA;EACE,cAAc;EACd,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,eAAe;EACf,SAAS;EACT,cAAc;AAChB;;AAEA;EACE,KAAK,uBAAuB,EAAE;EAC9B,OAAO,yBAAyB,EAAE;AACpC;;AAEA,gBAAgB;AAChB;EACE,kBAAkB;EAClB,aAAa;EACb,4CAA4C;EAC5C,cAAc;EACd,kBAAkB;EAClB,gBAAgB;EAChB,iBAAiB;EACjB,iBAAiB;EACjB,2BAA2B;AAC7B;;AAEA,2BAA2B;AAC3B;EACE;IACE,eAAe;IACf,iBAAiB;EACnB;;EAEA;IACE,sBAAsB;IACtB,uBAAuB;EACzB;;EAEA;IACE,eAAe;IACf,gBAAgB;EAClB;;EAEA;IACE,0BAA0B;EAC5B;;EAEA;IACE,0BAA0B;EAC5B;;EAEA;IACE,sBAAsB;IACtB,SAAS;EACX;;EAEA;IACE,WAAW;EACb;AACF;;AAEA;EACE,cAAc;EACd,gBAAgB;EAChB,iBAAiB;EACjB,qBAAqB;AACvB;;AAEA;EACE,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,cAAc;EACd,kBAAkB;AACpB","sourcesContent":["body {\n  background-color: #040121;\n  margin: 0;\n  padding: 0;\n}\n\n.feedback-page {\n  max-width: 900px;\n  margin: 40px auto;\n  text-align: left;\n  padding: 2rem;\n  background-color: rgba(115, 114, 133, 0.392);\n  border-radius: 16px;\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);\n  font-family: 'Inter', sans-serif;\n  color: #E6EDF3;\n  border: 1px solid #ffffff17;\n}\n\n.feedback-header {\n  text-align: center;\n  margin-bottom: 2rem;\n}\n\n.feedback-header h1 {\n  color: #E6EDF3;\n  font-size: 2.2rem;\n  margin-bottom: 0.5rem;\n}\n\n.feedback-intro {\n  color: #C9D1D9;\n  font-size: 1.1rem;\n  max-width: 80%;\n  margin: 0 auto;\n}\n\n/* Score Card Styles */\n.feedback-score-card {\n  background: rgba(115, 114, 133, 0.392);\n  color: #E6EDF3;\n  border-radius: 12px;\n  padding: 1.5rem;\n  margin-bottom: 2rem;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);\n  border: 1px solid #ffffff17;\n}\n\n.score-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 1rem;\n}\n\n.score-header h2 {\n  margin: 0;\n  font-size: 1.6rem;\n  font-weight: 500;\n}\n\n.score-emoji {\n  font-size: 2.2rem;\n}\n\n.score-content {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n\n.score-value {\n  display: flex;\n  align-items: baseline;\n}\n\n.score-number {\n  font-size: 3.5rem;\n  font-weight: bold;\n  line-height: 1;\n}\n\n.score-max {\n  font-size: 1.4rem;\n  opacity: 0.8;\n  margin-left: 4px;\n}\n\n.score-message {\n  font-size: 1.2rem;\n  max-width: 60%;\n  margin: 0;\n}\n\n/* Metrics Cards */\n.metrics-cards {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));\n  gap: 1rem;\n  margin-bottom: 2rem;\n}\n\n.metric-card {\n  background-color: rgba(115, 114, 133, 0.392);\n  border-radius: 10px;\n  padding: 1rem;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n  transition: transform 0.2s ease;\n  border: 1px solid #ffffff17;\n}\n\n.metric-card:hover {\n  transform: translateY(-3px);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n}\n\n.metric-name {\n  font-weight: 600;\n  color: #E6EDF3;\n  margin-bottom: 0.75rem;\n}\n\n.metric-value-container {\n  position: relative;\n  height: 24px;\n  background-color: #040121;\n  border-radius: 12px;\n  overflow: hidden;\n}\n\n.metric-bar {\n  height: 100%;\n  background: #281e70;\n  border-radius: 12px;\n  transition: width 0.8s cubic-bezier(0.16, 1, 0.3, 1);\n}\n\n.metric-number {\n  color: #E6EDF3;\n  font-size: 0.9rem;\n}\n\n/* Feedback Cards Styles */\n.feedback-sections {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  gap: 1.5rem;\n  margin-bottom: 2rem;\n}\n\n.feedback-card {\n  background-color: rgba(115, 114, 133, 0.5);\n  border-radius: 12px;\n  padding: 1.5rem;\n  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);\n  transition: transform 0.3s ease;\n  border: 1px solid #ffffff17;\n}\n\n.feedback-card:hover {\n  transform: translateY(-5px);\n}\n\n.card-header {\n  display: flex;\n  align-items: center;\n  margin-bottom: 1rem;\n}\n\n.card-icon {\n  font-size: 1.6rem;\n  margin-right: 10px;\n}\n\n.feedback-card h3 {\n  margin: 0;\n  font-size: 1.25rem;\n  color: #E6EDF3;\n}\n\n.feedback-list {\n  list-style-type: none;\n  padding: 0;\n  margin: 0;\n}\n\n.feedback-list li {\n  margin-bottom: 12px;\n  padding-left: 20px;\n  position: relative;\n  font-size: 0.95rem;\n  line-height: 1.4;\n  color: #C9D1D9;\n}\n\n.feedback-list li:before {\n  content: \"•\";\n  color: #281e70;\n  position: absolute;\n  left: 0;\n  font-weight: bold;\n}\n\n.feedback-list li a {\n  color: #E6EDF3;\n  text-decoration: none;\n  transition: color 0.2s ease;\n}\n\n.feedback-list li a:hover {\n  color: #ffffff;\n  text-decoration: underline;\n}\n\n/* Card Color Variations */\n.strength-card,\n.suggestion-card,\n.issue-card,\n.training-card {\n  border: 1px solid #ffffff17;\n}\n\n/* Action Buttons */\n.feedback-actions {\n  display: flex;\n  justify-content: center;\n  gap: 1.5rem;\n  margin-top: 2rem;\n}\n\n.action-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0.75rem 1.5rem;\n  border-radius: 28px;\n  font-size: 1rem;\n  font-weight: 600;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  border: none;\n  outline: none;\n  min-width: 180px;\n}\n\n.button-icon {\n  margin-right: 8px;\n  font-size: 1.2rem;\n}\n\n.chat-button {\n  background-color: rgba(115, 114, 133, 0.392);\n  color: #E6EDF3;\n  border: 1px solid #ffffff17;\n}\n\n.chat-button:hover {\n  background-color: #281e70;\n  transform: scale(1.03);\n}\n\n.home-button {\n  background-color: rgba(115, 114, 133, 0.392);\n  color: #E6EDF3;\n  border: 1px solid #ffffff17;\n}\n\n.home-button:hover {\n  background-color: #281e70;\n  transform: scale(1.03);\n}\n\n/* Loading State */\n.feedback-loading {\n  text-align: center;\n  padding: 60px 20px;\n  background-color: #040121;\n  color: #E6EDF3;\n  border-radius: 16px;\n  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);\n  max-width: 600px;\n  margin: 80px auto;\n  border: 1px solid #ffffff17;\n}\n\n.feedback-loading p {\n  margin-top: 16px;\n  font-size: 1.2rem;\n  color: #C9D1D9;\n}\n\n.spinner {\n  border: 4px solid #040121;\n  border-top: 4px solid #281e70;\n  border-radius: 50%;\n  width: 40px;\n  height: 40px;\n  animation: spin 1s linear infinite;\n  margin: 0 auto 24px;\n}\n\n.loading-facts {\n  margin-top: 40px;\n  padding: 20px;\n  background-color: rgba(115, 114, 133, 0.392);\n  border-radius: 10px;\n  max-width: 400px;\n  margin-left: auto;\n  margin-right: auto;\n  border: 1px solid #ffffff17;\n}\n\n.loading-facts h4 {\n  color: #E6EDF3;\n  margin-top: 0;\n  margin-bottom: 10px;\n}\n\n.loading-facts p {\n  font-size: 1rem;\n  margin: 0;\n  color: #C9D1D9;\n}\n\n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n\n/* Error State */\n.feedback-error {\n  text-align: center;\n  padding: 40px;\n  background-color: rgba(115, 114, 133, 0.392);\n  color: #E6EDF3;\n  border-radius: 8px;\n  max-width: 600px;\n  margin: 80px auto;\n  font-size: 1.1rem;\n  border: 1px solid #ffffff17;\n}\n\n/* Responsive Adjustments */\n@media (max-width: 768px) {\n  .feedback-page {\n    padding: 1.5rem;\n    margin: 20px auto;\n  }\n  \n  .score-content {\n    flex-direction: column;\n    align-items: flex-start;\n  }\n  \n  .score-message {\n    max-width: 100%;\n    margin-top: 1rem;\n  }\n  \n  .feedback-sections {\n    grid-template-columns: 1fr;\n  }\n  \n  .metrics-cards {\n    grid-template-columns: 1fr;\n  }\n  \n  .feedback-actions {\n    flex-direction: column;\n    gap: 1rem;\n  }\n  \n  .action-button {\n    width: 100%;\n  }\n}\n\n.custom-score-indicator {\n  color: #281e70;\n  margin-left: 5px;\n  font-size: 1.2rem;\n  vertical-align: super;\n}\n\n.custom-score-note {\n  display: block;\n  margin-top: 8px;\n  font-size: 0.85rem;\n  color: #C9D1D9;\n  font-style: italic;\n}\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/HomePage.css":
/*!********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/HomePage.css ***!
  \********************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.push([module.id, "@import url(https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap);"]);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.home-container {
  background-color: rgba(115, 114, 133, 0.392);
  padding: 3rem 2rem;
  border-radius: 16px;
  max-width: 1200px;
  width: 100%;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
  text-align: center;
  font-family: 'Inter', sans-serif;
  color: #E6EDF3;
  border: 1px solid #ffffff17;
  margin: 2rem 0;
}
  
.home-title {
  font-size: 28px;
  margin-bottom: 30px;
  color: #E6EDF3;
}
  
.home-title-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  margin-bottom: 2rem;
}
  
.home-logo-inline {
  width: 40px;
  height: auto;
  object-fit: contain;
}
  
.scenario-card {
  background-color: rgba(115, 114, 133, 0.392);
  padding: 2rem;
  border-radius: 10px;
  height: 80%;
  display: flex;
  flex-direction: column;
  box-shadow: 0 8px 6px rgba(0,0,0,0.1);
  text-align: left;
  border: 1px solid #ffffff17;
  color: #E6EDF3;
  margin-bottom: 1rem;
}
  
.scenario-card h2 {
  margin-bottom: 10px;
  color: #E6EDF3;
  font-size: 1.5rem;
}
  
.scenario-card p {
  color: #C9D1D9;
  margin-bottom: 1rem;
  line-height: 1.5;
}
  
.scenario-card .start-button {
  margin-top: auto;
  width: 100%;
  justify-content: center;
}
  
.start-button {
  margin-top: 20px;
  background-color: #040121;
  color: #E6EDF3;
  padding: 10px 18px;
  border: 1px solid #ffffff17;
  border-radius: 6px;
  cursor: pointer;
  font-size: 16px;
  transition: background-color 0.2s ease;
  height: 40px !important;
  display: flex !important;
  align-items: center !important;
  justify-content: center !important;
  position: relative !important;
}
  
.start-button:hover {
  background-color: #281e70;
}
  
.start-button:disabled {
  background-color: rgba(115, 114, 133, 0.392);
  cursor: not-allowed;
}

.reset-button {
  margin-left: 10px;
  padding: 10px 20px;
  background-color: #f44336;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
  
.reset-button:hover {
  background-color: #d32f2f;
}

.spinner {
  border: 2px solid #f3f3f3 !important;
  border-top: 2px solid #281e70 !important;
  border-radius: 50% !important;
  margin-top: 23px !important;
  width: 20px !important;
  height: 20px !important;
  animation: spin 0.8s linear infinite !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  margin-left: 10px !important;
  flex-shrink: 0 !important;
  position: absolute !important;
  right: calc(50% - 105px) !important;
}
  
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
  
.scenarios-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: 2rem;
  margin: 2rem 0;
  width: 100%;
}

.home-background {
  background-color: #040121;
  min-height: 100vh;
  width: 100vw;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2rem;
}
  
  `, "",{"version":3,"sources":["webpack://./src/components/HomePage.css"],"names":[],"mappings":"AAEA;EACE,4CAA4C;EAC5C,kBAAkB;EAClB,mBAAmB;EACnB,iBAAiB;EACjB,WAAW;EACX,yCAAyC;EACzC,kBAAkB;EAClB,gCAAgC;EAChC,cAAc;EACd,2BAA2B;EAC3B,cAAc;AAChB;;AAEA;EACE,eAAe;EACf,mBAAmB;EACnB,cAAc;AAChB;;AAEA;EACE,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,SAAS;EACT,mBAAmB;AACrB;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,mBAAmB;AACrB;;AAEA;EACE,4CAA4C;EAC5C,aAAa;EACb,mBAAmB;EACnB,WAAW;EACX,aAAa;EACb,sBAAsB;EACtB,qCAAqC;EACrC,gBAAgB;EAChB,2BAA2B;EAC3B,cAAc;EACd,mBAAmB;AACrB;;AAEA;EACE,mBAAmB;EACnB,cAAc;EACd,iBAAiB;AACnB;;AAEA;EACE,cAAc;EACd,mBAAmB;EACnB,gBAAgB;AAClB;;AAEA;EACE,gBAAgB;EAChB,WAAW;EACX,uBAAuB;AACzB;;AAEA;EACE,gBAAgB;EAChB,yBAAyB;EACzB,cAAc;EACd,kBAAkB;EAClB,2BAA2B;EAC3B,kBAAkB;EAClB,eAAe;EACf,eAAe;EACf,sCAAsC;EACtC,uBAAuB;EACvB,wBAAwB;EACxB,8BAA8B;EAC9B,kCAAkC;EAClC,6BAA6B;AAC/B;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,4CAA4C;EAC5C,mBAAmB;AACrB;;AAEA;EACE,iBAAiB;EACjB,kBAAkB;EAClB,yBAAyB;EACzB,YAAY;EACZ,YAAY;EACZ,kBAAkB;EAClB,eAAe;AACjB;;AAEA;EACE,yBAAyB;AAC3B;;AAEA;EACE,oCAAoC;EACpC,wCAAwC;EACxC,6BAA6B;EAC7B,2BAA2B;EAC3B,sBAAsB;EACtB,uBAAuB;EACvB,+CAA+C;EAC/C,+BAA+B;EAC/B,8BAA8B;EAC9B,kCAAkC;EAClC,4BAA4B;EAC5B,yBAAyB;EACzB,6BAA6B;EAC7B,mCAAmC;AACrC;;AAEA;EACE,KAAK,uBAAuB,EAAE;EAC9B,OAAO,yBAAyB,EAAE;AACpC;;AAEA;EACE,aAAa;EACb,2DAA2D;EAC3D,SAAS;EACT,cAAc;EACd,WAAW;AACb;;AAEA;EACE,yBAAyB;EACzB,iBAAiB;EACjB,YAAY;EACZ,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,aAAa;AACf","sourcesContent":["@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');\n\n.home-container {\n  background-color: rgba(115, 114, 133, 0.392);\n  padding: 3rem 2rem;\n  border-radius: 16px;\n  max-width: 1200px;\n  width: 100%;\n  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);\n  text-align: center;\n  font-family: 'Inter', sans-serif;\n  color: #E6EDF3;\n  border: 1px solid #ffffff17;\n  margin: 2rem 0;\n}\n  \n.home-title {\n  font-size: 28px;\n  margin-bottom: 30px;\n  color: #E6EDF3;\n}\n  \n.home-title-row {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 12px;\n  margin-bottom: 2rem;\n}\n  \n.home-logo-inline {\n  width: 40px;\n  height: auto;\n  object-fit: contain;\n}\n  \n.scenario-card {\n  background-color: rgba(115, 114, 133, 0.392);\n  padding: 2rem;\n  border-radius: 10px;\n  height: 80%;\n  display: flex;\n  flex-direction: column;\n  box-shadow: 0 8px 6px rgba(0,0,0,0.1);\n  text-align: left;\n  border: 1px solid #ffffff17;\n  color: #E6EDF3;\n  margin-bottom: 1rem;\n}\n  \n.scenario-card h2 {\n  margin-bottom: 10px;\n  color: #E6EDF3;\n  font-size: 1.5rem;\n}\n  \n.scenario-card p {\n  color: #C9D1D9;\n  margin-bottom: 1rem;\n  line-height: 1.5;\n}\n  \n.scenario-card .start-button {\n  margin-top: auto;\n  width: 100%;\n  justify-content: center;\n}\n  \n.start-button {\n  margin-top: 20px;\n  background-color: #040121;\n  color: #E6EDF3;\n  padding: 10px 18px;\n  border: 1px solid #ffffff17;\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 16px;\n  transition: background-color 0.2s ease;\n  height: 40px !important;\n  display: flex !important;\n  align-items: center !important;\n  justify-content: center !important;\n  position: relative !important;\n}\n  \n.start-button:hover {\n  background-color: #281e70;\n}\n  \n.start-button:disabled {\n  background-color: rgba(115, 114, 133, 0.392);\n  cursor: not-allowed;\n}\n\n.reset-button {\n  margin-left: 10px;\n  padding: 10px 20px;\n  background-color: #f44336;\n  color: white;\n  border: none;\n  border-radius: 5px;\n  cursor: pointer;\n}\n  \n.reset-button:hover {\n  background-color: #d32f2f;\n}\n\n.spinner {\n  border: 2px solid #f3f3f3 !important;\n  border-top: 2px solid #281e70 !important;\n  border-radius: 50% !important;\n  margin-top: 23px !important;\n  width: 20px !important;\n  height: 20px !important;\n  animation: spin 0.8s linear infinite !important;\n  display: inline-flex !important;\n  align-items: center !important;\n  justify-content: center !important;\n  margin-left: 10px !important;\n  flex-shrink: 0 !important;\n  position: absolute !important;\n  right: calc(50% - 105px) !important;\n}\n  \n@keyframes spin {\n  0% { transform: rotate(0deg); }\n  100% { transform: rotate(360deg); }\n}\n  \n.scenarios-container {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));\n  gap: 2rem;\n  margin: 2rem 0;\n  width: 100%;\n}\n\n.home-background {\n  background-color: #040121;\n  min-height: 100vh;\n  width: 100vw;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 2rem;\n}\n  \n  "],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/index.css":
/*!******************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/index.css ***!
  \******************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, ``, "",{"version":3,"sources":[],"names":[],"mappings":"","sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function () {
    return defaultMaxListeners;
  },
  set: function (arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }
  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

/***/ }),

/***/ "./node_modules/html-entities/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/html-entities/lib/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var named_references_1 = __webpack_require__(/*! ./named-references */ "./node_modules/html-entities/lib/named-references.js");
var numeric_unicode_map_1 = __webpack_require__(/*! ./numeric-unicode-map */ "./node_modules/html-entities/lib/numeric-unicode-map.js");
var surrogate_pairs_1 = __webpack_require__(/*! ./surrogate-pairs */ "./node_modules/html-entities/lib/surrogate-pairs.js");
var allNamedReferences = __assign(__assign({}, named_references_1.namedReferences), {
  all: named_references_1.namedReferences.html5
});
var encodeRegExps = {
  specialChars: /[<>'"&]/g,
  nonAscii: /[<>'"&\u0080-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
  nonAsciiPrintable: /[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
  nonAsciiPrintableOnly: /[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g,
  extensive: /[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF\uDC00-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g
};
var defaultEncodeOptions = {
  mode: "specialChars",
  level: "all",
  numeric: "decimal"
};
function encode(text, _a) {
  var _b = _a === void 0 ? defaultEncodeOptions : _a,
    _c = _b.mode,
    mode = _c === void 0 ? "specialChars" : _c,
    _d = _b.numeric,
    numeric = _d === void 0 ? "decimal" : _d,
    _e = _b.level,
    level = _e === void 0 ? "all" : _e;
  if (!text) {
    return "";
  }
  var encodeRegExp = encodeRegExps[mode];
  var references = allNamedReferences[level].characters;
  var isHex = numeric === "hexadecimal";
  return text.replace(encodeRegExp, function (input) {
    var result = references[input];
    if (!result) {
      var code = input.length > 1 ? surrogate_pairs_1.getCodePoint(input, 0) : input.charCodeAt(0);
      result = (isHex ? "&#x" + code.toString(16) : "&#" + code) + ";";
    }
    return result;
  });
}
exports.encode = encode;
var defaultDecodeOptions = {
  scope: "body",
  level: "all"
};
var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
var baseDecodeRegExps = {
  xml: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.xml
  },
  html4: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.html4
  },
  html5: {
    strict: strict,
    attribute: attribute,
    body: named_references_1.bodyRegExps.html5
  }
};
var decodeRegExps = __assign(__assign({}, baseDecodeRegExps), {
  all: baseDecodeRegExps.html5
});
var fromCharCode = String.fromCharCode;
var outOfBoundsChar = fromCharCode(65533);
var defaultDecodeEntityOptions = {
  level: "all"
};
function getDecodedEntity(entity, references, isAttribute, isStrict) {
  var decodeResult = entity;
  var decodeEntityLastChar = entity[entity.length - 1];
  if (isAttribute && decodeEntityLastChar === "=") {
    decodeResult = entity;
  } else if (isStrict && decodeEntityLastChar !== ";") {
    decodeResult = entity;
  } else {
    var decodeResultByReference = references[entity];
    if (decodeResultByReference) {
      decodeResult = decodeResultByReference;
    } else if (entity[0] === "&" && entity[1] === "#") {
      var decodeSecondChar = entity[2];
      var decodeCode = decodeSecondChar == "x" || decodeSecondChar == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
      decodeResult = decodeCode >= 1114111 ? outOfBoundsChar : decodeCode > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode] || decodeCode);
    }
  }
  return decodeResult;
}
function decodeEntity(entity, _a) {
  var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level,
    level = _b === void 0 ? "all" : _b;
  if (!entity) {
    return "";
  }
  return getDecodedEntity(entity, allNamedReferences[level].entities, false, false);
}
exports.decodeEntity = decodeEntity;
function decode(text, _a) {
  var _b = _a === void 0 ? defaultDecodeOptions : _a,
    _c = _b.level,
    level = _c === void 0 ? "all" : _c,
    _d = _b.scope,
    scope = _d === void 0 ? level === "xml" ? "strict" : "body" : _d;
  if (!text) {
    return "";
  }
  var decodeRegExp = decodeRegExps[level][scope];
  var references = allNamedReferences[level].entities;
  var isAttribute = scope === "attribute";
  var isStrict = scope === "strict";
  return text.replace(decodeRegExp, function (entity) {
    return getDecodedEntity(entity, references, isAttribute, isStrict);
  });
}
exports.decode = decode;

/***/ }),

/***/ "./node_modules/html-entities/lib/named-references.js":
/*!************************************************************!*\
  !*** ./node_modules/html-entities/lib/named-references.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bodyRegExps = {
  xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html4: /&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,
  html5: /&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g
};
exports.namedReferences = {
  xml: {
    entities: {
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&apos;": "'",
      "&amp;": "&"
    },
    characters: {
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&apos;",
      "&": "&amp;"
    }
  },
  html4: {
    entities: {
      "&apos;": "'",
      "&nbsp": " ",
      "&nbsp;": " ",
      "&iexcl": "¡",
      "&iexcl;": "¡",
      "&cent": "¢",
      "&cent;": "¢",
      "&pound": "£",
      "&pound;": "£",
      "&curren": "¤",
      "&curren;": "¤",
      "&yen": "¥",
      "&yen;": "¥",
      "&brvbar": "¦",
      "&brvbar;": "¦",
      "&sect": "§",
      "&sect;": "§",
      "&uml": "¨",
      "&uml;": "¨",
      "&copy": "©",
      "&copy;": "©",
      "&ordf": "ª",
      "&ordf;": "ª",
      "&laquo": "«",
      "&laquo;": "«",
      "&not": "¬",
      "&not;": "¬",
      "&shy": "­",
      "&shy;": "­",
      "&reg": "®",
      "&reg;": "®",
      "&macr": "¯",
      "&macr;": "¯",
      "&deg": "°",
      "&deg;": "°",
      "&plusmn": "±",
      "&plusmn;": "±",
      "&sup2": "²",
      "&sup2;": "²",
      "&sup3": "³",
      "&sup3;": "³",
      "&acute": "´",
      "&acute;": "´",
      "&micro": "µ",
      "&micro;": "µ",
      "&para": "¶",
      "&para;": "¶",
      "&middot": "·",
      "&middot;": "·",
      "&cedil": "¸",
      "&cedil;": "¸",
      "&sup1": "¹",
      "&sup1;": "¹",
      "&ordm": "º",
      "&ordm;": "º",
      "&raquo": "»",
      "&raquo;": "»",
      "&frac14": "¼",
      "&frac14;": "¼",
      "&frac12": "½",
      "&frac12;": "½",
      "&frac34": "¾",
      "&frac34;": "¾",
      "&iquest": "¿",
      "&iquest;": "¿",
      "&Agrave": "À",
      "&Agrave;": "À",
      "&Aacute": "Á",
      "&Aacute;": "Á",
      "&Acirc": "Â",
      "&Acirc;": "Â",
      "&Atilde": "Ã",
      "&Atilde;": "Ã",
      "&Auml": "Ä",
      "&Auml;": "Ä",
      "&Aring": "Å",
      "&Aring;": "Å",
      "&AElig": "Æ",
      "&AElig;": "Æ",
      "&Ccedil": "Ç",
      "&Ccedil;": "Ç",
      "&Egrave": "È",
      "&Egrave;": "È",
      "&Eacute": "É",
      "&Eacute;": "É",
      "&Ecirc": "Ê",
      "&Ecirc;": "Ê",
      "&Euml": "Ë",
      "&Euml;": "Ë",
      "&Igrave": "Ì",
      "&Igrave;": "Ì",
      "&Iacute": "Í",
      "&Iacute;": "Í",
      "&Icirc": "Î",
      "&Icirc;": "Î",
      "&Iuml": "Ï",
      "&Iuml;": "Ï",
      "&ETH": "Ð",
      "&ETH;": "Ð",
      "&Ntilde": "Ñ",
      "&Ntilde;": "Ñ",
      "&Ograve": "Ò",
      "&Ograve;": "Ò",
      "&Oacute": "Ó",
      "&Oacute;": "Ó",
      "&Ocirc": "Ô",
      "&Ocirc;": "Ô",
      "&Otilde": "Õ",
      "&Otilde;": "Õ",
      "&Ouml": "Ö",
      "&Ouml;": "Ö",
      "&times": "×",
      "&times;": "×",
      "&Oslash": "Ø",
      "&Oslash;": "Ø",
      "&Ugrave": "Ù",
      "&Ugrave;": "Ù",
      "&Uacute": "Ú",
      "&Uacute;": "Ú",
      "&Ucirc": "Û",
      "&Ucirc;": "Û",
      "&Uuml": "Ü",
      "&Uuml;": "Ü",
      "&Yacute": "Ý",
      "&Yacute;": "Ý",
      "&THORN": "Þ",
      "&THORN;": "Þ",
      "&szlig": "ß",
      "&szlig;": "ß",
      "&agrave": "à",
      "&agrave;": "à",
      "&aacute": "á",
      "&aacute;": "á",
      "&acirc": "â",
      "&acirc;": "â",
      "&atilde": "ã",
      "&atilde;": "ã",
      "&auml": "ä",
      "&auml;": "ä",
      "&aring": "å",
      "&aring;": "å",
      "&aelig": "æ",
      "&aelig;": "æ",
      "&ccedil": "ç",
      "&ccedil;": "ç",
      "&egrave": "è",
      "&egrave;": "è",
      "&eacute": "é",
      "&eacute;": "é",
      "&ecirc": "ê",
      "&ecirc;": "ê",
      "&euml": "ë",
      "&euml;": "ë",
      "&igrave": "ì",
      "&igrave;": "ì",
      "&iacute": "í",
      "&iacute;": "í",
      "&icirc": "î",
      "&icirc;": "î",
      "&iuml": "ï",
      "&iuml;": "ï",
      "&eth": "ð",
      "&eth;": "ð",
      "&ntilde": "ñ",
      "&ntilde;": "ñ",
      "&ograve": "ò",
      "&ograve;": "ò",
      "&oacute": "ó",
      "&oacute;": "ó",
      "&ocirc": "ô",
      "&ocirc;": "ô",
      "&otilde": "õ",
      "&otilde;": "õ",
      "&ouml": "ö",
      "&ouml;": "ö",
      "&divide": "÷",
      "&divide;": "÷",
      "&oslash": "ø",
      "&oslash;": "ø",
      "&ugrave": "ù",
      "&ugrave;": "ù",
      "&uacute": "ú",
      "&uacute;": "ú",
      "&ucirc": "û",
      "&ucirc;": "û",
      "&uuml": "ü",
      "&uuml;": "ü",
      "&yacute": "ý",
      "&yacute;": "ý",
      "&thorn": "þ",
      "&thorn;": "þ",
      "&yuml": "ÿ",
      "&yuml;": "ÿ",
      "&quot": '"',
      "&quot;": '"',
      "&amp": "&",
      "&amp;": "&",
      "&lt": "<",
      "&lt;": "<",
      "&gt": ">",
      "&gt;": ">",
      "&OElig;": "Œ",
      "&oelig;": "œ",
      "&Scaron;": "Š",
      "&scaron;": "š",
      "&Yuml;": "Ÿ",
      "&circ;": "ˆ",
      "&tilde;": "˜",
      "&ensp;": " ",
      "&emsp;": " ",
      "&thinsp;": " ",
      "&zwnj;": "‌",
      "&zwj;": "‍",
      "&lrm;": "‎",
      "&rlm;": "‏",
      "&ndash;": "–",
      "&mdash;": "—",
      "&lsquo;": "‘",
      "&rsquo;": "’",
      "&sbquo;": "‚",
      "&ldquo;": "“",
      "&rdquo;": "”",
      "&bdquo;": "„",
      "&dagger;": "†",
      "&Dagger;": "‡",
      "&permil;": "‰",
      "&lsaquo;": "‹",
      "&rsaquo;": "›",
      "&euro;": "€",
      "&fnof;": "ƒ",
      "&Alpha;": "Α",
      "&Beta;": "Β",
      "&Gamma;": "Γ",
      "&Delta;": "Δ",
      "&Epsilon;": "Ε",
      "&Zeta;": "Ζ",
      "&Eta;": "Η",
      "&Theta;": "Θ",
      "&Iota;": "Ι",
      "&Kappa;": "Κ",
      "&Lambda;": "Λ",
      "&Mu;": "Μ",
      "&Nu;": "Ν",
      "&Xi;": "Ξ",
      "&Omicron;": "Ο",
      "&Pi;": "Π",
      "&Rho;": "Ρ",
      "&Sigma;": "Σ",
      "&Tau;": "Τ",
      "&Upsilon;": "Υ",
      "&Phi;": "Φ",
      "&Chi;": "Χ",
      "&Psi;": "Ψ",
      "&Omega;": "Ω",
      "&alpha;": "α",
      "&beta;": "β",
      "&gamma;": "γ",
      "&delta;": "δ",
      "&epsilon;": "ε",
      "&zeta;": "ζ",
      "&eta;": "η",
      "&theta;": "θ",
      "&iota;": "ι",
      "&kappa;": "κ",
      "&lambda;": "λ",
      "&mu;": "μ",
      "&nu;": "ν",
      "&xi;": "ξ",
      "&omicron;": "ο",
      "&pi;": "π",
      "&rho;": "ρ",
      "&sigmaf;": "ς",
      "&sigma;": "σ",
      "&tau;": "τ",
      "&upsilon;": "υ",
      "&phi;": "φ",
      "&chi;": "χ",
      "&psi;": "ψ",
      "&omega;": "ω",
      "&thetasym;": "ϑ",
      "&upsih;": "ϒ",
      "&piv;": "ϖ",
      "&bull;": "•",
      "&hellip;": "…",
      "&prime;": "′",
      "&Prime;": "″",
      "&oline;": "‾",
      "&frasl;": "⁄",
      "&weierp;": "℘",
      "&image;": "ℑ",
      "&real;": "ℜ",
      "&trade;": "™",
      "&alefsym;": "ℵ",
      "&larr;": "←",
      "&uarr;": "↑",
      "&rarr;": "→",
      "&darr;": "↓",
      "&harr;": "↔",
      "&crarr;": "↵",
      "&lArr;": "⇐",
      "&uArr;": "⇑",
      "&rArr;": "⇒",
      "&dArr;": "⇓",
      "&hArr;": "⇔",
      "&forall;": "∀",
      "&part;": "∂",
      "&exist;": "∃",
      "&empty;": "∅",
      "&nabla;": "∇",
      "&isin;": "∈",
      "&notin;": "∉",
      "&ni;": "∋",
      "&prod;": "∏",
      "&sum;": "∑",
      "&minus;": "−",
      "&lowast;": "∗",
      "&radic;": "√",
      "&prop;": "∝",
      "&infin;": "∞",
      "&ang;": "∠",
      "&and;": "∧",
      "&or;": "∨",
      "&cap;": "∩",
      "&cup;": "∪",
      "&int;": "∫",
      "&there4;": "∴",
      "&sim;": "∼",
      "&cong;": "≅",
      "&asymp;": "≈",
      "&ne;": "≠",
      "&equiv;": "≡",
      "&le;": "≤",
      "&ge;": "≥",
      "&sub;": "⊂",
      "&sup;": "⊃",
      "&nsub;": "⊄",
      "&sube;": "⊆",
      "&supe;": "⊇",
      "&oplus;": "⊕",
      "&otimes;": "⊗",
      "&perp;": "⊥",
      "&sdot;": "⋅",
      "&lceil;": "⌈",
      "&rceil;": "⌉",
      "&lfloor;": "⌊",
      "&rfloor;": "⌋",
      "&lang;": "〈",
      "&rang;": "〉",
      "&loz;": "◊",
      "&spades;": "♠",
      "&clubs;": "♣",
      "&hearts;": "♥",
      "&diams;": "♦"
    },
    characters: {
      "'": "&apos;",
      " ": "&nbsp;",
      "¡": "&iexcl;",
      "¢": "&cent;",
      "£": "&pound;",
      "¤": "&curren;",
      "¥": "&yen;",
      "¦": "&brvbar;",
      "§": "&sect;",
      "¨": "&uml;",
      "©": "&copy;",
      "ª": "&ordf;",
      "«": "&laquo;",
      "¬": "&not;",
      "­": "&shy;",
      "®": "&reg;",
      "¯": "&macr;",
      "°": "&deg;",
      "±": "&plusmn;",
      "²": "&sup2;",
      "³": "&sup3;",
      "´": "&acute;",
      "µ": "&micro;",
      "¶": "&para;",
      "·": "&middot;",
      "¸": "&cedil;",
      "¹": "&sup1;",
      "º": "&ordm;",
      "»": "&raquo;",
      "¼": "&frac14;",
      "½": "&frac12;",
      "¾": "&frac34;",
      "¿": "&iquest;",
      "À": "&Agrave;",
      "Á": "&Aacute;",
      "Â": "&Acirc;",
      "Ã": "&Atilde;",
      "Ä": "&Auml;",
      "Å": "&Aring;",
      "Æ": "&AElig;",
      "Ç": "&Ccedil;",
      "È": "&Egrave;",
      "É": "&Eacute;",
      "Ê": "&Ecirc;",
      "Ë": "&Euml;",
      "Ì": "&Igrave;",
      "Í": "&Iacute;",
      "Î": "&Icirc;",
      "Ï": "&Iuml;",
      "Ð": "&ETH;",
      "Ñ": "&Ntilde;",
      "Ò": "&Ograve;",
      "Ó": "&Oacute;",
      "Ô": "&Ocirc;",
      "Õ": "&Otilde;",
      "Ö": "&Ouml;",
      "×": "&times;",
      "Ø": "&Oslash;",
      "Ù": "&Ugrave;",
      "Ú": "&Uacute;",
      "Û": "&Ucirc;",
      "Ü": "&Uuml;",
      "Ý": "&Yacute;",
      "Þ": "&THORN;",
      "ß": "&szlig;",
      "à": "&agrave;",
      "á": "&aacute;",
      "â": "&acirc;",
      "ã": "&atilde;",
      "ä": "&auml;",
      "å": "&aring;",
      "æ": "&aelig;",
      "ç": "&ccedil;",
      "è": "&egrave;",
      "é": "&eacute;",
      "ê": "&ecirc;",
      "ë": "&euml;",
      "ì": "&igrave;",
      "í": "&iacute;",
      "î": "&icirc;",
      "ï": "&iuml;",
      "ð": "&eth;",
      "ñ": "&ntilde;",
      "ò": "&ograve;",
      "ó": "&oacute;",
      "ô": "&ocirc;",
      "õ": "&otilde;",
      "ö": "&ouml;",
      "÷": "&divide;",
      "ø": "&oslash;",
      "ù": "&ugrave;",
      "ú": "&uacute;",
      "û": "&ucirc;",
      "ü": "&uuml;",
      "ý": "&yacute;",
      "þ": "&thorn;",
      "ÿ": "&yuml;",
      '"': "&quot;",
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      "Œ": "&OElig;",
      "œ": "&oelig;",
      "Š": "&Scaron;",
      "š": "&scaron;",
      "Ÿ": "&Yuml;",
      "ˆ": "&circ;",
      "˜": "&tilde;",
      " ": "&ensp;",
      " ": "&emsp;",
      " ": "&thinsp;",
      "‌": "&zwnj;",
      "‍": "&zwj;",
      "‎": "&lrm;",
      "‏": "&rlm;",
      "–": "&ndash;",
      "—": "&mdash;",
      "‘": "&lsquo;",
      "’": "&rsquo;",
      "‚": "&sbquo;",
      "“": "&ldquo;",
      "”": "&rdquo;",
      "„": "&bdquo;",
      "†": "&dagger;",
      "‡": "&Dagger;",
      "‰": "&permil;",
      "‹": "&lsaquo;",
      "›": "&rsaquo;",
      "€": "&euro;",
      "ƒ": "&fnof;",
      "Α": "&Alpha;",
      "Β": "&Beta;",
      "Γ": "&Gamma;",
      "Δ": "&Delta;",
      "Ε": "&Epsilon;",
      "Ζ": "&Zeta;",
      "Η": "&Eta;",
      "Θ": "&Theta;",
      "Ι": "&Iota;",
      "Κ": "&Kappa;",
      "Λ": "&Lambda;",
      "Μ": "&Mu;",
      "Ν": "&Nu;",
      "Ξ": "&Xi;",
      "Ο": "&Omicron;",
      "Π": "&Pi;",
      "Ρ": "&Rho;",
      "Σ": "&Sigma;",
      "Τ": "&Tau;",
      "Υ": "&Upsilon;",
      "Φ": "&Phi;",
      "Χ": "&Chi;",
      "Ψ": "&Psi;",
      "Ω": "&Omega;",
      "α": "&alpha;",
      "β": "&beta;",
      "γ": "&gamma;",
      "δ": "&delta;",
      "ε": "&epsilon;",
      "ζ": "&zeta;",
      "η": "&eta;",
      "θ": "&theta;",
      "ι": "&iota;",
      "κ": "&kappa;",
      "λ": "&lambda;",
      "μ": "&mu;",
      "ν": "&nu;",
      "ξ": "&xi;",
      "ο": "&omicron;",
      "π": "&pi;",
      "ρ": "&rho;",
      "ς": "&sigmaf;",
      "σ": "&sigma;",
      "τ": "&tau;",
      "υ": "&upsilon;",
      "φ": "&phi;",
      "χ": "&chi;",
      "ψ": "&psi;",
      "ω": "&omega;",
      "ϑ": "&thetasym;",
      "ϒ": "&upsih;",
      "ϖ": "&piv;",
      "•": "&bull;",
      "…": "&hellip;",
      "′": "&prime;",
      "″": "&Prime;",
      "‾": "&oline;",
      "⁄": "&frasl;",
      "℘": "&weierp;",
      "ℑ": "&image;",
      "ℜ": "&real;",
      "™": "&trade;",
      "ℵ": "&alefsym;",
      "←": "&larr;",
      "↑": "&uarr;",
      "→": "&rarr;",
      "↓": "&darr;",
      "↔": "&harr;",
      "↵": "&crarr;",
      "⇐": "&lArr;",
      "⇑": "&uArr;",
      "⇒": "&rArr;",
      "⇓": "&dArr;",
      "⇔": "&hArr;",
      "∀": "&forall;",
      "∂": "&part;",
      "∃": "&exist;",
      "∅": "&empty;",
      "∇": "&nabla;",
      "∈": "&isin;",
      "∉": "&notin;",
      "∋": "&ni;",
      "∏": "&prod;",
      "∑": "&sum;",
      "−": "&minus;",
      "∗": "&lowast;",
      "√": "&radic;",
      "∝": "&prop;",
      "∞": "&infin;",
      "∠": "&ang;",
      "∧": "&and;",
      "∨": "&or;",
      "∩": "&cap;",
      "∪": "&cup;",
      "∫": "&int;",
      "∴": "&there4;",
      "∼": "&sim;",
      "≅": "&cong;",
      "≈": "&asymp;",
      "≠": "&ne;",
      "≡": "&equiv;",
      "≤": "&le;",
      "≥": "&ge;",
      "⊂": "&sub;",
      "⊃": "&sup;",
      "⊄": "&nsub;",
      "⊆": "&sube;",
      "⊇": "&supe;",
      "⊕": "&oplus;",
      "⊗": "&otimes;",
      "⊥": "&perp;",
      "⋅": "&sdot;",
      "⌈": "&lceil;",
      "⌉": "&rceil;",
      "⌊": "&lfloor;",
      "⌋": "&rfloor;",
      "〈": "&lang;",
      "〉": "&rang;",
      "◊": "&loz;",
      "♠": "&spades;",
      "♣": "&clubs;",
      "♥": "&hearts;",
      "♦": "&diams;"
    }
  },
  html5: {
    entities: {
      "&AElig": "Æ",
      "&AElig;": "Æ",
      "&AMP": "&",
      "&AMP;": "&",
      "&Aacute": "Á",
      "&Aacute;": "Á",
      "&Abreve;": "Ă",
      "&Acirc": "Â",
      "&Acirc;": "Â",
      "&Acy;": "А",
      "&Afr;": "𝔄",
      "&Agrave": "À",
      "&Agrave;": "À",
      "&Alpha;": "Α",
      "&Amacr;": "Ā",
      "&And;": "⩓",
      "&Aogon;": "Ą",
      "&Aopf;": "𝔸",
      "&ApplyFunction;": "⁡",
      "&Aring": "Å",
      "&Aring;": "Å",
      "&Ascr;": "𝒜",
      "&Assign;": "≔",
      "&Atilde": "Ã",
      "&Atilde;": "Ã",
      "&Auml": "Ä",
      "&Auml;": "Ä",
      "&Backslash;": "∖",
      "&Barv;": "⫧",
      "&Barwed;": "⌆",
      "&Bcy;": "Б",
      "&Because;": "∵",
      "&Bernoullis;": "ℬ",
      "&Beta;": "Β",
      "&Bfr;": "𝔅",
      "&Bopf;": "𝔹",
      "&Breve;": "˘",
      "&Bscr;": "ℬ",
      "&Bumpeq;": "≎",
      "&CHcy;": "Ч",
      "&COPY": "©",
      "&COPY;": "©",
      "&Cacute;": "Ć",
      "&Cap;": "⋒",
      "&CapitalDifferentialD;": "ⅅ",
      "&Cayleys;": "ℭ",
      "&Ccaron;": "Č",
      "&Ccedil": "Ç",
      "&Ccedil;": "Ç",
      "&Ccirc;": "Ĉ",
      "&Cconint;": "∰",
      "&Cdot;": "Ċ",
      "&Cedilla;": "¸",
      "&CenterDot;": "·",
      "&Cfr;": "ℭ",
      "&Chi;": "Χ",
      "&CircleDot;": "⊙",
      "&CircleMinus;": "⊖",
      "&CirclePlus;": "⊕",
      "&CircleTimes;": "⊗",
      "&ClockwiseContourIntegral;": "∲",
      "&CloseCurlyDoubleQuote;": "”",
      "&CloseCurlyQuote;": "’",
      "&Colon;": "∷",
      "&Colone;": "⩴",
      "&Congruent;": "≡",
      "&Conint;": "∯",
      "&ContourIntegral;": "∮",
      "&Copf;": "ℂ",
      "&Coproduct;": "∐",
      "&CounterClockwiseContourIntegral;": "∳",
      "&Cross;": "⨯",
      "&Cscr;": "𝒞",
      "&Cup;": "⋓",
      "&CupCap;": "≍",
      "&DD;": "ⅅ",
      "&DDotrahd;": "⤑",
      "&DJcy;": "Ђ",
      "&DScy;": "Ѕ",
      "&DZcy;": "Џ",
      "&Dagger;": "‡",
      "&Darr;": "↡",
      "&Dashv;": "⫤",
      "&Dcaron;": "Ď",
      "&Dcy;": "Д",
      "&Del;": "∇",
      "&Delta;": "Δ",
      "&Dfr;": "𝔇",
      "&DiacriticalAcute;": "´",
      "&DiacriticalDot;": "˙",
      "&DiacriticalDoubleAcute;": "˝",
      "&DiacriticalGrave;": "`",
      "&DiacriticalTilde;": "˜",
      "&Diamond;": "⋄",
      "&DifferentialD;": "ⅆ",
      "&Dopf;": "𝔻",
      "&Dot;": "¨",
      "&DotDot;": "⃜",
      "&DotEqual;": "≐",
      "&DoubleContourIntegral;": "∯",
      "&DoubleDot;": "¨",
      "&DoubleDownArrow;": "⇓",
      "&DoubleLeftArrow;": "⇐",
      "&DoubleLeftRightArrow;": "⇔",
      "&DoubleLeftTee;": "⫤",
      "&DoubleLongLeftArrow;": "⟸",
      "&DoubleLongLeftRightArrow;": "⟺",
      "&DoubleLongRightArrow;": "⟹",
      "&DoubleRightArrow;": "⇒",
      "&DoubleRightTee;": "⊨",
      "&DoubleUpArrow;": "⇑",
      "&DoubleUpDownArrow;": "⇕",
      "&DoubleVerticalBar;": "∥",
      "&DownArrow;": "↓",
      "&DownArrowBar;": "⤓",
      "&DownArrowUpArrow;": "⇵",
      "&DownBreve;": "̑",
      "&DownLeftRightVector;": "⥐",
      "&DownLeftTeeVector;": "⥞",
      "&DownLeftVector;": "↽",
      "&DownLeftVectorBar;": "⥖",
      "&DownRightTeeVector;": "⥟",
      "&DownRightVector;": "⇁",
      "&DownRightVectorBar;": "⥗",
      "&DownTee;": "⊤",
      "&DownTeeArrow;": "↧",
      "&Downarrow;": "⇓",
      "&Dscr;": "𝒟",
      "&Dstrok;": "Đ",
      "&ENG;": "Ŋ",
      "&ETH": "Ð",
      "&ETH;": "Ð",
      "&Eacute": "É",
      "&Eacute;": "É",
      "&Ecaron;": "Ě",
      "&Ecirc": "Ê",
      "&Ecirc;": "Ê",
      "&Ecy;": "Э",
      "&Edot;": "Ė",
      "&Efr;": "𝔈",
      "&Egrave": "È",
      "&Egrave;": "È",
      "&Element;": "∈",
      "&Emacr;": "Ē",
      "&EmptySmallSquare;": "◻",
      "&EmptyVerySmallSquare;": "▫",
      "&Eogon;": "Ę",
      "&Eopf;": "𝔼",
      "&Epsilon;": "Ε",
      "&Equal;": "⩵",
      "&EqualTilde;": "≂",
      "&Equilibrium;": "⇌",
      "&Escr;": "ℰ",
      "&Esim;": "⩳",
      "&Eta;": "Η",
      "&Euml": "Ë",
      "&Euml;": "Ë",
      "&Exists;": "∃",
      "&ExponentialE;": "ⅇ",
      "&Fcy;": "Ф",
      "&Ffr;": "𝔉",
      "&FilledSmallSquare;": "◼",
      "&FilledVerySmallSquare;": "▪",
      "&Fopf;": "𝔽",
      "&ForAll;": "∀",
      "&Fouriertrf;": "ℱ",
      "&Fscr;": "ℱ",
      "&GJcy;": "Ѓ",
      "&GT": ">",
      "&GT;": ">",
      "&Gamma;": "Γ",
      "&Gammad;": "Ϝ",
      "&Gbreve;": "Ğ",
      "&Gcedil;": "Ģ",
      "&Gcirc;": "Ĝ",
      "&Gcy;": "Г",
      "&Gdot;": "Ġ",
      "&Gfr;": "𝔊",
      "&Gg;": "⋙",
      "&Gopf;": "𝔾",
      "&GreaterEqual;": "≥",
      "&GreaterEqualLess;": "⋛",
      "&GreaterFullEqual;": "≧",
      "&GreaterGreater;": "⪢",
      "&GreaterLess;": "≷",
      "&GreaterSlantEqual;": "⩾",
      "&GreaterTilde;": "≳",
      "&Gscr;": "𝒢",
      "&Gt;": "≫",
      "&HARDcy;": "Ъ",
      "&Hacek;": "ˇ",
      "&Hat;": "^",
      "&Hcirc;": "Ĥ",
      "&Hfr;": "ℌ",
      "&HilbertSpace;": "ℋ",
      "&Hopf;": "ℍ",
      "&HorizontalLine;": "─",
      "&Hscr;": "ℋ",
      "&Hstrok;": "Ħ",
      "&HumpDownHump;": "≎",
      "&HumpEqual;": "≏",
      "&IEcy;": "Е",
      "&IJlig;": "Ĳ",
      "&IOcy;": "Ё",
      "&Iacute": "Í",
      "&Iacute;": "Í",
      "&Icirc": "Î",
      "&Icirc;": "Î",
      "&Icy;": "И",
      "&Idot;": "İ",
      "&Ifr;": "ℑ",
      "&Igrave": "Ì",
      "&Igrave;": "Ì",
      "&Im;": "ℑ",
      "&Imacr;": "Ī",
      "&ImaginaryI;": "ⅈ",
      "&Implies;": "⇒",
      "&Int;": "∬",
      "&Integral;": "∫",
      "&Intersection;": "⋂",
      "&InvisibleComma;": "⁣",
      "&InvisibleTimes;": "⁢",
      "&Iogon;": "Į",
      "&Iopf;": "𝕀",
      "&Iota;": "Ι",
      "&Iscr;": "ℐ",
      "&Itilde;": "Ĩ",
      "&Iukcy;": "І",
      "&Iuml": "Ï",
      "&Iuml;": "Ï",
      "&Jcirc;": "Ĵ",
      "&Jcy;": "Й",
      "&Jfr;": "𝔍",
      "&Jopf;": "𝕁",
      "&Jscr;": "𝒥",
      "&Jsercy;": "Ј",
      "&Jukcy;": "Є",
      "&KHcy;": "Х",
      "&KJcy;": "Ќ",
      "&Kappa;": "Κ",
      "&Kcedil;": "Ķ",
      "&Kcy;": "К",
      "&Kfr;": "𝔎",
      "&Kopf;": "𝕂",
      "&Kscr;": "𝒦",
      "&LJcy;": "Љ",
      "&LT": "<",
      "&LT;": "<",
      "&Lacute;": "Ĺ",
      "&Lambda;": "Λ",
      "&Lang;": "⟪",
      "&Laplacetrf;": "ℒ",
      "&Larr;": "↞",
      "&Lcaron;": "Ľ",
      "&Lcedil;": "Ļ",
      "&Lcy;": "Л",
      "&LeftAngleBracket;": "⟨",
      "&LeftArrow;": "←",
      "&LeftArrowBar;": "⇤",
      "&LeftArrowRightArrow;": "⇆",
      "&LeftCeiling;": "⌈",
      "&LeftDoubleBracket;": "⟦",
      "&LeftDownTeeVector;": "⥡",
      "&LeftDownVector;": "⇃",
      "&LeftDownVectorBar;": "⥙",
      "&LeftFloor;": "⌊",
      "&LeftRightArrow;": "↔",
      "&LeftRightVector;": "⥎",
      "&LeftTee;": "⊣",
      "&LeftTeeArrow;": "↤",
      "&LeftTeeVector;": "⥚",
      "&LeftTriangle;": "⊲",
      "&LeftTriangleBar;": "⧏",
      "&LeftTriangleEqual;": "⊴",
      "&LeftUpDownVector;": "⥑",
      "&LeftUpTeeVector;": "⥠",
      "&LeftUpVector;": "↿",
      "&LeftUpVectorBar;": "⥘",
      "&LeftVector;": "↼",
      "&LeftVectorBar;": "⥒",
      "&Leftarrow;": "⇐",
      "&Leftrightarrow;": "⇔",
      "&LessEqualGreater;": "⋚",
      "&LessFullEqual;": "≦",
      "&LessGreater;": "≶",
      "&LessLess;": "⪡",
      "&LessSlantEqual;": "⩽",
      "&LessTilde;": "≲",
      "&Lfr;": "𝔏",
      "&Ll;": "⋘",
      "&Lleftarrow;": "⇚",
      "&Lmidot;": "Ŀ",
      "&LongLeftArrow;": "⟵",
      "&LongLeftRightArrow;": "⟷",
      "&LongRightArrow;": "⟶",
      "&Longleftarrow;": "⟸",
      "&Longleftrightarrow;": "⟺",
      "&Longrightarrow;": "⟹",
      "&Lopf;": "𝕃",
      "&LowerLeftArrow;": "↙",
      "&LowerRightArrow;": "↘",
      "&Lscr;": "ℒ",
      "&Lsh;": "↰",
      "&Lstrok;": "Ł",
      "&Lt;": "≪",
      "&Map;": "⤅",
      "&Mcy;": "М",
      "&MediumSpace;": " ",
      "&Mellintrf;": "ℳ",
      "&Mfr;": "𝔐",
      "&MinusPlus;": "∓",
      "&Mopf;": "𝕄",
      "&Mscr;": "ℳ",
      "&Mu;": "Μ",
      "&NJcy;": "Њ",
      "&Nacute;": "Ń",
      "&Ncaron;": "Ň",
      "&Ncedil;": "Ņ",
      "&Ncy;": "Н",
      "&NegativeMediumSpace;": "​",
      "&NegativeThickSpace;": "​",
      "&NegativeThinSpace;": "​",
      "&NegativeVeryThinSpace;": "​",
      "&NestedGreaterGreater;": "≫",
      "&NestedLessLess;": "≪",
      "&NewLine;": "\n",
      "&Nfr;": "𝔑",
      "&NoBreak;": "⁠",
      "&NonBreakingSpace;": " ",
      "&Nopf;": "ℕ",
      "&Not;": "⫬",
      "&NotCongruent;": "≢",
      "&NotCupCap;": "≭",
      "&NotDoubleVerticalBar;": "∦",
      "&NotElement;": "∉",
      "&NotEqual;": "≠",
      "&NotEqualTilde;": "≂̸",
      "&NotExists;": "∄",
      "&NotGreater;": "≯",
      "&NotGreaterEqual;": "≱",
      "&NotGreaterFullEqual;": "≧̸",
      "&NotGreaterGreater;": "≫̸",
      "&NotGreaterLess;": "≹",
      "&NotGreaterSlantEqual;": "⩾̸",
      "&NotGreaterTilde;": "≵",
      "&NotHumpDownHump;": "≎̸",
      "&NotHumpEqual;": "≏̸",
      "&NotLeftTriangle;": "⋪",
      "&NotLeftTriangleBar;": "⧏̸",
      "&NotLeftTriangleEqual;": "⋬",
      "&NotLess;": "≮",
      "&NotLessEqual;": "≰",
      "&NotLessGreater;": "≸",
      "&NotLessLess;": "≪̸",
      "&NotLessSlantEqual;": "⩽̸",
      "&NotLessTilde;": "≴",
      "&NotNestedGreaterGreater;": "⪢̸",
      "&NotNestedLessLess;": "⪡̸",
      "&NotPrecedes;": "⊀",
      "&NotPrecedesEqual;": "⪯̸",
      "&NotPrecedesSlantEqual;": "⋠",
      "&NotReverseElement;": "∌",
      "&NotRightTriangle;": "⋫",
      "&NotRightTriangleBar;": "⧐̸",
      "&NotRightTriangleEqual;": "⋭",
      "&NotSquareSubset;": "⊏̸",
      "&NotSquareSubsetEqual;": "⋢",
      "&NotSquareSuperset;": "⊐̸",
      "&NotSquareSupersetEqual;": "⋣",
      "&NotSubset;": "⊂⃒",
      "&NotSubsetEqual;": "⊈",
      "&NotSucceeds;": "⊁",
      "&NotSucceedsEqual;": "⪰̸",
      "&NotSucceedsSlantEqual;": "⋡",
      "&NotSucceedsTilde;": "≿̸",
      "&NotSuperset;": "⊃⃒",
      "&NotSupersetEqual;": "⊉",
      "&NotTilde;": "≁",
      "&NotTildeEqual;": "≄",
      "&NotTildeFullEqual;": "≇",
      "&NotTildeTilde;": "≉",
      "&NotVerticalBar;": "∤",
      "&Nscr;": "𝒩",
      "&Ntilde": "Ñ",
      "&Ntilde;": "Ñ",
      "&Nu;": "Ν",
      "&OElig;": "Œ",
      "&Oacute": "Ó",
      "&Oacute;": "Ó",
      "&Ocirc": "Ô",
      "&Ocirc;": "Ô",
      "&Ocy;": "О",
      "&Odblac;": "Ő",
      "&Ofr;": "𝔒",
      "&Ograve": "Ò",
      "&Ograve;": "Ò",
      "&Omacr;": "Ō",
      "&Omega;": "Ω",
      "&Omicron;": "Ο",
      "&Oopf;": "𝕆",
      "&OpenCurlyDoubleQuote;": "“",
      "&OpenCurlyQuote;": "‘",
      "&Or;": "⩔",
      "&Oscr;": "𝒪",
      "&Oslash": "Ø",
      "&Oslash;": "Ø",
      "&Otilde": "Õ",
      "&Otilde;": "Õ",
      "&Otimes;": "⨷",
      "&Ouml": "Ö",
      "&Ouml;": "Ö",
      "&OverBar;": "‾",
      "&OverBrace;": "⏞",
      "&OverBracket;": "⎴",
      "&OverParenthesis;": "⏜",
      "&PartialD;": "∂",
      "&Pcy;": "П",
      "&Pfr;": "𝔓",
      "&Phi;": "Φ",
      "&Pi;": "Π",
      "&PlusMinus;": "±",
      "&Poincareplane;": "ℌ",
      "&Popf;": "ℙ",
      "&Pr;": "⪻",
      "&Precedes;": "≺",
      "&PrecedesEqual;": "⪯",
      "&PrecedesSlantEqual;": "≼",
      "&PrecedesTilde;": "≾",
      "&Prime;": "″",
      "&Product;": "∏",
      "&Proportion;": "∷",
      "&Proportional;": "∝",
      "&Pscr;": "𝒫",
      "&Psi;": "Ψ",
      "&QUOT": '"',
      "&QUOT;": '"',
      "&Qfr;": "𝔔",
      "&Qopf;": "ℚ",
      "&Qscr;": "𝒬",
      "&RBarr;": "⤐",
      "&REG": "®",
      "&REG;": "®",
      "&Racute;": "Ŕ",
      "&Rang;": "⟫",
      "&Rarr;": "↠",
      "&Rarrtl;": "⤖",
      "&Rcaron;": "Ř",
      "&Rcedil;": "Ŗ",
      "&Rcy;": "Р",
      "&Re;": "ℜ",
      "&ReverseElement;": "∋",
      "&ReverseEquilibrium;": "⇋",
      "&ReverseUpEquilibrium;": "⥯",
      "&Rfr;": "ℜ",
      "&Rho;": "Ρ",
      "&RightAngleBracket;": "⟩",
      "&RightArrow;": "→",
      "&RightArrowBar;": "⇥",
      "&RightArrowLeftArrow;": "⇄",
      "&RightCeiling;": "⌉",
      "&RightDoubleBracket;": "⟧",
      "&RightDownTeeVector;": "⥝",
      "&RightDownVector;": "⇂",
      "&RightDownVectorBar;": "⥕",
      "&RightFloor;": "⌋",
      "&RightTee;": "⊢",
      "&RightTeeArrow;": "↦",
      "&RightTeeVector;": "⥛",
      "&RightTriangle;": "⊳",
      "&RightTriangleBar;": "⧐",
      "&RightTriangleEqual;": "⊵",
      "&RightUpDownVector;": "⥏",
      "&RightUpTeeVector;": "⥜",
      "&RightUpVector;": "↾",
      "&RightUpVectorBar;": "⥔",
      "&RightVector;": "⇀",
      "&RightVectorBar;": "⥓",
      "&Rightarrow;": "⇒",
      "&Ropf;": "ℝ",
      "&RoundImplies;": "⥰",
      "&Rrightarrow;": "⇛",
      "&Rscr;": "ℛ",
      "&Rsh;": "↱",
      "&RuleDelayed;": "⧴",
      "&SHCHcy;": "Щ",
      "&SHcy;": "Ш",
      "&SOFTcy;": "Ь",
      "&Sacute;": "Ś",
      "&Sc;": "⪼",
      "&Scaron;": "Š",
      "&Scedil;": "Ş",
      "&Scirc;": "Ŝ",
      "&Scy;": "С",
      "&Sfr;": "𝔖",
      "&ShortDownArrow;": "↓",
      "&ShortLeftArrow;": "←",
      "&ShortRightArrow;": "→",
      "&ShortUpArrow;": "↑",
      "&Sigma;": "Σ",
      "&SmallCircle;": "∘",
      "&Sopf;": "𝕊",
      "&Sqrt;": "√",
      "&Square;": "□",
      "&SquareIntersection;": "⊓",
      "&SquareSubset;": "⊏",
      "&SquareSubsetEqual;": "⊑",
      "&SquareSuperset;": "⊐",
      "&SquareSupersetEqual;": "⊒",
      "&SquareUnion;": "⊔",
      "&Sscr;": "𝒮",
      "&Star;": "⋆",
      "&Sub;": "⋐",
      "&Subset;": "⋐",
      "&SubsetEqual;": "⊆",
      "&Succeeds;": "≻",
      "&SucceedsEqual;": "⪰",
      "&SucceedsSlantEqual;": "≽",
      "&SucceedsTilde;": "≿",
      "&SuchThat;": "∋",
      "&Sum;": "∑",
      "&Sup;": "⋑",
      "&Superset;": "⊃",
      "&SupersetEqual;": "⊇",
      "&Supset;": "⋑",
      "&THORN": "Þ",
      "&THORN;": "Þ",
      "&TRADE;": "™",
      "&TSHcy;": "Ћ",
      "&TScy;": "Ц",
      "&Tab;": "\t",
      "&Tau;": "Τ",
      "&Tcaron;": "Ť",
      "&Tcedil;": "Ţ",
      "&Tcy;": "Т",
      "&Tfr;": "𝔗",
      "&Therefore;": "∴",
      "&Theta;": "Θ",
      "&ThickSpace;": "  ",
      "&ThinSpace;": " ",
      "&Tilde;": "∼",
      "&TildeEqual;": "≃",
      "&TildeFullEqual;": "≅",
      "&TildeTilde;": "≈",
      "&Topf;": "𝕋",
      "&TripleDot;": "⃛",
      "&Tscr;": "𝒯",
      "&Tstrok;": "Ŧ",
      "&Uacute": "Ú",
      "&Uacute;": "Ú",
      "&Uarr;": "↟",
      "&Uarrocir;": "⥉",
      "&Ubrcy;": "Ў",
      "&Ubreve;": "Ŭ",
      "&Ucirc": "Û",
      "&Ucirc;": "Û",
      "&Ucy;": "У",
      "&Udblac;": "Ű",
      "&Ufr;": "𝔘",
      "&Ugrave": "Ù",
      "&Ugrave;": "Ù",
      "&Umacr;": "Ū",
      "&UnderBar;": "_",
      "&UnderBrace;": "⏟",
      "&UnderBracket;": "⎵",
      "&UnderParenthesis;": "⏝",
      "&Union;": "⋃",
      "&UnionPlus;": "⊎",
      "&Uogon;": "Ų",
      "&Uopf;": "𝕌",
      "&UpArrow;": "↑",
      "&UpArrowBar;": "⤒",
      "&UpArrowDownArrow;": "⇅",
      "&UpDownArrow;": "↕",
      "&UpEquilibrium;": "⥮",
      "&UpTee;": "⊥",
      "&UpTeeArrow;": "↥",
      "&Uparrow;": "⇑",
      "&Updownarrow;": "⇕",
      "&UpperLeftArrow;": "↖",
      "&UpperRightArrow;": "↗",
      "&Upsi;": "ϒ",
      "&Upsilon;": "Υ",
      "&Uring;": "Ů",
      "&Uscr;": "𝒰",
      "&Utilde;": "Ũ",
      "&Uuml": "Ü",
      "&Uuml;": "Ü",
      "&VDash;": "⊫",
      "&Vbar;": "⫫",
      "&Vcy;": "В",
      "&Vdash;": "⊩",
      "&Vdashl;": "⫦",
      "&Vee;": "⋁",
      "&Verbar;": "‖",
      "&Vert;": "‖",
      "&VerticalBar;": "∣",
      "&VerticalLine;": "|",
      "&VerticalSeparator;": "❘",
      "&VerticalTilde;": "≀",
      "&VeryThinSpace;": " ",
      "&Vfr;": "𝔙",
      "&Vopf;": "𝕍",
      "&Vscr;": "𝒱",
      "&Vvdash;": "⊪",
      "&Wcirc;": "Ŵ",
      "&Wedge;": "⋀",
      "&Wfr;": "𝔚",
      "&Wopf;": "𝕎",
      "&Wscr;": "𝒲",
      "&Xfr;": "𝔛",
      "&Xi;": "Ξ",
      "&Xopf;": "𝕏",
      "&Xscr;": "𝒳",
      "&YAcy;": "Я",
      "&YIcy;": "Ї",
      "&YUcy;": "Ю",
      "&Yacute": "Ý",
      "&Yacute;": "Ý",
      "&Ycirc;": "Ŷ",
      "&Ycy;": "Ы",
      "&Yfr;": "𝔜",
      "&Yopf;": "𝕐",
      "&Yscr;": "𝒴",
      "&Yuml;": "Ÿ",
      "&ZHcy;": "Ж",
      "&Zacute;": "Ź",
      "&Zcaron;": "Ž",
      "&Zcy;": "З",
      "&Zdot;": "Ż",
      "&ZeroWidthSpace;": "​",
      "&Zeta;": "Ζ",
      "&Zfr;": "ℨ",
      "&Zopf;": "ℤ",
      "&Zscr;": "𝒵",
      "&aacute": "á",
      "&aacute;": "á",
      "&abreve;": "ă",
      "&ac;": "∾",
      "&acE;": "∾̳",
      "&acd;": "∿",
      "&acirc": "â",
      "&acirc;": "â",
      "&acute": "´",
      "&acute;": "´",
      "&acy;": "а",
      "&aelig": "æ",
      "&aelig;": "æ",
      "&af;": "⁡",
      "&afr;": "𝔞",
      "&agrave": "à",
      "&agrave;": "à",
      "&alefsym;": "ℵ",
      "&aleph;": "ℵ",
      "&alpha;": "α",
      "&amacr;": "ā",
      "&amalg;": "⨿",
      "&amp": "&",
      "&amp;": "&",
      "&and;": "∧",
      "&andand;": "⩕",
      "&andd;": "⩜",
      "&andslope;": "⩘",
      "&andv;": "⩚",
      "&ang;": "∠",
      "&ange;": "⦤",
      "&angle;": "∠",
      "&angmsd;": "∡",
      "&angmsdaa;": "⦨",
      "&angmsdab;": "⦩",
      "&angmsdac;": "⦪",
      "&angmsdad;": "⦫",
      "&angmsdae;": "⦬",
      "&angmsdaf;": "⦭",
      "&angmsdag;": "⦮",
      "&angmsdah;": "⦯",
      "&angrt;": "∟",
      "&angrtvb;": "⊾",
      "&angrtvbd;": "⦝",
      "&angsph;": "∢",
      "&angst;": "Å",
      "&angzarr;": "⍼",
      "&aogon;": "ą",
      "&aopf;": "𝕒",
      "&ap;": "≈",
      "&apE;": "⩰",
      "&apacir;": "⩯",
      "&ape;": "≊",
      "&apid;": "≋",
      "&apos;": "'",
      "&approx;": "≈",
      "&approxeq;": "≊",
      "&aring": "å",
      "&aring;": "å",
      "&ascr;": "𝒶",
      "&ast;": "*",
      "&asymp;": "≈",
      "&asympeq;": "≍",
      "&atilde": "ã",
      "&atilde;": "ã",
      "&auml": "ä",
      "&auml;": "ä",
      "&awconint;": "∳",
      "&awint;": "⨑",
      "&bNot;": "⫭",
      "&backcong;": "≌",
      "&backepsilon;": "϶",
      "&backprime;": "‵",
      "&backsim;": "∽",
      "&backsimeq;": "⋍",
      "&barvee;": "⊽",
      "&barwed;": "⌅",
      "&barwedge;": "⌅",
      "&bbrk;": "⎵",
      "&bbrktbrk;": "⎶",
      "&bcong;": "≌",
      "&bcy;": "б",
      "&bdquo;": "„",
      "&becaus;": "∵",
      "&because;": "∵",
      "&bemptyv;": "⦰",
      "&bepsi;": "϶",
      "&bernou;": "ℬ",
      "&beta;": "β",
      "&beth;": "ℶ",
      "&between;": "≬",
      "&bfr;": "𝔟",
      "&bigcap;": "⋂",
      "&bigcirc;": "◯",
      "&bigcup;": "⋃",
      "&bigodot;": "⨀",
      "&bigoplus;": "⨁",
      "&bigotimes;": "⨂",
      "&bigsqcup;": "⨆",
      "&bigstar;": "★",
      "&bigtriangledown;": "▽",
      "&bigtriangleup;": "△",
      "&biguplus;": "⨄",
      "&bigvee;": "⋁",
      "&bigwedge;": "⋀",
      "&bkarow;": "⤍",
      "&blacklozenge;": "⧫",
      "&blacksquare;": "▪",
      "&blacktriangle;": "▴",
      "&blacktriangledown;": "▾",
      "&blacktriangleleft;": "◂",
      "&blacktriangleright;": "▸",
      "&blank;": "␣",
      "&blk12;": "▒",
      "&blk14;": "░",
      "&blk34;": "▓",
      "&block;": "█",
      "&bne;": "=⃥",
      "&bnequiv;": "≡⃥",
      "&bnot;": "⌐",
      "&bopf;": "𝕓",
      "&bot;": "⊥",
      "&bottom;": "⊥",
      "&bowtie;": "⋈",
      "&boxDL;": "╗",
      "&boxDR;": "╔",
      "&boxDl;": "╖",
      "&boxDr;": "╓",
      "&boxH;": "═",
      "&boxHD;": "╦",
      "&boxHU;": "╩",
      "&boxHd;": "╤",
      "&boxHu;": "╧",
      "&boxUL;": "╝",
      "&boxUR;": "╚",
      "&boxUl;": "╜",
      "&boxUr;": "╙",
      "&boxV;": "║",
      "&boxVH;": "╬",
      "&boxVL;": "╣",
      "&boxVR;": "╠",
      "&boxVh;": "╫",
      "&boxVl;": "╢",
      "&boxVr;": "╟",
      "&boxbox;": "⧉",
      "&boxdL;": "╕",
      "&boxdR;": "╒",
      "&boxdl;": "┐",
      "&boxdr;": "┌",
      "&boxh;": "─",
      "&boxhD;": "╥",
      "&boxhU;": "╨",
      "&boxhd;": "┬",
      "&boxhu;": "┴",
      "&boxminus;": "⊟",
      "&boxplus;": "⊞",
      "&boxtimes;": "⊠",
      "&boxuL;": "╛",
      "&boxuR;": "╘",
      "&boxul;": "┘",
      "&boxur;": "└",
      "&boxv;": "│",
      "&boxvH;": "╪",
      "&boxvL;": "╡",
      "&boxvR;": "╞",
      "&boxvh;": "┼",
      "&boxvl;": "┤",
      "&boxvr;": "├",
      "&bprime;": "‵",
      "&breve;": "˘",
      "&brvbar": "¦",
      "&brvbar;": "¦",
      "&bscr;": "𝒷",
      "&bsemi;": "⁏",
      "&bsim;": "∽",
      "&bsime;": "⋍",
      "&bsol;": "\\",
      "&bsolb;": "⧅",
      "&bsolhsub;": "⟈",
      "&bull;": "•",
      "&bullet;": "•",
      "&bump;": "≎",
      "&bumpE;": "⪮",
      "&bumpe;": "≏",
      "&bumpeq;": "≏",
      "&cacute;": "ć",
      "&cap;": "∩",
      "&capand;": "⩄",
      "&capbrcup;": "⩉",
      "&capcap;": "⩋",
      "&capcup;": "⩇",
      "&capdot;": "⩀",
      "&caps;": "∩︀",
      "&caret;": "⁁",
      "&caron;": "ˇ",
      "&ccaps;": "⩍",
      "&ccaron;": "č",
      "&ccedil": "ç",
      "&ccedil;": "ç",
      "&ccirc;": "ĉ",
      "&ccups;": "⩌",
      "&ccupssm;": "⩐",
      "&cdot;": "ċ",
      "&cedil": "¸",
      "&cedil;": "¸",
      "&cemptyv;": "⦲",
      "&cent": "¢",
      "&cent;": "¢",
      "&centerdot;": "·",
      "&cfr;": "𝔠",
      "&chcy;": "ч",
      "&check;": "✓",
      "&checkmark;": "✓",
      "&chi;": "χ",
      "&cir;": "○",
      "&cirE;": "⧃",
      "&circ;": "ˆ",
      "&circeq;": "≗",
      "&circlearrowleft;": "↺",
      "&circlearrowright;": "↻",
      "&circledR;": "®",
      "&circledS;": "Ⓢ",
      "&circledast;": "⊛",
      "&circledcirc;": "⊚",
      "&circleddash;": "⊝",
      "&cire;": "≗",
      "&cirfnint;": "⨐",
      "&cirmid;": "⫯",
      "&cirscir;": "⧂",
      "&clubs;": "♣",
      "&clubsuit;": "♣",
      "&colon;": ":",
      "&colone;": "≔",
      "&coloneq;": "≔",
      "&comma;": ",",
      "&commat;": "@",
      "&comp;": "∁",
      "&compfn;": "∘",
      "&complement;": "∁",
      "&complexes;": "ℂ",
      "&cong;": "≅",
      "&congdot;": "⩭",
      "&conint;": "∮",
      "&copf;": "𝕔",
      "&coprod;": "∐",
      "&copy": "©",
      "&copy;": "©",
      "&copysr;": "℗",
      "&crarr;": "↵",
      "&cross;": "✗",
      "&cscr;": "𝒸",
      "&csub;": "⫏",
      "&csube;": "⫑",
      "&csup;": "⫐",
      "&csupe;": "⫒",
      "&ctdot;": "⋯",
      "&cudarrl;": "⤸",
      "&cudarrr;": "⤵",
      "&cuepr;": "⋞",
      "&cuesc;": "⋟",
      "&cularr;": "↶",
      "&cularrp;": "⤽",
      "&cup;": "∪",
      "&cupbrcap;": "⩈",
      "&cupcap;": "⩆",
      "&cupcup;": "⩊",
      "&cupdot;": "⊍",
      "&cupor;": "⩅",
      "&cups;": "∪︀",
      "&curarr;": "↷",
      "&curarrm;": "⤼",
      "&curlyeqprec;": "⋞",
      "&curlyeqsucc;": "⋟",
      "&curlyvee;": "⋎",
      "&curlywedge;": "⋏",
      "&curren": "¤",
      "&curren;": "¤",
      "&curvearrowleft;": "↶",
      "&curvearrowright;": "↷",
      "&cuvee;": "⋎",
      "&cuwed;": "⋏",
      "&cwconint;": "∲",
      "&cwint;": "∱",
      "&cylcty;": "⌭",
      "&dArr;": "⇓",
      "&dHar;": "⥥",
      "&dagger;": "†",
      "&daleth;": "ℸ",
      "&darr;": "↓",
      "&dash;": "‐",
      "&dashv;": "⊣",
      "&dbkarow;": "⤏",
      "&dblac;": "˝",
      "&dcaron;": "ď",
      "&dcy;": "д",
      "&dd;": "ⅆ",
      "&ddagger;": "‡",
      "&ddarr;": "⇊",
      "&ddotseq;": "⩷",
      "&deg": "°",
      "&deg;": "°",
      "&delta;": "δ",
      "&demptyv;": "⦱",
      "&dfisht;": "⥿",
      "&dfr;": "𝔡",
      "&dharl;": "⇃",
      "&dharr;": "⇂",
      "&diam;": "⋄",
      "&diamond;": "⋄",
      "&diamondsuit;": "♦",
      "&diams;": "♦",
      "&die;": "¨",
      "&digamma;": "ϝ",
      "&disin;": "⋲",
      "&div;": "÷",
      "&divide": "÷",
      "&divide;": "÷",
      "&divideontimes;": "⋇",
      "&divonx;": "⋇",
      "&djcy;": "ђ",
      "&dlcorn;": "⌞",
      "&dlcrop;": "⌍",
      "&dollar;": "$",
      "&dopf;": "𝕕",
      "&dot;": "˙",
      "&doteq;": "≐",
      "&doteqdot;": "≑",
      "&dotminus;": "∸",
      "&dotplus;": "∔",
      "&dotsquare;": "⊡",
      "&doublebarwedge;": "⌆",
      "&downarrow;": "↓",
      "&downdownarrows;": "⇊",
      "&downharpoonleft;": "⇃",
      "&downharpoonright;": "⇂",
      "&drbkarow;": "⤐",
      "&drcorn;": "⌟",
      "&drcrop;": "⌌",
      "&dscr;": "𝒹",
      "&dscy;": "ѕ",
      "&dsol;": "⧶",
      "&dstrok;": "đ",
      "&dtdot;": "⋱",
      "&dtri;": "▿",
      "&dtrif;": "▾",
      "&duarr;": "⇵",
      "&duhar;": "⥯",
      "&dwangle;": "⦦",
      "&dzcy;": "џ",
      "&dzigrarr;": "⟿",
      "&eDDot;": "⩷",
      "&eDot;": "≑",
      "&eacute": "é",
      "&eacute;": "é",
      "&easter;": "⩮",
      "&ecaron;": "ě",
      "&ecir;": "≖",
      "&ecirc": "ê",
      "&ecirc;": "ê",
      "&ecolon;": "≕",
      "&ecy;": "э",
      "&edot;": "ė",
      "&ee;": "ⅇ",
      "&efDot;": "≒",
      "&efr;": "𝔢",
      "&eg;": "⪚",
      "&egrave": "è",
      "&egrave;": "è",
      "&egs;": "⪖",
      "&egsdot;": "⪘",
      "&el;": "⪙",
      "&elinters;": "⏧",
      "&ell;": "ℓ",
      "&els;": "⪕",
      "&elsdot;": "⪗",
      "&emacr;": "ē",
      "&empty;": "∅",
      "&emptyset;": "∅",
      "&emptyv;": "∅",
      "&emsp13;": " ",
      "&emsp14;": " ",
      "&emsp;": " ",
      "&eng;": "ŋ",
      "&ensp;": " ",
      "&eogon;": "ę",
      "&eopf;": "𝕖",
      "&epar;": "⋕",
      "&eparsl;": "⧣",
      "&eplus;": "⩱",
      "&epsi;": "ε",
      "&epsilon;": "ε",
      "&epsiv;": "ϵ",
      "&eqcirc;": "≖",
      "&eqcolon;": "≕",
      "&eqsim;": "≂",
      "&eqslantgtr;": "⪖",
      "&eqslantless;": "⪕",
      "&equals;": "=",
      "&equest;": "≟",
      "&equiv;": "≡",
      "&equivDD;": "⩸",
      "&eqvparsl;": "⧥",
      "&erDot;": "≓",
      "&erarr;": "⥱",
      "&escr;": "ℯ",
      "&esdot;": "≐",
      "&esim;": "≂",
      "&eta;": "η",
      "&eth": "ð",
      "&eth;": "ð",
      "&euml": "ë",
      "&euml;": "ë",
      "&euro;": "€",
      "&excl;": "!",
      "&exist;": "∃",
      "&expectation;": "ℰ",
      "&exponentiale;": "ⅇ",
      "&fallingdotseq;": "≒",
      "&fcy;": "ф",
      "&female;": "♀",
      "&ffilig;": "ﬃ",
      "&fflig;": "ﬀ",
      "&ffllig;": "ﬄ",
      "&ffr;": "𝔣",
      "&filig;": "ﬁ",
      "&fjlig;": "fj",
      "&flat;": "♭",
      "&fllig;": "ﬂ",
      "&fltns;": "▱",
      "&fnof;": "ƒ",
      "&fopf;": "𝕗",
      "&forall;": "∀",
      "&fork;": "⋔",
      "&forkv;": "⫙",
      "&fpartint;": "⨍",
      "&frac12": "½",
      "&frac12;": "½",
      "&frac13;": "⅓",
      "&frac14": "¼",
      "&frac14;": "¼",
      "&frac15;": "⅕",
      "&frac16;": "⅙",
      "&frac18;": "⅛",
      "&frac23;": "⅔",
      "&frac25;": "⅖",
      "&frac34": "¾",
      "&frac34;": "¾",
      "&frac35;": "⅗",
      "&frac38;": "⅜",
      "&frac45;": "⅘",
      "&frac56;": "⅚",
      "&frac58;": "⅝",
      "&frac78;": "⅞",
      "&frasl;": "⁄",
      "&frown;": "⌢",
      "&fscr;": "𝒻",
      "&gE;": "≧",
      "&gEl;": "⪌",
      "&gacute;": "ǵ",
      "&gamma;": "γ",
      "&gammad;": "ϝ",
      "&gap;": "⪆",
      "&gbreve;": "ğ",
      "&gcirc;": "ĝ",
      "&gcy;": "г",
      "&gdot;": "ġ",
      "&ge;": "≥",
      "&gel;": "⋛",
      "&geq;": "≥",
      "&geqq;": "≧",
      "&geqslant;": "⩾",
      "&ges;": "⩾",
      "&gescc;": "⪩",
      "&gesdot;": "⪀",
      "&gesdoto;": "⪂",
      "&gesdotol;": "⪄",
      "&gesl;": "⋛︀",
      "&gesles;": "⪔",
      "&gfr;": "𝔤",
      "&gg;": "≫",
      "&ggg;": "⋙",
      "&gimel;": "ℷ",
      "&gjcy;": "ѓ",
      "&gl;": "≷",
      "&glE;": "⪒",
      "&gla;": "⪥",
      "&glj;": "⪤",
      "&gnE;": "≩",
      "&gnap;": "⪊",
      "&gnapprox;": "⪊",
      "&gne;": "⪈",
      "&gneq;": "⪈",
      "&gneqq;": "≩",
      "&gnsim;": "⋧",
      "&gopf;": "𝕘",
      "&grave;": "`",
      "&gscr;": "ℊ",
      "&gsim;": "≳",
      "&gsime;": "⪎",
      "&gsiml;": "⪐",
      "&gt": ">",
      "&gt;": ">",
      "&gtcc;": "⪧",
      "&gtcir;": "⩺",
      "&gtdot;": "⋗",
      "&gtlPar;": "⦕",
      "&gtquest;": "⩼",
      "&gtrapprox;": "⪆",
      "&gtrarr;": "⥸",
      "&gtrdot;": "⋗",
      "&gtreqless;": "⋛",
      "&gtreqqless;": "⪌",
      "&gtrless;": "≷",
      "&gtrsim;": "≳",
      "&gvertneqq;": "≩︀",
      "&gvnE;": "≩︀",
      "&hArr;": "⇔",
      "&hairsp;": " ",
      "&half;": "½",
      "&hamilt;": "ℋ",
      "&hardcy;": "ъ",
      "&harr;": "↔",
      "&harrcir;": "⥈",
      "&harrw;": "↭",
      "&hbar;": "ℏ",
      "&hcirc;": "ĥ",
      "&hearts;": "♥",
      "&heartsuit;": "♥",
      "&hellip;": "…",
      "&hercon;": "⊹",
      "&hfr;": "𝔥",
      "&hksearow;": "⤥",
      "&hkswarow;": "⤦",
      "&hoarr;": "⇿",
      "&homtht;": "∻",
      "&hookleftarrow;": "↩",
      "&hookrightarrow;": "↪",
      "&hopf;": "𝕙",
      "&horbar;": "―",
      "&hscr;": "𝒽",
      "&hslash;": "ℏ",
      "&hstrok;": "ħ",
      "&hybull;": "⁃",
      "&hyphen;": "‐",
      "&iacute": "í",
      "&iacute;": "í",
      "&ic;": "⁣",
      "&icirc": "î",
      "&icirc;": "î",
      "&icy;": "и",
      "&iecy;": "е",
      "&iexcl": "¡",
      "&iexcl;": "¡",
      "&iff;": "⇔",
      "&ifr;": "𝔦",
      "&igrave": "ì",
      "&igrave;": "ì",
      "&ii;": "ⅈ",
      "&iiiint;": "⨌",
      "&iiint;": "∭",
      "&iinfin;": "⧜",
      "&iiota;": "℩",
      "&ijlig;": "ĳ",
      "&imacr;": "ī",
      "&image;": "ℑ",
      "&imagline;": "ℐ",
      "&imagpart;": "ℑ",
      "&imath;": "ı",
      "&imof;": "⊷",
      "&imped;": "Ƶ",
      "&in;": "∈",
      "&incare;": "℅",
      "&infin;": "∞",
      "&infintie;": "⧝",
      "&inodot;": "ı",
      "&int;": "∫",
      "&intcal;": "⊺",
      "&integers;": "ℤ",
      "&intercal;": "⊺",
      "&intlarhk;": "⨗",
      "&intprod;": "⨼",
      "&iocy;": "ё",
      "&iogon;": "į",
      "&iopf;": "𝕚",
      "&iota;": "ι",
      "&iprod;": "⨼",
      "&iquest": "¿",
      "&iquest;": "¿",
      "&iscr;": "𝒾",
      "&isin;": "∈",
      "&isinE;": "⋹",
      "&isindot;": "⋵",
      "&isins;": "⋴",
      "&isinsv;": "⋳",
      "&isinv;": "∈",
      "&it;": "⁢",
      "&itilde;": "ĩ",
      "&iukcy;": "і",
      "&iuml": "ï",
      "&iuml;": "ï",
      "&jcirc;": "ĵ",
      "&jcy;": "й",
      "&jfr;": "𝔧",
      "&jmath;": "ȷ",
      "&jopf;": "𝕛",
      "&jscr;": "𝒿",
      "&jsercy;": "ј",
      "&jukcy;": "є",
      "&kappa;": "κ",
      "&kappav;": "ϰ",
      "&kcedil;": "ķ",
      "&kcy;": "к",
      "&kfr;": "𝔨",
      "&kgreen;": "ĸ",
      "&khcy;": "х",
      "&kjcy;": "ќ",
      "&kopf;": "𝕜",
      "&kscr;": "𝓀",
      "&lAarr;": "⇚",
      "&lArr;": "⇐",
      "&lAtail;": "⤛",
      "&lBarr;": "⤎",
      "&lE;": "≦",
      "&lEg;": "⪋",
      "&lHar;": "⥢",
      "&lacute;": "ĺ",
      "&laemptyv;": "⦴",
      "&lagran;": "ℒ",
      "&lambda;": "λ",
      "&lang;": "⟨",
      "&langd;": "⦑",
      "&langle;": "⟨",
      "&lap;": "⪅",
      "&laquo": "«",
      "&laquo;": "«",
      "&larr;": "←",
      "&larrb;": "⇤",
      "&larrbfs;": "⤟",
      "&larrfs;": "⤝",
      "&larrhk;": "↩",
      "&larrlp;": "↫",
      "&larrpl;": "⤹",
      "&larrsim;": "⥳",
      "&larrtl;": "↢",
      "&lat;": "⪫",
      "&latail;": "⤙",
      "&late;": "⪭",
      "&lates;": "⪭︀",
      "&lbarr;": "⤌",
      "&lbbrk;": "❲",
      "&lbrace;": "{",
      "&lbrack;": "[",
      "&lbrke;": "⦋",
      "&lbrksld;": "⦏",
      "&lbrkslu;": "⦍",
      "&lcaron;": "ľ",
      "&lcedil;": "ļ",
      "&lceil;": "⌈",
      "&lcub;": "{",
      "&lcy;": "л",
      "&ldca;": "⤶",
      "&ldquo;": "“",
      "&ldquor;": "„",
      "&ldrdhar;": "⥧",
      "&ldrushar;": "⥋",
      "&ldsh;": "↲",
      "&le;": "≤",
      "&leftarrow;": "←",
      "&leftarrowtail;": "↢",
      "&leftharpoondown;": "↽",
      "&leftharpoonup;": "↼",
      "&leftleftarrows;": "⇇",
      "&leftrightarrow;": "↔",
      "&leftrightarrows;": "⇆",
      "&leftrightharpoons;": "⇋",
      "&leftrightsquigarrow;": "↭",
      "&leftthreetimes;": "⋋",
      "&leg;": "⋚",
      "&leq;": "≤",
      "&leqq;": "≦",
      "&leqslant;": "⩽",
      "&les;": "⩽",
      "&lescc;": "⪨",
      "&lesdot;": "⩿",
      "&lesdoto;": "⪁",
      "&lesdotor;": "⪃",
      "&lesg;": "⋚︀",
      "&lesges;": "⪓",
      "&lessapprox;": "⪅",
      "&lessdot;": "⋖",
      "&lesseqgtr;": "⋚",
      "&lesseqqgtr;": "⪋",
      "&lessgtr;": "≶",
      "&lesssim;": "≲",
      "&lfisht;": "⥼",
      "&lfloor;": "⌊",
      "&lfr;": "𝔩",
      "&lg;": "≶",
      "&lgE;": "⪑",
      "&lhard;": "↽",
      "&lharu;": "↼",
      "&lharul;": "⥪",
      "&lhblk;": "▄",
      "&ljcy;": "љ",
      "&ll;": "≪",
      "&llarr;": "⇇",
      "&llcorner;": "⌞",
      "&llhard;": "⥫",
      "&lltri;": "◺",
      "&lmidot;": "ŀ",
      "&lmoust;": "⎰",
      "&lmoustache;": "⎰",
      "&lnE;": "≨",
      "&lnap;": "⪉",
      "&lnapprox;": "⪉",
      "&lne;": "⪇",
      "&lneq;": "⪇",
      "&lneqq;": "≨",
      "&lnsim;": "⋦",
      "&loang;": "⟬",
      "&loarr;": "⇽",
      "&lobrk;": "⟦",
      "&longleftarrow;": "⟵",
      "&longleftrightarrow;": "⟷",
      "&longmapsto;": "⟼",
      "&longrightarrow;": "⟶",
      "&looparrowleft;": "↫",
      "&looparrowright;": "↬",
      "&lopar;": "⦅",
      "&lopf;": "𝕝",
      "&loplus;": "⨭",
      "&lotimes;": "⨴",
      "&lowast;": "∗",
      "&lowbar;": "_",
      "&loz;": "◊",
      "&lozenge;": "◊",
      "&lozf;": "⧫",
      "&lpar;": "(",
      "&lparlt;": "⦓",
      "&lrarr;": "⇆",
      "&lrcorner;": "⌟",
      "&lrhar;": "⇋",
      "&lrhard;": "⥭",
      "&lrm;": "‎",
      "&lrtri;": "⊿",
      "&lsaquo;": "‹",
      "&lscr;": "𝓁",
      "&lsh;": "↰",
      "&lsim;": "≲",
      "&lsime;": "⪍",
      "&lsimg;": "⪏",
      "&lsqb;": "[",
      "&lsquo;": "‘",
      "&lsquor;": "‚",
      "&lstrok;": "ł",
      "&lt": "<",
      "&lt;": "<",
      "&ltcc;": "⪦",
      "&ltcir;": "⩹",
      "&ltdot;": "⋖",
      "&lthree;": "⋋",
      "&ltimes;": "⋉",
      "&ltlarr;": "⥶",
      "&ltquest;": "⩻",
      "&ltrPar;": "⦖",
      "&ltri;": "◃",
      "&ltrie;": "⊴",
      "&ltrif;": "◂",
      "&lurdshar;": "⥊",
      "&luruhar;": "⥦",
      "&lvertneqq;": "≨︀",
      "&lvnE;": "≨︀",
      "&mDDot;": "∺",
      "&macr": "¯",
      "&macr;": "¯",
      "&male;": "♂",
      "&malt;": "✠",
      "&maltese;": "✠",
      "&map;": "↦",
      "&mapsto;": "↦",
      "&mapstodown;": "↧",
      "&mapstoleft;": "↤",
      "&mapstoup;": "↥",
      "&marker;": "▮",
      "&mcomma;": "⨩",
      "&mcy;": "м",
      "&mdash;": "—",
      "&measuredangle;": "∡",
      "&mfr;": "𝔪",
      "&mho;": "℧",
      "&micro": "µ",
      "&micro;": "µ",
      "&mid;": "∣",
      "&midast;": "*",
      "&midcir;": "⫰",
      "&middot": "·",
      "&middot;": "·",
      "&minus;": "−",
      "&minusb;": "⊟",
      "&minusd;": "∸",
      "&minusdu;": "⨪",
      "&mlcp;": "⫛",
      "&mldr;": "…",
      "&mnplus;": "∓",
      "&models;": "⊧",
      "&mopf;": "𝕞",
      "&mp;": "∓",
      "&mscr;": "𝓂",
      "&mstpos;": "∾",
      "&mu;": "μ",
      "&multimap;": "⊸",
      "&mumap;": "⊸",
      "&nGg;": "⋙̸",
      "&nGt;": "≫⃒",
      "&nGtv;": "≫̸",
      "&nLeftarrow;": "⇍",
      "&nLeftrightarrow;": "⇎",
      "&nLl;": "⋘̸",
      "&nLt;": "≪⃒",
      "&nLtv;": "≪̸",
      "&nRightarrow;": "⇏",
      "&nVDash;": "⊯",
      "&nVdash;": "⊮",
      "&nabla;": "∇",
      "&nacute;": "ń",
      "&nang;": "∠⃒",
      "&nap;": "≉",
      "&napE;": "⩰̸",
      "&napid;": "≋̸",
      "&napos;": "ŉ",
      "&napprox;": "≉",
      "&natur;": "♮",
      "&natural;": "♮",
      "&naturals;": "ℕ",
      "&nbsp": " ",
      "&nbsp;": " ",
      "&nbump;": "≎̸",
      "&nbumpe;": "≏̸",
      "&ncap;": "⩃",
      "&ncaron;": "ň",
      "&ncedil;": "ņ",
      "&ncong;": "≇",
      "&ncongdot;": "⩭̸",
      "&ncup;": "⩂",
      "&ncy;": "н",
      "&ndash;": "–",
      "&ne;": "≠",
      "&neArr;": "⇗",
      "&nearhk;": "⤤",
      "&nearr;": "↗",
      "&nearrow;": "↗",
      "&nedot;": "≐̸",
      "&nequiv;": "≢",
      "&nesear;": "⤨",
      "&nesim;": "≂̸",
      "&nexist;": "∄",
      "&nexists;": "∄",
      "&nfr;": "𝔫",
      "&ngE;": "≧̸",
      "&nge;": "≱",
      "&ngeq;": "≱",
      "&ngeqq;": "≧̸",
      "&ngeqslant;": "⩾̸",
      "&nges;": "⩾̸",
      "&ngsim;": "≵",
      "&ngt;": "≯",
      "&ngtr;": "≯",
      "&nhArr;": "⇎",
      "&nharr;": "↮",
      "&nhpar;": "⫲",
      "&ni;": "∋",
      "&nis;": "⋼",
      "&nisd;": "⋺",
      "&niv;": "∋",
      "&njcy;": "њ",
      "&nlArr;": "⇍",
      "&nlE;": "≦̸",
      "&nlarr;": "↚",
      "&nldr;": "‥",
      "&nle;": "≰",
      "&nleftarrow;": "↚",
      "&nleftrightarrow;": "↮",
      "&nleq;": "≰",
      "&nleqq;": "≦̸",
      "&nleqslant;": "⩽̸",
      "&nles;": "⩽̸",
      "&nless;": "≮",
      "&nlsim;": "≴",
      "&nlt;": "≮",
      "&nltri;": "⋪",
      "&nltrie;": "⋬",
      "&nmid;": "∤",
      "&nopf;": "𝕟",
      "&not": "¬",
      "&not;": "¬",
      "&notin;": "∉",
      "&notinE;": "⋹̸",
      "&notindot;": "⋵̸",
      "&notinva;": "∉",
      "&notinvb;": "⋷",
      "&notinvc;": "⋶",
      "&notni;": "∌",
      "&notniva;": "∌",
      "&notnivb;": "⋾",
      "&notnivc;": "⋽",
      "&npar;": "∦",
      "&nparallel;": "∦",
      "&nparsl;": "⫽⃥",
      "&npart;": "∂̸",
      "&npolint;": "⨔",
      "&npr;": "⊀",
      "&nprcue;": "⋠",
      "&npre;": "⪯̸",
      "&nprec;": "⊀",
      "&npreceq;": "⪯̸",
      "&nrArr;": "⇏",
      "&nrarr;": "↛",
      "&nrarrc;": "⤳̸",
      "&nrarrw;": "↝̸",
      "&nrightarrow;": "↛",
      "&nrtri;": "⋫",
      "&nrtrie;": "⋭",
      "&nsc;": "⊁",
      "&nsccue;": "⋡",
      "&nsce;": "⪰̸",
      "&nscr;": "𝓃",
      "&nshortmid;": "∤",
      "&nshortparallel;": "∦",
      "&nsim;": "≁",
      "&nsime;": "≄",
      "&nsimeq;": "≄",
      "&nsmid;": "∤",
      "&nspar;": "∦",
      "&nsqsube;": "⋢",
      "&nsqsupe;": "⋣",
      "&nsub;": "⊄",
      "&nsubE;": "⫅̸",
      "&nsube;": "⊈",
      "&nsubset;": "⊂⃒",
      "&nsubseteq;": "⊈",
      "&nsubseteqq;": "⫅̸",
      "&nsucc;": "⊁",
      "&nsucceq;": "⪰̸",
      "&nsup;": "⊅",
      "&nsupE;": "⫆̸",
      "&nsupe;": "⊉",
      "&nsupset;": "⊃⃒",
      "&nsupseteq;": "⊉",
      "&nsupseteqq;": "⫆̸",
      "&ntgl;": "≹",
      "&ntilde": "ñ",
      "&ntilde;": "ñ",
      "&ntlg;": "≸",
      "&ntriangleleft;": "⋪",
      "&ntrianglelefteq;": "⋬",
      "&ntriangleright;": "⋫",
      "&ntrianglerighteq;": "⋭",
      "&nu;": "ν",
      "&num;": "#",
      "&numero;": "№",
      "&numsp;": " ",
      "&nvDash;": "⊭",
      "&nvHarr;": "⤄",
      "&nvap;": "≍⃒",
      "&nvdash;": "⊬",
      "&nvge;": "≥⃒",
      "&nvgt;": ">⃒",
      "&nvinfin;": "⧞",
      "&nvlArr;": "⤂",
      "&nvle;": "≤⃒",
      "&nvlt;": "<⃒",
      "&nvltrie;": "⊴⃒",
      "&nvrArr;": "⤃",
      "&nvrtrie;": "⊵⃒",
      "&nvsim;": "∼⃒",
      "&nwArr;": "⇖",
      "&nwarhk;": "⤣",
      "&nwarr;": "↖",
      "&nwarrow;": "↖",
      "&nwnear;": "⤧",
      "&oS;": "Ⓢ",
      "&oacute": "ó",
      "&oacute;": "ó",
      "&oast;": "⊛",
      "&ocir;": "⊚",
      "&ocirc": "ô",
      "&ocirc;": "ô",
      "&ocy;": "о",
      "&odash;": "⊝",
      "&odblac;": "ő",
      "&odiv;": "⨸",
      "&odot;": "⊙",
      "&odsold;": "⦼",
      "&oelig;": "œ",
      "&ofcir;": "⦿",
      "&ofr;": "𝔬",
      "&ogon;": "˛",
      "&ograve": "ò",
      "&ograve;": "ò",
      "&ogt;": "⧁",
      "&ohbar;": "⦵",
      "&ohm;": "Ω",
      "&oint;": "∮",
      "&olarr;": "↺",
      "&olcir;": "⦾",
      "&olcross;": "⦻",
      "&oline;": "‾",
      "&olt;": "⧀",
      "&omacr;": "ō",
      "&omega;": "ω",
      "&omicron;": "ο",
      "&omid;": "⦶",
      "&ominus;": "⊖",
      "&oopf;": "𝕠",
      "&opar;": "⦷",
      "&operp;": "⦹",
      "&oplus;": "⊕",
      "&or;": "∨",
      "&orarr;": "↻",
      "&ord;": "⩝",
      "&order;": "ℴ",
      "&orderof;": "ℴ",
      "&ordf": "ª",
      "&ordf;": "ª",
      "&ordm": "º",
      "&ordm;": "º",
      "&origof;": "⊶",
      "&oror;": "⩖",
      "&orslope;": "⩗",
      "&orv;": "⩛",
      "&oscr;": "ℴ",
      "&oslash": "ø",
      "&oslash;": "ø",
      "&osol;": "⊘",
      "&otilde": "õ",
      "&otilde;": "õ",
      "&otimes;": "⊗",
      "&otimesas;": "⨶",
      "&ouml": "ö",
      "&ouml;": "ö",
      "&ovbar;": "⌽",
      "&par;": "∥",
      "&para": "¶",
      "&para;": "¶",
      "&parallel;": "∥",
      "&parsim;": "⫳",
      "&parsl;": "⫽",
      "&part;": "∂",
      "&pcy;": "п",
      "&percnt;": "%",
      "&period;": ".",
      "&permil;": "‰",
      "&perp;": "⊥",
      "&pertenk;": "‱",
      "&pfr;": "𝔭",
      "&phi;": "φ",
      "&phiv;": "ϕ",
      "&phmmat;": "ℳ",
      "&phone;": "☎",
      "&pi;": "π",
      "&pitchfork;": "⋔",
      "&piv;": "ϖ",
      "&planck;": "ℏ",
      "&planckh;": "ℎ",
      "&plankv;": "ℏ",
      "&plus;": "+",
      "&plusacir;": "⨣",
      "&plusb;": "⊞",
      "&pluscir;": "⨢",
      "&plusdo;": "∔",
      "&plusdu;": "⨥",
      "&pluse;": "⩲",
      "&plusmn": "±",
      "&plusmn;": "±",
      "&plussim;": "⨦",
      "&plustwo;": "⨧",
      "&pm;": "±",
      "&pointint;": "⨕",
      "&popf;": "𝕡",
      "&pound": "£",
      "&pound;": "£",
      "&pr;": "≺",
      "&prE;": "⪳",
      "&prap;": "⪷",
      "&prcue;": "≼",
      "&pre;": "⪯",
      "&prec;": "≺",
      "&precapprox;": "⪷",
      "&preccurlyeq;": "≼",
      "&preceq;": "⪯",
      "&precnapprox;": "⪹",
      "&precneqq;": "⪵",
      "&precnsim;": "⋨",
      "&precsim;": "≾",
      "&prime;": "′",
      "&primes;": "ℙ",
      "&prnE;": "⪵",
      "&prnap;": "⪹",
      "&prnsim;": "⋨",
      "&prod;": "∏",
      "&profalar;": "⌮",
      "&profline;": "⌒",
      "&profsurf;": "⌓",
      "&prop;": "∝",
      "&propto;": "∝",
      "&prsim;": "≾",
      "&prurel;": "⊰",
      "&pscr;": "𝓅",
      "&psi;": "ψ",
      "&puncsp;": " ",
      "&qfr;": "𝔮",
      "&qint;": "⨌",
      "&qopf;": "𝕢",
      "&qprime;": "⁗",
      "&qscr;": "𝓆",
      "&quaternions;": "ℍ",
      "&quatint;": "⨖",
      "&quest;": "?",
      "&questeq;": "≟",
      "&quot": '"',
      "&quot;": '"',
      "&rAarr;": "⇛",
      "&rArr;": "⇒",
      "&rAtail;": "⤜",
      "&rBarr;": "⤏",
      "&rHar;": "⥤",
      "&race;": "∽̱",
      "&racute;": "ŕ",
      "&radic;": "√",
      "&raemptyv;": "⦳",
      "&rang;": "⟩",
      "&rangd;": "⦒",
      "&range;": "⦥",
      "&rangle;": "⟩",
      "&raquo": "»",
      "&raquo;": "»",
      "&rarr;": "→",
      "&rarrap;": "⥵",
      "&rarrb;": "⇥",
      "&rarrbfs;": "⤠",
      "&rarrc;": "⤳",
      "&rarrfs;": "⤞",
      "&rarrhk;": "↪",
      "&rarrlp;": "↬",
      "&rarrpl;": "⥅",
      "&rarrsim;": "⥴",
      "&rarrtl;": "↣",
      "&rarrw;": "↝",
      "&ratail;": "⤚",
      "&ratio;": "∶",
      "&rationals;": "ℚ",
      "&rbarr;": "⤍",
      "&rbbrk;": "❳",
      "&rbrace;": "}",
      "&rbrack;": "]",
      "&rbrke;": "⦌",
      "&rbrksld;": "⦎",
      "&rbrkslu;": "⦐",
      "&rcaron;": "ř",
      "&rcedil;": "ŗ",
      "&rceil;": "⌉",
      "&rcub;": "}",
      "&rcy;": "р",
      "&rdca;": "⤷",
      "&rdldhar;": "⥩",
      "&rdquo;": "”",
      "&rdquor;": "”",
      "&rdsh;": "↳",
      "&real;": "ℜ",
      "&realine;": "ℛ",
      "&realpart;": "ℜ",
      "&reals;": "ℝ",
      "&rect;": "▭",
      "&reg": "®",
      "&reg;": "®",
      "&rfisht;": "⥽",
      "&rfloor;": "⌋",
      "&rfr;": "𝔯",
      "&rhard;": "⇁",
      "&rharu;": "⇀",
      "&rharul;": "⥬",
      "&rho;": "ρ",
      "&rhov;": "ϱ",
      "&rightarrow;": "→",
      "&rightarrowtail;": "↣",
      "&rightharpoondown;": "⇁",
      "&rightharpoonup;": "⇀",
      "&rightleftarrows;": "⇄",
      "&rightleftharpoons;": "⇌",
      "&rightrightarrows;": "⇉",
      "&rightsquigarrow;": "↝",
      "&rightthreetimes;": "⋌",
      "&ring;": "˚",
      "&risingdotseq;": "≓",
      "&rlarr;": "⇄",
      "&rlhar;": "⇌",
      "&rlm;": "‏",
      "&rmoust;": "⎱",
      "&rmoustache;": "⎱",
      "&rnmid;": "⫮",
      "&roang;": "⟭",
      "&roarr;": "⇾",
      "&robrk;": "⟧",
      "&ropar;": "⦆",
      "&ropf;": "𝕣",
      "&roplus;": "⨮",
      "&rotimes;": "⨵",
      "&rpar;": ")",
      "&rpargt;": "⦔",
      "&rppolint;": "⨒",
      "&rrarr;": "⇉",
      "&rsaquo;": "›",
      "&rscr;": "𝓇",
      "&rsh;": "↱",
      "&rsqb;": "]",
      "&rsquo;": "’",
      "&rsquor;": "’",
      "&rthree;": "⋌",
      "&rtimes;": "⋊",
      "&rtri;": "▹",
      "&rtrie;": "⊵",
      "&rtrif;": "▸",
      "&rtriltri;": "⧎",
      "&ruluhar;": "⥨",
      "&rx;": "℞",
      "&sacute;": "ś",
      "&sbquo;": "‚",
      "&sc;": "≻",
      "&scE;": "⪴",
      "&scap;": "⪸",
      "&scaron;": "š",
      "&sccue;": "≽",
      "&sce;": "⪰",
      "&scedil;": "ş",
      "&scirc;": "ŝ",
      "&scnE;": "⪶",
      "&scnap;": "⪺",
      "&scnsim;": "⋩",
      "&scpolint;": "⨓",
      "&scsim;": "≿",
      "&scy;": "с",
      "&sdot;": "⋅",
      "&sdotb;": "⊡",
      "&sdote;": "⩦",
      "&seArr;": "⇘",
      "&searhk;": "⤥",
      "&searr;": "↘",
      "&searrow;": "↘",
      "&sect": "§",
      "&sect;": "§",
      "&semi;": ";",
      "&seswar;": "⤩",
      "&setminus;": "∖",
      "&setmn;": "∖",
      "&sext;": "✶",
      "&sfr;": "𝔰",
      "&sfrown;": "⌢",
      "&sharp;": "♯",
      "&shchcy;": "щ",
      "&shcy;": "ш",
      "&shortmid;": "∣",
      "&shortparallel;": "∥",
      "&shy": "­",
      "&shy;": "­",
      "&sigma;": "σ",
      "&sigmaf;": "ς",
      "&sigmav;": "ς",
      "&sim;": "∼",
      "&simdot;": "⩪",
      "&sime;": "≃",
      "&simeq;": "≃",
      "&simg;": "⪞",
      "&simgE;": "⪠",
      "&siml;": "⪝",
      "&simlE;": "⪟",
      "&simne;": "≆",
      "&simplus;": "⨤",
      "&simrarr;": "⥲",
      "&slarr;": "←",
      "&smallsetminus;": "∖",
      "&smashp;": "⨳",
      "&smeparsl;": "⧤",
      "&smid;": "∣",
      "&smile;": "⌣",
      "&smt;": "⪪",
      "&smte;": "⪬",
      "&smtes;": "⪬︀",
      "&softcy;": "ь",
      "&sol;": "/",
      "&solb;": "⧄",
      "&solbar;": "⌿",
      "&sopf;": "𝕤",
      "&spades;": "♠",
      "&spadesuit;": "♠",
      "&spar;": "∥",
      "&sqcap;": "⊓",
      "&sqcaps;": "⊓︀",
      "&sqcup;": "⊔",
      "&sqcups;": "⊔︀",
      "&sqsub;": "⊏",
      "&sqsube;": "⊑",
      "&sqsubset;": "⊏",
      "&sqsubseteq;": "⊑",
      "&sqsup;": "⊐",
      "&sqsupe;": "⊒",
      "&sqsupset;": "⊐",
      "&sqsupseteq;": "⊒",
      "&squ;": "□",
      "&square;": "□",
      "&squarf;": "▪",
      "&squf;": "▪",
      "&srarr;": "→",
      "&sscr;": "𝓈",
      "&ssetmn;": "∖",
      "&ssmile;": "⌣",
      "&sstarf;": "⋆",
      "&star;": "☆",
      "&starf;": "★",
      "&straightepsilon;": "ϵ",
      "&straightphi;": "ϕ",
      "&strns;": "¯",
      "&sub;": "⊂",
      "&subE;": "⫅",
      "&subdot;": "⪽",
      "&sube;": "⊆",
      "&subedot;": "⫃",
      "&submult;": "⫁",
      "&subnE;": "⫋",
      "&subne;": "⊊",
      "&subplus;": "⪿",
      "&subrarr;": "⥹",
      "&subset;": "⊂",
      "&subseteq;": "⊆",
      "&subseteqq;": "⫅",
      "&subsetneq;": "⊊",
      "&subsetneqq;": "⫋",
      "&subsim;": "⫇",
      "&subsub;": "⫕",
      "&subsup;": "⫓",
      "&succ;": "≻",
      "&succapprox;": "⪸",
      "&succcurlyeq;": "≽",
      "&succeq;": "⪰",
      "&succnapprox;": "⪺",
      "&succneqq;": "⪶",
      "&succnsim;": "⋩",
      "&succsim;": "≿",
      "&sum;": "∑",
      "&sung;": "♪",
      "&sup1": "¹",
      "&sup1;": "¹",
      "&sup2": "²",
      "&sup2;": "²",
      "&sup3": "³",
      "&sup3;": "³",
      "&sup;": "⊃",
      "&supE;": "⫆",
      "&supdot;": "⪾",
      "&supdsub;": "⫘",
      "&supe;": "⊇",
      "&supedot;": "⫄",
      "&suphsol;": "⟉",
      "&suphsub;": "⫗",
      "&suplarr;": "⥻",
      "&supmult;": "⫂",
      "&supnE;": "⫌",
      "&supne;": "⊋",
      "&supplus;": "⫀",
      "&supset;": "⊃",
      "&supseteq;": "⊇",
      "&supseteqq;": "⫆",
      "&supsetneq;": "⊋",
      "&supsetneqq;": "⫌",
      "&supsim;": "⫈",
      "&supsub;": "⫔",
      "&supsup;": "⫖",
      "&swArr;": "⇙",
      "&swarhk;": "⤦",
      "&swarr;": "↙",
      "&swarrow;": "↙",
      "&swnwar;": "⤪",
      "&szlig": "ß",
      "&szlig;": "ß",
      "&target;": "⌖",
      "&tau;": "τ",
      "&tbrk;": "⎴",
      "&tcaron;": "ť",
      "&tcedil;": "ţ",
      "&tcy;": "т",
      "&tdot;": "⃛",
      "&telrec;": "⌕",
      "&tfr;": "𝔱",
      "&there4;": "∴",
      "&therefore;": "∴",
      "&theta;": "θ",
      "&thetasym;": "ϑ",
      "&thetav;": "ϑ",
      "&thickapprox;": "≈",
      "&thicksim;": "∼",
      "&thinsp;": " ",
      "&thkap;": "≈",
      "&thksim;": "∼",
      "&thorn": "þ",
      "&thorn;": "þ",
      "&tilde;": "˜",
      "&times": "×",
      "&times;": "×",
      "&timesb;": "⊠",
      "&timesbar;": "⨱",
      "&timesd;": "⨰",
      "&tint;": "∭",
      "&toea;": "⤨",
      "&top;": "⊤",
      "&topbot;": "⌶",
      "&topcir;": "⫱",
      "&topf;": "𝕥",
      "&topfork;": "⫚",
      "&tosa;": "⤩",
      "&tprime;": "‴",
      "&trade;": "™",
      "&triangle;": "▵",
      "&triangledown;": "▿",
      "&triangleleft;": "◃",
      "&trianglelefteq;": "⊴",
      "&triangleq;": "≜",
      "&triangleright;": "▹",
      "&trianglerighteq;": "⊵",
      "&tridot;": "◬",
      "&trie;": "≜",
      "&triminus;": "⨺",
      "&triplus;": "⨹",
      "&trisb;": "⧍",
      "&tritime;": "⨻",
      "&trpezium;": "⏢",
      "&tscr;": "𝓉",
      "&tscy;": "ц",
      "&tshcy;": "ћ",
      "&tstrok;": "ŧ",
      "&twixt;": "≬",
      "&twoheadleftarrow;": "↞",
      "&twoheadrightarrow;": "↠",
      "&uArr;": "⇑",
      "&uHar;": "⥣",
      "&uacute": "ú",
      "&uacute;": "ú",
      "&uarr;": "↑",
      "&ubrcy;": "ў",
      "&ubreve;": "ŭ",
      "&ucirc": "û",
      "&ucirc;": "û",
      "&ucy;": "у",
      "&udarr;": "⇅",
      "&udblac;": "ű",
      "&udhar;": "⥮",
      "&ufisht;": "⥾",
      "&ufr;": "𝔲",
      "&ugrave": "ù",
      "&ugrave;": "ù",
      "&uharl;": "↿",
      "&uharr;": "↾",
      "&uhblk;": "▀",
      "&ulcorn;": "⌜",
      "&ulcorner;": "⌜",
      "&ulcrop;": "⌏",
      "&ultri;": "◸",
      "&umacr;": "ū",
      "&uml": "¨",
      "&uml;": "¨",
      "&uogon;": "ų",
      "&uopf;": "𝕦",
      "&uparrow;": "↑",
      "&updownarrow;": "↕",
      "&upharpoonleft;": "↿",
      "&upharpoonright;": "↾",
      "&uplus;": "⊎",
      "&upsi;": "υ",
      "&upsih;": "ϒ",
      "&upsilon;": "υ",
      "&upuparrows;": "⇈",
      "&urcorn;": "⌝",
      "&urcorner;": "⌝",
      "&urcrop;": "⌎",
      "&uring;": "ů",
      "&urtri;": "◹",
      "&uscr;": "𝓊",
      "&utdot;": "⋰",
      "&utilde;": "ũ",
      "&utri;": "▵",
      "&utrif;": "▴",
      "&uuarr;": "⇈",
      "&uuml": "ü",
      "&uuml;": "ü",
      "&uwangle;": "⦧",
      "&vArr;": "⇕",
      "&vBar;": "⫨",
      "&vBarv;": "⫩",
      "&vDash;": "⊨",
      "&vangrt;": "⦜",
      "&varepsilon;": "ϵ",
      "&varkappa;": "ϰ",
      "&varnothing;": "∅",
      "&varphi;": "ϕ",
      "&varpi;": "ϖ",
      "&varpropto;": "∝",
      "&varr;": "↕",
      "&varrho;": "ϱ",
      "&varsigma;": "ς",
      "&varsubsetneq;": "⊊︀",
      "&varsubsetneqq;": "⫋︀",
      "&varsupsetneq;": "⊋︀",
      "&varsupsetneqq;": "⫌︀",
      "&vartheta;": "ϑ",
      "&vartriangleleft;": "⊲",
      "&vartriangleright;": "⊳",
      "&vcy;": "в",
      "&vdash;": "⊢",
      "&vee;": "∨",
      "&veebar;": "⊻",
      "&veeeq;": "≚",
      "&vellip;": "⋮",
      "&verbar;": "|",
      "&vert;": "|",
      "&vfr;": "𝔳",
      "&vltri;": "⊲",
      "&vnsub;": "⊂⃒",
      "&vnsup;": "⊃⃒",
      "&vopf;": "𝕧",
      "&vprop;": "∝",
      "&vrtri;": "⊳",
      "&vscr;": "𝓋",
      "&vsubnE;": "⫋︀",
      "&vsubne;": "⊊︀",
      "&vsupnE;": "⫌︀",
      "&vsupne;": "⊋︀",
      "&vzigzag;": "⦚",
      "&wcirc;": "ŵ",
      "&wedbar;": "⩟",
      "&wedge;": "∧",
      "&wedgeq;": "≙",
      "&weierp;": "℘",
      "&wfr;": "𝔴",
      "&wopf;": "𝕨",
      "&wp;": "℘",
      "&wr;": "≀",
      "&wreath;": "≀",
      "&wscr;": "𝓌",
      "&xcap;": "⋂",
      "&xcirc;": "◯",
      "&xcup;": "⋃",
      "&xdtri;": "▽",
      "&xfr;": "𝔵",
      "&xhArr;": "⟺",
      "&xharr;": "⟷",
      "&xi;": "ξ",
      "&xlArr;": "⟸",
      "&xlarr;": "⟵",
      "&xmap;": "⟼",
      "&xnis;": "⋻",
      "&xodot;": "⨀",
      "&xopf;": "𝕩",
      "&xoplus;": "⨁",
      "&xotime;": "⨂",
      "&xrArr;": "⟹",
      "&xrarr;": "⟶",
      "&xscr;": "𝓍",
      "&xsqcup;": "⨆",
      "&xuplus;": "⨄",
      "&xutri;": "△",
      "&xvee;": "⋁",
      "&xwedge;": "⋀",
      "&yacute": "ý",
      "&yacute;": "ý",
      "&yacy;": "я",
      "&ycirc;": "ŷ",
      "&ycy;": "ы",
      "&yen": "¥",
      "&yen;": "¥",
      "&yfr;": "𝔶",
      "&yicy;": "ї",
      "&yopf;": "𝕪",
      "&yscr;": "𝓎",
      "&yucy;": "ю",
      "&yuml": "ÿ",
      "&yuml;": "ÿ",
      "&zacute;": "ź",
      "&zcaron;": "ž",
      "&zcy;": "з",
      "&zdot;": "ż",
      "&zeetrf;": "ℨ",
      "&zeta;": "ζ",
      "&zfr;": "𝔷",
      "&zhcy;": "ж",
      "&zigrarr;": "⇝",
      "&zopf;": "𝕫",
      "&zscr;": "𝓏",
      "&zwj;": "‍",
      "&zwnj;": "‌"
    },
    characters: {
      "Æ": "&AElig;",
      "&": "&amp;",
      "Á": "&Aacute;",
      "Ă": "&Abreve;",
      "Â": "&Acirc;",
      "А": "&Acy;",
      "𝔄": "&Afr;",
      "À": "&Agrave;",
      "Α": "&Alpha;",
      "Ā": "&Amacr;",
      "⩓": "&And;",
      "Ą": "&Aogon;",
      "𝔸": "&Aopf;",
      "⁡": "&af;",
      "Å": "&angst;",
      "𝒜": "&Ascr;",
      "≔": "&coloneq;",
      "Ã": "&Atilde;",
      "Ä": "&Auml;",
      "∖": "&ssetmn;",
      "⫧": "&Barv;",
      "⌆": "&doublebarwedge;",
      "Б": "&Bcy;",
      "∵": "&because;",
      "ℬ": "&bernou;",
      "Β": "&Beta;",
      "𝔅": "&Bfr;",
      "𝔹": "&Bopf;",
      "˘": "&breve;",
      "≎": "&bump;",
      "Ч": "&CHcy;",
      "©": "&copy;",
      "Ć": "&Cacute;",
      "⋒": "&Cap;",
      "ⅅ": "&DD;",
      "ℭ": "&Cfr;",
      "Č": "&Ccaron;",
      "Ç": "&Ccedil;",
      "Ĉ": "&Ccirc;",
      "∰": "&Cconint;",
      "Ċ": "&Cdot;",
      "¸": "&cedil;",
      "·": "&middot;",
      "Χ": "&Chi;",
      "⊙": "&odot;",
      "⊖": "&ominus;",
      "⊕": "&oplus;",
      "⊗": "&otimes;",
      "∲": "&cwconint;",
      "”": "&rdquor;",
      "’": "&rsquor;",
      "∷": "&Proportion;",
      "⩴": "&Colone;",
      "≡": "&equiv;",
      "∯": "&DoubleContourIntegral;",
      "∮": "&oint;",
      "ℂ": "&complexes;",
      "∐": "&coprod;",
      "∳": "&awconint;",
      "⨯": "&Cross;",
      "𝒞": "&Cscr;",
      "⋓": "&Cup;",
      "≍": "&asympeq;",
      "⤑": "&DDotrahd;",
      "Ђ": "&DJcy;",
      "Ѕ": "&DScy;",
      "Џ": "&DZcy;",
      "‡": "&ddagger;",
      "↡": "&Darr;",
      "⫤": "&DoubleLeftTee;",
      "Ď": "&Dcaron;",
      "Д": "&Dcy;",
      "∇": "&nabla;",
      "Δ": "&Delta;",
      "𝔇": "&Dfr;",
      "´": "&acute;",
      "˙": "&dot;",
      "˝": "&dblac;",
      "`": "&grave;",
      "˜": "&tilde;",
      "⋄": "&diamond;",
      "ⅆ": "&dd;",
      "𝔻": "&Dopf;",
      "¨": "&uml;",
      "⃜": "&DotDot;",
      "≐": "&esdot;",
      "⇓": "&dArr;",
      "⇐": "&lArr;",
      "⇔": "&iff;",
      "⟸": "&xlArr;",
      "⟺": "&xhArr;",
      "⟹": "&xrArr;",
      "⇒": "&rArr;",
      "⊨": "&vDash;",
      "⇑": "&uArr;",
      "⇕": "&vArr;",
      "∥": "&spar;",
      "↓": "&downarrow;",
      "⤓": "&DownArrowBar;",
      "⇵": "&duarr;",
      "̑": "&DownBreve;",
      "⥐": "&DownLeftRightVector;",
      "⥞": "&DownLeftTeeVector;",
      "↽": "&lhard;",
      "⥖": "&DownLeftVectorBar;",
      "⥟": "&DownRightTeeVector;",
      "⇁": "&rightharpoondown;",
      "⥗": "&DownRightVectorBar;",
      "⊤": "&top;",
      "↧": "&mapstodown;",
      "𝒟": "&Dscr;",
      "Đ": "&Dstrok;",
      "Ŋ": "&ENG;",
      "Ð": "&ETH;",
      "É": "&Eacute;",
      "Ě": "&Ecaron;",
      "Ê": "&Ecirc;",
      "Э": "&Ecy;",
      "Ė": "&Edot;",
      "𝔈": "&Efr;",
      "È": "&Egrave;",
      "∈": "&isinv;",
      "Ē": "&Emacr;",
      "◻": "&EmptySmallSquare;",
      "▫": "&EmptyVerySmallSquare;",
      "Ę": "&Eogon;",
      "𝔼": "&Eopf;",
      "Ε": "&Epsilon;",
      "⩵": "&Equal;",
      "≂": "&esim;",
      "⇌": "&rlhar;",
      "ℰ": "&expectation;",
      "⩳": "&Esim;",
      "Η": "&Eta;",
      "Ë": "&Euml;",
      "∃": "&exist;",
      "ⅇ": "&exponentiale;",
      "Ф": "&Fcy;",
      "𝔉": "&Ffr;",
      "◼": "&FilledSmallSquare;",
      "▪": "&squf;",
      "𝔽": "&Fopf;",
      "∀": "&forall;",
      "ℱ": "&Fscr;",
      "Ѓ": "&GJcy;",
      ">": "&gt;",
      "Γ": "&Gamma;",
      "Ϝ": "&Gammad;",
      "Ğ": "&Gbreve;",
      "Ģ": "&Gcedil;",
      "Ĝ": "&Gcirc;",
      "Г": "&Gcy;",
      "Ġ": "&Gdot;",
      "𝔊": "&Gfr;",
      "⋙": "&ggg;",
      "𝔾": "&Gopf;",
      "≥": "&geq;",
      "⋛": "&gtreqless;",
      "≧": "&geqq;",
      "⪢": "&GreaterGreater;",
      "≷": "&gtrless;",
      "⩾": "&ges;",
      "≳": "&gtrsim;",
      "𝒢": "&Gscr;",
      "≫": "&gg;",
      "Ъ": "&HARDcy;",
      "ˇ": "&caron;",
      "^": "&Hat;",
      "Ĥ": "&Hcirc;",
      "ℌ": "&Poincareplane;",
      "ℋ": "&hamilt;",
      "ℍ": "&quaternions;",
      "─": "&boxh;",
      "Ħ": "&Hstrok;",
      "≏": "&bumpeq;",
      "Е": "&IEcy;",
      "Ĳ": "&IJlig;",
      "Ё": "&IOcy;",
      "Í": "&Iacute;",
      "Î": "&Icirc;",
      "И": "&Icy;",
      "İ": "&Idot;",
      "ℑ": "&imagpart;",
      "Ì": "&Igrave;",
      "Ī": "&Imacr;",
      "ⅈ": "&ii;",
      "∬": "&Int;",
      "∫": "&int;",
      "⋂": "&xcap;",
      "⁣": "&ic;",
      "⁢": "&it;",
      "Į": "&Iogon;",
      "𝕀": "&Iopf;",
      "Ι": "&Iota;",
      "ℐ": "&imagline;",
      "Ĩ": "&Itilde;",
      "І": "&Iukcy;",
      "Ï": "&Iuml;",
      "Ĵ": "&Jcirc;",
      "Й": "&Jcy;",
      "𝔍": "&Jfr;",
      "𝕁": "&Jopf;",
      "𝒥": "&Jscr;",
      "Ј": "&Jsercy;",
      "Є": "&Jukcy;",
      "Х": "&KHcy;",
      "Ќ": "&KJcy;",
      "Κ": "&Kappa;",
      "Ķ": "&Kcedil;",
      "К": "&Kcy;",
      "𝔎": "&Kfr;",
      "𝕂": "&Kopf;",
      "𝒦": "&Kscr;",
      "Љ": "&LJcy;",
      "<": "&lt;",
      "Ĺ": "&Lacute;",
      "Λ": "&Lambda;",
      "⟪": "&Lang;",
      "ℒ": "&lagran;",
      "↞": "&twoheadleftarrow;",
      "Ľ": "&Lcaron;",
      "Ļ": "&Lcedil;",
      "Л": "&Lcy;",
      "⟨": "&langle;",
      "←": "&slarr;",
      "⇤": "&larrb;",
      "⇆": "&lrarr;",
      "⌈": "&lceil;",
      "⟦": "&lobrk;",
      "⥡": "&LeftDownTeeVector;",
      "⇃": "&downharpoonleft;",
      "⥙": "&LeftDownVectorBar;",
      "⌊": "&lfloor;",
      "↔": "&leftrightarrow;",
      "⥎": "&LeftRightVector;",
      "⊣": "&dashv;",
      "↤": "&mapstoleft;",
      "⥚": "&LeftTeeVector;",
      "⊲": "&vltri;",
      "⧏": "&LeftTriangleBar;",
      "⊴": "&trianglelefteq;",
      "⥑": "&LeftUpDownVector;",
      "⥠": "&LeftUpTeeVector;",
      "↿": "&upharpoonleft;",
      "⥘": "&LeftUpVectorBar;",
      "↼": "&lharu;",
      "⥒": "&LeftVectorBar;",
      "⋚": "&lesseqgtr;",
      "≦": "&leqq;",
      "≶": "&lg;",
      "⪡": "&LessLess;",
      "⩽": "&les;",
      "≲": "&lsim;",
      "𝔏": "&Lfr;",
      "⋘": "&Ll;",
      "⇚": "&lAarr;",
      "Ŀ": "&Lmidot;",
      "⟵": "&xlarr;",
      "⟷": "&xharr;",
      "⟶": "&xrarr;",
      "𝕃": "&Lopf;",
      "↙": "&swarrow;",
      "↘": "&searrow;",
      "↰": "&lsh;",
      "Ł": "&Lstrok;",
      "≪": "&ll;",
      "⤅": "&Map;",
      "М": "&Mcy;",
      " ": "&MediumSpace;",
      "ℳ": "&phmmat;",
      "𝔐": "&Mfr;",
      "∓": "&mp;",
      "𝕄": "&Mopf;",
      "Μ": "&Mu;",
      "Њ": "&NJcy;",
      "Ń": "&Nacute;",
      "Ň": "&Ncaron;",
      "Ņ": "&Ncedil;",
      "Н": "&Ncy;",
      "​": "&ZeroWidthSpace;",
      "\n": "&NewLine;",
      "𝔑": "&Nfr;",
      "⁠": "&NoBreak;",
      " ": "&nbsp;",
      "ℕ": "&naturals;",
      "⫬": "&Not;",
      "≢": "&nequiv;",
      "≭": "&NotCupCap;",
      "∦": "&nspar;",
      "∉": "&notinva;",
      "≠": "&ne;",
      "≂̸": "&nesim;",
      "∄": "&nexists;",
      "≯": "&ngtr;",
      "≱": "&ngeq;",
      "≧̸": "&ngeqq;",
      "≫̸": "&nGtv;",
      "≹": "&ntgl;",
      "⩾̸": "&nges;",
      "≵": "&ngsim;",
      "≎̸": "&nbump;",
      "≏̸": "&nbumpe;",
      "⋪": "&ntriangleleft;",
      "⧏̸": "&NotLeftTriangleBar;",
      "⋬": "&ntrianglelefteq;",
      "≮": "&nlt;",
      "≰": "&nleq;",
      "≸": "&ntlg;",
      "≪̸": "&nLtv;",
      "⩽̸": "&nles;",
      "≴": "&nlsim;",
      "⪢̸": "&NotNestedGreaterGreater;",
      "⪡̸": "&NotNestedLessLess;",
      "⊀": "&nprec;",
      "⪯̸": "&npreceq;",
      "⋠": "&nprcue;",
      "∌": "&notniva;",
      "⋫": "&ntriangleright;",
      "⧐̸": "&NotRightTriangleBar;",
      "⋭": "&ntrianglerighteq;",
      "⊏̸": "&NotSquareSubset;",
      "⋢": "&nsqsube;",
      "⊐̸": "&NotSquareSuperset;",
      "⋣": "&nsqsupe;",
      "⊂⃒": "&vnsub;",
      "⊈": "&nsubseteq;",
      "⊁": "&nsucc;",
      "⪰̸": "&nsucceq;",
      "⋡": "&nsccue;",
      "≿̸": "&NotSucceedsTilde;",
      "⊃⃒": "&vnsup;",
      "⊉": "&nsupseteq;",
      "≁": "&nsim;",
      "≄": "&nsimeq;",
      "≇": "&ncong;",
      "≉": "&napprox;",
      "∤": "&nsmid;",
      "𝒩": "&Nscr;",
      "Ñ": "&Ntilde;",
      "Ν": "&Nu;",
      "Œ": "&OElig;",
      "Ó": "&Oacute;",
      "Ô": "&Ocirc;",
      "О": "&Ocy;",
      "Ő": "&Odblac;",
      "𝔒": "&Ofr;",
      "Ò": "&Ograve;",
      "Ō": "&Omacr;",
      "Ω": "&ohm;",
      "Ο": "&Omicron;",
      "𝕆": "&Oopf;",
      "“": "&ldquo;",
      "‘": "&lsquo;",
      "⩔": "&Or;",
      "𝒪": "&Oscr;",
      "Ø": "&Oslash;",
      "Õ": "&Otilde;",
      "⨷": "&Otimes;",
      "Ö": "&Ouml;",
      "‾": "&oline;",
      "⏞": "&OverBrace;",
      "⎴": "&tbrk;",
      "⏜": "&OverParenthesis;",
      "∂": "&part;",
      "П": "&Pcy;",
      "𝔓": "&Pfr;",
      "Φ": "&Phi;",
      "Π": "&Pi;",
      "±": "&pm;",
      "ℙ": "&primes;",
      "⪻": "&Pr;",
      "≺": "&prec;",
      "⪯": "&preceq;",
      "≼": "&preccurlyeq;",
      "≾": "&prsim;",
      "″": "&Prime;",
      "∏": "&prod;",
      "∝": "&vprop;",
      "𝒫": "&Pscr;",
      "Ψ": "&Psi;",
      '"': "&quot;",
      "𝔔": "&Qfr;",
      "ℚ": "&rationals;",
      "𝒬": "&Qscr;",
      "⤐": "&drbkarow;",
      "®": "&reg;",
      "Ŕ": "&Racute;",
      "⟫": "&Rang;",
      "↠": "&twoheadrightarrow;",
      "⤖": "&Rarrtl;",
      "Ř": "&Rcaron;",
      "Ŗ": "&Rcedil;",
      "Р": "&Rcy;",
      "ℜ": "&realpart;",
      "∋": "&niv;",
      "⇋": "&lrhar;",
      "⥯": "&duhar;",
      "Ρ": "&Rho;",
      "⟩": "&rangle;",
      "→": "&srarr;",
      "⇥": "&rarrb;",
      "⇄": "&rlarr;",
      "⌉": "&rceil;",
      "⟧": "&robrk;",
      "⥝": "&RightDownTeeVector;",
      "⇂": "&downharpoonright;",
      "⥕": "&RightDownVectorBar;",
      "⌋": "&rfloor;",
      "⊢": "&vdash;",
      "↦": "&mapsto;",
      "⥛": "&RightTeeVector;",
      "⊳": "&vrtri;",
      "⧐": "&RightTriangleBar;",
      "⊵": "&trianglerighteq;",
      "⥏": "&RightUpDownVector;",
      "⥜": "&RightUpTeeVector;",
      "↾": "&upharpoonright;",
      "⥔": "&RightUpVectorBar;",
      "⇀": "&rightharpoonup;",
      "⥓": "&RightVectorBar;",
      "ℝ": "&reals;",
      "⥰": "&RoundImplies;",
      "⇛": "&rAarr;",
      "ℛ": "&realine;",
      "↱": "&rsh;",
      "⧴": "&RuleDelayed;",
      "Щ": "&SHCHcy;",
      "Ш": "&SHcy;",
      "Ь": "&SOFTcy;",
      "Ś": "&Sacute;",
      "⪼": "&Sc;",
      "Š": "&Scaron;",
      "Ş": "&Scedil;",
      "Ŝ": "&Scirc;",
      "С": "&Scy;",
      "𝔖": "&Sfr;",
      "↑": "&uparrow;",
      "Σ": "&Sigma;",
      "∘": "&compfn;",
      "𝕊": "&Sopf;",
      "√": "&radic;",
      "□": "&square;",
      "⊓": "&sqcap;",
      "⊏": "&sqsubset;",
      "⊑": "&sqsubseteq;",
      "⊐": "&sqsupset;",
      "⊒": "&sqsupseteq;",
      "⊔": "&sqcup;",
      "𝒮": "&Sscr;",
      "⋆": "&sstarf;",
      "⋐": "&Subset;",
      "⊆": "&subseteq;",
      "≻": "&succ;",
      "⪰": "&succeq;",
      "≽": "&succcurlyeq;",
      "≿": "&succsim;",
      "∑": "&sum;",
      "⋑": "&Supset;",
      "⊃": "&supset;",
      "⊇": "&supseteq;",
      "Þ": "&THORN;",
      "™": "&trade;",
      "Ћ": "&TSHcy;",
      "Ц": "&TScy;",
      "\t": "&Tab;",
      "Τ": "&Tau;",
      "Ť": "&Tcaron;",
      "Ţ": "&Tcedil;",
      "Т": "&Tcy;",
      "𝔗": "&Tfr;",
      "∴": "&therefore;",
      "Θ": "&Theta;",
      "  ": "&ThickSpace;",
      " ": "&thinsp;",
      "∼": "&thksim;",
      "≃": "&simeq;",
      "≅": "&cong;",
      "≈": "&thkap;",
      "𝕋": "&Topf;",
      "⃛": "&tdot;",
      "𝒯": "&Tscr;",
      "Ŧ": "&Tstrok;",
      "Ú": "&Uacute;",
      "↟": "&Uarr;",
      "⥉": "&Uarrocir;",
      "Ў": "&Ubrcy;",
      "Ŭ": "&Ubreve;",
      "Û": "&Ucirc;",
      "У": "&Ucy;",
      "Ű": "&Udblac;",
      "𝔘": "&Ufr;",
      "Ù": "&Ugrave;",
      "Ū": "&Umacr;",
      _: "&lowbar;",
      "⏟": "&UnderBrace;",
      "⎵": "&bbrk;",
      "⏝": "&UnderParenthesis;",
      "⋃": "&xcup;",
      "⊎": "&uplus;",
      "Ų": "&Uogon;",
      "𝕌": "&Uopf;",
      "⤒": "&UpArrowBar;",
      "⇅": "&udarr;",
      "↕": "&varr;",
      "⥮": "&udhar;",
      "⊥": "&perp;",
      "↥": "&mapstoup;",
      "↖": "&nwarrow;",
      "↗": "&nearrow;",
      "ϒ": "&upsih;",
      "Υ": "&Upsilon;",
      "Ů": "&Uring;",
      "𝒰": "&Uscr;",
      "Ũ": "&Utilde;",
      "Ü": "&Uuml;",
      "⊫": "&VDash;",
      "⫫": "&Vbar;",
      "В": "&Vcy;",
      "⊩": "&Vdash;",
      "⫦": "&Vdashl;",
      "⋁": "&xvee;",
      "‖": "&Vert;",
      "∣": "&smid;",
      "|": "&vert;",
      "❘": "&VerticalSeparator;",
      "≀": "&wreath;",
      " ": "&hairsp;",
      "𝔙": "&Vfr;",
      "𝕍": "&Vopf;",
      "𝒱": "&Vscr;",
      "⊪": "&Vvdash;",
      "Ŵ": "&Wcirc;",
      "⋀": "&xwedge;",
      "𝔚": "&Wfr;",
      "𝕎": "&Wopf;",
      "𝒲": "&Wscr;",
      "𝔛": "&Xfr;",
      "Ξ": "&Xi;",
      "𝕏": "&Xopf;",
      "𝒳": "&Xscr;",
      "Я": "&YAcy;",
      "Ї": "&YIcy;",
      "Ю": "&YUcy;",
      "Ý": "&Yacute;",
      "Ŷ": "&Ycirc;",
      "Ы": "&Ycy;",
      "𝔜": "&Yfr;",
      "𝕐": "&Yopf;",
      "𝒴": "&Yscr;",
      "Ÿ": "&Yuml;",
      "Ж": "&ZHcy;",
      "Ź": "&Zacute;",
      "Ž": "&Zcaron;",
      "З": "&Zcy;",
      "Ż": "&Zdot;",
      "Ζ": "&Zeta;",
      "ℨ": "&zeetrf;",
      "ℤ": "&integers;",
      "𝒵": "&Zscr;",
      "á": "&aacute;",
      "ă": "&abreve;",
      "∾": "&mstpos;",
      "∾̳": "&acE;",
      "∿": "&acd;",
      "â": "&acirc;",
      "а": "&acy;",
      "æ": "&aelig;",
      "𝔞": "&afr;",
      "à": "&agrave;",
      "ℵ": "&aleph;",
      "α": "&alpha;",
      "ā": "&amacr;",
      "⨿": "&amalg;",
      "∧": "&wedge;",
      "⩕": "&andand;",
      "⩜": "&andd;",
      "⩘": "&andslope;",
      "⩚": "&andv;",
      "∠": "&angle;",
      "⦤": "&ange;",
      "∡": "&measuredangle;",
      "⦨": "&angmsdaa;",
      "⦩": "&angmsdab;",
      "⦪": "&angmsdac;",
      "⦫": "&angmsdad;",
      "⦬": "&angmsdae;",
      "⦭": "&angmsdaf;",
      "⦮": "&angmsdag;",
      "⦯": "&angmsdah;",
      "∟": "&angrt;",
      "⊾": "&angrtvb;",
      "⦝": "&angrtvbd;",
      "∢": "&angsph;",
      "⍼": "&angzarr;",
      "ą": "&aogon;",
      "𝕒": "&aopf;",
      "⩰": "&apE;",
      "⩯": "&apacir;",
      "≊": "&approxeq;",
      "≋": "&apid;",
      "'": "&apos;",
      "å": "&aring;",
      "𝒶": "&ascr;",
      "*": "&midast;",
      "ã": "&atilde;",
      "ä": "&auml;",
      "⨑": "&awint;",
      "⫭": "&bNot;",
      "≌": "&bcong;",
      "϶": "&bepsi;",
      "‵": "&bprime;",
      "∽": "&bsim;",
      "⋍": "&bsime;",
      "⊽": "&barvee;",
      "⌅": "&barwedge;",
      "⎶": "&bbrktbrk;",
      "б": "&bcy;",
      "„": "&ldquor;",
      "⦰": "&bemptyv;",
      "β": "&beta;",
      "ℶ": "&beth;",
      "≬": "&twixt;",
      "𝔟": "&bfr;",
      "◯": "&xcirc;",
      "⨀": "&xodot;",
      "⨁": "&xoplus;",
      "⨂": "&xotime;",
      "⨆": "&xsqcup;",
      "★": "&starf;",
      "▽": "&xdtri;",
      "△": "&xutri;",
      "⨄": "&xuplus;",
      "⤍": "&rbarr;",
      "⧫": "&lozf;",
      "▴": "&utrif;",
      "▾": "&dtrif;",
      "◂": "&ltrif;",
      "▸": "&rtrif;",
      "␣": "&blank;",
      "▒": "&blk12;",
      "░": "&blk14;",
      "▓": "&blk34;",
      "█": "&block;",
      "=⃥": "&bne;",
      "≡⃥": "&bnequiv;",
      "⌐": "&bnot;",
      "𝕓": "&bopf;",
      "⋈": "&bowtie;",
      "╗": "&boxDL;",
      "╔": "&boxDR;",
      "╖": "&boxDl;",
      "╓": "&boxDr;",
      "═": "&boxH;",
      "╦": "&boxHD;",
      "╩": "&boxHU;",
      "╤": "&boxHd;",
      "╧": "&boxHu;",
      "╝": "&boxUL;",
      "╚": "&boxUR;",
      "╜": "&boxUl;",
      "╙": "&boxUr;",
      "║": "&boxV;",
      "╬": "&boxVH;",
      "╣": "&boxVL;",
      "╠": "&boxVR;",
      "╫": "&boxVh;",
      "╢": "&boxVl;",
      "╟": "&boxVr;",
      "⧉": "&boxbox;",
      "╕": "&boxdL;",
      "╒": "&boxdR;",
      "┐": "&boxdl;",
      "┌": "&boxdr;",
      "╥": "&boxhD;",
      "╨": "&boxhU;",
      "┬": "&boxhd;",
      "┴": "&boxhu;",
      "⊟": "&minusb;",
      "⊞": "&plusb;",
      "⊠": "&timesb;",
      "╛": "&boxuL;",
      "╘": "&boxuR;",
      "┘": "&boxul;",
      "└": "&boxur;",
      "│": "&boxv;",
      "╪": "&boxvH;",
      "╡": "&boxvL;",
      "╞": "&boxvR;",
      "┼": "&boxvh;",
      "┤": "&boxvl;",
      "├": "&boxvr;",
      "¦": "&brvbar;",
      "𝒷": "&bscr;",
      "⁏": "&bsemi;",
      "\\": "&bsol;",
      "⧅": "&bsolb;",
      "⟈": "&bsolhsub;",
      "•": "&bullet;",
      "⪮": "&bumpE;",
      "ć": "&cacute;",
      "∩": "&cap;",
      "⩄": "&capand;",
      "⩉": "&capbrcup;",
      "⩋": "&capcap;",
      "⩇": "&capcup;",
      "⩀": "&capdot;",
      "∩︀": "&caps;",
      "⁁": "&caret;",
      "⩍": "&ccaps;",
      "č": "&ccaron;",
      "ç": "&ccedil;",
      "ĉ": "&ccirc;",
      "⩌": "&ccups;",
      "⩐": "&ccupssm;",
      "ċ": "&cdot;",
      "⦲": "&cemptyv;",
      "¢": "&cent;",
      "𝔠": "&cfr;",
      "ч": "&chcy;",
      "✓": "&checkmark;",
      "χ": "&chi;",
      "○": "&cir;",
      "⧃": "&cirE;",
      "ˆ": "&circ;",
      "≗": "&cire;",
      "↺": "&olarr;",
      "↻": "&orarr;",
      "Ⓢ": "&oS;",
      "⊛": "&oast;",
      "⊚": "&ocir;",
      "⊝": "&odash;",
      "⨐": "&cirfnint;",
      "⫯": "&cirmid;",
      "⧂": "&cirscir;",
      "♣": "&clubsuit;",
      ":": "&colon;",
      ",": "&comma;",
      "@": "&commat;",
      "∁": "&complement;",
      "⩭": "&congdot;",
      "𝕔": "&copf;",
      "℗": "&copysr;",
      "↵": "&crarr;",
      "✗": "&cross;",
      "𝒸": "&cscr;",
      "⫏": "&csub;",
      "⫑": "&csube;",
      "⫐": "&csup;",
      "⫒": "&csupe;",
      "⋯": "&ctdot;",
      "⤸": "&cudarrl;",
      "⤵": "&cudarrr;",
      "⋞": "&curlyeqprec;",
      "⋟": "&curlyeqsucc;",
      "↶": "&curvearrowleft;",
      "⤽": "&cularrp;",
      "∪": "&cup;",
      "⩈": "&cupbrcap;",
      "⩆": "&cupcap;",
      "⩊": "&cupcup;",
      "⊍": "&cupdot;",
      "⩅": "&cupor;",
      "∪︀": "&cups;",
      "↷": "&curvearrowright;",
      "⤼": "&curarrm;",
      "⋎": "&cuvee;",
      "⋏": "&cuwed;",
      "¤": "&curren;",
      "∱": "&cwint;",
      "⌭": "&cylcty;",
      "⥥": "&dHar;",
      "†": "&dagger;",
      "ℸ": "&daleth;",
      "‐": "&hyphen;",
      "⤏": "&rBarr;",
      "ď": "&dcaron;",
      "д": "&dcy;",
      "⇊": "&downdownarrows;",
      "⩷": "&eDDot;",
      "°": "&deg;",
      "δ": "&delta;",
      "⦱": "&demptyv;",
      "⥿": "&dfisht;",
      "𝔡": "&dfr;",
      "♦": "&diams;",
      "ϝ": "&gammad;",
      "⋲": "&disin;",
      "÷": "&divide;",
      "⋇": "&divonx;",
      "ђ": "&djcy;",
      "⌞": "&llcorner;",
      "⌍": "&dlcrop;",
      $: "&dollar;",
      "𝕕": "&dopf;",
      "≑": "&eDot;",
      "∸": "&minusd;",
      "∔": "&plusdo;",
      "⊡": "&sdotb;",
      "⌟": "&lrcorner;",
      "⌌": "&drcrop;",
      "𝒹": "&dscr;",
      "ѕ": "&dscy;",
      "⧶": "&dsol;",
      "đ": "&dstrok;",
      "⋱": "&dtdot;",
      "▿": "&triangledown;",
      "⦦": "&dwangle;",
      "џ": "&dzcy;",
      "⟿": "&dzigrarr;",
      "é": "&eacute;",
      "⩮": "&easter;",
      "ě": "&ecaron;",
      "≖": "&eqcirc;",
      "ê": "&ecirc;",
      "≕": "&eqcolon;",
      "э": "&ecy;",
      "ė": "&edot;",
      "≒": "&fallingdotseq;",
      "𝔢": "&efr;",
      "⪚": "&eg;",
      "è": "&egrave;",
      "⪖": "&eqslantgtr;",
      "⪘": "&egsdot;",
      "⪙": "&el;",
      "⏧": "&elinters;",
      "ℓ": "&ell;",
      "⪕": "&eqslantless;",
      "⪗": "&elsdot;",
      "ē": "&emacr;",
      "∅": "&varnothing;",
      " ": "&emsp13;",
      " ": "&emsp14;",
      " ": "&emsp;",
      "ŋ": "&eng;",
      " ": "&ensp;",
      "ę": "&eogon;",
      "𝕖": "&eopf;",
      "⋕": "&epar;",
      "⧣": "&eparsl;",
      "⩱": "&eplus;",
      "ε": "&epsilon;",
      "ϵ": "&varepsilon;",
      "=": "&equals;",
      "≟": "&questeq;",
      "⩸": "&equivDD;",
      "⧥": "&eqvparsl;",
      "≓": "&risingdotseq;",
      "⥱": "&erarr;",
      "ℯ": "&escr;",
      "η": "&eta;",
      "ð": "&eth;",
      "ë": "&euml;",
      "€": "&euro;",
      "!": "&excl;",
      "ф": "&fcy;",
      "♀": "&female;",
      "ﬃ": "&ffilig;",
      "ﬀ": "&fflig;",
      "ﬄ": "&ffllig;",
      "𝔣": "&ffr;",
      "ﬁ": "&filig;",
      fj: "&fjlig;",
      "♭": "&flat;",
      "ﬂ": "&fllig;",
      "▱": "&fltns;",
      "ƒ": "&fnof;",
      "𝕗": "&fopf;",
      "⋔": "&pitchfork;",
      "⫙": "&forkv;",
      "⨍": "&fpartint;",
      "½": "&half;",
      "⅓": "&frac13;",
      "¼": "&frac14;",
      "⅕": "&frac15;",
      "⅙": "&frac16;",
      "⅛": "&frac18;",
      "⅔": "&frac23;",
      "⅖": "&frac25;",
      "¾": "&frac34;",
      "⅗": "&frac35;",
      "⅜": "&frac38;",
      "⅘": "&frac45;",
      "⅚": "&frac56;",
      "⅝": "&frac58;",
      "⅞": "&frac78;",
      "⁄": "&frasl;",
      "⌢": "&sfrown;",
      "𝒻": "&fscr;",
      "⪌": "&gtreqqless;",
      "ǵ": "&gacute;",
      "γ": "&gamma;",
      "⪆": "&gtrapprox;",
      "ğ": "&gbreve;",
      "ĝ": "&gcirc;",
      "г": "&gcy;",
      "ġ": "&gdot;",
      "⪩": "&gescc;",
      "⪀": "&gesdot;",
      "⪂": "&gesdoto;",
      "⪄": "&gesdotol;",
      "⋛︀": "&gesl;",
      "⪔": "&gesles;",
      "𝔤": "&gfr;",
      "ℷ": "&gimel;",
      "ѓ": "&gjcy;",
      "⪒": "&glE;",
      "⪥": "&gla;",
      "⪤": "&glj;",
      "≩": "&gneqq;",
      "⪊": "&gnapprox;",
      "⪈": "&gneq;",
      "⋧": "&gnsim;",
      "𝕘": "&gopf;",
      "ℊ": "&gscr;",
      "⪎": "&gsime;",
      "⪐": "&gsiml;",
      "⪧": "&gtcc;",
      "⩺": "&gtcir;",
      "⋗": "&gtrdot;",
      "⦕": "&gtlPar;",
      "⩼": "&gtquest;",
      "⥸": "&gtrarr;",
      "≩︀": "&gvnE;",
      "ъ": "&hardcy;",
      "⥈": "&harrcir;",
      "↭": "&leftrightsquigarrow;",
      "ℏ": "&plankv;",
      "ĥ": "&hcirc;",
      "♥": "&heartsuit;",
      "…": "&mldr;",
      "⊹": "&hercon;",
      "𝔥": "&hfr;",
      "⤥": "&searhk;",
      "⤦": "&swarhk;",
      "⇿": "&hoarr;",
      "∻": "&homtht;",
      "↩": "&larrhk;",
      "↪": "&rarrhk;",
      "𝕙": "&hopf;",
      "―": "&horbar;",
      "𝒽": "&hscr;",
      "ħ": "&hstrok;",
      "⁃": "&hybull;",
      "í": "&iacute;",
      "î": "&icirc;",
      "и": "&icy;",
      "е": "&iecy;",
      "¡": "&iexcl;",
      "𝔦": "&ifr;",
      "ì": "&igrave;",
      "⨌": "&qint;",
      "∭": "&tint;",
      "⧜": "&iinfin;",
      "℩": "&iiota;",
      "ĳ": "&ijlig;",
      "ī": "&imacr;",
      "ı": "&inodot;",
      "⊷": "&imof;",
      "Ƶ": "&imped;",
      "℅": "&incare;",
      "∞": "&infin;",
      "⧝": "&infintie;",
      "⊺": "&intercal;",
      "⨗": "&intlarhk;",
      "⨼": "&iprod;",
      "ё": "&iocy;",
      "į": "&iogon;",
      "𝕚": "&iopf;",
      "ι": "&iota;",
      "¿": "&iquest;",
      "𝒾": "&iscr;",
      "⋹": "&isinE;",
      "⋵": "&isindot;",
      "⋴": "&isins;",
      "⋳": "&isinsv;",
      "ĩ": "&itilde;",
      "і": "&iukcy;",
      "ï": "&iuml;",
      "ĵ": "&jcirc;",
      "й": "&jcy;",
      "𝔧": "&jfr;",
      "ȷ": "&jmath;",
      "𝕛": "&jopf;",
      "𝒿": "&jscr;",
      "ј": "&jsercy;",
      "є": "&jukcy;",
      "κ": "&kappa;",
      "ϰ": "&varkappa;",
      "ķ": "&kcedil;",
      "к": "&kcy;",
      "𝔨": "&kfr;",
      "ĸ": "&kgreen;",
      "х": "&khcy;",
      "ќ": "&kjcy;",
      "𝕜": "&kopf;",
      "𝓀": "&kscr;",
      "⤛": "&lAtail;",
      "⤎": "&lBarr;",
      "⪋": "&lesseqqgtr;",
      "⥢": "&lHar;",
      "ĺ": "&lacute;",
      "⦴": "&laemptyv;",
      "λ": "&lambda;",
      "⦑": "&langd;",
      "⪅": "&lessapprox;",
      "«": "&laquo;",
      "⤟": "&larrbfs;",
      "⤝": "&larrfs;",
      "↫": "&looparrowleft;",
      "⤹": "&larrpl;",
      "⥳": "&larrsim;",
      "↢": "&leftarrowtail;",
      "⪫": "&lat;",
      "⤙": "&latail;",
      "⪭": "&late;",
      "⪭︀": "&lates;",
      "⤌": "&lbarr;",
      "❲": "&lbbrk;",
      "{": "&lcub;",
      "[": "&lsqb;",
      "⦋": "&lbrke;",
      "⦏": "&lbrksld;",
      "⦍": "&lbrkslu;",
      "ľ": "&lcaron;",
      "ļ": "&lcedil;",
      "л": "&lcy;",
      "⤶": "&ldca;",
      "⥧": "&ldrdhar;",
      "⥋": "&ldrushar;",
      "↲": "&ldsh;",
      "≤": "&leq;",
      "⇇": "&llarr;",
      "⋋": "&lthree;",
      "⪨": "&lescc;",
      "⩿": "&lesdot;",
      "⪁": "&lesdoto;",
      "⪃": "&lesdotor;",
      "⋚︀": "&lesg;",
      "⪓": "&lesges;",
      "⋖": "&ltdot;",
      "⥼": "&lfisht;",
      "𝔩": "&lfr;",
      "⪑": "&lgE;",
      "⥪": "&lharul;",
      "▄": "&lhblk;",
      "љ": "&ljcy;",
      "⥫": "&llhard;",
      "◺": "&lltri;",
      "ŀ": "&lmidot;",
      "⎰": "&lmoustache;",
      "≨": "&lneqq;",
      "⪉": "&lnapprox;",
      "⪇": "&lneq;",
      "⋦": "&lnsim;",
      "⟬": "&loang;",
      "⇽": "&loarr;",
      "⟼": "&xmap;",
      "↬": "&rarrlp;",
      "⦅": "&lopar;",
      "𝕝": "&lopf;",
      "⨭": "&loplus;",
      "⨴": "&lotimes;",
      "∗": "&lowast;",
      "◊": "&lozenge;",
      "(": "&lpar;",
      "⦓": "&lparlt;",
      "⥭": "&lrhard;",
      "‎": "&lrm;",
      "⊿": "&lrtri;",
      "‹": "&lsaquo;",
      "𝓁": "&lscr;",
      "⪍": "&lsime;",
      "⪏": "&lsimg;",
      "‚": "&sbquo;",
      "ł": "&lstrok;",
      "⪦": "&ltcc;",
      "⩹": "&ltcir;",
      "⋉": "&ltimes;",
      "⥶": "&ltlarr;",
      "⩻": "&ltquest;",
      "⦖": "&ltrPar;",
      "◃": "&triangleleft;",
      "⥊": "&lurdshar;",
      "⥦": "&luruhar;",
      "≨︀": "&lvnE;",
      "∺": "&mDDot;",
      "¯": "&strns;",
      "♂": "&male;",
      "✠": "&maltese;",
      "▮": "&marker;",
      "⨩": "&mcomma;",
      "м": "&mcy;",
      "—": "&mdash;",
      "𝔪": "&mfr;",
      "℧": "&mho;",
      "µ": "&micro;",
      "⫰": "&midcir;",
      "−": "&minus;",
      "⨪": "&minusdu;",
      "⫛": "&mlcp;",
      "⊧": "&models;",
      "𝕞": "&mopf;",
      "𝓂": "&mscr;",
      "μ": "&mu;",
      "⊸": "&mumap;",
      "⋙̸": "&nGg;",
      "≫⃒": "&nGt;",
      "⇍": "&nlArr;",
      "⇎": "&nhArr;",
      "⋘̸": "&nLl;",
      "≪⃒": "&nLt;",
      "⇏": "&nrArr;",
      "⊯": "&nVDash;",
      "⊮": "&nVdash;",
      "ń": "&nacute;",
      "∠⃒": "&nang;",
      "⩰̸": "&napE;",
      "≋̸": "&napid;",
      "ŉ": "&napos;",
      "♮": "&natural;",
      "⩃": "&ncap;",
      "ň": "&ncaron;",
      "ņ": "&ncedil;",
      "⩭̸": "&ncongdot;",
      "⩂": "&ncup;",
      "н": "&ncy;",
      "–": "&ndash;",
      "⇗": "&neArr;",
      "⤤": "&nearhk;",
      "≐̸": "&nedot;",
      "⤨": "&toea;",
      "𝔫": "&nfr;",
      "↮": "&nleftrightarrow;",
      "⫲": "&nhpar;",
      "⋼": "&nis;",
      "⋺": "&nisd;",
      "њ": "&njcy;",
      "≦̸": "&nleqq;",
      "↚": "&nleftarrow;",
      "‥": "&nldr;",
      "𝕟": "&nopf;",
      "¬": "&not;",
      "⋹̸": "&notinE;",
      "⋵̸": "&notindot;",
      "⋷": "&notinvb;",
      "⋶": "&notinvc;",
      "⋾": "&notnivb;",
      "⋽": "&notnivc;",
      "⫽⃥": "&nparsl;",
      "∂̸": "&npart;",
      "⨔": "&npolint;",
      "↛": "&nrightarrow;",
      "⤳̸": "&nrarrc;",
      "↝̸": "&nrarrw;",
      "𝓃": "&nscr;",
      "⊄": "&nsub;",
      "⫅̸": "&nsubseteqq;",
      "⊅": "&nsup;",
      "⫆̸": "&nsupseteqq;",
      "ñ": "&ntilde;",
      "ν": "&nu;",
      "#": "&num;",
      "№": "&numero;",
      " ": "&numsp;",
      "⊭": "&nvDash;",
      "⤄": "&nvHarr;",
      "≍⃒": "&nvap;",
      "⊬": "&nvdash;",
      "≥⃒": "&nvge;",
      ">⃒": "&nvgt;",
      "⧞": "&nvinfin;",
      "⤂": "&nvlArr;",
      "≤⃒": "&nvle;",
      "<⃒": "&nvlt;",
      "⊴⃒": "&nvltrie;",
      "⤃": "&nvrArr;",
      "⊵⃒": "&nvrtrie;",
      "∼⃒": "&nvsim;",
      "⇖": "&nwArr;",
      "⤣": "&nwarhk;",
      "⤧": "&nwnear;",
      "ó": "&oacute;",
      "ô": "&ocirc;",
      "о": "&ocy;",
      "ő": "&odblac;",
      "⨸": "&odiv;",
      "⦼": "&odsold;",
      "œ": "&oelig;",
      "⦿": "&ofcir;",
      "𝔬": "&ofr;",
      "˛": "&ogon;",
      "ò": "&ograve;",
      "⧁": "&ogt;",
      "⦵": "&ohbar;",
      "⦾": "&olcir;",
      "⦻": "&olcross;",
      "⧀": "&olt;",
      "ō": "&omacr;",
      "ω": "&omega;",
      "ο": "&omicron;",
      "⦶": "&omid;",
      "𝕠": "&oopf;",
      "⦷": "&opar;",
      "⦹": "&operp;",
      "∨": "&vee;",
      "⩝": "&ord;",
      "ℴ": "&oscr;",
      "ª": "&ordf;",
      "º": "&ordm;",
      "⊶": "&origof;",
      "⩖": "&oror;",
      "⩗": "&orslope;",
      "⩛": "&orv;",
      "ø": "&oslash;",
      "⊘": "&osol;",
      "õ": "&otilde;",
      "⨶": "&otimesas;",
      "ö": "&ouml;",
      "⌽": "&ovbar;",
      "¶": "&para;",
      "⫳": "&parsim;",
      "⫽": "&parsl;",
      "п": "&pcy;",
      "%": "&percnt;",
      ".": "&period;",
      "‰": "&permil;",
      "‱": "&pertenk;",
      "𝔭": "&pfr;",
      "φ": "&phi;",
      "ϕ": "&varphi;",
      "☎": "&phone;",
      "π": "&pi;",
      "ϖ": "&varpi;",
      "ℎ": "&planckh;",
      "+": "&plus;",
      "⨣": "&plusacir;",
      "⨢": "&pluscir;",
      "⨥": "&plusdu;",
      "⩲": "&pluse;",
      "⨦": "&plussim;",
      "⨧": "&plustwo;",
      "⨕": "&pointint;",
      "𝕡": "&popf;",
      "£": "&pound;",
      "⪳": "&prE;",
      "⪷": "&precapprox;",
      "⪹": "&prnap;",
      "⪵": "&prnE;",
      "⋨": "&prnsim;",
      "′": "&prime;",
      "⌮": "&profalar;",
      "⌒": "&profline;",
      "⌓": "&profsurf;",
      "⊰": "&prurel;",
      "𝓅": "&pscr;",
      "ψ": "&psi;",
      " ": "&puncsp;",
      "𝔮": "&qfr;",
      "𝕢": "&qopf;",
      "⁗": "&qprime;",
      "𝓆": "&qscr;",
      "⨖": "&quatint;",
      "?": "&quest;",
      "⤜": "&rAtail;",
      "⥤": "&rHar;",
      "∽̱": "&race;",
      "ŕ": "&racute;",
      "⦳": "&raemptyv;",
      "⦒": "&rangd;",
      "⦥": "&range;",
      "»": "&raquo;",
      "⥵": "&rarrap;",
      "⤠": "&rarrbfs;",
      "⤳": "&rarrc;",
      "⤞": "&rarrfs;",
      "⥅": "&rarrpl;",
      "⥴": "&rarrsim;",
      "↣": "&rightarrowtail;",
      "↝": "&rightsquigarrow;",
      "⤚": "&ratail;",
      "∶": "&ratio;",
      "❳": "&rbbrk;",
      "}": "&rcub;",
      "]": "&rsqb;",
      "⦌": "&rbrke;",
      "⦎": "&rbrksld;",
      "⦐": "&rbrkslu;",
      "ř": "&rcaron;",
      "ŗ": "&rcedil;",
      "р": "&rcy;",
      "⤷": "&rdca;",
      "⥩": "&rdldhar;",
      "↳": "&rdsh;",
      "▭": "&rect;",
      "⥽": "&rfisht;",
      "𝔯": "&rfr;",
      "⥬": "&rharul;",
      "ρ": "&rho;",
      "ϱ": "&varrho;",
      "⇉": "&rrarr;",
      "⋌": "&rthree;",
      "˚": "&ring;",
      "‏": "&rlm;",
      "⎱": "&rmoustache;",
      "⫮": "&rnmid;",
      "⟭": "&roang;",
      "⇾": "&roarr;",
      "⦆": "&ropar;",
      "𝕣": "&ropf;",
      "⨮": "&roplus;",
      "⨵": "&rotimes;",
      ")": "&rpar;",
      "⦔": "&rpargt;",
      "⨒": "&rppolint;",
      "›": "&rsaquo;",
      "𝓇": "&rscr;",
      "⋊": "&rtimes;",
      "▹": "&triangleright;",
      "⧎": "&rtriltri;",
      "⥨": "&ruluhar;",
      "℞": "&rx;",
      "ś": "&sacute;",
      "⪴": "&scE;",
      "⪸": "&succapprox;",
      "š": "&scaron;",
      "ş": "&scedil;",
      "ŝ": "&scirc;",
      "⪶": "&succneqq;",
      "⪺": "&succnapprox;",
      "⋩": "&succnsim;",
      "⨓": "&scpolint;",
      "с": "&scy;",
      "⋅": "&sdot;",
      "⩦": "&sdote;",
      "⇘": "&seArr;",
      "§": "&sect;",
      ";": "&semi;",
      "⤩": "&tosa;",
      "✶": "&sext;",
      "𝔰": "&sfr;",
      "♯": "&sharp;",
      "щ": "&shchcy;",
      "ш": "&shcy;",
      "­": "&shy;",
      "σ": "&sigma;",
      "ς": "&varsigma;",
      "⩪": "&simdot;",
      "⪞": "&simg;",
      "⪠": "&simgE;",
      "⪝": "&siml;",
      "⪟": "&simlE;",
      "≆": "&simne;",
      "⨤": "&simplus;",
      "⥲": "&simrarr;",
      "⨳": "&smashp;",
      "⧤": "&smeparsl;",
      "⌣": "&ssmile;",
      "⪪": "&smt;",
      "⪬": "&smte;",
      "⪬︀": "&smtes;",
      "ь": "&softcy;",
      "/": "&sol;",
      "⧄": "&solb;",
      "⌿": "&solbar;",
      "𝕤": "&sopf;",
      "♠": "&spadesuit;",
      "⊓︀": "&sqcaps;",
      "⊔︀": "&sqcups;",
      "𝓈": "&sscr;",
      "☆": "&star;",
      "⊂": "&subset;",
      "⫅": "&subseteqq;",
      "⪽": "&subdot;",
      "⫃": "&subedot;",
      "⫁": "&submult;",
      "⫋": "&subsetneqq;",
      "⊊": "&subsetneq;",
      "⪿": "&subplus;",
      "⥹": "&subrarr;",
      "⫇": "&subsim;",
      "⫕": "&subsub;",
      "⫓": "&subsup;",
      "♪": "&sung;",
      "¹": "&sup1;",
      "²": "&sup2;",
      "³": "&sup3;",
      "⫆": "&supseteqq;",
      "⪾": "&supdot;",
      "⫘": "&supdsub;",
      "⫄": "&supedot;",
      "⟉": "&suphsol;",
      "⫗": "&suphsub;",
      "⥻": "&suplarr;",
      "⫂": "&supmult;",
      "⫌": "&supsetneqq;",
      "⊋": "&supsetneq;",
      "⫀": "&supplus;",
      "⫈": "&supsim;",
      "⫔": "&supsub;",
      "⫖": "&supsup;",
      "⇙": "&swArr;",
      "⤪": "&swnwar;",
      "ß": "&szlig;",
      "⌖": "&target;",
      "τ": "&tau;",
      "ť": "&tcaron;",
      "ţ": "&tcedil;",
      "т": "&tcy;",
      "⌕": "&telrec;",
      "𝔱": "&tfr;",
      "θ": "&theta;",
      "ϑ": "&vartheta;",
      "þ": "&thorn;",
      "×": "&times;",
      "⨱": "&timesbar;",
      "⨰": "&timesd;",
      "⌶": "&topbot;",
      "⫱": "&topcir;",
      "𝕥": "&topf;",
      "⫚": "&topfork;",
      "‴": "&tprime;",
      "▵": "&utri;",
      "≜": "&trie;",
      "◬": "&tridot;",
      "⨺": "&triminus;",
      "⨹": "&triplus;",
      "⧍": "&trisb;",
      "⨻": "&tritime;",
      "⏢": "&trpezium;",
      "𝓉": "&tscr;",
      "ц": "&tscy;",
      "ћ": "&tshcy;",
      "ŧ": "&tstrok;",
      "⥣": "&uHar;",
      "ú": "&uacute;",
      "ў": "&ubrcy;",
      "ŭ": "&ubreve;",
      "û": "&ucirc;",
      "у": "&ucy;",
      "ű": "&udblac;",
      "⥾": "&ufisht;",
      "𝔲": "&ufr;",
      "ù": "&ugrave;",
      "▀": "&uhblk;",
      "⌜": "&ulcorner;",
      "⌏": "&ulcrop;",
      "◸": "&ultri;",
      "ū": "&umacr;",
      "ų": "&uogon;",
      "𝕦": "&uopf;",
      "υ": "&upsilon;",
      "⇈": "&uuarr;",
      "⌝": "&urcorner;",
      "⌎": "&urcrop;",
      "ů": "&uring;",
      "◹": "&urtri;",
      "𝓊": "&uscr;",
      "⋰": "&utdot;",
      "ũ": "&utilde;",
      "ü": "&uuml;",
      "⦧": "&uwangle;",
      "⫨": "&vBar;",
      "⫩": "&vBarv;",
      "⦜": "&vangrt;",
      "⊊︀": "&vsubne;",
      "⫋︀": "&vsubnE;",
      "⊋︀": "&vsupne;",
      "⫌︀": "&vsupnE;",
      "в": "&vcy;",
      "⊻": "&veebar;",
      "≚": "&veeeq;",
      "⋮": "&vellip;",
      "𝔳": "&vfr;",
      "𝕧": "&vopf;",
      "𝓋": "&vscr;",
      "⦚": "&vzigzag;",
      "ŵ": "&wcirc;",
      "⩟": "&wedbar;",
      "≙": "&wedgeq;",
      "℘": "&wp;",
      "𝔴": "&wfr;",
      "𝕨": "&wopf;",
      "𝓌": "&wscr;",
      "𝔵": "&xfr;",
      "ξ": "&xi;",
      "⋻": "&xnis;",
      "𝕩": "&xopf;",
      "𝓍": "&xscr;",
      "ý": "&yacute;",
      "я": "&yacy;",
      "ŷ": "&ycirc;",
      "ы": "&ycy;",
      "¥": "&yen;",
      "𝔶": "&yfr;",
      "ї": "&yicy;",
      "𝕪": "&yopf;",
      "𝓎": "&yscr;",
      "ю": "&yucy;",
      "ÿ": "&yuml;",
      "ź": "&zacute;",
      "ž": "&zcaron;",
      "з": "&zcy;",
      "ż": "&zdot;",
      "ζ": "&zeta;",
      "𝔷": "&zfr;",
      "ж": "&zhcy;",
      "⇝": "&zigrarr;",
      "𝕫": "&zopf;",
      "𝓏": "&zscr;",
      "‍": "&zwj;",
      "‌": "&zwnj;"
    }
  }
};

/***/ }),

/***/ "./node_modules/html-entities/lib/numeric-unicode-map.js":
/*!***************************************************************!*\
  !*** ./node_modules/html-entities/lib/numeric-unicode-map.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.numericUnicodeMap = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
};

/***/ }),

/***/ "./node_modules/html-entities/lib/surrogate-pairs.js":
/*!***********************************************************!*\
  !*** ./node_modules/html-entities/lib/surrogate-pairs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.fromCodePoint = String.fromCodePoint || function (astralCodePoint) {
  return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
};
exports.getCodePoint = String.prototype.codePointAt ? function (input, position) {
  return input.codePointAt(position);
} : function (input, position) {
  return (input.charCodeAt(position) - 55296) * 1024 + input.charCodeAt(position + 1) - 56320 + 65536;
};
exports.highSurrogateFrom = 55296;
exports.highSurrogateTo = 56319;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/microsoft.cognitiveservices.speech.sdk.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/microsoft.cognitiveservices.speech.sdk.js ***!
  \*******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
/* eslint-disable @typescript-eslint/no-unused-vars */
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
const Exports_js_1 = __webpack_require__(/*! ./src/common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
// Note: this instantiation ensures the above import isn't
// removed on compile. The import being absent causes an error on running
void new Exports_js_1.AgentConfig();
// Speech SDK API
__exportStar(__webpack_require__(/*! ./src/sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js"), exports);

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ConsoleLoggingListener.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ConsoleLoggingListener.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


/* eslint-disable @typescript-eslint/no-unsafe-assignment */
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConsoleLoggingListener = void 0;
const fs = __importStar(__webpack_require__(/*! fs */ "?f824"));
const LogLevel_js_1 = __webpack_require__(/*! ../sdk/LogLevel.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LogLevel.js");
const Contracts_js_1 = __webpack_require__(/*! ../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
class ConsoleLoggingListener {
  constructor(logLevelFilter = LogLevel_js_1.LogLevel.None) {
    this.privLogPath = undefined;
    this.privEnableConsoleOutput = true;
    this.privLogLevelFilter = logLevelFilter;
  }
  set logPath(path) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(fs.openSync, "\nFile System access not available");
    this.privLogPath = path;
  }
  set enableConsoleOutput(enableOutput) {
    this.privEnableConsoleOutput = enableOutput;
  }
  onEvent(event) {
    if (event.eventType >= this.privLogLevelFilter) {
      const log = this.toString(event);
      if (!!this.logCallback) {
        this.logCallback(log);
      }
      if (!!this.privLogPath) {
        fs.writeFileSync(this.privLogPath, log + "\n", {
          flag: "a+"
        });
      }
      if (this.privEnableConsoleOutput) {
        switch (event.eventType) {
          case LogLevel_js_1.LogLevel.Debug:
            // eslint-disable-next-line no-console
            console.debug(log);
            break;
          case LogLevel_js_1.LogLevel.Info:
            // eslint-disable-next-line no-console
            console.info(log);
            break;
          case LogLevel_js_1.LogLevel.Warning:
            // eslint-disable-next-line no-console
            console.warn(log);
            break;
          case LogLevel_js_1.LogLevel.Error:
            // eslint-disable-next-line no-console
            console.error(log);
            break;
          default:
            // eslint-disable-next-line no-console
            console.log(log);
            break;
        }
      }
    }
  }
  toString(event) {
    const logFragments = [`${event.eventTime}`, `${event.name}`];
    const e = event;
    for (const prop in e) {
      if (prop && event.hasOwnProperty(prop) && prop !== "eventTime" && prop !== "eventType" && prop !== "eventId" && prop !== "name" && prop !== "constructor") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const value = e[prop];
        let valueToLog = "<NULL>";
        if (value !== undefined && value !== null) {
          if (typeof value === "number" || typeof value === "string") {
            valueToLog = value.toString();
          } else {
            valueToLog = JSON.stringify(value);
          }
        }
        logFragments.push(`${prop}: ${valueToLog}`);
      }
    }
    return logFragments.join(" | ");
  }
}
exports.ConsoleLoggingListener = ConsoleLoggingListener;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
__exportStar(__webpack_require__(/*! ./ConsoleLoggingListener.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ConsoleLoggingListener.js"), exports);
__exportStar(__webpack_require__(/*! ./IRecorder.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/IRecorder.js"), exports);
__exportStar(__webpack_require__(/*! ./MicAudioSource.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/MicAudioSource.js"), exports);
__exportStar(__webpack_require__(/*! ./FileAudioSource.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js"), exports);
__exportStar(__webpack_require__(/*! ./PCMRecorder.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/PCMRecorder.js"), exports);
__exportStar(__webpack_require__(/*! ./WebsocketConnection.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/WebsocketConnection.js"), exports);
__exportStar(__webpack_require__(/*! ./WebsocketMessageAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/WebsocketMessageAdapter.js"), exports);
__exportStar(__webpack_require__(/*! ./ReplayableAudioNode.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ReplayableAudioNode.js"), exports);
__exportStar(__webpack_require__(/*! ./ProxyInfo.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ProxyInfo.js"), exports);
__exportStar(__webpack_require__(/*! ./RestMessageAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/RestMessageAdapter.js"), exports);
__exportStar(__webpack_require__(/*! ./RestConfigBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/RestConfigBase.js"), exports);

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/FileAudioSource.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FileAudioSource = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const AudioStreamFormat_js_1 = __webpack_require__(/*! ../sdk/Audio/AudioStreamFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js");
class FileAudioSource {
  constructor(file, filename, audioSourceId) {
    this.privStreams = {};
    this.privHeaderEnd = 44;
    this.privId = audioSourceId ? audioSourceId : Exports_js_2.createNoDashGuid();
    this.privEvents = new Exports_js_2.EventSource();
    this.privSource = file;
    if (typeof window !== "undefined" && typeof Blob !== "undefined" && this.privSource instanceof Blob) {
      this.privFilename = file.name;
    } else {
      this.privFilename = filename || "unknown.wav";
    }
    // Read the header.
    this.privAudioFormatPromise = this.readHeader();
  }
  get format() {
    return this.privAudioFormatPromise;
  }
  turnOn() {
    if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
      const errorMsg = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
      this.onEvent(new Exports_js_2.AudioSourceErrorEvent(errorMsg, ""));
      return Promise.reject(errorMsg);
    }
    this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId)); // no stream id
    this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
    return;
  }
  id() {
    return this.privId;
  }
  async attach(audioNodeId) {
    this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
    const stream = await this.upload(audioNodeId);
    this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
    return Promise.resolve({
      detach: async () => {
        stream.readEnded();
        delete this.privStreams[audioNodeId];
        this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
        await this.turnOff();
      },
      id: () => audioNodeId,
      read: () => stream.read()
    });
  }
  detach(audioNodeId) {
    if (audioNodeId && this.privStreams[audioNodeId]) {
      this.privStreams[audioNodeId].close();
      delete this.privStreams[audioNodeId];
      this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
    }
  }
  turnOff() {
    for (const streamId in this.privStreams) {
      if (streamId) {
        const stream = this.privStreams[streamId];
        if (stream && !stream.isClosed) {
          stream.close();
        }
      }
    }
    this.onEvent(new Exports_js_2.AudioSourceOffEvent(this.privId)); // no stream now
    return Promise.resolve();
  }
  get events() {
    return this.privEvents;
  }
  get deviceInfo() {
    return this.privAudioFormatPromise.then(result => Promise.resolve({
      bitspersample: result.bitsPerSample,
      channelcount: result.channels,
      connectivity: Exports_js_1.connectivity.Unknown,
      manufacturer: "Speech SDK",
      model: "File",
      samplerate: result.samplesPerSec,
      type: Exports_js_1.type.File
    }));
  }
  readHeader() {
    // Read the wave header.
    const maxHeaderSize = 4296;
    const header = this.privSource.slice(0, maxHeaderSize);
    const headerResult = new Exports_js_2.Deferred();
    const processHeader = header => {
      const view = new DataView(header);
      const getWord = index => String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));
      // RIFF 4 bytes.
      if ("RIFF" !== getWord(0)) {
        headerResult.reject("Invalid WAV header in file, RIFF was not found");
        return;
      }
      // length, 4 bytes
      // RIFF Type & fmt 8 bytes
      if ("WAVE" !== getWord(8) || "fmt " !== getWord(12)) {
        headerResult.reject("Invalid WAV header in file, WAVEfmt was not found");
        return;
      }
      const formatSize = view.getInt32(16, true);
      const channelCount = view.getUint16(22, true);
      const sampleRate = view.getUint32(24, true);
      const bitsPerSample = view.getUint16(34, true);
      // Confirm if header is 44 bytes long.
      let pos = 36 + Math.max(formatSize - 16, 0);
      for (; getWord(pos) !== "data"; pos += 2) {
        if (pos > maxHeaderSize - 8) {
          headerResult.reject("Invalid WAV header in file, data block was not found");
          return;
        }
      }
      this.privHeaderEnd = pos + 8;
      headerResult.resolve(AudioStreamFormat_js_1.AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));
    };
    if (typeof window !== "undefined" && typeof Blob !== "undefined" && header instanceof Blob) {
      const reader = new FileReader();
      reader.onload = event => {
        const header = event.target.result;
        processHeader(header);
      };
      reader.readAsArrayBuffer(header);
    } else {
      const h = header;
      processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));
    }
    return headerResult.promise;
  }
  async upload(audioNodeId) {
    const onerror = error => {
      const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;
      this.onEvent(new Exports_js_2.AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));
      throw new Error(errorMsg);
    };
    try {
      await this.turnOn();
      const format = await this.privAudioFormatPromise;
      const stream = new Exports_js_2.ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);
      this.privStreams[audioNodeId] = stream;
      const chunk = this.privSource.slice(this.privHeaderEnd);
      const processFile = buff => {
        if (stream.isClosed) {
          return; // output stream was closed (somebody called TurnOff). We're done here.
        }
        stream.writeStreamChunk({
          buffer: buff,
          isEnd: false,
          timeReceived: Date.now()
        });
        stream.close();
      };
      if (typeof window !== "undefined" && typeof Blob !== "undefined" && chunk instanceof Blob) {
        const reader = new FileReader();
        reader.onerror = ev => onerror(ev.toString());
        reader.onload = event => {
          const fileBuffer = event.target.result;
          processFile(fileBuffer);
        };
        reader.readAsArrayBuffer(chunk);
      } else {
        const c = chunk;
        processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));
      }
      return stream;
    } catch (e) {
      onerror(e);
    }
  }
  onEvent(event) {
    this.privEvents.onEvent(event);
    Exports_js_2.Events.instance.onEvent(event);
  }
}
exports.FileAudioSource = FileAudioSource;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/IRecorder.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/IRecorder.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/MicAudioSource.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/MicAudioSource.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MicAudioSource = exports.AudioWorkletSourceURLPropertyName = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const AudioStreamFormat_js_1 = __webpack_require__(/*! ../sdk/Audio/AudioStreamFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js");
exports.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
class MicAudioSource {
  constructor(privRecorder, deviceId, audioSourceId, mediaStream) {
    this.privRecorder = privRecorder;
    this.deviceId = deviceId;
    this.privStreams = {};
    this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;
    this.privId = audioSourceId ? audioSourceId : Exports_js_2.createNoDashGuid();
    this.privEvents = new Exports_js_2.EventSource();
    this.privMediaStream = mediaStream || null;
    this.privIsClosing = false;
  }
  get format() {
    return Promise.resolve(MicAudioSource.AUDIOFORMAT);
  }
  turnOn() {
    if (this.privInitializeDeferral) {
      return this.privInitializeDeferral.promise;
    }
    this.privInitializeDeferral = new Exports_js_2.Deferred();
    try {
      this.createAudioContext();
    } catch (error) {
      if (error instanceof Error) {
        const typedError = error;
        this.privInitializeDeferral.reject(typedError.name + ": " + typedError.message);
      } else {
        this.privInitializeDeferral.reject(error);
      }
      return this.privInitializeDeferral.promise;
    }
    const nav = window.navigator;
    let getUserMedia =
    // eslint-disable-next-line
    nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;
    if (!!nav.mediaDevices) {
      getUserMedia = (constraints, successCallback, errorCallback) => {
        nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);
      };
    }
    if (!getUserMedia) {
      const errorMsg = "Browser does not support getUserMedia.";
      this.privInitializeDeferral.reject(errorMsg);
      this.onEvent(new Exports_js_2.AudioSourceErrorEvent(errorMsg, "")); // mic initialized error - no streamid at this point
    } else {
      const next = () => {
        this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId)); // no stream id
        if (this.privMediaStream && this.privMediaStream.active) {
          this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
          this.privInitializeDeferral.resolve();
        } else {
          getUserMedia({
            audio: this.deviceId ? {
              deviceId: this.deviceId
            } : true,
            video: false
          }, mediaStream => {
            this.privMediaStream = mediaStream;
            this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
            this.privInitializeDeferral.resolve();
          }, error => {
            const errorMsg = `Error occurred during microphone initialization: ${error}`;
            this.privInitializeDeferral.reject(errorMsg);
            this.onEvent(new Exports_js_2.AudioSourceErrorEvent(this.privId, errorMsg));
          });
        }
      };
      if (this.privContext.state === "suspended") {
        // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.
        // https://github.com/WebAudio/web-audio-api/issues/790
        this.privContext.resume().then(next).catch(reason => {
          this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);
        });
      } else {
        next();
      }
    }
    return this.privInitializeDeferral.promise;
  }
  id() {
    return this.privId;
  }
  attach(audioNodeId) {
    this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
    return this.listen(audioNodeId).then(stream => {
      this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
      return {
        detach: async () => {
          stream.readEnded();
          delete this.privStreams[audioNodeId];
          this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
          return this.turnOff();
        },
        id: () => audioNodeId,
        read: () => stream.read()
      };
    });
  }
  detach(audioNodeId) {
    if (audioNodeId && this.privStreams[audioNodeId]) {
      this.privStreams[audioNodeId].close();
      delete this.privStreams[audioNodeId];
      this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
    }
  }
  async turnOff() {
    for (const streamId in this.privStreams) {
      if (streamId) {
        const stream = this.privStreams[streamId];
        if (stream) {
          stream.close();
        }
      }
    }
    this.onEvent(new Exports_js_2.AudioSourceOffEvent(this.privId)); // no stream now
    if (this.privInitializeDeferral) {
      // Correctly handle when browser forces mic off before turnOn() completes
      // eslint-disable-next-line @typescript-eslint/await-thenable
      await this.privInitializeDeferral;
      this.privInitializeDeferral = null;
    }
    await this.destroyAudioContext();
    return;
  }
  get events() {
    return this.privEvents;
  }
  get deviceInfo() {
    return this.getMicrophoneLabel().then(label => ({
      bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,
      channelcount: MicAudioSource.AUDIOFORMAT.channels,
      connectivity: Exports_js_1.connectivity.Unknown,
      manufacturer: "Speech SDK",
      model: label,
      samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,
      type: Exports_js_1.type.Microphones
    }));
  }
  setProperty(name, value) {
    if (name === exports.AudioWorkletSourceURLPropertyName) {
      this.privRecorder.setWorkletUrl(value);
    } else {
      throw new Error("Property '" + name + "' is not supported on Microphone.");
    }
  }
  getMicrophoneLabel() {
    const defaultMicrophoneName = "microphone";
    // If we did this already, return the value.
    if (this.privMicrophoneLabel !== undefined) {
      return Promise.resolve(this.privMicrophoneLabel);
    }
    // If the stream isn't currently running, we can't query devices because security.
    if (this.privMediaStream === undefined || !this.privMediaStream.active) {
      return Promise.resolve(defaultMicrophoneName);
    }
    // Setup a default
    this.privMicrophoneLabel = defaultMicrophoneName;
    // Get the id of the device running the audio track.
    const microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId;
    // If the browser doesn't support getting the device ID, set a default and return.
    if (undefined === microphoneDeviceId) {
      return Promise.resolve(this.privMicrophoneLabel);
    }
    const deferred = new Exports_js_2.Deferred();
    // Enumerate the media devices.
    navigator.mediaDevices.enumerateDevices().then(devices => {
      for (const device of devices) {
        if (device.deviceId === microphoneDeviceId) {
          // Found the device
          this.privMicrophoneLabel = device.label;
          break;
        }
      }
      deferred.resolve(this.privMicrophoneLabel);
    }, () => deferred.resolve(this.privMicrophoneLabel));
    return deferred.promise;
  }
  async listen(audioNodeId) {
    await this.turnOn();
    const stream = new Exports_js_2.ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);
    this.privStreams[audioNodeId] = stream;
    try {
      this.privRecorder.record(this.privContext, this.privMediaStream, stream);
    } catch (error) {
      this.onEvent(new Exports_js_2.AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));
      throw error;
    }
    const result = stream;
    return result;
  }
  onEvent(event) {
    this.privEvents.onEvent(event);
    Exports_js_2.Events.instance.onEvent(event);
  }
  createAudioContext() {
    if (!!this.privContext) {
      return;
    }
    this.privContext = AudioStreamFormat_js_1.AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);
  }
  async destroyAudioContext() {
    if (!this.privContext) {
      return;
    }
    this.privRecorder.releaseMediaResources(this.privContext);
    // This pattern brought to you by a bug in the TypeScript compiler where it
    // confuses the ("close" in this.privContext) with this.privContext always being null as the alternate.
    // https://github.com/Microsoft/TypeScript/issues/11498
    let hasClose = false;
    if ("close" in this.privContext) {
      hasClose = true;
    }
    if (hasClose) {
      if (!this.privIsClosing) {
        // The audio context close may take enough time that the close is called twice
        this.privIsClosing = true;
        await this.privContext.close();
        this.privContext = null;
        this.privIsClosing = false;
      }
    } else if (null !== this.privContext && this.privContext.state === "running") {
      // Suspend actually takes a callback, but analogous to the
      // resume method, it'll be only fired if suspend is called
      // in a direct response to a user action. The later is not always
      // the case, as TurnOff is also called, when we receive an
      // end-of-speech message from the service. So, doing a best effort
      // fire-and-forget here.
      await this.privContext.suspend();
    }
  }
}
exports.MicAudioSource = MicAudioSource;
MicAudioSource.AUDIOFORMAT = AudioStreamFormat_js_1.AudioStreamFormat.getDefaultInputFormat();

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/PCMRecorder.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/PCMRecorder.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PcmRecorder = void 0;
const Exports_1 = __webpack_require__(/*! ../common/Exports */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
class PcmRecorder {
  constructor(stopInputOnRelease) {
    this.privStopInputOnRelease = stopInputOnRelease;
  }
  record(context, mediaStream, outputStream) {
    const desiredSampleRate = 16000;
    const waveStreamEncoder = new Exports_1.RiffPcmEncoder(context.sampleRate, desiredSampleRate);
    const micInput = context.createMediaStreamSource(mediaStream);
    const attachScriptProcessor = () => {
      // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
      const scriptNode = (() => {
        let bufferSize = 0;
        try {
          return context.createScriptProcessor(bufferSize, 1, 1);
        } catch (error) {
          // Webkit (<= version 31) requires a valid bufferSize.
          bufferSize = 2048;
          let audioSampleRate = context.sampleRate;
          while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {
            bufferSize <<= 1;
            audioSampleRate >>= 1;
          }
          return context.createScriptProcessor(bufferSize, 1, 1);
        }
      })();
      scriptNode.onaudioprocess = event => {
        const inputFrame = event.inputBuffer.getChannelData(0);
        if (outputStream && !outputStream.isClosed) {
          const waveFrame = waveStreamEncoder.encode(inputFrame);
          if (!!waveFrame) {
            outputStream.writeStreamChunk({
              buffer: waveFrame,
              isEnd: false,
              timeReceived: Date.now()
            });
          }
        }
      };
      micInput.connect(scriptNode);
      scriptNode.connect(context.destination);
      this.privMediaResources = {
        scriptProcessorNode: scriptNode,
        source: micInput,
        stream: mediaStream
      };
    };
    // https://webaudio.github.io/web-audio-api/#audioworklet
    // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread
    const skipAudioWorklet = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
    if (!!context.audioWorklet && !skipAudioWorklet) {
      if (!this.privSpeechProcessorScript) {
        const workletScript = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`;
        const blob = new Blob([workletScript], {
          type: "application/javascript; charset=utf-8"
        });
        this.privSpeechProcessorScript = URL.createObjectURL(blob);
      }
      context.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
        const workletNode = new AudioWorkletNode(context, "speech-processor");
        workletNode.port.onmessage = ev => {
          const inputFrame = ev.data;
          if (outputStream && !outputStream.isClosed) {
            const waveFrame = waveStreamEncoder.encode(inputFrame);
            if (!!waveFrame) {
              outputStream.writeStreamChunk({
                buffer: waveFrame,
                isEnd: false,
                timeReceived: Date.now()
              });
            }
          }
        };
        micInput.connect(workletNode);
        workletNode.connect(context.destination);
        this.privMediaResources = {
          scriptProcessorNode: workletNode,
          source: micInput,
          stream: mediaStream
        };
      }).catch(() => {
        attachScriptProcessor();
      });
    } else {
      try {
        attachScriptProcessor();
      } catch (err) {
        throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err}`);
      }
    }
  }
  releaseMediaResources(context) {
    if (this.privMediaResources) {
      if (this.privMediaResources.scriptProcessorNode) {
        this.privMediaResources.scriptProcessorNode.disconnect(context.destination);
        this.privMediaResources.scriptProcessorNode = null;
      }
      if (this.privMediaResources.source) {
        this.privMediaResources.source.disconnect();
        if (this.privStopInputOnRelease) {
          this.privMediaResources.stream.getTracks().forEach(track => track.stop());
        }
        this.privMediaResources.source = null;
      }
    }
  }
  setWorkletUrl(url) {
    this.privSpeechProcessorScript = url;
  }
}
exports.PcmRecorder = PcmRecorder;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ProxyInfo.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ProxyInfo.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProxyInfo = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class ProxyInfo {
  constructor(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
    this.privProxyHostName = proxyHostName;
    this.privProxyPort = proxyPort;
    this.privProxyUserName = proxyUserName;
    this.privProxyPassword = proxyPassword;
  }
  static fromParameters(parameters) {
    return new ProxyInfo(parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyPort), 10), parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyUserName), parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyPassword));
  }
  static fromRecognizerConfig(config) {
    return this.fromParameters(config.parameters);
  }
  get HostName() {
    return this.privProxyHostName;
  }
  get Port() {
    return this.privProxyPort;
  }
  get UserName() {
    return this.privProxyUserName;
  }
  get Password() {
    return this.privProxyPassword;
  }
}
exports.ProxyInfo = ProxyInfo;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ReplayableAudioNode.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/ReplayableAudioNode.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ReplayableAudioNode = void 0;
class ReplayableAudioNode {
  constructor(audioSource, bytesPerSecond) {
    this.privBuffers = [];
    this.privReplayOffset = 0;
    this.privLastShrinkOffset = 0;
    this.privBufferStartOffset = 0;
    this.privBufferSerial = 0;
    this.privBufferedBytes = 0;
    this.privReplay = false;
    this.privLastChunkAcquiredTime = 0;
    this.privAudioNode = audioSource;
    this.privBytesPerSecond = bytesPerSecond;
  }
  id() {
    return this.privAudioNode.id();
  }
  // Reads and returns the next chunk of audio buffer.
  // If replay of existing buffers are needed, read() will first seek and replay
  // existing content, and upoin completion it will read new content from the underlying
  // audio node, saving that content into the replayable buffers.
  read() {
    // if there is a replay request to honor.
    if (!!this.privReplay && this.privBuffers.length !== 0) {
      // Find the start point in the buffers.
      // Offsets are in 100ns increments.
      // So how many bytes do we need to seek to get the right offset?
      const offsetToSeek = this.privReplayOffset - this.privBufferStartOffset;
      let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);
      if (0 !== bytesToSeek % 2) {
        bytesToSeek++;
      }
      let i = 0;
      while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {
        bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
      }
      if (i < this.privBuffers.length) {
        const retVal = this.privBuffers[i].chunk.buffer.slice(bytesToSeek);
        this.privReplayOffset += retVal.byteLength / this.privBytesPerSecond * 1e+7;
        // If we've reached the end of the buffers, stop replaying.
        if (i === this.privBuffers.length - 1) {
          this.privReplay = false;
        }
        return Promise.resolve({
          buffer: retVal,
          isEnd: false,
          timeReceived: this.privBuffers[i].chunk.timeReceived
        });
      }
    }
    return this.privAudioNode.read().then(result => {
      if (result && result.buffer) {
        this.privBuffers.push(new BufferEntry(result, this.privBufferSerial++, this.privBufferedBytes));
        this.privBufferedBytes += result.buffer.byteLength;
      }
      return result;
    });
  }
  detach() {
    this.privBuffers = undefined;
    return this.privAudioNode.detach();
  }
  replay() {
    if (this.privBuffers && 0 !== this.privBuffers.length) {
      this.privReplay = true;
      this.privReplayOffset = this.privLastShrinkOffset;
    }
  }
  // Shrinks the existing audio buffers to start at the new offset, or at the
  // beginning of the buffer closest to the requested offset.
  // A replay request will start from the last shrink point.
  shrinkBuffers(offset) {
    if (this.privBuffers === undefined || this.privBuffers.length === 0) {
      return;
    }
    this.privLastShrinkOffset = offset;
    // Find the start point in the buffers.
    // Offsets are in 100ns increments.
    // So how many bytes do we need to seek to get the right offset?
    const offsetToSeek = offset - this.privBufferStartOffset;
    let bytesToSeek = Math.round(offsetToSeek * this.privBytesPerSecond * 1e-7);
    let i = 0;
    while (i < this.privBuffers.length && bytesToSeek >= this.privBuffers[i].chunk.buffer.byteLength) {
      bytesToSeek -= this.privBuffers[i++].chunk.buffer.byteLength;
    }
    this.privBufferStartOffset = Math.round(offset - bytesToSeek / this.privBytesPerSecond * 1e+7);
    this.privBuffers = this.privBuffers.slice(i);
  }
  // Finds the time a buffer of audio was first seen by offset.
  findTimeAtOffset(offset) {
    if (offset < this.privBufferStartOffset || this.privBuffers === undefined) {
      return 0;
    }
    for (const value of this.privBuffers) {
      const startOffset = value.byteOffset / this.privBytesPerSecond * 1e7;
      const endOffset = startOffset + value.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
      if (offset >= startOffset && offset <= endOffset) {
        return value.chunk.timeReceived;
      }
    }
    return 0;
  }
}
exports.ReplayableAudioNode = ReplayableAudioNode;
// Primary use of this class is to help debugging problems with the replay
// code. If the memory cost of alloc / dealloc gets too much, drop it and just use
// the ArrayBuffer directly.
class BufferEntry {
  constructor(chunk, serial, byteOffset) {
    this.chunk = chunk;
    this.serial = serial;
    this.byteOffset = byteOffset;
  }
}

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/RestConfigBase.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/RestConfigBase.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RestConfigBase = void 0;
class RestConfigBase {
  static get requestOptions() {
    return RestConfigBase.privDefaultRequestOptions;
  }
  static get configParams() {
    return RestConfigBase.privDefaultParams;
  }
  static get restErrors() {
    return RestConfigBase.privRestErrors;
  }
}
exports.RestConfigBase = RestConfigBase;
RestConfigBase.privDefaultRequestOptions = {
  headers: {
    Accept: "application/json"
  },
  ignoreCache: false,
  timeout: 10000
};
RestConfigBase.privRestErrors = {
  authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
  authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
  invalidArgs: "Required input not found: {arg}.",
  invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
  invalidParticipantRequest: "The requested participant was not found.",
  permissionDeniedConnect: "Required credentials not found.",
  permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
  permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
  permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
  permissionDeniedStart: "Invalid operation: there is already an active conversation."
};
RestConfigBase.privDefaultParams = {
  apiVersion: "api-version",
  authorization: "Authorization",
  clientAppId: "X-ClientAppId",
  contentTypeKey: "Content-Type",
  correlationId: "X-CorrelationId",
  languageCode: "language",
  nickname: "nickname",
  profanity: "profanity",
  requestId: "X-RequestId",
  roomId: "roomid",
  sessionToken: "token",
  subscriptionKey: "Ocp-Apim-Subscription-Key",
  subscriptionRegion: "Ocp-Apim-Subscription-Region",
  token: "X-CapitoToken"
};

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/RestMessageAdapter.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/RestMessageAdapter.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RestMessageAdapter = exports.RestRequestType = void 0;
const bent_1 = __importDefault(__webpack_require__(/*! bent */ "./node_modules/bent/src/browser.js"));
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
var RestRequestType;
(function (RestRequestType) {
  RestRequestType["Get"] = "GET";
  RestRequestType["Post"] = "POST";
  RestRequestType["Delete"] = "DELETE";
  RestRequestType["File"] = "file";
})(RestRequestType = exports.RestRequestType || (exports.RestRequestType = {}));
// accept rest operations via request method and return abstracted objects from server response
class RestMessageAdapter {
  constructor(configParams) {
    if (!configParams) {
      throw new Exports_js_1.ArgumentNullError("configParams");
    }
    this.privHeaders = configParams.headers;
    this.privIgnoreCache = configParams.ignoreCache;
  }
  static extractHeaderValue(headerKey, headers) {
    let headerValue = "";
    try {
      const arr = headers.trim().split(/[\r\n]+/);
      const headerMap = {};
      arr.forEach(line => {
        const parts = line.split(": ");
        const header = parts.shift().toLowerCase();
        const value = parts.join(": ");
        headerMap[header] = value;
      });
      headerValue = headerMap[headerKey.toLowerCase()];
    } catch (e) {
      // ignore the error
    }
    return headerValue;
  }
  set options(configParams) {
    this.privHeaders = configParams.headers;
    this.privIgnoreCache = configParams.ignoreCache;
  }
  setHeaders(key, value) {
    this.privHeaders[key] = value;
  }
  request(method, uri, queryParams = {}, body = null) {
    const responseReceivedDeferral = new Exports_js_1.Deferred();
    const requestCommand = method === RestRequestType.File ? "POST" : method;
    const handleRestResponse = (data, j = {}) => {
      const d = data;
      return {
        data: JSON.stringify(j),
        headers: JSON.stringify(data.headers),
        json: j,
        ok: data.statusCode >= 200 && data.statusCode < 300,
        status: data.statusCode,
        statusText: j.error ? j.error.message : d.statusText ? d.statusText : d.statusMessage
      };
    };
    const send = postData => {
      const sendRequest = bent_1.default(uri, requestCommand, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404);
      const params = this.queryParams(queryParams) === "" ? "" : `?${this.queryParams(queryParams)}`;
      sendRequest(params, postData).then(async data => {
        if (method === RestRequestType.Delete || data.statusCode === 204) {
          // No JSON from Delete and reset (204) operations
          responseReceivedDeferral.resolve(handleRestResponse(data));
        } else {
          try {
            const j = await data.json();
            responseReceivedDeferral.resolve(handleRestResponse(data, j));
          } catch {
            responseReceivedDeferral.resolve(handleRestResponse(data));
          }
        }
      }).catch(error => {
        responseReceivedDeferral.reject(error);
      });
    };
    if (this.privIgnoreCache) {
      this.privHeaders["Cache-Control"] = "no-cache";
    }
    if (method === RestRequestType.Post && body) {
      this.privHeaders["content-type"] = "application/json";
      this.privHeaders["Content-Type"] = "application/json";
    }
    send(body);
    return responseReceivedDeferral.promise;
  }
  queryParams(params = {}) {
    return Object.keys(params).map(k => encodeURIComponent(k) + "=" + encodeURIComponent(params[k])).join("&");
  }
}
exports.RestMessageAdapter = RestMessageAdapter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/WebsocketConnection.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/WebsocketConnection.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebsocketConnection = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const WebsocketMessageAdapter_js_1 = __webpack_require__(/*! ./WebsocketMessageAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/WebsocketMessageAdapter.js");
class WebsocketConnection {
  constructor(uri, queryParameters, headers, messageFormatter, proxyInfo, enableCompression = false, connectionId) {
    this.privIsDisposed = false;
    if (!uri) {
      throw new Exports_js_1.ArgumentNullError("uri");
    }
    if (!messageFormatter) {
      throw new Exports_js_1.ArgumentNullError("messageFormatter");
    }
    this.privMessageFormatter = messageFormatter;
    let queryParams = "";
    let i = 0;
    if (queryParameters) {
      for (const paramName in queryParameters) {
        if (paramName) {
          queryParams += i === 0 && uri.indexOf("?") === -1 ? "?" : "&";
          const key = encodeURIComponent(paramName);
          queryParams += key;
          let val = queryParameters[paramName];
          if (val) {
            val = encodeURIComponent(val);
            queryParams += `=${val}`;
          }
          i++;
        }
      }
    }
    if (headers) {
      for (const headerName in headers) {
        if (headerName) {
          queryParams += i === 0 && uri.indexOf("?") === -1 ? "?" : "&";
          const val = encodeURIComponent(headers[headerName]);
          queryParams += `${headerName}=${val}`;
          i++;
        }
      }
    }
    this.privUri = uri + queryParams;
    this.privId = connectionId ? connectionId : Exports_js_1.createNoDashGuid();
    this.privConnectionMessageAdapter = new WebsocketMessageAdapter_js_1.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, proxyInfo, headers, enableCompression);
  }
  async dispose() {
    this.privIsDisposed = true;
    if (this.privConnectionMessageAdapter) {
      await this.privConnectionMessageAdapter.close();
    }
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  get id() {
    return this.privId;
  }
  get uri() {
    return this.privUri;
  }
  state() {
    return this.privConnectionMessageAdapter.state;
  }
  open() {
    return this.privConnectionMessageAdapter.open();
  }
  send(message) {
    return this.privConnectionMessageAdapter.send(message);
  }
  read() {
    return this.privConnectionMessageAdapter.read();
  }
  get events() {
    return this.privConnectionMessageAdapter.events;
  }
}
exports.WebsocketConnection = WebsocketConnection;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/WebsocketMessageAdapter.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/WebsocketMessageAdapter.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebsocketMessageAdapter = void 0;
const net = __importStar(__webpack_require__(/*! net */ "?540f"));
const tls = __importStar(__webpack_require__(/*! tls */ "?71f6"));
const agent_base_1 = __importDefault(__webpack_require__(/*! agent-base */ "?875c"));
const https_proxy_agent_1 = __importDefault(__webpack_require__(/*! https-proxy-agent */ "?a523"));
const ws_1 = __importDefault(__webpack_require__(/*! ws */ "?3dbe"));
const HeaderNames_js_1 = __webpack_require__(/*! ../common.speech/HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
class WebsocketMessageAdapter {
  constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {
    if (!uri) {
      throw new Exports_js_1.ArgumentNullError("uri");
    }
    if (!messageFormatter) {
      throw new Exports_js_1.ArgumentNullError("messageFormatter");
    }
    this.proxyInfo = proxyInfo;
    this.privConnectionEvents = new Exports_js_1.EventSource();
    this.privConnectionId = connectionId;
    this.privMessageFormatter = messageFormatter;
    this.privConnectionState = Exports_js_1.ConnectionState.None;
    this.privUri = uri;
    this.privHeaders = headers;
    this.privEnableCompression = enableCompression;
    // Add the connection ID to the headers
    this.privHeaders[HeaderNames_js_1.HeaderNames.ConnectionId] = this.privConnectionId;
    this.privLastErrorReceived = "";
  }
  get state() {
    return this.privConnectionState;
  }
  open() {
    if (this.privConnectionState === Exports_js_1.ConnectionState.Disconnected) {
      return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
    }
    if (this.privConnectionEstablishDeferral) {
      return this.privConnectionEstablishDeferral.promise;
    }
    this.privConnectionEstablishDeferral = new Exports_js_1.Deferred();
    this.privCertificateValidatedDeferral = new Exports_js_1.Deferred();
    this.privConnectionState = Exports_js_1.ConnectionState.Connecting;
    try {
      if (typeof WebSocket !== "undefined" && !WebsocketMessageAdapter.forceNpmWebSocket) {
        // Browser handles cert checks.
        this.privCertificateValidatedDeferral.resolve();
        this.privWebsocketClient = new WebSocket(this.privUri);
      } else {
        const options = {
          headers: this.privHeaders,
          perMessageDeflate: this.privEnableCompression
        };
        // The ocsp library will handle validation for us and fail the connection if needed.
        this.privCertificateValidatedDeferral.resolve();
        options.agent = this.getAgent();
        // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465
        // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61
        const uri = new URL(this.privUri);
        let protocol = uri.protocol;
        if (protocol?.toLocaleLowerCase() === "wss:") {
          protocol = "https:";
        } else if (protocol?.toLocaleLowerCase() === "ws:") {
          protocol = "http:";
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        options.agent.protocol = protocol;
        this.privWebsocketClient = new ws_1.default(this.privUri, options);
      }
      this.privWebsocketClient.binaryType = "arraybuffer";
      this.privReceivingMessageQueue = new Exports_js_1.Queue();
      this.privDisconnectDeferral = new Exports_js_1.Deferred();
      this.privSendMessageQueue = new Exports_js_1.Queue();
      this.processSendQueue().catch(reason => {
        Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));
      });
    } catch (error) {
      this.privConnectionEstablishDeferral.resolve(new Exports_js_1.ConnectionOpenResponse(500, error));
      return this.privConnectionEstablishDeferral.promise;
    }
    this.onEvent(new Exports_js_1.ConnectionStartEvent(this.privConnectionId, this.privUri));
    this.privWebsocketClient.onopen = () => {
      this.privCertificateValidatedDeferral.promise.then(() => {
        this.privConnectionState = Exports_js_1.ConnectionState.Connected;
        this.onEvent(new Exports_js_1.ConnectionEstablishedEvent(this.privConnectionId));
        this.privConnectionEstablishDeferral.resolve(new Exports_js_1.ConnectionOpenResponse(200, ""));
      }, error => {
        this.privConnectionEstablishDeferral.reject(error);
      });
    };
    this.privWebsocketClient.onerror = e => {
      this.onEvent(new Exports_js_1.ConnectionErrorEvent(this.privConnectionId, e.message, e.type));
      this.privLastErrorReceived = e.message;
    };
    this.privWebsocketClient.onclose = e => {
      if (this.privConnectionState === Exports_js_1.ConnectionState.Connecting) {
        this.privConnectionState = Exports_js_1.ConnectionState.Disconnected;
        // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));
        this.privConnectionEstablishDeferral.resolve(new Exports_js_1.ConnectionOpenResponse(e.code, e.reason + " " + this.privLastErrorReceived));
      } else {
        this.privConnectionState = Exports_js_1.ConnectionState.Disconnected;
        this.privWebsocketClient = null;
        this.onEvent(new Exports_js_1.ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));
      }
      this.onClose(e.code, e.reason).catch(reason => {
        Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));
      });
    };
    this.privWebsocketClient.onmessage = e => {
      const networkReceivedTime = new Date().toISOString();
      if (this.privConnectionState === Exports_js_1.ConnectionState.Connected) {
        const deferred = new Exports_js_1.Deferred();
        // let id = ++this.idCounter;
        this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);
        if (e.data instanceof ArrayBuffer) {
          const rawMessage = new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Binary, e.data);
          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {
            this.onEvent(new Exports_js_1.ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));
            deferred.resolve(connectionMessage);
          }, error => {
            // TODO: Events for these ?
            deferred.reject(`Invalid binary message format. Error: ${error}`);
          });
        } else {
          const rawMessage = new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Text, e.data);
          this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {
            this.onEvent(new Exports_js_1.ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));
            deferred.resolve(connectionMessage);
          }, error => {
            // TODO: Events for these ?
            deferred.reject(`Invalid text message format. Error: ${error}`);
          });
        }
      }
    };
    return this.privConnectionEstablishDeferral.promise;
  }
  send(message) {
    if (this.privConnectionState !== Exports_js_1.ConnectionState.Connected) {
      return Promise.reject(`Cannot send on connection that is in ${Exports_js_1.ConnectionState[this.privConnectionState]} state`);
    }
    const messageSendStatusDeferral = new Exports_js_1.Deferred();
    const messageSendDeferral = new Exports_js_1.Deferred();
    this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);
    this.privMessageFormatter.fromConnectionMessage(message).then(rawMessage => {
      messageSendDeferral.resolve({
        Message: message,
        RawWebsocketMessage: rawMessage,
        sendStatusDeferral: messageSendStatusDeferral
      });
    }, error => {
      messageSendDeferral.reject(`Error formatting the message. ${error}`);
    });
    return messageSendStatusDeferral.promise;
  }
  read() {
    if (this.privConnectionState !== Exports_js_1.ConnectionState.Connected) {
      return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);
    }
    return this.privReceivingMessageQueue.dequeue();
  }
  close(reason) {
    if (this.privWebsocketClient) {
      if (this.privConnectionState !== Exports_js_1.ConnectionState.Disconnected) {
        this.privWebsocketClient.close(1000, reason ? reason : "Normal closure by client");
      }
    } else {
      return Promise.resolve();
    }
    return this.privDisconnectDeferral.promise;
  }
  get events() {
    return this.privConnectionEvents;
  }
  sendRawMessage(sendItem) {
    try {
      // indicates we are draining the queue and it came with no message;
      if (!sendItem) {
        return Promise.resolve();
      }
      this.onEvent(new Exports_js_1.ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));
      // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing
      if (this.isWebsocketOpen) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);
      } else {
        return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + sendItem.Message.id + " " + new Error().stack);
      }
      return Promise.resolve();
    } catch (e) {
      return Promise.reject(`websocket send error: ${e}`);
    }
  }
  async onClose(code, reason) {
    const closeReason = `Connection closed. ${code}: ${reason}`;
    this.privConnectionState = Exports_js_1.ConnectionState.Disconnected;
    this.privDisconnectDeferral.resolve();
    await this.privReceivingMessageQueue.drainAndDispose(() => {
      // TODO: Events for these ?
      // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));
    }, closeReason);
    await this.privSendMessageQueue.drainAndDispose(pendingSendItem => {
      pendingSendItem.sendStatusDeferral.reject(closeReason);
    }, closeReason);
  }
  async processSendQueue() {
    while (true) {
      const itemToSend = this.privSendMessageQueue.dequeue();
      const sendItem = await itemToSend;
      // indicates we are draining the queue and it came with no message;
      if (!sendItem) {
        return;
      }
      try {
        await this.sendRawMessage(sendItem);
        sendItem.sendStatusDeferral.resolve();
      } catch (sendError) {
        sendItem.sendStatusDeferral.reject(sendError);
      }
    }
  }
  onEvent(event) {
    this.privConnectionEvents.onEvent(event);
    Exports_js_1.Events.instance.onEvent(event);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getAgent() {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const agent = new agent_base_1.default.Agent(this.createConnection);
    if (this.proxyInfo !== undefined && this.proxyInfo.HostName !== undefined && this.proxyInfo.Port > 0) {
      agent.proxyInfo = this.proxyInfo;
    }
    return agent;
  }
  static GetProxyAgent(proxyInfo) {
    const httpProxyOptions = {
      host: proxyInfo.HostName,
      port: proxyInfo.Port
    };
    if (!!proxyInfo.UserName) {
      httpProxyOptions.headers = {
        "Proxy-Authentication": "Basic " + new Buffer(`${proxyInfo.UserName}:${proxyInfo.Password === undefined ? "" : proxyInfo.Password}`).toString("base64")
      };
    } else {
      httpProxyOptions.headers = {};
    }
    httpProxyOptions.headers.requestOCSP = "true";
    const httpProxyAgent = new https_proxy_agent_1.default(httpProxyOptions);
    return httpProxyAgent;
  }
  createConnection(request, options) {
    let socketPromise;
    options = {
      ...options,
      ...{
        requestOCSP: true,
        servername: options.host
      }
    };
    if (!!this.proxyInfo) {
      const httpProxyAgent = WebsocketMessageAdapter.GetProxyAgent(this.proxyInfo);
      const baseAgent = httpProxyAgent;
      socketPromise = new Promise((resolve, reject) => {
        baseAgent.callback(request, options, (error, socket) => {
          if (!!error) {
            reject(error);
          } else {
            resolve(socket);
          }
        });
      });
    } else {
      if (!!options.secureEndpoint) {
        socketPromise = Promise.resolve(tls.connect(options));
      } else {
        socketPromise = Promise.resolve(net.connect(options));
      }
    }
    return socketPromise;
  }
  get isWebsocketOpen() {
    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
  }
}
exports.WebsocketMessageAdapter = WebsocketMessageAdapter;
WebsocketMessageAdapter.forceNpmWebSocket = false;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AddedLmIntent.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AddedLmIntent.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AddedLmIntent = void 0;
/**
 * @class AddedLmIntent
 */
// eslint-disable-next-line max-classes-per-file
class AddedLmIntent {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param modelImpl - The model.
   * @param intentName - The intent name.
   */
  constructor(modelImpl, intentName) {
    this.modelImpl = modelImpl;
    this.intentName = intentName;
  }
}
exports.AddedLmIntent = AddedLmIntent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AgentConfig.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AgentConfig.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AgentConfig = void 0;
/**
 * Represents the JSON used in the agent.config message sent to the speech service.
 */
class AgentConfig {
  toJsonString() {
    return JSON.stringify(this.iPrivConfig);
  }
  get() {
    return this.iPrivConfig;
  }
  /**
   * Setter for the agent.config object.
   * @param value a JSON serializable object.
   */
  set(value) {
    this.iPrivConfig = value;
  }
}
exports.AgentConfig = AgentConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AvatarSynthesisAdapter.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AvatarSynthesisAdapter.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AvatarSynthesisAdapter = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class AvatarSynthesisAdapter extends Exports_js_2.SynthesisAdapterBase {
  constructor(authentication, connectionFactory, synthesizerConfig, avatarSynthesizer, avatarConfig) {
    super(authentication, connectionFactory, synthesizerConfig, undefined);
    this.privAvatarSynthesizer = avatarSynthesizer;
    this.privSynthesizer = avatarSynthesizer;
    this.privAvatarConfig = avatarConfig;
  }
  setSynthesisContextSynthesisSection() {
    this.privSynthesisContext.setSynthesisSection(undefined);
  }
  setSpeechConfigSynthesisSection() {
    this.privSynthesizerConfig.synthesisVideoSection = {
      format: {
        bitrate: this.privAvatarConfig.videoFormat?.bitrate,
        codec: this.privAvatarConfig.videoFormat?.codec,
        crop: {
          bottomRight: {
            x: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.x,
            y: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.y
          },
          topLeft: {
            x: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.x,
            y: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.y
          }
        },
        resolution: {
          height: this.privAvatarConfig.videoFormat?.height,
          width: this.privAvatarConfig.videoFormat?.width
        }
      },
      protocol: {
        name: "WebRTC",
        webrtcConfig: {
          clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(Exports_js_1.PropertyId.TalkingAvatarService_WebRTC_SDP)),
          iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
        }
      },
      talkingAvatar: {
        background: {
          color: this.privAvatarConfig.backgroundColor,
          image: {
            url: this.privAvatarConfig.backgroundImage?.toString()
          }
        },
        character: this.privAvatarConfig.character,
        customized: this.privAvatarConfig.customized,
        style: this.privAvatarConfig.style,
        useBuiltInVoice: this.privAvatarConfig.useBuiltInVoice
      }
    };
  }
  onAvatarEvent(metadata) {
    if (!!this.privAvatarSynthesizer.avatarEventReceived) {
      const avatarEventArgs = new Exports_js_1.AvatarEventArgs(metadata.Data.Offset, metadata.Data.Name);
      try {
        this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, avatarEventArgs);
      } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
      }
    }
  }
}
exports.AvatarSynthesisAdapter = AvatarSynthesisAdapter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/CognitiveSubscriptionKeyAuthentication.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/CognitiveSubscriptionKeyAuthentication.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CognitiveSubscriptionKeyAuthentication = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const IAuthentication_js_1 = __webpack_require__(/*! ./IAuthentication.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IAuthentication.js");
/**
 * @class
 */
class CognitiveSubscriptionKeyAuthentication {
  /**
   * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
   * @constructor
   * @param {string} subscriptionKey - The subscription key
   */
  constructor(subscriptionKey) {
    if (!subscriptionKey) {
      throw new Exports_js_1.ArgumentNullError("subscriptionKey");
    }
    this.privAuthInfo = new IAuthentication_js_1.AuthInfo(HeaderNames_js_1.HeaderNames.AuthKey, subscriptionKey);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetch(authFetchEventId) {
    return Promise.resolve(this.privAuthInfo);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetchOnExpiry(authFetchEventId) {
    return Promise.resolve(this.privAuthInfo);
  }
}
exports.CognitiveSubscriptionKeyAuthentication = CognitiveSubscriptionKeyAuthentication;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/CognitiveTokenAuthentication.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/CognitiveTokenAuthentication.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CognitiveTokenAuthentication = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const IAuthentication_js_1 = __webpack_require__(/*! ./IAuthentication.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IAuthentication.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
class CognitiveTokenAuthentication {
  constructor(fetchCallback, fetchOnExpiryCallback) {
    if (!fetchCallback) {
      throw new Exports_js_1.ArgumentNullError("fetchCallback");
    }
    if (!fetchOnExpiryCallback) {
      throw new Exports_js_1.ArgumentNullError("fetchOnExpiryCallback");
    }
    this.privFetchCallback = fetchCallback;
    this.privFetchOnExpiryCallback = fetchOnExpiryCallback;
  }
  fetch(authFetchEventId) {
    return this.privFetchCallback(authFetchEventId).then(token => new IAuthentication_js_1.AuthInfo(HeaderNames_js_1.HeaderNames.Authorization, token === undefined ? undefined : CognitiveTokenAuthentication.privTokenPrefix + token));
  }
  fetchOnExpiry(authFetchEventId) {
    return this.privFetchOnExpiryCallback(authFetchEventId).then(token => new IAuthentication_js_1.AuthInfo(HeaderNames_js_1.HeaderNames.Authorization, token === undefined ? undefined : CognitiveTokenAuthentication.privTokenPrefix + token));
  }
}
exports.CognitiveTokenAuthentication = CognitiveTokenAuthentication;
CognitiveTokenAuthentication.privTokenPrefix = "Bearer ";

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionFactoryBase = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ./QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
class ConnectionFactoryBase {
  static getHostSuffix(region) {
    if (!!region) {
      if (region.toLowerCase().startsWith("china")) {
        return ".azure.cn";
      }
      if (region.toLowerCase().startsWith("usgov")) {
        return ".azure.us";
      }
    }
    return ".microsoft.com";
  }
  setCommonUrlParams(config, queryParams, endpoint) {
    const propertyIdToParameterMap = new Map([[Exports_js_2.PropertyId.Speech_SegmentationSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.SegmentationSilenceTimeoutMs], [Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, QueryParameterNames_js_1.QueryParameterNames.EnableAudioLogging], [Exports_js_2.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.EndSilenceTimeoutMs], [Exports_js_2.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.InitialSilenceTimeoutMs], [Exports_js_2.PropertyId.SpeechServiceResponse_PostProcessingOption, QueryParameterNames_js_1.QueryParameterNames.Postprocessing], [Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, QueryParameterNames_js_1.QueryParameterNames.Profanity], [Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, QueryParameterNames_js_1.QueryParameterNames.EnableWordLevelTimestamps], [Exports_js_2.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, QueryParameterNames_js_1.QueryParameterNames.StableIntermediateThreshold]]);
    propertyIdToParameterMap.forEach((parameterName, propertyId) => {
      this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);
    });
    const serviceProperties = JSON.parse(config.parameters.getProperty(Exports_js_1.ServicePropertiesPropertyName, "{}"));
    Object.keys(serviceProperties).forEach(value => {
      queryParams[value] = serviceProperties[value];
    });
  }
  setUrlParameter(propId, parameterName, config, queryParams, endpoint) {
    const value = config.parameters.getProperty(propId, undefined);
    // FIXME: The .search() check will incorrectly match parameter name anywhere in the string
    //        including e.g. the path portion, or even as a substring of other query parameters
    if (value && (!endpoint || endpoint.search(parameterName) === -1)) {
      queryParams[parameterName] = value.toLocaleLowerCase();
    }
  }
}
exports.ConnectionFactoryBase = ConnectionFactoryBase;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationServiceRecognizer.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationServiceRecognizer.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class ConversationServiceRecognizer extends Exports_js_2.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
    this.handleSpeechPhraseMessage = async textBody => this.handleSpeechPhrase(textBody);
    this.handleSpeechHypothesisMessage = textBody => this.handleSpeechHypothesis(textBody);
  }
  processTypeSpecificMessages(connectionMessage) {
    void connectionMessage;
    return;
  }
  handleRecognizedCallback(result, offset, sessionId) {
    void result;
    void offset;
    void sessionId;
    return;
  }
  handleRecognizingCallback(result, duration, sessionId) {
    void result;
    void duration;
    void sessionId;
    return;
  }
  async processSpeechMessages(connectionMessage) {
    let processed = false;
    switch (connectionMessage.path.toLowerCase()) {
      case "speech.hypothesis":
      case "speech.fragment":
        if (!!this.handleSpeechHypothesisMessage) {
          this.handleSpeechHypothesisMessage(connectionMessage.textBody);
        }
        processed = true;
        break;
      case "speech.phrase":
        if (!!this.handleSpeechPhraseMessage) {
          await this.handleSpeechPhraseMessage(connectionMessage.textBody);
        }
        processed = true;
        break;
      default:
        break;
    }
    return processed;
  }
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    // Implementing to allow inheritance
    void sessionId;
    void requestId;
    void cancellationReason;
    void errorCode;
    void error;
  }
  async handleSpeechPhrase(textBody) {
    const simple = Exports_js_2.SimpleSpeechPhrase.fromJSON(textBody, this.privRequestSession.currentTurnAudioOffset);
    const resultReason = Exports_js_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
    let result;
    const resultProps = new Exports_js_1.PropertyCollection();
    resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, textBody);
    this.privRequestSession.onPhraseRecognized(simple.Offset + simple.Duration);
    if (Exports_js_1.ResultReason.Canceled === resultReason) {
      const cancelReason = Exports_js_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
      const cancellationErrorCode = Exports_js_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
      await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
    } else {
      if (simple.RecognitionStatus !== Exports_js_2.RecognitionStatus.EndOfDictation) {
        if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.OutputFormatPropertyName) === Exports_js_1.OutputFormat[Exports_js_1.OutputFormat.Simple]) {
          result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, undefined, simple.asJson(), resultProps);
        } else {
          const detailed = Exports_js_2.DetailedSpeechPhrase.fromJSON(textBody, this.privRequestSession.currentTurnAudioOffset);
          result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.Text, detailed.Duration, detailed.Offset, detailed.Language, detailed.LanguageDetectionConfidence, detailed.SpeakerId, undefined, detailed.asJson(), resultProps);
        }
        this.handleRecognizedCallback(result, result.offset, this.privRequestSession.sessionId);
      }
    }
  }
  handleSpeechHypothesis(textBody) {
    const hypothesis = Exports_js_2.SpeechHypothesis.fromJSON(textBody, this.privRequestSession.currentTurnAudioOffset);
    const resultProps = new Exports_js_1.PropertyCollection();
    resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, textBody);
    const result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_js_1.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, hypothesis.Offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, hypothesis.SpeakerId, undefined, hypothesis.asJson(), resultProps);
    this.privRequestSession.onHypothesis(hypothesis.Offset);
    this.handleRecognizingCallback(result, hypothesis.Duration, this.privRequestSession.sessionId);
  }
}
exports.ConversationServiceRecognizer = ConversationServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationTranscriberConnectionFactory.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationTranscriberConnectionFactory.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranscriberConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ./QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
class ConversationTranscriberConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  constructor() {
    super(...arguments);
    this.universalUri = "/speech/universal/v2";
  }
  create(config, authInfo, connectionId) {
    let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
    const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, undefined);
    const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
    const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".stt.speech" + hostSuffix);
    const queryParams = {};
    const endpointId = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, undefined);
    const language = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, undefined);
    if (endpointId) {
      if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId) === -1) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
      }
    } else if (language) {
      if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.Language) === -1) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
      }
    }
    if (config.autoDetectSourceLanguages !== undefined) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableLanguageId] = "true";
    }
    this.setV2UrlParams(config, queryParams, endpoint);
    if (!endpoint) {
      endpoint = `${host}${this.universalUri}`;
    }
    const headers = {};
    if (authInfo.token !== undefined && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    const webSocketConnection = new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_4.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    // Set the value of SpeechServiceConnection_Url to webSocketConnection.uri (and not to `endpoint`), since this value is the final
    // URI that was used to make the connection (including query parameters).
    const uri = webSocketConnection.uri;
    config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, uri);
    return webSocketConnection;
  }
  setV2UrlParams(config, queryParams, endpoint) {
    const propertyIdToParameterMap = new Map([[Exports_js_2.PropertyId.Speech_SegmentationSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.SegmentationSilenceTimeoutMs], [Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, QueryParameterNames_js_1.QueryParameterNames.EnableAudioLogging], [Exports_js_2.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.EndSilenceTimeoutMs], [Exports_js_2.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, QueryParameterNames_js_1.QueryParameterNames.InitialSilenceTimeoutMs], [Exports_js_2.PropertyId.SpeechServiceResponse_PostProcessingOption, QueryParameterNames_js_1.QueryParameterNames.Postprocessing], [Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, QueryParameterNames_js_1.QueryParameterNames.Profanity], [Exports_js_2.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, QueryParameterNames_js_1.QueryParameterNames.StableIntermediateThreshold]]);
    propertyIdToParameterMap.forEach((parameterName, propertyId) => {
      this.setUrlParameter(propertyId, parameterName, config, queryParams, endpoint);
    });
    const serviceProperties = JSON.parse(config.parameters.getProperty(Exports_js_3.ServicePropertiesPropertyName, "{}"));
    Object.keys(serviceProperties).forEach(value => {
      queryParams[value] = serviceProperties[value];
    });
  }
}
exports.ConversationTranscriberConnectionFactory = ConversationTranscriberConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationTranscriptionServiceRecognizer.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationTranscriptionServiceRecognizer.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranscriptionServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
// eslint-disable-next-line max-classes-per-file
class ConversationTranscriptionServiceRecognizer extends Exports_js_2.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationTranscriber);
    this.privConversationTranscriber = conversationTranscriber;
    this.setSpeakerDiarizationJson();
  }
  setSpeakerDiarizationJson() {
    if (this.privEnableSpeakerId) {
      const phraseDetection = this.privSpeechContext.getSection("phraseDetection");
      phraseDetection.mode = "Conversation";
      const speakerDiarization = {};
      speakerDiarization.mode = "Anonymous";
      speakerDiarization.audioSessionId = this.privDiarizationSessionId;
      speakerDiarization.audioOffsetMs = 0;
      speakerDiarization.diarizeIntermediates = this.privRecognizerConfig.parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceResponse_DiarizeIntermediateResults, "false") === "true";
      phraseDetection.speakerDiarization = speakerDiarization;
      this.privSpeechContext.setSection("phraseDetection", phraseDetection);
    }
  }
  async processTypeSpecificMessages(connectionMessage) {
    let result;
    const resultProps = new Exports_js_1.PropertyCollection();
    resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
    let processed = false;
    switch (connectionMessage.path.toLowerCase()) {
      case "speech.hypothesis":
      case "speech.fragment":
        const hypothesis = Exports_js_2.SpeechHypothesis.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        result = new Exports_js_1.ConversationTranscriptionResult(this.privRequestSession.requestId, Exports_js_1.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, hypothesis.Offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, hypothesis.SpeakerId, undefined, hypothesis.asJson(), resultProps);
        this.privRequestSession.onHypothesis(hypothesis.Offset);
        const ev = new Exports_js_1.ConversationTranscriptionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);
        if (!!this.privConversationTranscriber.transcribing) {
          try {
            this.privConversationTranscriber.transcribing(this.privConversationTranscriber, ev);
            /* eslint-disable no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        processed = true;
        break;
      case "speech.phrase":
        const simple = Exports_js_2.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        const resultReason = Exports_js_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus);
        this.privRequestSession.onPhraseRecognized(simple.Offset + simple.Duration);
        if (Exports_js_1.ResultReason.Canceled === resultReason) {
          const cancelReason = Exports_js_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
          const cancellationErrorCode = Exports_js_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
          await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
        } else {
          if (!(this.privRequestSession.isSpeechEnded && resultReason === Exports_js_1.ResultReason.NoMatch && simple.RecognitionStatus !== Exports_js_2.RecognitionStatus.InitialSilenceTimeout)) {
            if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.OutputFormatPropertyName) === Exports_js_1.OutputFormat[Exports_js_1.OutputFormat.Simple]) {
              result = new Exports_js_1.ConversationTranscriptionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset, simple.Language, simple.LanguageDetectionConfidence, simple.SpeakerId, undefined, simple.asJson(), resultProps);
            } else {
              const detailed = Exports_js_2.DetailedSpeechPhrase.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
              result = new Exports_js_1.ConversationTranscriptionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === Exports_js_2.RecognitionStatus.Success ? detailed.NBest[0].Display : undefined, detailed.Duration, detailed.Offset, detailed.Language, detailed.LanguageDetectionConfidence, simple.SpeakerId, undefined, detailed.asJson(), resultProps);
            }
            const event = new Exports_js_1.ConversationTranscriptionEventArgs(result, result.offset, this.privRequestSession.sessionId);
            if (!!this.privConversationTranscriber.transcribed) {
              try {
                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, event);
                /* eslint-disable no-empty */
              } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
              }
            }
          }
        }
        processed = true;
        break;
      default:
        break;
    }
    return processed;
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    const properties = new Exports_js_1.PropertyCollection();
    properties.setProperty(Exports_js_2.CancellationErrorCodePropertyName, Exports_js_1.CancellationErrorCode[errorCode]);
    if (!!this.privConversationTranscriber.canceled) {
      const cancelEvent = new Exports_js_1.ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
      try {
        this.privConversationTranscriber.canceled(this.privConversationTranscriber, cancelEvent);
        /* eslint-disable no-empty */
      } catch {}
    }
  }
}
exports.ConversationTranscriptionServiceRecognizer = ConversationTranscriptionServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogConnectorFactory.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogConnectorFactory.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DialogConnectionFactory = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ./QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
class DialogConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  create(config, authInfo, connectionId) {
    const applicationId = config.parameters.getProperty(Exports_js_3.PropertyId.Conversation_ApplicationId, "");
    const dialogType = config.parameters.getProperty(Exports_js_3.PropertyId.Conversation_DialogType);
    const region = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Region);
    const language = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US");
    const requestTurnStatus = config.parameters.getProperty(Exports_js_3.PropertyId.Conversation_Request_Bot_Status_Messages, "true");
    const queryParams = {};
    queryParams[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = config.parameters.getProperty(Exports_js_2.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]).toLowerCase();
    queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
    queryParams[QueryParameterNames_js_1.QueryParameterNames.RequestBotStatusMessages] = requestTurnStatus;
    if (applicationId) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.BotId] = applicationId;
      if (dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands) {
        queryParams[HeaderNames_js_1.HeaderNames.CustomCommandsAppId] = applicationId;
      }
    }
    const resourceInfix = dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "";
    const version = dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : dialogType === Exports_js_3.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0";
    const headers = {};
    if (authInfo.token != null && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    // The URL used for connection is chosen in a priority order of specification:
    //  1. If a custom endpoint is provided, that URL is used verbatim.
    //  2. If a custom host is provided (e.g. "wss://my.custom.endpoint.com:1123"), a URL is constructed from it.
    //  3. If no custom connection details are provided, a URL is constructed from default values.
    let endpoint = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint, "");
    if (!endpoint) {
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      const host = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Host, `wss://${region}.${DialogConnectionFactory.BaseUrl}${hostSuffix}`);
      const standardizedHost = host.endsWith("/") ? host : host + "/";
      endpoint = `${standardizedHost}${resourceInfix}${DialogConnectionFactory.ApiKey}/${version}`;
    }
    this.setCommonUrlParams(config, queryParams, endpoint);
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    return new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_4.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
  }
}
exports.DialogConnectionFactory = DialogConnectionFactory;
DialogConnectionFactory.ApiKey = "api";
DialogConnectionFactory.BaseUrl = "convai.speech";

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DialogServiceAdapter = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const DialogEvents_js_1 = __webpack_require__(/*! ../common/DialogEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DialogEvents.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const AudioOutputFormat_js_1 = __webpack_require__(/*! ../sdk/Audio/AudioOutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js");
const Exports_js_3 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const DialogServiceTurnStateManager_js_1 = __webpack_require__(/*! ./DialogServiceTurnStateManager.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceTurnStateManager.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const ActivityResponsePayload_js_1 = __webpack_require__(/*! ./ServiceMessages/ActivityResponsePayload.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/ActivityResponsePayload.js");
const SpeechConnectionMessage_Internal_js_1 = __webpack_require__(/*! ./SpeechConnectionMessage.Internal.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js");
class DialogServiceAdapter extends Exports_js_4.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);
    this.privEvents = new Exports_js_2.EventSource();
    this.privDialogServiceConnector = dialogServiceConnector;
    this.receiveMessageOverride = () => this.receiveDialogMessageOverride();
    this.privTurnStateManager = new DialogServiceTurnStateManager_js_1.DialogServiceTurnStateManager();
    this.recognizeOverride = (recoMode, successCallback, errorCallback) => this.listenOnce(recoMode, successCallback, errorCallback);
    this.postConnectImplOverride = connection => this.dialogConnectImpl(connection);
    this.configConnectionOverride = connection => this.configConnection(connection);
    this.disconnectOverride = () => this.privDisconnect();
    this.privDialogAudioSource = audioSource;
    this.agentConfigSent = false;
    this.privLastResult = null;
    this.connectionEvents.attach(connectionEvent => {
      if (connectionEvent.name === "ConnectionClosedEvent") {
        this.terminateMessageLoop = true;
      }
    });
  }
  async sendMessage(message) {
    const interactionGuid = Exports_js_2.createGuid();
    const requestId = Exports_js_2.createNoDashGuid();
    const agentMessage = {
      context: {
        interactionId: interactionGuid
      },
      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
      messagePayload: JSON.parse(message),
      version: 0.5
    };
    const agentMessageJson = JSON.stringify(agentMessage);
    const connection = await this.fetchConnection();
    await connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "agent", requestId, "application/json", agentMessageJson));
  }
  async privDisconnect() {
    await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.NoError, "Disconnecting");
    this.terminateMessageLoop = true;
    this.agentConfigSent = false;
    return;
  }
  processTypeSpecificMessages(connectionMessage) {
    const resultProps = new Exports_js_3.PropertyCollection();
    if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {
      resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
    }
    let result;
    let processed;
    switch (connectionMessage.path.toLowerCase()) {
      case "speech.phrase":
        const speechPhrase = Exports_js_4.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        this.privRequestSession.onPhraseRecognized(speechPhrase.Offset + speechPhrase.Duration);
        if (speechPhrase.RecognitionStatus !== Exports_js_4.RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== Exports_js_4.RecognitionStatus.Error) {
          const args = this.fireEventForResult(speechPhrase, resultProps);
          this.privLastResult = args.result;
          if (!!this.privDialogServiceConnector.recognized) {
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);
              /* eslint-disable no-empty */
            } catch (error) {
              // Not going to let errors in the event handler
              // trip things up.
            }
          }
        }
        processed = true;
        break;
      case "speech.hypothesis":
        const hypothesis = Exports_js_4.SpeechHypothesis.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        result = new Exports_js_3.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_js_3.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, hypothesis.Offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, hypothesis.asJson(), resultProps);
        this.privRequestSession.onHypothesis(hypothesis.Offset);
        const ev = new Exports_js_3.SpeechRecognitionEventArgs(result, hypothesis.Offset, this.privRequestSession.sessionId);
        if (!!this.privDialogServiceConnector.recognizing) {
          try {
            this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);
            /* eslint-disable no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        processed = true;
        break;
      case "speech.keyword":
        const keyword = Exports_js_4.SpeechKeyword.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        result = new Exports_js_3.SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === "Accepted" ? Exports_js_3.ResultReason.RecognizedKeyword : Exports_js_3.ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, keyword.asJson(), resultProps);
        if (keyword.Status !== "Accepted") {
          this.privLastResult = result;
        }
        const event = new Exports_js_3.SpeechRecognitionEventArgs(result, result.duration, result.resultId);
        if (!!this.privDialogServiceConnector.recognized) {
          try {
            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);
            /* eslint-disable no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        processed = true;
        break;
      case "audio":
        {
          const audioRequestId = connectionMessage.requestId.toUpperCase();
          const turn = this.privTurnStateManager.GetTurn(audioRequestId);
          try {
            // Empty binary message signals end of stream.
            if (!connectionMessage.binaryBody) {
              turn.endAudioStream();
            } else {
              turn.audioStream.write(connectionMessage.binaryBody);
            }
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        processed = true;
        break;
      case "response":
        {
          this.handleResponseMessage(connectionMessage);
        }
        processed = true;
        break;
      default:
        break;
    }
    const defferal = new Exports_js_2.Deferred();
    defferal.resolve(processed);
    return defferal.promise;
  }
  // Cancels recognition.
  async cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    this.terminateMessageLoop = true;
    if (!!this.privRequestSession.isRecognizing) {
      await this.privRequestSession.onStopRecognizing();
    }
    if (!!this.privDialogServiceConnector.canceled) {
      const properties = new Exports_js_3.PropertyCollection();
      properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);
      const cancelEvent = new Exports_js_3.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
      try {
        this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);
        /* eslint-disable no-empty */
      } catch {}
      if (!!this.privSuccessCallback) {
        const result = new Exports_js_3.SpeechRecognitionResult(undefined,
        // ResultId
        Exports_js_3.ResultReason.Canceled, undefined,
        // Text
        undefined,
        // Duration
        undefined,
        // Offset
        undefined,
        // Language
        undefined,
        // Language Detection Confidence
        undefined,
        // Speaker Id
        error, undefined,
        // Json
        properties);
        try {
          this.privSuccessCallback(result);
          this.privSuccessCallback = undefined;
          /* eslint-disable no-empty */
        } catch {}
      }
    }
  }
  async listenOnce(recoMode, successCallback, errorCallback) {
    this.privRecognizerConfig.recognitionMode = recoMode;
    this.privSuccessCallback = successCallback;
    this.privErrorCallback = errorCallback;
    this.privRequestSession.startNewRecognition();
    this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);
    this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
    // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
    const conPromise = this.connectImpl();
    const preAudioPromise = this.sendPreAudioMessages();
    const node = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);
    const format = await this.privDialogAudioSource.format;
    const deviceInfo = await this.privDialogAudioSource.deviceInfo;
    const audioNode = new Exports_js_1.ReplayableAudioNode(node, format.avgBytesPerSec);
    await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
    this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
      source: deviceInfo
    };
    try {
      await conPromise;
      await preAudioPromise;
    } catch (error) {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, error);
      return Promise.resolve();
    }
    const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
    if (!!this.privRecognizer.sessionStarted) {
      this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
    }
    const audioSendPromise = this.sendAudio(audioNode);
    // /* eslint-disable no-empty */
    audioSendPromise.then(() => {}, async error => {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
    });
  }
  // Establishes a websocket connection to the end point.
  dialogConnectImpl(connection) {
    this.privConnectionLoop = this.startMessageLoop();
    return connection;
  }
  receiveDialogMessageOverride() {
    // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages
    const communicationCustodian = new Exports_js_2.Deferred();
    const loop = async () => {
      try {
        const isDisposed = this.isDisposed();
        const terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;
        if (isDisposed || terminateMessageLoop) {
          // We're done.
          communicationCustodian.resolve(undefined);
          return;
        }
        const connection = await this.fetchConnection();
        const message = await connection.read();
        if (!message) {
          return loop();
        }
        const connectionMessage = SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage.fromConnectionMessage(message);
        switch (connectionMessage.path.toLowerCase()) {
          case "turn.start":
            {
              const turnRequestId = connectionMessage.requestId.toUpperCase();
              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();
              // turn started by the service
              if (turnRequestId !== audioSessionReqId) {
                this.privTurnStateManager.StartTurn(turnRequestId);
              } else {
                this.privRequestSession.onServiceTurnStartResponse();
              }
            }
            break;
          case "speech.startdetected":
            const speechStartDetected = Exports_js_4.SpeechDetected.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
            const speechStartEventArgs = new Exports_js_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);
            if (!!this.privRecognizer.speechStartDetected) {
              this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);
            }
            break;
          case "speech.enddetected":
            let json;
            if (connectionMessage.textBody.length > 0) {
              json = connectionMessage.textBody;
            } else {
              // If the request was empty, the JSON returned is empty.
              json = "{ Offset: 0 }";
            }
            const speechStopDetected = Exports_js_4.SpeechDetected.fromJSON(json, this.privRequestSession.currentTurnAudioOffset);
            this.privRequestSession.onServiceRecognized(speechStopDetected.Offset);
            const speechStopEventArgs = new Exports_js_3.RecognitionEventArgs(speechStopDetected.Offset, this.privRequestSession.sessionId);
            if (!!this.privRecognizer.speechEndDetected) {
              this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);
            }
            break;
          case "turn.end":
            {
              const turnEndRequestId = connectionMessage.requestId.toUpperCase();
              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();
              // turn started by the service
              if (turnEndRequestId !== audioSessionReqId) {
                this.privTurnStateManager.CompleteTurn(turnEndRequestId);
              } else {
                // Audio session turn
                const sessionStopEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
                await this.privRequestSession.onServiceTurnEndResponse(false);
                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                  if (!!this.privRecognizer.sessionStopped) {
                    this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);
                  }
                }
                // report result to promise.
                if (!!this.privSuccessCallback && this.privLastResult) {
                  try {
                    this.privSuccessCallback(this.privLastResult);
                    this.privLastResult = null;
                  } catch (e) {
                    if (!!this.privErrorCallback) {
                      this.privErrorCallback(e);
                    }
                  }
                  // Only invoke the call back once.
                  // and if it's successful don't invoke the
                  // error after that.
                  this.privSuccessCallback = undefined;
                  this.privErrorCallback = undefined;
                }
              }
            }
            break;
          default:
            try {
              const processed = await this.processTypeSpecificMessages(connectionMessage);
              if (!processed) {
                if (!!this.serviceEvents) {
                  this.serviceEvents.onEvent(new Exports_js_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
                }
              }
            } catch (e) {
              //
            }
        }
        const ret = loop();
        return ret;
      } catch (error) {
        this.terminateMessageLoop = true;
        communicationCustodian.resolve();
      }
    };
    loop().catch(reason => {
      Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));
    });
    return communicationCustodian.promise;
  }
  async startMessageLoop() {
    this.terminateMessageLoop = false;
    try {
      await this.receiveDialogMessageOverride();
    } catch (error) {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
    }
    return Promise.resolve();
  }
  // Takes an established websocket connection to the endpoint and sends speech configuration information.
  async configConnection(connection) {
    if (this.terminateMessageLoop) {
      this.terminateMessageLoop = false;
      return Promise.reject("Connection to service terminated.");
    }
    await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());
    await this.sendAgentConfig(connection);
    return connection;
  }
  async sendPreAudioMessages() {
    const connection = await this.fetchConnection();
    this.addKeywordContextData();
    await this.sendSpeechContext(connection, true);
    await this.sendAgentContext(connection);
    await this.sendWaveHeader(connection);
  }
  sendAgentConfig(connection) {
    if (this.agentConfig && !this.agentConfigSent) {
      if (this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.Conversation_DialogType) === Exports_js_3.DialogServiceConfig.DialogTypes.CustomCommands) {
        const config = this.agentConfig.get();
        config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us");
        this.agentConfig.set(config);
      }
      this.onEvent(new DialogEvents_js_1.SendingAgentContextMessageEvent(this.agentConfig));
      const agentConfigJson = this.agentConfig.toJsonString();
      // guard against sending this multiple times on one connection
      this.agentConfigSent = true;
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", agentConfigJson));
    }
    return;
  }
  sendAgentContext(connection) {
    const guid = Exports_js_2.createGuid();
    const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(Exports_js_3.PropertyId.Conversation_Speech_Activity_Template);
    const agentContext = {
      channelData: "",
      context: {
        interactionId: guid
      },
      messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,
      version: 0.5
    };
    const agentContextJson = JSON.stringify(agentContext);
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", agentContextJson));
  }
  fireEventForResult(serviceResult, properties) {
    const resultReason = Exports_js_4.EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);
    const result = new Exports_js_3.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, serviceResult.Offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, serviceResult.asJson(), properties);
    const ev = new Exports_js_3.SpeechRecognitionEventArgs(result, serviceResult.Offset, this.privRequestSession.sessionId);
    return ev;
  }
  handleResponseMessage(responseMessage) {
    // "response" messages can contain either "message" (activity) or "MessageStatus" data. Fire the appropriate
    // event according to the message type that's specified.
    const responsePayload = JSON.parse(responseMessage.textBody);
    switch (responsePayload.messageType.toLowerCase()) {
      case "message":
        const responseRequestId = responseMessage.requestId.toUpperCase();
        const activityPayload = ActivityResponsePayload_js_1.ActivityPayloadResponse.fromJSON(responseMessage.textBody);
        const turn = this.privTurnStateManager.GetTurn(responseRequestId);
        // update the conversation Id
        if (activityPayload.conversationId) {
          const updateAgentConfig = this.agentConfig.get();
          updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;
          this.agentConfig.set(updateAgentConfig);
        }
        const pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormat_js_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));
        const activity = new Exports_js_3.ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);
        if (!!this.privDialogServiceConnector.activityReceived) {
          try {
            this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);
            /* eslint-disable-next-line no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        break;
      case "messagestatus":
        if (!!this.privDialogServiceConnector.turnStatusReceived) {
          try {
            this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new Exports_js_3.TurnStatusReceivedEventArgs(responseMessage.textBody));
            /* eslint-disable-next-line no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        break;
      default:
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));
        break;
    }
  }
  onEvent(event) {
    this.privEvents.onEvent(event);
    Exports_js_2.Events.instance.onEvent(event);
  }
  addKeywordContextData() {
    const keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
    if (keywordPropertyValue === undefined) {
      return;
    }
    const keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets");
    const keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations");
    const keywords = keywordPropertyValue.split(";");
    const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(";");
    const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(";");
    const keywordDefinitionArray = [];
    for (let i = 0; i < keywords.length; i++) {
      const definition = {};
      definition.text = keywords[i];
      if (i < keywordOffsets.length) {
        definition.offset = Number(keywordOffsets[i]);
      }
      if (i < keywordDurations.length) {
        definition.duration = Number(keywordDurations[i]);
      }
      keywordDefinitionArray.push(definition);
    }
    this.speechContext.setSection("invocationSource", "VoiceActivationWithKeyword");
    this.speechContext.setSection("keywordDetection", [{
      clientDetectedKeywords: keywordDefinitionArray,
      onReject: {
        action: "EndOfTurn"
      },
      type: "startTrigger"
    }]);
  }
}
exports.DialogServiceAdapter = DialogServiceAdapter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceTurnState.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceTurnState.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DialogServiceTurnState = void 0;
const AudioOutputFormat_js_1 = __webpack_require__(/*! ../sdk/Audio/AudioOutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js");
const AudioOutputStream_js_1 = __webpack_require__(/*! ../sdk/Audio/AudioOutputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js");
const ActivityResponsePayload_js_1 = __webpack_require__(/*! ./ServiceMessages/ActivityResponsePayload.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/ActivityResponsePayload.js");
class DialogServiceTurnState {
  constructor(manager, requestId) {
    this.privRequestId = requestId;
    this.privIsCompleted = false;
    this.privAudioStream = null;
    this.privTurnManager = manager;
    this.resetTurnEndTimeout();
  }
  get audioStream() {
    // Called when is needed to stream.
    this.resetTurnEndTimeout();
    return this.privAudioStream;
  }
  processActivityPayload(payload, audioFormat) {
    if (payload.messageDataStreamType === ActivityResponsePayload_js_1.MessageDataStreamType.TextToSpeechAudio) {
      this.privAudioStream = AudioOutputStream_js_1.AudioOutputStream.createPullStream();
      this.privAudioStream.format = audioFormat !== undefined ? audioFormat : AudioOutputFormat_js_1.AudioOutputFormatImpl.getDefaultOutputFormat();
    }
    return this.privAudioStream;
  }
  endAudioStream() {
    if (this.privAudioStream !== null && !this.privAudioStream.isClosed) {
      this.privAudioStream.close();
    }
  }
  complete() {
    if (this.privTimeoutToken !== undefined) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      clearTimeout(this.privTimeoutToken);
    }
    this.endAudioStream();
  }
  resetTurnEndTimeout() {
    if (this.privTimeoutToken !== undefined) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      clearTimeout(this.privTimeoutToken);
    }
    this.privTimeoutToken = setTimeout(() => {
      this.privTurnManager.CompleteTurn(this.privRequestId);
      return;
    }, 2000);
  }
}
exports.DialogServiceTurnState = DialogServiceTurnState;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceTurnStateManager.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceTurnStateManager.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DialogServiceTurnStateManager = void 0;
const Error_js_1 = __webpack_require__(/*! ../common/Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const DialogServiceTurnState_js_1 = __webpack_require__(/*! ./DialogServiceTurnState.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceTurnState.js");
class DialogServiceTurnStateManager {
  constructor() {
    this.privTurnMap = new Map();
    return;
  }
  StartTurn(id) {
    if (this.privTurnMap.has(id)) {
      throw new Error_js_1.InvalidOperationError("Service error: There is already a turn with id:" + id);
    }
    const turnState = new DialogServiceTurnState_js_1.DialogServiceTurnState(this, id);
    this.privTurnMap.set(id, turnState);
    return this.privTurnMap.get(id);
  }
  GetTurn(id) {
    return this.privTurnMap.get(id);
  }
  CompleteTurn(id) {
    if (!this.privTurnMap.has(id)) {
      throw new Error_js_1.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + id);
    }
    const turnState = this.privTurnMap.get(id);
    turnState.complete();
    this.privTurnMap.delete(id);
    return turnState;
  }
}
exports.DialogServiceTurnStateManager = DialogServiceTurnStateManager;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DynamicGrammarBuilder.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DynamicGrammarBuilder.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DynamicGrammarBuilder = void 0;
/**
 * Responsible for building the object to be sent to the speech service to support dynamic grammars.
 * @class DynamicGrammarBuilder
 */
class DynamicGrammarBuilder {
  // Adds one more reference phrases to the dynamic grammar to send.
  // All added phrases are generic phrases.
  addPhrase(phrase) {
    if (!this.privPhrases) {
      this.privPhrases = [];
    }
    if (phrase instanceof Array) {
      this.privPhrases = this.privPhrases.concat(phrase);
    } else {
      this.privPhrases.push(phrase);
    }
  }
  // Clears all phrases stored in the current object.
  clearPhrases() {
    this.privPhrases = undefined;
  }
  // Adds one or more reference grammars to the current grammar.
  addReferenceGrammar(grammar) {
    if (!this.privGrammars) {
      this.privGrammars = [];
    }
    if (grammar instanceof Array) {
      this.privGrammars = this.privGrammars.concat(grammar);
    } else {
      this.privGrammars.push(grammar);
    }
  }
  // clears all grammars stored on the recognizer.
  clearGrammars() {
    this.privGrammars = undefined;
  }
  // Generates an object that represents the dynamic grammar used by the Speech Service.
  // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
  // of a DynamicGrammarBuilder
  generateGrammarObject() {
    if (this.privGrammars === undefined && this.privPhrases === undefined) {
      return undefined;
    }
    const retObj = {};
    retObj.ReferenceGrammars = this.privGrammars;
    if (undefined !== this.privPhrases && 0 !== this.privPhrases.length) {
      const retPhrases = [];
      this.privPhrases.forEach(value => {
        retPhrases.push({
          Text: value
        });
      });
      retObj.Groups = [{
        Type: "Generic",
        Items: retPhrases
      }];
    }
    return retObj;
  }
}
exports.DynamicGrammarBuilder = DynamicGrammarBuilder;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DynamicGrammarInterfaces.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DynamicGrammarInterfaces.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/EnumTranslation.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/EnumTranslation.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EnumTranslation = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class EnumTranslation {
  static implTranslateRecognitionResult(recognitionStatus, expectEndOfDictation = false) {
    let reason = Exports_js_1.ResultReason.Canceled;
    switch (recognitionStatus) {
      case Exports_js_2.RecognitionStatus.Success:
        reason = Exports_js_1.ResultReason.RecognizedSpeech;
        break;
      case Exports_js_2.RecognitionStatus.EndOfDictation:
        // If we need the result in EndOfDictation (typically some session level result),
        // translate into RecognizedSpeech, otherwise NoMatch
        reason = expectEndOfDictation ? Exports_js_1.ResultReason.RecognizedSpeech : Exports_js_1.ResultReason.NoMatch;
        break;
      case Exports_js_2.RecognitionStatus.NoMatch:
      case Exports_js_2.RecognitionStatus.InitialSilenceTimeout:
      case Exports_js_2.RecognitionStatus.BabbleTimeout:
        reason = Exports_js_1.ResultReason.NoMatch;
        break;
      case Exports_js_2.RecognitionStatus.Error:
      case Exports_js_2.RecognitionStatus.BadRequest:
      case Exports_js_2.RecognitionStatus.Forbidden:
      default:
        reason = Exports_js_1.ResultReason.Canceled;
        break;
    }
    return reason;
  }
  static implTranslateCancelResult(recognitionStatus) {
    let reason = Exports_js_1.CancellationReason.EndOfStream;
    switch (recognitionStatus) {
      case Exports_js_2.RecognitionStatus.Success:
      case Exports_js_2.RecognitionStatus.EndOfDictation:
      case Exports_js_2.RecognitionStatus.NoMatch:
        reason = Exports_js_1.CancellationReason.EndOfStream;
        break;
      case Exports_js_2.RecognitionStatus.InitialSilenceTimeout:
      case Exports_js_2.RecognitionStatus.BabbleTimeout:
      case Exports_js_2.RecognitionStatus.Error:
      case Exports_js_2.RecognitionStatus.BadRequest:
      case Exports_js_2.RecognitionStatus.Forbidden:
      default:
        reason = Exports_js_1.CancellationReason.Error;
        break;
    }
    return reason;
  }
  static implTranslateCancelErrorCode(recognitionStatus) {
    let reason = Exports_js_1.CancellationErrorCode.NoError;
    switch (recognitionStatus) {
      case Exports_js_2.RecognitionStatus.Error:
        reason = Exports_js_1.CancellationErrorCode.ServiceError;
        break;
      case Exports_js_2.RecognitionStatus.TooManyRequests:
        reason = Exports_js_1.CancellationErrorCode.TooManyRequests;
        break;
      case Exports_js_2.RecognitionStatus.BadRequest:
        reason = Exports_js_1.CancellationErrorCode.BadRequestParameters;
        break;
      case Exports_js_2.RecognitionStatus.Forbidden:
        reason = Exports_js_1.CancellationErrorCode.Forbidden;
        break;
      default:
        reason = Exports_js_1.CancellationErrorCode.NoError;
        break;
    }
    return reason;
  }
  static implTranslateErrorDetails(cancellationErrorCode) {
    let errorDetails = "The speech service encountered an internal error and could not continue.";
    switch (cancellationErrorCode) {
      case Exports_js_1.CancellationErrorCode.Forbidden:
        errorDetails = "The recognizer is using a free subscription that ran out of quota.";
        break;
      case Exports_js_1.CancellationErrorCode.BadRequestParameters:
        errorDetails = "Invalid parameter or unsupported audio format in the request.";
        break;
      case Exports_js_1.CancellationErrorCode.TooManyRequests:
        errorDetails = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
        break;
      default:
        break;
    }
    return errorDetails;
  }
}
exports.EnumTranslation = EnumTranslation;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AutoDetectSourceLanguagesOpenRangeOptionName = exports.ForceDictationPropertyName = exports.ServicePropertiesPropertyName = exports.CancellationErrorCodePropertyName = exports.OutputFormatPropertyName = void 0;
// Make sure not to export internal modules.
//
__exportStar(__webpack_require__(/*! ./CognitiveSubscriptionKeyAuthentication.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/CognitiveSubscriptionKeyAuthentication.js"), exports);
__exportStar(__webpack_require__(/*! ./CognitiveTokenAuthentication.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/CognitiveTokenAuthentication.js"), exports);
__exportStar(__webpack_require__(/*! ./IAuthentication.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IAuthentication.js"), exports);
__exportStar(__webpack_require__(/*! ./IConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./ISynthesisConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ISynthesisConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./IntentConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IntentConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeakerRecognitionConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerRecognitionConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./RecognitionEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognitionEvents.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceRecognizerBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceRecognizerBase.js"), exports);
__exportStar(__webpack_require__(/*! ./ConversationServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./RecognizerConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognizerConfig.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeechServiceInterfaces.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceInterfaces.js"), exports);
__exportStar(__webpack_require__(/*! ./WebsocketMessageFormatter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/WebsocketMessageFormatter.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeechConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./ConversationTranscriberConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationTranscriberConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./TranscriberConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranscriberConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./TranslationConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeechSynthesisConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechSynthesisConnectionFactory.js"), exports);
__exportStar(__webpack_require__(/*! ./EnumTranslation.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/EnumTranslation.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/Enums.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/Enums.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/TranslationSynthesisEnd.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationSynthesisEnd.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/TranslationHypothesis.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationHypothesis.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/TranslationPhrase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationPhrase.js"), exports);
__exportStar(__webpack_require__(/*! ./TranslationServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/SpeechDetected.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechDetected.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/SpeechHypothesis.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechHypothesis.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/SpeechKeyword.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechKeyword.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeechServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./ConversationTranscriptionServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConversationTranscriptionServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./TranscriptionServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranscriptionServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/DetailedSpeechPhrase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/DetailedSpeechPhrase.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/SimpleSpeechPhrase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SimpleSpeechPhrase.js"), exports);
__exportStar(__webpack_require__(/*! ./AddedLmIntent.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AddedLmIntent.js"), exports);
__exportStar(__webpack_require__(/*! ./IntentServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IntentServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/IntentResponse.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/IntentResponse.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/SpeakerResponse.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeakerResponse.js"), exports);
__exportStar(__webpack_require__(/*! ./RequestSession.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RequestSession.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeechContext.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechContext.js"), exports);
__exportStar(__webpack_require__(/*! ./DynamicGrammarBuilder.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DynamicGrammarBuilder.js"), exports);
__exportStar(__webpack_require__(/*! ./DynamicGrammarInterfaces.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DynamicGrammarInterfaces.js"), exports);
__exportStar(__webpack_require__(/*! ./DialogServiceAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogServiceAdapter.js"), exports);
__exportStar(__webpack_require__(/*! ./AgentConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AgentConfig.js"), exports);
__exportStar(__webpack_require__(/*! ./Transcription/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/Exports.js"), exports);
__exportStar(__webpack_require__(/*! ./ServiceMessages/SynthesisAudioMetadata.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SynthesisAudioMetadata.js"), exports);
__exportStar(__webpack_require__(/*! ./SynthesisTurn.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js"), exports);
__exportStar(__webpack_require__(/*! ./SynthesisAdapterBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisAdapterBase.js"), exports);
var AvatarSynthesisAdapter_js_1 = __webpack_require__(/*! ./AvatarSynthesisAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/AvatarSynthesisAdapter.js");
Object.defineProperty(exports, "AvatarSynthesisAdapter", ({
  enumerable: true,
  get: function () {
    return AvatarSynthesisAdapter_js_1.AvatarSynthesisAdapter;
  }
}));
var SpeechSynthesisAdapter_js_1 = __webpack_require__(/*! ./SpeechSynthesisAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechSynthesisAdapter.js");
Object.defineProperty(exports, "SpeechSynthesisAdapter", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisAdapter_js_1.SpeechSynthesisAdapter;
  }
}));
__exportStar(__webpack_require__(/*! ./SynthesisRestAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisRestAdapter.js"), exports);
__exportStar(__webpack_require__(/*! ./SynthesizerConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesizerConfig.js"), exports);
__exportStar(__webpack_require__(/*! ./SynthesisContext.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisContext.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeakerRecognitionConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerRecognitionConfig.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeakerServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./VoiceServiceRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/VoiceServiceRecognizer.js"), exports);
__exportStar(__webpack_require__(/*! ./SpeechServiceConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceConfig.js"), exports);
exports.OutputFormatPropertyName = "OutputFormat";
exports.CancellationErrorCodePropertyName = "CancellationErrorCode";
exports.ServicePropertiesPropertyName = "ServiceProperties";
exports.ForceDictationPropertyName = "ForceDictation";
exports.AutoDetectSourceLanguagesOpenRangeOptionName = "OpenRange";

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HeaderNames = void 0;
class HeaderNames {}
exports.HeaderNames = HeaderNames;
HeaderNames.AuthKey = "Ocp-Apim-Subscription-Key";
HeaderNames.Authorization = "Authorization";
HeaderNames.SpIDAuthKey = "Apim-Subscription-Id";
HeaderNames.ConnectionId = "X-ConnectionId";
HeaderNames.ContentType = "Content-Type";
HeaderNames.CustomCommandsAppId = "X-CommandsAppId";
HeaderNames.Path = "Path";
HeaderNames.RequestId = "X-RequestId";
HeaderNames.RequestStreamId = "X-StreamId";
HeaderNames.RequestTimestamp = "X-Timestamp";

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IAuthentication.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IAuthentication.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AuthInfo = void 0;
class AuthInfo {
  constructor(headerName, token) {
    this.privHeaderName = headerName;
    this.privToken = token;
  }
  get headerName() {
    return this.privHeaderName;
  }
  get token() {
    return this.privToken;
  }
}
exports.AuthInfo = AuthInfo;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IConnectionFactory.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IConnectionFactory.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ISynthesisConnectionFactory.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ISynthesisConnectionFactory.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IntentConnectionFactory.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IntentConnectionFactory.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IntentConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
class IntentConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  create(config, authInfo, connectionId) {
    let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint);
    if (!endpoint) {
      const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_IntentRegion);
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".sr.speech" + hostSuffix);
      endpoint = host + "/speech/recognition/interactive/cognitiveservices/v1";
    }
    const queryParams = {
      format: "simple",
      language: config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage)
    };
    this.setCommonUrlParams(config, queryParams, endpoint);
    const headers = {};
    if (authInfo.token !== undefined && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    return new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
  }
  getSpeechRegionFromIntentRegion(intentRegion) {
    switch (intentRegion) {
      case "West US":
      case "US West":
      case "westus":
        return "uswest";
      case "West US 2":
      case "US West 2":
      case "westus2":
        return "uswest2";
      case "South Central US":
      case "US South Central":
      case "southcentralus":
        return "ussouthcentral";
      case "West Central US":
      case "US West Central":
      case "westcentralus":
        return "uswestcentral";
      case "East US":
      case "US East":
      case "eastus":
        return "useast";
      case "East US 2":
      case "US East 2":
      case "eastus2":
        return "useast2";
      case "West Europe":
      case "Europe West":
      case "westeurope":
        return "europewest";
      case "North Europe":
      case "Europe North":
      case "northeurope":
        return "europenorth";
      case "Brazil South":
      case "South Brazil":
      case "southbrazil":
        return "brazilsouth";
      case "Australia East":
      case "East Australia":
      case "eastaustralia":
        return "australiaeast";
      case "Southeast Asia":
      case "Asia Southeast":
      case "southeastasia":
        return "asiasoutheast";
      case "East Asia":
      case "Asia East":
      case "eastasia":
        return "asiaeast";
      default:
        return intentRegion;
    }
  }
}
exports.IntentConnectionFactory = IntentConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IntentServiceRecognizer.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/IntentServiceRecognizer.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IntentServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
// eslint-disable-next-line max-classes-per-file
class IntentServiceRecognizer extends Exports_js_3.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
    this.privIntentRecognizer = recognizer;
    this.privIntentDataSent = false;
  }
  setIntents(addedIntents, umbrellaIntent) {
    this.privAddedLmIntents = addedIntents;
    this.privUmbrellaIntent = umbrellaIntent;
    this.privIntentDataSent = true;
  }
  processTypeSpecificMessages(connectionMessage) {
    let result;
    let ev;
    let processed = false;
    const resultProps = new Exports_js_2.PropertyCollection();
    if (connectionMessage.messageType === Exports_js_1.MessageType.Text) {
      resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
    }
    switch (connectionMessage.path.toLowerCase()) {
      case "speech.hypothesis":
        const speechHypothesis = Exports_js_3.SpeechHypothesis.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        result = new Exports_js_2.IntentRecognitionResult(undefined, this.privRequestSession.requestId, Exports_js_2.ResultReason.RecognizingIntent, speechHypothesis.Text, speechHypothesis.Duration, speechHypothesis.Offset, speechHypothesis.Language, speechHypothesis.LanguageDetectionConfidence, undefined, speechHypothesis.asJson(), resultProps);
        this.privRequestSession.onHypothesis(result.offset);
        ev = new Exports_js_2.IntentRecognitionEventArgs(result, speechHypothesis.Offset, this.privRequestSession.sessionId);
        if (!!this.privIntentRecognizer.recognizing) {
          try {
            this.privIntentRecognizer.recognizing(this.privIntentRecognizer, ev);
            /* eslint-disable no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        processed = true;
        break;
      case "speech.phrase":
        const simple = Exports_js_3.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        result = new Exports_js_2.IntentRecognitionResult(undefined, this.privRequestSession.requestId, Exports_js_3.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus), simple.DisplayText, simple.Duration, simple.Offset, simple.Language, simple.LanguageDetectionConfidence, undefined, simple.asJson(), resultProps);
        ev = new Exports_js_2.IntentRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
        const sendEvent = () => {
          if (!!this.privIntentRecognizer.recognized) {
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);
              /* eslint-disable no-empty */
            } catch (error) {
              // Not going to let errors in the event handler
              // trip things up.
            }
          }
          // report result to promise.
          if (!!this.privSuccessCallback) {
            try {
              this.privSuccessCallback(result);
            } catch (e) {
              if (!!this.privErrorCallback) {
                this.privErrorCallback(e);
              }
            }
            // Only invoke the call back once.
            // and if it's successful don't invoke the
            // error after that.
            this.privSuccessCallback = undefined;
            this.privErrorCallback = undefined;
          }
        };
        // If intent data was sent, the terminal result for this recognizer is an intent being found.
        // If no intent data was sent, the terminal event is speech recognition being successful.
        if (false === this.privIntentDataSent || Exports_js_2.ResultReason.NoMatch === ev.result.reason) {
          // Advance the buffers.
          this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);
          sendEvent();
        } else {
          // Squirrel away the args, when the response event arrives it will build upon them
          // and then return
          this.privPendingIntentArgs = ev;
        }
        processed = true;
        break;
      case "response":
        // Response from LUIS
        ev = this.privPendingIntentArgs;
        this.privPendingIntentArgs = undefined;
        if (undefined === ev) {
          if ("" === connectionMessage.textBody) {
            // This condition happens if there is nothing but silence in the
            // audio sent to the service.
            return;
          }
          // Odd... Not sure this can happen
          ev = new Exports_js_2.IntentRecognitionEventArgs(new Exports_js_2.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
        }
        const intentResponse = Exports_js_3.IntentResponse.fromJSON(connectionMessage.textBody);
        // If LUIS didn't return anything, send the existing event, else
        // modify it to show the match.
        // See if the intent found is in the list of intents asked for.
        if (null !== intentResponse && !!intentResponse.topScoringIntent && !!intentResponse.topScoringIntent.intent) {
          let addedIntent = this.privAddedLmIntents[intentResponse.topScoringIntent.intent];
          if (this.privUmbrellaIntent !== undefined) {
            addedIntent = this.privUmbrellaIntent;
          }
          if (!!addedIntent) {
            const intentId = addedIntent === undefined || addedIntent.intentName === undefined ? intentResponse.topScoringIntent.intent : addedIntent.intentName;
            let reason = ev.result.reason;
            if (undefined !== intentId) {
              reason = Exports_js_2.ResultReason.RecognizedIntent;
            }
            // make sure, properties is set.
            const properties = undefined !== ev.result.properties ? ev.result.properties : new Exports_js_2.PropertyCollection();
            properties.setProperty(Exports_js_2.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, connectionMessage.textBody);
            ev = new Exports_js_2.IntentRecognitionEventArgs(new Exports_js_2.IntentRecognitionResult(intentId, ev.result.resultId, reason, ev.result.text, ev.result.duration, ev.result.offset, undefined, undefined, ev.result.errorDetails, ev.result.json, properties), ev.offset, ev.sessionId);
          }
        }
        this.privRequestSession.onPhraseRecognized(ev.offset + ev.result.duration);
        if (!!this.privIntentRecognizer.recognized) {
          try {
            this.privIntentRecognizer.recognized(this.privIntentRecognizer, ev);
            /* eslint-disable no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        // report result to promise.
        if (!!this.privSuccessCallback) {
          try {
            this.privSuccessCallback(ev.result);
          } catch (e) {
            if (!!this.privErrorCallback) {
              this.privErrorCallback(e);
            }
          }
          // Only invoke the call back once.
          // and if it's successful don't invoke the
          // error after that.
          this.privSuccessCallback = undefined;
          this.privErrorCallback = undefined;
        }
        processed = true;
        break;
      default:
        break;
    }
    const defferal = new Exports_js_1.Deferred();
    defferal.resolve(processed);
    return defferal.promise;
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    const properties = new Exports_js_2.PropertyCollection();
    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
    if (!!this.privIntentRecognizer.canceled) {
      const cancelEvent = new Exports_js_2.IntentRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, undefined, sessionId);
      try {
        this.privIntentRecognizer.canceled(this.privIntentRecognizer, cancelEvent);
        /* eslint-disable no-empty */
      } catch {}
    }
    if (!!this.privSuccessCallback) {
      const result = new Exports_js_2.IntentRecognitionResult(undefined,
      // Intent Id
      requestId, Exports_js_2.ResultReason.Canceled, undefined,
      // Text
      undefined,
      // Duration
      undefined,
      // Offset
      undefined,
      // Language
      undefined,
      // LanguageDetectionConfidence
      error, undefined,
      // Json
      properties);
      try {
        this.privSuccessCallback(result);
        this.privSuccessCallback = undefined;
        /* eslint-disable no-empty */
      } catch {}
    }
  }
}
exports.IntentServiceRecognizer = IntentServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.QueryParameterNames = void 0;
class QueryParameterNames {}
exports.QueryParameterNames = QueryParameterNames;
QueryParameterNames.BotId = "botid";
QueryParameterNames.CustomSpeechDeploymentId = "cid";
QueryParameterNames.CustomVoiceDeploymentId = "deploymentId";
QueryParameterNames.EnableAudioLogging = "storeAudio";
QueryParameterNames.EnableLanguageId = "lidEnabled";
QueryParameterNames.EnableWordLevelTimestamps = "wordLevelTimestamps";
QueryParameterNames.EndSilenceTimeoutMs = "endSilenceTimeoutMs";
QueryParameterNames.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs";
QueryParameterNames.SegmentationMaximumTimeMs = "segmentationMaximumTimeMs";
QueryParameterNames.SegmentationStrategy = "segmentationStrategy";
QueryParameterNames.Format = "format";
QueryParameterNames.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs";
QueryParameterNames.Language = "language";
QueryParameterNames.Profanity = "profanity";
QueryParameterNames.RequestBotStatusMessages = "enableBotMessageStatus";
QueryParameterNames.StableIntermediateThreshold = "stableIntermediateThreshold";
QueryParameterNames.StableTranslation = "stableTranslation";
QueryParameterNames.TestHooks = "testhooks";
QueryParameterNames.Postprocessing = "postprocessing";
QueryParameterNames.CtsMeetingId = "meetingId";
QueryParameterNames.CtsDeviceId = "deviceId";
QueryParameterNames.CtsIsParticipant = "isParticipant";
QueryParameterNames.EnableAvatar = "enableTalkingAvatar";

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognitionEvents.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognitionEvents.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RecognitionEndedEvent = exports.RecognitionCompletionStatus = exports.RecognitionStartedEvent = exports.ConnectingToServiceEvent = exports.ListeningStartedEvent = exports.RecognitionTriggeredEvent = exports.SpeechRecognitionEvent = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
class SpeechRecognitionEvent extends Exports_js_1.PlatformEvent {
  constructor(eventName, requestId, sessionId, eventType = Exports_js_1.EventType.Info) {
    super(eventName, eventType);
    this.privRequestId = requestId;
    this.privSessionId = sessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get sessionId() {
    return this.privSessionId;
  }
}
exports.SpeechRecognitionEvent = SpeechRecognitionEvent;
class RecognitionTriggeredEvent extends SpeechRecognitionEvent {
  constructor(requestId, sessionId, audioSourceId, audioNodeId) {
    super("RecognitionTriggeredEvent", requestId, sessionId);
    this.privAudioSourceId = audioSourceId;
    this.privAudioNodeId = audioNodeId;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
}
exports.RecognitionTriggeredEvent = RecognitionTriggeredEvent;
class ListeningStartedEvent extends SpeechRecognitionEvent {
  constructor(requestId, sessionId, audioSourceId, audioNodeId) {
    super("ListeningStartedEvent", requestId, sessionId);
    this.privAudioSourceId = audioSourceId;
    this.privAudioNodeId = audioNodeId;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
}
exports.ListeningStartedEvent = ListeningStartedEvent;
class ConnectingToServiceEvent extends SpeechRecognitionEvent {
  constructor(requestId, authFetchEventid, sessionId) {
    super("ConnectingToServiceEvent", requestId, sessionId);
    this.privAuthFetchEventid = authFetchEventid;
  }
  get authFetchEventid() {
    return this.privAuthFetchEventid;
  }
}
exports.ConnectingToServiceEvent = ConnectingToServiceEvent;
class RecognitionStartedEvent extends SpeechRecognitionEvent {
  constructor(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId) {
    super("RecognitionStartedEvent", requestId, sessionId);
    this.privAudioSourceId = audioSourceId;
    this.privAudioNodeId = audioNodeId;
    this.privAuthFetchEventId = authFetchEventId;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
exports.RecognitionStartedEvent = RecognitionStartedEvent;
var RecognitionCompletionStatus;
(function (RecognitionCompletionStatus) {
  RecognitionCompletionStatus[RecognitionCompletionStatus["Success"] = 0] = "Success";
  RecognitionCompletionStatus[RecognitionCompletionStatus["AudioSourceError"] = 1] = "AudioSourceError";
  RecognitionCompletionStatus[RecognitionCompletionStatus["AudioSourceTimeout"] = 2] = "AudioSourceTimeout";
  RecognitionCompletionStatus[RecognitionCompletionStatus["AuthTokenFetchError"] = 3] = "AuthTokenFetchError";
  RecognitionCompletionStatus[RecognitionCompletionStatus["AuthTokenFetchTimeout"] = 4] = "AuthTokenFetchTimeout";
  RecognitionCompletionStatus[RecognitionCompletionStatus["UnAuthorized"] = 5] = "UnAuthorized";
  RecognitionCompletionStatus[RecognitionCompletionStatus["ConnectTimeout"] = 6] = "ConnectTimeout";
  RecognitionCompletionStatus[RecognitionCompletionStatus["ConnectError"] = 7] = "ConnectError";
  RecognitionCompletionStatus[RecognitionCompletionStatus["ClientRecognitionActivityTimeout"] = 8] = "ClientRecognitionActivityTimeout";
  RecognitionCompletionStatus[RecognitionCompletionStatus["UnknownError"] = 9] = "UnknownError";
})(RecognitionCompletionStatus = exports.RecognitionCompletionStatus || (exports.RecognitionCompletionStatus = {}));
class RecognitionEndedEvent extends SpeechRecognitionEvent {
  constructor(requestId, audioSourceId, audioNodeId, authFetchEventId, sessionId, serviceTag, status, error) {
    super("RecognitionEndedEvent", requestId, sessionId, status === RecognitionCompletionStatus.Success ? Exports_js_1.EventType.Info : Exports_js_1.EventType.Error);
    this.privAudioSourceId = audioSourceId;
    this.privAudioNodeId = audioNodeId;
    this.privAuthFetchEventId = authFetchEventId;
    this.privStatus = status;
    this.privError = error;
    this.privServiceTag = serviceTag;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
  get serviceTag() {
    return this.privServiceTag;
  }
  get status() {
    return this.privStatus;
  }
  get error() {
    return this.privError;
  }
}
exports.RecognitionEndedEvent = RecognitionEndedEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognizerConfig.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognizerConfig.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RecognizerConfig = exports.SpeechResultFormat = exports.RecognitionMode = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
var RecognitionMode;
(function (RecognitionMode) {
  RecognitionMode[RecognitionMode["Interactive"] = 0] = "Interactive";
  RecognitionMode[RecognitionMode["Conversation"] = 1] = "Conversation";
  RecognitionMode[RecognitionMode["Dictation"] = 2] = "Dictation";
})(RecognitionMode = exports.RecognitionMode || (exports.RecognitionMode = {}));
var SpeechResultFormat;
(function (SpeechResultFormat) {
  SpeechResultFormat[SpeechResultFormat["Simple"] = 0] = "Simple";
  SpeechResultFormat[SpeechResultFormat["Detailed"] = 1] = "Detailed";
})(SpeechResultFormat = exports.SpeechResultFormat || (exports.SpeechResultFormat = {}));
class RecognizerConfig {
  constructor(speechServiceConfig, parameters) {
    this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new Exports_js_2.SpeechServiceConfig(new Exports_js_2.Context(null));
    this.privParameters = parameters;
    this.privMaxRetryCount = parseInt(parameters.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10);
    this.privLanguageIdMode = parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceConnection_LanguageIdMode, undefined);
    this.privEnableSpeakerId = false;
  }
  get parameters() {
    return this.privParameters;
  }
  get recognitionMode() {
    return this.privRecognitionMode;
  }
  set recognitionMode(value) {
    this.privRecognitionMode = value;
    this.privRecognitionActivityTimeout = value === RecognitionMode.Interactive ? 8000 : 25000;
    this.privSpeechServiceConfig.Recognition = RecognitionMode[value];
  }
  get SpeechServiceConfig() {
    return this.privSpeechServiceConfig;
  }
  get recognitionActivityTimeout() {
    return this.privRecognitionActivityTimeout;
  }
  get isContinuousRecognition() {
    return this.privRecognitionMode !== RecognitionMode.Interactive;
  }
  get languageIdMode() {
    return this.privLanguageIdMode;
  }
  get autoDetectSourceLanguages() {
    return this.parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, undefined);
  }
  get recognitionEndpointVersion() {
    return this.parameters.getProperty(Exports_js_1.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, undefined);
  }
  get sourceLanguageModels() {
    const models = [];
    let modelsExist = false;
    if (this.autoDetectSourceLanguages !== undefined) {
      for (const language of this.autoDetectSourceLanguages.split(",")) {
        const customProperty = language + Exports_js_1.PropertyId.SpeechServiceConnection_EndpointId.toString();
        const modelId = this.parameters.getProperty(customProperty, undefined);
        if (modelId !== undefined) {
          models.push({
            language,
            endpoint: modelId
          });
          modelsExist = true;
        } else {
          models.push({
            language,
            endpoint: ""
          });
        }
      }
    }
    return modelsExist ? models : undefined;
  }
  get maxRetryCount() {
    return this.privMaxRetryCount;
  }
  get isSpeakerDiarizationEnabled() {
    return this.privEnableSpeakerId;
  }
  set isSpeakerDiarizationEnabled(value) {
    this.privEnableSpeakerId = value;
  }
}
exports.RecognizerConfig = RecognizerConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RequestSession.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RequestSession.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RequestSession = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const RecognitionEvents_js_1 = __webpack_require__(/*! ./RecognitionEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognitionEvents.js");
const ServiceTelemetryListener_Internal_js_1 = __webpack_require__(/*! ./ServiceTelemetryListener.Internal.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceTelemetryListener.Internal.js");
class RequestSession {
  constructor(audioSourceId) {
    this.privIsDisposed = false;
    this.privDetachables = new Array();
    this.privIsAudioNodeDetached = false;
    this.privIsRecognizing = false;
    this.privIsSpeechEnded = false;
    this.privTurnStartAudioOffset = 0;
    this.privLastRecoOffset = 0;
    this.privHypothesisReceived = false;
    this.privBytesSent = 0;
    this.privRecognitionBytesSent = 0;
    this.privRecogNumber = 0;
    this.privInTurn = false;
    this.privConnectionAttempts = 0;
    this.privAudioSourceId = audioSourceId;
    this.privRequestId = Exports_js_1.createNoDashGuid();
    this.privAudioNodeId = Exports_js_1.createNoDashGuid();
    this.privTurnDeferral = new Exports_js_1.Deferred();
    // We're not in a turn, so resolve.
    this.privTurnDeferral.resolve();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
  get turnCompletionPromise() {
    return this.privTurnDeferral.promise;
  }
  get isSpeechEnded() {
    return this.privIsSpeechEnded;
  }
  get isRecognizing() {
    return this.privIsRecognizing;
  }
  get currentTurnAudioOffset() {
    return this.privTurnStartAudioOffset;
  }
  get recogNumber() {
    return this.privRecogNumber;
  }
  get numConnectionAttempts() {
    return this.privConnectionAttempts;
  }
  // The number of bytes sent for the current connection.
  // Counter is reset to 0 each time a connection is established.
  get bytesSent() {
    return this.privBytesSent;
  }
  // The number of bytes sent for the current recognition.
  // Counter is reset to 0 each time recognition is started.
  get recognitionBytesSent() {
    return this.privRecognitionBytesSent;
  }
  listenForServiceTelemetry(eventSource) {
    if (!!this.privServiceTelemetryListener) {
      this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));
    }
  }
  startNewRecognition() {
    this.privRecognitionBytesSent = 0;
    this.privIsSpeechEnded = false;
    this.privIsRecognizing = true;
    this.privTurnStartAudioOffset = 0;
    this.privLastRecoOffset = 0;
    this.privRecogNumber++;
    this.privServiceTelemetryListener = new ServiceTelemetryListener_Internal_js_1.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);
    this.onEvent(new RecognitionEvents_js_1.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
  }
  async onAudioSourceAttachCompleted(audioNode, isError) {
    this.privAudioNode = audioNode;
    this.privIsAudioNodeDetached = false;
    if (isError) {
      await this.onComplete();
    } else {
      this.onEvent(new RecognitionEvents_js_1.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
  }
  onPreConnectionStart(authFetchEventId, connectionId) {
    this.privAuthFetchEventId = authFetchEventId;
    this.privSessionId = connectionId;
    this.onEvent(new RecognitionEvents_js_1.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
  }
  async onAuthCompleted(isError) {
    if (isError) {
      await this.onComplete();
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async onConnectionEstablishCompleted(statusCode, reason) {
    if (statusCode === 200) {
      this.onEvent(new RecognitionEvents_js_1.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));
      if (!!this.privAudioNode) {
        this.privAudioNode.replay();
      }
      this.privTurnStartAudioOffset = this.privLastRecoOffset;
      this.privBytesSent = 0;
      return;
    } else if (statusCode === 403) {
      await this.onComplete();
    }
  }
  async onServiceTurnEndResponse(continuousRecognition) {
    this.privTurnDeferral.resolve();
    if (!continuousRecognition || this.isSpeechEnded) {
      await this.onComplete();
      this.privInTurn = false;
    } else {
      // Start a new request set.
      this.privTurnStartAudioOffset = this.privLastRecoOffset;
      this.privAudioNode.replay();
    }
  }
  onSpeechContext() {
    this.privRequestId = Exports_js_1.createNoDashGuid();
  }
  onServiceTurnStartResponse() {
    if (!!this.privTurnDeferral && !!this.privInTurn) {
      // What? How are we starting a turn with another not done?
      this.privTurnDeferral.reject("Another turn started before current completed.");
      // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      this.privTurnDeferral.promise.then().catch(() => {});
    }
    this.privInTurn = true;
    this.privTurnDeferral = new Exports_js_1.Deferred();
  }
  onHypothesis(offset) {
    if (!this.privHypothesisReceived) {
      this.privHypothesisReceived = true;
      this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));
    }
  }
  onPhraseRecognized(offset) {
    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));
    this.onServiceRecognized(offset);
  }
  onServiceRecognized(offset) {
    this.privLastRecoOffset = offset;
    this.privHypothesisReceived = false;
    this.privAudioNode.shrinkBuffers(offset);
    this.privConnectionAttempts = 0;
  }
  onAudioSent(bytesSent) {
    this.privBytesSent += bytesSent;
    this.privRecognitionBytesSent += bytesSent;
  }
  onRetryConnection() {
    this.privConnectionAttempts++;
  }
  async dispose() {
    if (!this.privIsDisposed) {
      // we should have completed by now. If we did not its an unknown error.
      this.privIsDisposed = true;
      for (const detachable of this.privDetachables) {
        await detachable.detach();
      }
      if (!!this.privServiceTelemetryListener) {
        this.privServiceTelemetryListener.dispose();
      }
      this.privIsRecognizing = false;
    }
  }
  getTelemetry() {
    if (this.privServiceTelemetryListener.hasTelemetry) {
      return this.privServiceTelemetryListener.getTelemetry();
    } else {
      return null;
    }
  }
  async onStopRecognizing() {
    await this.onComplete();
  }
  // Should be called with the audioNode for this session has indicated that it is out of speech.
  onSpeechEnded() {
    this.privIsSpeechEnded = true;
  }
  onEvent(event) {
    if (!!this.privServiceTelemetryListener) {
      this.privServiceTelemetryListener.onEvent(event);
    }
    Exports_js_1.Events.instance.onEvent(event);
  }
  async onComplete() {
    if (!!this.privIsRecognizing) {
      this.privIsRecognizing = false;
      await this.detachAudioNode();
    }
  }
  async detachAudioNode() {
    if (!this.privIsAudioNodeDetached) {
      this.privIsAudioNodeDetached = true;
      if (this.privAudioNode) {
        await this.privAudioNode.detach();
      }
    }
  }
}
exports.RequestSession = RequestSession;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/ActivityResponsePayload.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/ActivityResponsePayload.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// response
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageDataStreamType = exports.ActivityPayloadResponse = void 0;
class ActivityPayloadResponse {
  constructor(json) {
    this.privActivityResponse = JSON.parse(json);
  }
  static fromJSON(json) {
    return new ActivityPayloadResponse(json);
  }
  get conversationId() {
    return this.privActivityResponse.conversationId;
  }
  get messageDataStreamType() {
    return this.privActivityResponse.messageDataStreamType;
  }
  get messagePayload() {
    return this.privActivityResponse.messagePayload;
  }
  get version() {
    return this.privActivityResponse.version;
  }
}
exports.ActivityPayloadResponse = ActivityPayloadResponse;
var MessageDataStreamType;
(function (MessageDataStreamType) {
  MessageDataStreamType[MessageDataStreamType["None"] = 0] = "None";
  MessageDataStreamType[MessageDataStreamType["TextToSpeechAudio"] = 1] = "TextToSpeechAudio";
})(MessageDataStreamType = exports.MessageDataStreamType || (exports.MessageDataStreamType = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/DetailedSpeechPhrase.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/DetailedSpeechPhrase.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DetailedSpeechPhrase = void 0;
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class DetailedSpeechPhrase {
  constructor(json, baseOffset) {
    this.privDetailedSpeechPhrase = JSON.parse(json);
    this.privDetailedSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privDetailedSpeechPhrase.RecognitionStatus);
    this.updateOffsets(baseOffset);
  }
  static fromJSON(json, baseOffset) {
    return new DetailedSpeechPhrase(json, baseOffset);
  }
  updateOffsets(baseOffset) {
    this.privDetailedSpeechPhrase.Offset += baseOffset;
    if (!!this.privDetailedSpeechPhrase.NBest) {
      for (const phrase of this.privDetailedSpeechPhrase.NBest) {
        if (!!phrase.Words) {
          for (const word of phrase.Words) {
            word.Offset += baseOffset;
          }
        }
        if (!!phrase.DisplayWords) {
          for (const word of phrase.DisplayWords) {
            word.Offset += baseOffset;
          }
        }
      }
    }
  }
  asJson() {
    const jsonObj = {
      ...this.privDetailedSpeechPhrase
    };
    // Convert the enum value to its string representation for serialization purposes.
    return JSON.stringify({
      ...jsonObj,
      RecognitionStatus: Exports_js_1.RecognitionStatus[jsonObj.RecognitionStatus]
    });
  }
  get RecognitionStatus() {
    return this.privDetailedSpeechPhrase.RecognitionStatus;
  }
  get NBest() {
    return this.privDetailedSpeechPhrase.NBest;
  }
  get Duration() {
    return this.privDetailedSpeechPhrase.Duration;
  }
  get Offset() {
    return this.privDetailedSpeechPhrase.Offset;
  }
  get Language() {
    return this.privDetailedSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
  }
  get LanguageDetectionConfidence() {
    return this.privDetailedSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
  }
  get Text() {
    if (!!this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0]) {
      return this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText;
    }
    return this.privDetailedSpeechPhrase.DisplayText;
  }
  get SpeakerId() {
    return this.privDetailedSpeechPhrase.SpeakerId;
  }
  mapRecognitionStatus(status) {
    if (typeof status === "string") {
      return Exports_js_1.RecognitionStatus[status];
    } else if (typeof status === "number") {
      return status;
    }
  }
}
exports.DetailedSpeechPhrase = DetailedSpeechPhrase;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/Enums.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/Enums.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RecognitionStatus = exports.SynthesisStatus = void 0;
/**
 * @class SynthesisStatus
 * @private
 */
var SynthesisStatus;
(function (SynthesisStatus) {
  /**
   * The response contains valid audio data.
   * @member SynthesisStatus.Success
   */
  SynthesisStatus[SynthesisStatus["Success"] = 0] = "Success";
  /**
   * Indicates the end of audio data. No valid audio data is included in the message.
   * @member SynthesisStatus.SynthesisEnd
   */
  SynthesisStatus[SynthesisStatus["SynthesisEnd"] = 1] = "SynthesisEnd";
  /**
   * Indicates an error occurred during synthesis data processing.
   * @member SynthesisStatus.Error
   */
  SynthesisStatus[SynthesisStatus["Error"] = 2] = "Error";
})(SynthesisStatus = exports.SynthesisStatus || (exports.SynthesisStatus = {}));
var RecognitionStatus;
(function (RecognitionStatus) {
  RecognitionStatus[RecognitionStatus["Success"] = 0] = "Success";
  RecognitionStatus[RecognitionStatus["NoMatch"] = 1] = "NoMatch";
  RecognitionStatus[RecognitionStatus["InitialSilenceTimeout"] = 2] = "InitialSilenceTimeout";
  RecognitionStatus[RecognitionStatus["BabbleTimeout"] = 3] = "BabbleTimeout";
  RecognitionStatus[RecognitionStatus["Error"] = 4] = "Error";
  RecognitionStatus[RecognitionStatus["EndOfDictation"] = 5] = "EndOfDictation";
  RecognitionStatus[RecognitionStatus["TooManyRequests"] = 6] = "TooManyRequests";
  RecognitionStatus[RecognitionStatus["BadRequest"] = 7] = "BadRequest";
  RecognitionStatus[RecognitionStatus["Forbidden"] = 8] = "Forbidden";
})(RecognitionStatus = exports.RecognitionStatus || (exports.RecognitionStatus = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/IntentResponse.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/IntentResponse.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// response
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IntentResponse = void 0;
class IntentResponse {
  constructor(json) {
    if (json === "") {
      this.privIntentResponse = {};
    } else {
      this.privIntentResponse = JSON.parse(json);
    }
  }
  static fromJSON(json) {
    return new IntentResponse(json);
  }
  get query() {
    return this.privIntentResponse.query;
  }
  get topScoringIntent() {
    return this.privIntentResponse.topScoringIntent;
  }
  get entities() {
    return this.privIntentResponse.entities;
  }
}
exports.IntentResponse = IntentResponse;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SimpleSpeechPhrase.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SimpleSpeechPhrase.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SimpleSpeechPhrase = void 0;
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class SimpleSpeechPhrase {
  constructor(json, baseOffset = 0) {
    this.privSimpleSpeechPhrase = JSON.parse(json);
    this.privSimpleSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privSimpleSpeechPhrase.RecognitionStatus); // RecognitionStatus[this.privSimpleSpeechPhrase.RecognitionStatus as unknown as keyof typeof RecognitionStatus];
    this.updateOffset(baseOffset);
  }
  static fromJSON(json, baseOffset) {
    return new SimpleSpeechPhrase(json, baseOffset);
  }
  updateOffset(baseOffset) {
    this.privSimpleSpeechPhrase.Offset += baseOffset;
  }
  asJson() {
    const jsonObj = {
      ...this.privSimpleSpeechPhrase
    };
    // Convert the enum value to its string representation for serialization purposes.
    return JSON.stringify({
      ...jsonObj,
      RecognitionStatus: Exports_js_1.RecognitionStatus[jsonObj.RecognitionStatus]
    });
  }
  get RecognitionStatus() {
    return this.privSimpleSpeechPhrase.RecognitionStatus;
  }
  get DisplayText() {
    return this.privSimpleSpeechPhrase.DisplayText;
  }
  get Offset() {
    return this.privSimpleSpeechPhrase.Offset;
  }
  get Duration() {
    return this.privSimpleSpeechPhrase.Duration;
  }
  get Language() {
    return this.privSimpleSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
  }
  get LanguageDetectionConfidence() {
    return this.privSimpleSpeechPhrase.PrimaryLanguage === undefined ? undefined : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
  }
  get SpeakerId() {
    return this.privSimpleSpeechPhrase.SpeakerId;
  }
  mapRecognitionStatus(status) {
    if (typeof status === "string") {
      return Exports_js_1.RecognitionStatus[status];
    } else if (typeof status === "number") {
      return status;
    }
  }
}
exports.SimpleSpeechPhrase = SimpleSpeechPhrase;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeakerResponse.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeakerResponse.js ***!
  \******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechDetected.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechDetected.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechDetected = void 0;
class SpeechDetected {
  constructor(json, baseOffset) {
    this.privSpeechStartDetected = JSON.parse(json);
    this.privSpeechStartDetected.Offset += baseOffset;
  }
  static fromJSON(json, baseOffset) {
    return new SpeechDetected(json, baseOffset);
  }
  get Offset() {
    return this.privSpeechStartDetected.Offset;
  }
}
exports.SpeechDetected = SpeechDetected;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechHypothesis.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechHypothesis.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechHypothesis = void 0;
class SpeechHypothesis {
  constructor(json, baseOffset) {
    this.privSpeechHypothesis = JSON.parse(json);
    this.updateOffset(baseOffset);
  }
  static fromJSON(json, baseOffset) {
    return new SpeechHypothesis(json, baseOffset);
  }
  updateOffset(baseOffset) {
    this.privSpeechHypothesis.Offset += baseOffset;
  }
  asJson() {
    return JSON.stringify(this.privSpeechHypothesis);
  }
  get Text() {
    return this.privSpeechHypothesis.Text;
  }
  get Offset() {
    return this.privSpeechHypothesis.Offset;
  }
  get Duration() {
    return this.privSpeechHypothesis.Duration;
  }
  get Language() {
    return this.privSpeechHypothesis.PrimaryLanguage === undefined ? undefined : this.privSpeechHypothesis.PrimaryLanguage.Language;
  }
  get LanguageDetectionConfidence() {
    return this.privSpeechHypothesis.PrimaryLanguage === undefined ? undefined : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
  }
  get SpeakerId() {
    return this.privSpeechHypothesis.SpeakerId;
  }
}
exports.SpeechHypothesis = SpeechHypothesis;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechKeyword.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SpeechKeyword.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechKeyword = void 0;
class SpeechKeyword {
  constructor(json, baseOffset) {
    this.privSpeechKeyword = JSON.parse(json);
    this.privSpeechKeyword.Offset += baseOffset;
  }
  static fromJSON(json, baseOffset) {
    return new SpeechKeyword(json, baseOffset);
  }
  get Status() {
    return this.privSpeechKeyword.Status;
  }
  get Text() {
    return this.privSpeechKeyword.Text;
  }
  get Offset() {
    return this.privSpeechKeyword.Offset;
  }
  get Duration() {
    return this.privSpeechKeyword.Duration;
  }
  asJson() {
    return JSON.stringify(this.privSpeechKeyword);
  }
}
exports.SpeechKeyword = SpeechKeyword;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SynthesisAudioMetadata.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SynthesisAudioMetadata.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisAudioMetadata = exports.MetadataType = void 0;
var MetadataType;
(function (MetadataType) {
  MetadataType["WordBoundary"] = "WordBoundary";
  MetadataType["Bookmark"] = "Bookmark";
  MetadataType["Viseme"] = "Viseme";
  MetadataType["SentenceBoundary"] = "SentenceBoundary";
  MetadataType["SessionEnd"] = "SessionEnd";
  MetadataType["AvatarSignal"] = "TalkingAvatarSignal";
})(MetadataType = exports.MetadataType || (exports.MetadataType = {}));
class SynthesisAudioMetadata {
  constructor(json) {
    this.privSynthesisAudioMetadata = JSON.parse(json);
  }
  static fromJSON(json) {
    return new SynthesisAudioMetadata(json);
  }
  get Metadata() {
    return this.privSynthesisAudioMetadata.Metadata;
  }
}
exports.SynthesisAudioMetadata = SynthesisAudioMetadata;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationHypothesis.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationHypothesis.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationHypothesis = void 0;
const Contracts_js_1 = __webpack_require__(/*! ../../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const TranslationStatus_js_1 = __webpack_require__(/*! ../TranslationStatus.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationStatus.js");
class TranslationHypothesis {
  constructor(hypothesis, baseOffset) {
    this.privTranslationHypothesis = hypothesis;
    this.privTranslationHypothesis.Offset += baseOffset;
    this.privTranslationHypothesis.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationHypothesis.Translation.TranslationStatus);
  }
  static fromJSON(json, baseOffset) {
    return new TranslationHypothesis(JSON.parse(json), baseOffset);
  }
  static fromTranslationResponse(translationHypothesis, baseOffset) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(translationHypothesis, "translationHypothesis");
    const hypothesis = translationHypothesis.SpeechHypothesis;
    translationHypothesis.SpeechHypothesis = undefined;
    hypothesis.Translation = translationHypothesis;
    return new TranslationHypothesis(hypothesis, baseOffset);
  }
  get Duration() {
    return this.privTranslationHypothesis.Duration;
  }
  get Offset() {
    return this.privTranslationHypothesis.Offset;
  }
  get Text() {
    return this.privTranslationHypothesis.Text;
  }
  get Translation() {
    return this.privTranslationHypothesis.Translation;
  }
  get Language() {
    return this.privTranslationHypothesis.PrimaryLanguage?.Language;
  }
  asJson() {
    const jsonObj = {
      ...this.privTranslationHypothesis
    };
    // Convert the enum value to its string representation for serialization purposes.
    return jsonObj.Translation !== undefined ? JSON.stringify({
      ...jsonObj,
      TranslationStatus: TranslationStatus_js_1.TranslationStatus[jsonObj.Translation.TranslationStatus]
    }) : JSON.stringify(jsonObj);
  }
  mapTranslationStatus(status) {
    if (typeof status === "string") {
      return TranslationStatus_js_1.TranslationStatus[status];
    } else if (typeof status === "number") {
      return status;
    }
  }
}
exports.TranslationHypothesis = TranslationHypothesis;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationPhrase.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationPhrase.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationPhrase = void 0;
const Contracts_js_1 = __webpack_require__(/*! ../../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const TranslationStatus_js_1 = __webpack_require__(/*! ../TranslationStatus.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationStatus.js");
class TranslationPhrase {
  constructor(phrase, baseOffset) {
    this.privTranslationPhrase = phrase;
    this.privTranslationPhrase.Offset += baseOffset;
    this.privTranslationPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privTranslationPhrase.RecognitionStatus);
    if (this.privTranslationPhrase.Translation !== undefined) {
      this.privTranslationPhrase.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationPhrase.Translation.TranslationStatus);
    }
  }
  static fromJSON(json, baseOffset) {
    return new TranslationPhrase(JSON.parse(json), baseOffset);
  }
  static fromTranslationResponse(translationResponse, baseOffset) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(translationResponse, "translationResponse");
    const phrase = translationResponse.SpeechPhrase;
    translationResponse.SpeechPhrase = undefined;
    phrase.Translation = translationResponse;
    phrase.Text = phrase.DisplayText;
    return new TranslationPhrase(phrase, baseOffset);
  }
  get RecognitionStatus() {
    return this.privTranslationPhrase.RecognitionStatus;
  }
  get Offset() {
    return this.privTranslationPhrase.Offset;
  }
  get Duration() {
    return this.privTranslationPhrase.Duration;
  }
  get Text() {
    return this.privTranslationPhrase.Text;
  }
  get Language() {
    return this.privTranslationPhrase.PrimaryLanguage?.Language;
  }
  get Confidence() {
    return this.privTranslationPhrase.PrimaryLanguage?.Confidence;
  }
  get Translation() {
    return this.privTranslationPhrase.Translation;
  }
  asJson() {
    const jsonObj = {
      ...this.privTranslationPhrase
    };
    // Convert the enum values to their string representations for serialization
    const serializedObj = {
      ...jsonObj,
      RecognitionStatus: Exports_js_1.RecognitionStatus[jsonObj.RecognitionStatus]
    };
    if (jsonObj.Translation) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      serializedObj.Translation = {
        ...jsonObj.Translation,
        TranslationStatus: TranslationStatus_js_1.TranslationStatus[jsonObj.Translation.TranslationStatus]
      };
    }
    return JSON.stringify(serializedObj);
  }
  mapRecognitionStatus(status) {
    if (typeof status === "string") {
      return Exports_js_1.RecognitionStatus[status];
    } else if (typeof status === "number") {
      return status;
    }
  }
  mapTranslationStatus(status) {
    if (typeof status === "string") {
      return TranslationStatus_js_1.TranslationStatus[status];
    } else if (typeof status === "number") {
      return status;
    }
  }
}
exports.TranslationPhrase = TranslationPhrase;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationSynthesisEnd.js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TranslationSynthesisEnd.js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationSynthesisEnd = void 0;
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class TranslationSynthesisEnd {
  constructor(json) {
    this.privSynthesisEnd = JSON.parse(json);
    if (!!this.privSynthesisEnd.SynthesisStatus) {
      this.privSynthesisEnd.SynthesisStatus = Exports_js_1.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus];
    }
    if (!!this.privSynthesisEnd.Status) {
      this.privSynthesisEnd.SynthesisStatus = Exports_js_1.SynthesisStatus[this.privSynthesisEnd.Status];
    }
  }
  static fromJSON(json) {
    return new TranslationSynthesisEnd(json);
  }
  get SynthesisStatus() {
    return this.privSynthesisEnd.SynthesisStatus;
  }
  get FailureReason() {
    return this.privSynthesisEnd.FailureReason;
  }
}
exports.TranslationSynthesisEnd = TranslationSynthesisEnd;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TurnStatusPayload.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TurnStatusPayload.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TurnStatusResponsePayload = void 0;
class TurnStatusResponsePayload {
  constructor(json) {
    this.privMessageStatusResponse = JSON.parse(json);
  }
  static fromJSON(json) {
    return new TurnStatusResponsePayload(json);
  }
  get interactionId() {
    return this.privMessageStatusResponse.interactionId;
  }
  get conversationId() {
    return this.privMessageStatusResponse.conversationId;
  }
  get statusCode() {
    // Payloads may contain a limited set of textual representations or a numeric status
    // code. The textual values are here converted into numeric ones.
    switch (this.privMessageStatusResponse.statusCode) {
      case "Success":
        return 200;
      case "Failed":
        return 400;
      case "TimedOut":
        return 429;
      default:
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return this.privMessageStatusResponse.statusCode;
    }
  }
}
exports.TurnStatusResponsePayload = TurnStatusResponsePayload;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceRecognizerBase.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceRecognizerBase.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServiceRecognizerBase = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const SpeechConnectionMessage_Internal_js_1 = __webpack_require__(/*! ./SpeechConnectionMessage.Internal.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js");
class ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
    // A promise for a configured connection.
    // Do not consume directly, call fetchConnection instead.
    this.privConnectionConfigurationPromise = undefined;
    // A promise for a connection, but one that has not had the speech context sent yet.
    // Do not consume directly, call fetchConnection instead.
    this.privConnectionPromise = undefined;
    this.privSetTimeout = setTimeout;
    this.privIsLiveAudio = false;
    this.privAverageBytesPerMs = 0;
    this.privEnableSpeakerId = false;
    this.privExpectContentAssessmentResponse = false;
    this.recognizeOverride = undefined;
    this.recognizeSpeaker = undefined;
    this.disconnectOverride = undefined;
    this.receiveMessageOverride = undefined;
    this.sendPrePayloadJSONOverride = undefined;
    this.postConnectImplOverride = undefined;
    this.configConnectionOverride = undefined;
    this.handleSpeechPhraseMessage = undefined;
    this.handleSpeechHypothesisMessage = undefined;
    if (!authentication) {
      throw new Exports_js_2.ArgumentNullError("authentication");
    }
    if (!connectionFactory) {
      throw new Exports_js_2.ArgumentNullError("connectionFactory");
    }
    if (!audioSource) {
      throw new Exports_js_2.ArgumentNullError("audioSource");
    }
    if (!recognizerConfig) {
      throw new Exports_js_2.ArgumentNullError("recognizerConfig");
    }
    this.privEnableSpeakerId = recognizerConfig.isSpeakerDiarizationEnabled;
    this.privMustReportEndOfStream = false;
    this.privAuthentication = authentication;
    this.privConnectionFactory = connectionFactory;
    this.privAudioSource = audioSource;
    this.privRecognizerConfig = recognizerConfig;
    this.privIsDisposed = false;
    this.privRecognizer = recognizer;
    this.privRequestSession = new Exports_js_4.RequestSession(this.privAudioSource.id());
    this.privConnectionEvents = new Exports_js_2.EventSource();
    this.privServiceEvents = new Exports_js_2.EventSource();
    this.privDynamicGrammar = new Exports_js_4.DynamicGrammarBuilder();
    this.privSpeechContext = new Exports_js_4.SpeechContext(this.privDynamicGrammar);
    this.privAgentConfig = new Exports_js_4.AgentConfig();
    const webWorkerLoadType = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.WebWorkerLoadType, "on").toLowerCase();
    if (webWorkerLoadType === "on" && typeof Blob !== "undefined" && typeof Worker !== "undefined") {
      this.privSetTimeout = Exports_js_2.Timeout.setTimeout;
    } else {
      if (typeof window !== "undefined") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.privSetTimeout = window.setTimeout.bind(window);
      }
      if (typeof globalThis !== "undefined") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.privSetTimeout = globalThis.setTimeout.bind(globalThis);
      }
    }
    this.connectionEvents.attach(connectionEvent => {
      if (connectionEvent.name === "ConnectionClosedEvent") {
        const connectionClosedEvent = connectionEvent;
        if (connectionClosedEvent.statusCode === 1003 || connectionClosedEvent.statusCode === 1007 || connectionClosedEvent.statusCode === 1002 || connectionClosedEvent.statusCode === 4000 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) {
          void this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? Exports_js_3.CancellationErrorCode.BadRequestParameters : Exports_js_3.CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);
        }
      }
    });
    if (this.privEnableSpeakerId) {
      this.privDiarizationSessionId = Exports_js_2.createNoDashGuid();
    }
    this.setLanguageIdJson();
    this.setOutputDetailLevelJson();
  }
  setTranslationJson() {
    const targetLanguages = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined);
    if (targetLanguages !== undefined) {
      const languages = targetLanguages.split(",");
      const translationVoice = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, undefined);
      const action = translationVoice !== undefined ? "Synthesize" : "None";
      this.privSpeechContext.setSection("translation", {
        onSuccess: {
          action
        },
        output: {
          interimResults: {
            mode: "Always"
          }
        },
        targetLanguages: languages
      });
      if (translationVoice !== undefined) {
        const languageToVoiceMap = {};
        for (const lang of languages) {
          languageToVoiceMap[lang] = translationVoice;
        }
        this.privSpeechContext.setSection("synthesis", {
          defaultVoices: languageToVoiceMap
        });
      }
    }
  }
  setSpeechSegmentationTimeoutJson() {
    const speechSegmentationSilenceTimeoutMs = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.Speech_SegmentationSilenceTimeoutMs, undefined);
    const speechSegmentationMaximumTimeMs = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.Speech_SegmentationMaximumTimeMs, undefined);
    const speechSegmentationStrategy = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.Speech_SegmentationStrategy, undefined);
    const segmentation = {
      segmentation: {
        mode: ""
      }
    };
    let configuredSegment = false;
    if (speechSegmentationStrategy !== undefined) {
      configuredSegment = true;
      let segMode = "";
      switch (speechSegmentationStrategy.toLowerCase()) {
        case "default":
          break;
        case "time":
          segMode = "Custom";
          break;
        case "semantic":
          segMode = "Semantic";
          break;
      }
      segmentation.segmentation.mode = segMode;
    }
    if (speechSegmentationSilenceTimeoutMs !== undefined) {
      configuredSegment = true;
      const segmentationSilenceTimeoutMs = parseInt(speechSegmentationSilenceTimeoutMs, 10);
      segmentation.segmentation.mode = "Custom";
      segmentation.segmentation.segmentationSilenceTimeoutMs = segmentationSilenceTimeoutMs;
    }
    if (speechSegmentationMaximumTimeMs !== undefined) {
      configuredSegment = true;
      const segmentationMaximumTimeMs = parseInt(speechSegmentationMaximumTimeMs, 10);
      segmentation.segmentation.mode = "Custom";
      segmentation.segmentation.segmentationForcedTimeoutMs = segmentationMaximumTimeMs;
    }
    if (configuredSegment) {
      const recoMode = this.recognitionMode === Exports_js_4.RecognitionMode.Conversation ? "CONVERSATION" : this.recognitionMode === Exports_js_4.RecognitionMode.Dictation ? "DICTATION" : "INTERACTIVE";
      const phraseDetection = this.privSpeechContext.getSection("phraseDetection");
      phraseDetection.mode = recoMode;
      phraseDetection[recoMode] = segmentation;
      this.privSpeechContext.setSection("phraseDetection", phraseDetection);
    }
  }
  setLanguageIdJson() {
    const phraseDetection = this.privSpeechContext.getSection("phraseDetection");
    if (this.privRecognizerConfig.autoDetectSourceLanguages !== undefined) {
      const sourceLanguages = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
      let speechContextLidMode;
      if (this.privRecognizerConfig.languageIdMode === "Continuous") {
        speechContextLidMode = "DetectContinuous";
      } else {
        // recognizerConfig.languageIdMode === "AtStart"
        speechContextLidMode = "DetectAtAudioStart";
      }
      this.privSpeechContext.setSection("languageId", {
        Priority: "PrioritizeLatency",
        languages: sourceLanguages,
        mode: speechContextLidMode,
        onSuccess: {
          action: "Recognize"
        },
        onUnknown: {
          action: "None"
        }
      });
      this.privSpeechContext.setSection("phraseOutput", {
        interimResults: {
          resultType: "Auto"
        },
        phraseResults: {
          resultType: "Always"
        }
      });
      const customModels = this.privRecognizerConfig.sourceLanguageModels;
      if (customModels !== undefined) {
        phraseDetection.customModels = customModels;
        phraseDetection.onInterim = {
          action: "None"
        };
        phraseDetection.onSuccess = {
          action: "None"
        };
      }
    }
    const targetLanguages = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined);
    if (targetLanguages !== undefined) {
      phraseDetection.onInterim = {
        action: "Translate"
      };
      phraseDetection.onSuccess = {
        action: "Translate"
      };
      this.privSpeechContext.setSection("phraseOutput", {
        interimResults: {
          resultType: "None"
        },
        phraseResults: {
          resultType: "None"
        }
      });
    }
    this.privSpeechContext.setSection("phraseDetection", phraseDetection);
  }
  setOutputDetailLevelJson() {
    if (this.privEnableSpeakerId) {
      const requestWordLevelTimestamps = this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase();
      if (requestWordLevelTimestamps === "true") {
        this.privSpeechContext.setWordLevelTimings();
      } else {
        const outputFormat = this.privRecognizerConfig.parameters.getProperty(Exports_js_4.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]).toLowerCase();
        if (outputFormat === Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Detailed].toLocaleLowerCase()) {
          this.privSpeechContext.setDetailedOutputFormat();
        }
      }
    }
  }
  get isSpeakerDiarizationEnabled() {
    return this.privEnableSpeakerId;
  }
  get audioSource() {
    return this.privAudioSource;
  }
  get speechContext() {
    return this.privSpeechContext;
  }
  get dynamicGrammar() {
    return this.privDynamicGrammar;
  }
  get agentConfig() {
    return this.privAgentConfig;
  }
  set conversationTranslatorToken(token) {
    this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.ConversationTranslator_Token, token);
  }
  set voiceProfileType(type) {
    this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SpeakerIdMode, type);
  }
  set authentication(auth) {
    this.privAuthentication = auth;
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  async dispose(reason) {
    this.privIsDisposed = true;
    if (this.privConnectionConfigurationPromise !== undefined) {
      try {
        const connection = await this.privConnectionConfigurationPromise;
        await connection.dispose(reason);
      } catch (error) {
        // The connection is in a bad state. But we're trying to kill it, so...
        return;
      }
    }
  }
  get connectionEvents() {
    return this.privConnectionEvents;
  }
  get serviceEvents() {
    return this.privServiceEvents;
  }
  get recognitionMode() {
    return this.privRecognizerConfig.recognitionMode;
  }
  async recognize(recoMode, successCallback, errorCallBack) {
    if (this.recognizeOverride !== undefined) {
      await this.recognizeOverride(recoMode, successCallback, errorCallBack);
      return;
    }
    // Clear the existing configuration promise to force a re-transmission of config and context.
    this.privConnectionConfigurationPromise = undefined;
    this.privRecognizerConfig.recognitionMode = recoMode;
    this.setSpeechSegmentationTimeoutJson();
    this.setTranslationJson();
    this.privSuccessCallback = successCallback;
    this.privErrorCallback = errorCallBack;
    this.privRequestSession.startNewRecognition();
    this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
    // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
    const conPromise = this.connectImpl();
    let audioNode;
    try {
      const audioStreamNode = await this.audioSource.attach(this.privRequestSession.audioNodeId);
      const format = await this.audioSource.format;
      const deviceInfo = await this.audioSource.deviceInfo;
      this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === Exports_js_4.type.Microphones;
      audioNode = new Exports_js_1.ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
        source: deviceInfo
      };
    } catch (error) {
      await this.privRequestSession.onStopRecognizing();
      throw error;
    }
    try {
      await conPromise;
    } catch (error) {
      await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, error);
      return;
    }
    const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
    if (!!this.privRecognizer.sessionStarted) {
      this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
    }
    void this.receiveMessage();
    const audioSendPromise = this.sendAudio(audioNode);
    audioSendPromise.catch(async error => {
      await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
    });
    return;
  }
  async stopRecognizing() {
    if (this.privRequestSession.isRecognizing) {
      try {
        await this.audioSource.turnOff();
        await this.sendFinalAudio();
        await this.privRequestSession.onStopRecognizing();
        await this.privRequestSession.turnCompletionPromise;
      } finally {
        await this.privRequestSession.dispose();
      }
    }
    return;
  }
  async connect() {
    await this.connectImpl();
    return Promise.resolve();
  }
  connectAsync(cb, err) {
    this.connectImpl().then(() => {
      try {
        if (!!cb) {
          cb();
        }
      } catch (e) {
        if (!!err) {
          err(e);
        }
      }
    }, reason => {
      try {
        if (!!err) {
          err(reason);
        }
        /* eslint-disable no-empty */
      } catch (error) {}
    });
  }
  async disconnect() {
    await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.NoError, "Disconnecting");
    if (this.disconnectOverride !== undefined) {
      await this.disconnectOverride();
    }
    if (this.privConnectionPromise !== undefined) {
      try {
        await (await this.privConnectionPromise).dispose();
      } catch (error) {}
    }
    this.privConnectionPromise = undefined;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  sendMessage(message) {
    return;
  }
  async sendNetworkMessage(path, payload) {
    const type = typeof payload === "string" ? Exports_js_2.MessageType.Text : Exports_js_2.MessageType.Binary;
    const contentType = typeof payload === "string" ? "application/json" : "";
    const connection = await this.fetchConnection();
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload));
  }
  set activityTemplate(messagePayload) {
    this.privActivityTemplate = messagePayload;
  }
  get activityTemplate() {
    return this.privActivityTemplate;
  }
  set expectContentAssessmentResponse(value) {
    this.privExpectContentAssessmentResponse = value;
  }
  async sendTelemetryData() {
    const telemetryData = this.privRequestSession.getTelemetry();
    if (ServiceRecognizerBase.telemetryDataEnabled !== true || this.privIsDisposed || null === telemetryData) {
      return;
    }
    if (!!ServiceRecognizerBase.telemetryData) {
      try {
        ServiceRecognizerBase.telemetryData(telemetryData);
        /* eslint-disable no-empty */
      } catch {}
    }
    const connection = await this.fetchConnection();
    await connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", telemetryData));
  }
  // Cancels recognition.
  async cancelRecognitionLocal(cancellationReason, errorCode, error) {
    if (!!this.privRequestSession.isRecognizing) {
      await this.privRequestSession.onStopRecognizing();
      this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, cancellationReason, errorCode, error);
    }
  }
  async receiveMessage() {
    try {
      if (this.privIsDisposed) {
        // We're done.
        return;
      }
      let connection = await this.fetchConnection();
      const message = await connection.read();
      if (this.receiveMessageOverride !== undefined) {
        return this.receiveMessageOverride();
      }
      // indicates we are draining the queue and it came with no message;
      if (!message) {
        return this.receiveMessage();
      }
      this.privServiceHasSentMessage = true;
      const connectionMessage = SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage.fromConnectionMessage(message);
      if (connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase()) {
        switch (connectionMessage.path.toLowerCase()) {
          case "turn.start":
            this.privMustReportEndOfStream = true;
            this.privRequestSession.onServiceTurnStartResponse();
            break;
          case "speech.startdetected":
            const speechStartDetected = Exports_js_4.SpeechDetected.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
            const speechStartEventArgs = new Exports_js_3.RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);
            if (!!this.privRecognizer.speechStartDetected) {
              this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);
            }
            break;
          case "speech.enddetected":
            let json;
            if (connectionMessage.textBody.length > 0) {
              json = connectionMessage.textBody;
            } else {
              // If the request was empty, the JSON returned is empty.
              json = "{ Offset: 0 }";
            }
            const speechStopDetected = Exports_js_4.SpeechDetected.fromJSON(json, this.privRequestSession.currentTurnAudioOffset);
            const speechStopEventArgs = new Exports_js_3.RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
            if (!!this.privRecognizer.speechEndDetected) {
              this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);
            }
            break;
          case "turn.end":
            await this.sendTelemetryData();
            if (this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream) {
              this.privMustReportEndOfStream = false;
              await this.cancelRecognitionLocal(Exports_js_3.CancellationReason.EndOfStream, Exports_js_3.CancellationErrorCode.NoError, undefined);
            }
            const sessionStopEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
            await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition);
            if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
              if (!!this.privRecognizer.sessionStopped) {
                this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);
              }
              return;
            } else {
              connection = await this.fetchConnection();
              await this.sendPrePayloadJSON(connection);
            }
            break;
          default:
            if (!(await this.processTypeSpecificMessages(connectionMessage))) {
              // here are some messages that the derived class has not processed, dispatch them to connect class
              if (!!this.privServiceEvents) {
                this.serviceEvents.onEvent(new Exports_js_2.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
              }
            }
        }
      }
      return this.receiveMessage();
    } catch (error) {
      return null;
    }
  }
  updateSpeakerDiarizationAudioOffset() {
    const bytesSent = this.privRequestSession.recognitionBytesSent;
    const audioOffsetMs = this.privAverageBytesPerMs !== 0 ? bytesSent / this.privAverageBytesPerMs : 0;
    this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(audioOffsetMs);
  }
  sendSpeechContext(connection, generateNewRequestId) {
    if (this.privEnableSpeakerId) {
      this.updateSpeakerDiarizationAudioOffset();
    }
    const speechContextJson = this.speechContext.toJSON();
    if (generateNewRequestId) {
      this.privRequestSession.onSpeechContext();
    }
    if (speechContextJson) {
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", speechContextJson));
    }
    return;
  }
  noOp() {
    // operation not supported
    return;
  }
  // Encapsulated for derived service recognizers that need to send additional JSON
  async sendPrePayloadJSON(connection, generateNewRequestId = true) {
    if (this.sendPrePayloadJSONOverride !== undefined) {
      return this.sendPrePayloadJSONOverride(connection);
    }
    await this.sendSpeechContext(connection, generateNewRequestId);
    await this.sendWaveHeader(connection);
    return;
  }
  async sendWaveHeader(connection) {
    const format = await this.audioSource.format;
    // this.writeBufferToConsole(format.header);
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", format.header));
  }
  // Establishes a websocket connection to the end point.
  connectImpl() {
    if (this.privConnectionPromise !== undefined) {
      return this.privConnectionPromise.then(connection => {
        if (connection.state() === Exports_js_2.ConnectionState.Disconnected) {
          this.privConnectionId = null;
          this.privConnectionPromise = undefined;
          this.privServiceHasSentMessage = false;
          return this.connectImpl();
        }
        return this.privConnectionPromise;
      }, () => {
        this.privConnectionId = null;
        this.privConnectionPromise = undefined;
        this.privServiceHasSentMessage = false;
        return this.connectImpl();
      });
    }
    this.privConnectionPromise = this.retryableConnect();
    // Attach an empty handler to allow the promise to run in the background while
    // other startup events happen. It'll eventually be awaited on.
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    this.privConnectionPromise.catch(() => {});
    if (this.postConnectImplOverride !== undefined) {
      return this.postConnectImplOverride(this.privConnectionPromise);
    }
    return this.privConnectionPromise;
  }
  sendSpeechServiceConfig(connection, requestSession, SpeechServiceConfigJson) {
    requestSession.onSpeechContext();
    // filter out anything that is not required for the service to work.
    if (ServiceRecognizerBase.telemetryDataEnabled !== true) {
      const withTelemetry = JSON.parse(SpeechServiceConfigJson);
      const replacement = {
        context: {
          system: withTelemetry.context.system
        }
      };
      SpeechServiceConfigJson = JSON.stringify(replacement);
    }
    if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
      const json = JSON.parse(SpeechServiceConfigJson);
      json.context.DisableReferenceChannel = "True";
      json.context.MicSpec = "1_0_0";
      SpeechServiceConfigJson = JSON.stringify(json);
    }
    if (SpeechServiceConfigJson) {
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speech.config", requestSession.requestId, "application/json", SpeechServiceConfigJson));
    }
    return;
  }
  async fetchConnection() {
    if (this.privConnectionConfigurationPromise !== undefined) {
      return this.privConnectionConfigurationPromise.then(connection => {
        if (connection.state() === Exports_js_2.ConnectionState.Disconnected) {
          this.privConnectionId = null;
          this.privConnectionConfigurationPromise = undefined;
          this.privServiceHasSentMessage = false;
          return this.fetchConnection();
        }
        return this.privConnectionConfigurationPromise;
      }, () => {
        this.privConnectionId = null;
        this.privConnectionConfigurationPromise = undefined;
        this.privServiceHasSentMessage = false;
        return this.fetchConnection();
      });
    }
    this.privConnectionConfigurationPromise = this.configureConnection();
    return await this.privConnectionConfigurationPromise;
  }
  async sendAudio(audioStreamNode) {
    const audioFormat = await this.audioSource.format;
    this.privAverageBytesPerMs = audioFormat.avgBytesPerSec / 1000;
    // The time we last sent data to the service.
    let nextSendTime = Date.now();
    // Max amount to send before we start to throttle
    const fastLaneSizeMs = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000");
    const maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);
    const startRecogNumber = this.privRequestSession.recogNumber;
    const readAndUploadCycle = async () => {
      // If speech is done, stop sending audio.
      if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {
        const connection = await this.fetchConnection();
        const audioStreamChunk = await audioStreamNode.read();
        // we have a new audio chunk to upload.
        if (this.privRequestSession.isSpeechEnded) {
          // If service already recognized audio end then don't send any more audio
          return;
        }
        let payload;
        let sendDelay;
        if (!audioStreamChunk || audioStreamChunk.isEnd) {
          payload = null;
          sendDelay = 0;
        } else {
          payload = audioStreamChunk.buffer;
          this.privRequestSession.onAudioSent(payload.byteLength);
          if (maxSendUnthrottledBytes >= this.privRequestSession.bytesSent) {
            sendDelay = 0;
          } else {
            sendDelay = Math.max(0, nextSendTime - Date.now());
          }
        }
        if (0 !== sendDelay) {
          await this.delay(sendDelay);
        }
        if (payload !== null) {
          nextSendTime = Date.now() + payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2);
        }
        // Are we still alive?
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {
          connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Binary, "audio", this.privRequestSession.requestId, null, payload)).catch(() => {
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {});
          });
          if (!audioStreamChunk?.isEnd) {
            // this.writeBufferToConsole(payload);
            // Regardless of success or failure, schedule the next upload.
            // If the underlying connection was broken, the next cycle will
            // get a new connection and re-transmit missing audio automatically.
            return readAndUploadCycle();
          } else {
            // the audio stream has been closed, no need to schedule next
            // read-upload cycle.
            if (!this.privIsLiveAudio) {
              this.privRequestSession.onSpeechEnded();
            }
          }
        }
      }
    };
    return readAndUploadCycle();
  }
  async retryableConnect() {
    let isUnAuthorized = false;
    this.privAuthFetchEventId = Exports_js_2.createNoDashGuid();
    const sessionId = this.privRequestSession.sessionId;
    this.privConnectionId = sessionId !== undefined ? sessionId : Exports_js_2.createNoDashGuid();
    this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
    let lastStatusCode = 0;
    let lastReason = "";
    while (this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount) {
      // Get the auth information for the connection. This is a bit of overkill for the current API surface, but leaving the plumbing in place to be able to raise a developer-customer
      // facing event when a connection fails to let them try and provide new auth information.
      const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      const auth = await authPromise;
      await this.privRequestSession.onAuthCompleted(false);
      // Create the connection
      const connection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId);
      // Attach the telemetry handlers.
      this.privRequestSession.listenForServiceTelemetry(connection.events);
      // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,
      // it'll stop sending events.
      connection.events.attach(event => {
        this.connectionEvents.onEvent(event);
      });
      const response = await connection.open();
      // 200 == everything is fine.
      if (response.statusCode === 200) {
        await this.privRequestSession.onConnectionEstablishCompleted(response.statusCode);
        return Promise.resolve(connection);
      } else if (response.statusCode === 1006) {
        isUnAuthorized = true;
      }
      lastStatusCode = response.statusCode;
      lastReason = response.reason;
      this.privRequestSession.onRetryConnection();
    }
    await this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason);
    return Promise.reject(`Unable to contact server. StatusCode: ${lastStatusCode}, ${this.privRecognizerConfig.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${lastReason}`);
  }
  delay(delayMs) {
    return new Promise(resolve => this.privSetTimeout(resolve, delayMs));
  }
  writeBufferToConsole(buffer) {
    let out = "Buffer Size: ";
    if (null === buffer) {
      out += "null";
    } else {
      const readView = new Uint8Array(buffer);
      out += `${buffer.byteLength}\r\n`;
      for (let i = 0; i < buffer.byteLength; i++) {
        out += readView[i].toString(16).padStart(2, "0") + " ";
        if ((i + 1) % 16 === 0) {
          // eslint-disable-next-line no-console
          console.info(out);
          out = "";
        }
      }
    }
    // eslint-disable-next-line no-console
    console.info(out);
  }
  async sendFinalAudio() {
    const connection = await this.fetchConnection();
    await connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
    return;
  }
  // Takes an established websocket connection to the endpoint and sends speech configuration information.
  async configureConnection() {
    const connection = await this.connectImpl();
    if (this.configConnectionOverride !== undefined) {
      return this.configConnectionOverride(connection);
    }
    await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());
    await this.sendPrePayloadJSON(connection, false);
    return connection;
  }
}
exports.ServiceRecognizerBase = ServiceRecognizerBase;
ServiceRecognizerBase.telemetryDataEnabled = true;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceTelemetryListener.Internal.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceTelemetryListener.Internal.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServiceTelemetryListener = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const RecognitionEvents_js_1 = __webpack_require__(/*! ./RecognitionEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognitionEvents.js");
class ServiceTelemetryListener {
  constructor(requestId, audioSourceId, audioNodeId) {
    this.privIsDisposed = false;
    this.privListeningTriggerMetric = null;
    this.privMicMetric = null;
    this.privConnectionEstablishMetric = null;
    this.privRequestId = requestId;
    this.privAudioSourceId = audioSourceId;
    this.privAudioNodeId = audioNodeId;
    this.privReceivedMessages = {};
    this.privPhraseLatencies = [];
    this.privHypothesisLatencies = [];
  }
  phraseReceived(audioReceivedTime) {
    if (audioReceivedTime > 0) {
      // 0 indicates the time is unknown. Drop it.
      this.privPhraseLatencies.push(Date.now() - audioReceivedTime);
    }
  }
  hypothesisReceived(audioReceivedTime) {
    if (audioReceivedTime > 0) {
      // 0 indicates the time is unknown. Drop it.
      this.privHypothesisLatencies.push(Date.now() - audioReceivedTime);
    }
  }
  onEvent(e) {
    if (this.privIsDisposed) {
      return;
    }
    if (e instanceof RecognitionEvents_js_1.RecognitionTriggeredEvent && e.requestId === this.privRequestId) {
      this.privListeningTriggerMetric = {
        End: e.eventTime,
        Name: "ListeningTrigger",
        Start: e.eventTime
      };
    }
    if (e instanceof Exports_js_1.AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      this.privMicStartTime = e.eventTime;
    }
    if (e instanceof Exports_js_1.AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      this.privMicStartTime = e.eventTime;
    }
    if (e instanceof Exports_js_1.AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId) {
      if (!this.privMicMetric) {
        this.privMicMetric = {
          End: e.eventTime,
          Error: e.error,
          Name: "Microphone",
          Start: this.privMicStartTime
        };
      }
    }
    if (e instanceof Exports_js_1.AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      if (!this.privMicMetric) {
        this.privMicMetric = {
          End: e.eventTime,
          Error: e.error,
          Name: "Microphone",
          Start: this.privMicStartTime
        };
      }
    }
    if (e instanceof Exports_js_1.AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId) {
      if (!this.privMicMetric) {
        this.privMicMetric = {
          End: e.eventTime,
          Name: "Microphone",
          Start: this.privMicStartTime
        };
      }
    }
    if (e instanceof RecognitionEvents_js_1.ConnectingToServiceEvent && e.requestId === this.privRequestId) {
      this.privConnectionId = e.sessionId;
    }
    if (e instanceof Exports_js_1.ConnectionStartEvent && e.connectionId === this.privConnectionId) {
      this.privConnectionStartTime = e.eventTime;
    }
    if (e instanceof Exports_js_1.ConnectionEstablishedEvent && e.connectionId === this.privConnectionId) {
      if (!this.privConnectionEstablishMetric) {
        this.privConnectionEstablishMetric = {
          End: e.eventTime,
          Id: this.privConnectionId,
          Name: "Connection",
          Start: this.privConnectionStartTime
        };
      }
    }
    if (e instanceof Exports_js_1.ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId) {
      if (!this.privConnectionEstablishMetric) {
        this.privConnectionEstablishMetric = {
          End: e.eventTime,
          Error: this.getConnectionError(e.statusCode),
          Id: this.privConnectionId,
          Name: "Connection",
          Start: this.privConnectionStartTime
        };
      }
    }
    if (e instanceof Exports_js_1.ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId) {
      if (e.message && e.message.headers && e.message.headers.path) {
        if (!this.privReceivedMessages[e.message.headers.path]) {
          this.privReceivedMessages[e.message.headers.path] = new Array();
        }
        const maxMessagesToSend = 50;
        if (this.privReceivedMessages[e.message.headers.path].length < maxMessagesToSend) {
          this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime);
        }
      }
    }
  }
  getTelemetry() {
    const metrics = new Array();
    if (this.privListeningTriggerMetric) {
      metrics.push(this.privListeningTriggerMetric);
    }
    if (this.privMicMetric) {
      metrics.push(this.privMicMetric);
    }
    if (this.privConnectionEstablishMetric) {
      metrics.push(this.privConnectionEstablishMetric);
    }
    if (this.privPhraseLatencies.length > 0) {
      metrics.push({
        PhraseLatencyMs: this.privPhraseLatencies
      });
    }
    if (this.privHypothesisLatencies.length > 0) {
      metrics.push({
        FirstHypothesisLatencyMs: this.privHypothesisLatencies
      });
    }
    const telemetry = {
      Metrics: metrics,
      ReceivedMessages: this.privReceivedMessages
    };
    const json = JSON.stringify(telemetry);
    // We dont want to send the same telemetry again. So clean those out.
    this.privReceivedMessages = {};
    this.privListeningTriggerMetric = null;
    this.privMicMetric = null;
    this.privConnectionEstablishMetric = null;
    this.privPhraseLatencies = [];
    this.privHypothesisLatencies = [];
    return json;
  }
  // Determines if there are any telemetry events to send to the service.
  get hasTelemetry() {
    return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
  }
  dispose() {
    this.privIsDisposed = true;
  }
  getConnectionError(statusCode) {
    /*
    -- Websocket status codes --
    NormalClosure = 1000,
    EndpointUnavailable = 1001,
    ProtocolError = 1002,
    InvalidMessageType = 1003,
    Empty = 1005,
    InvalidPayloadData = 1007,
    PolicyViolation = 1008,
    MessageTooBig = 1009,
    MandatoryExtension = 1010,
    InternalServerError = 1011
    */
    switch (statusCode) {
      case 400:
      case 1002:
      case 1003:
      case 1005:
      case 1007:
      case 1008:
      case 1009:
        return "BadRequest";
      case 401:
        return "Unauthorized";
      case 403:
        return "Forbidden";
      case 503:
      case 1001:
        return "ServerUnavailable";
      case 500:
      case 1011:
        return "ServerError";
      case 408:
      case 504:
        return "Timeout";
      default:
        return "statuscode:" + statusCode.toString();
    }
  }
}
exports.ServiceTelemetryListener = ServiceTelemetryListener;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerRecognitionConfig.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerRecognitionConfig.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeakerRecognitionConfig = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class SpeakerRecognitionConfig {
  constructor(context, parameters) {
    this.privContext = context ? context : new Exports_js_1.Context(null);
    this.privParameters = parameters;
  }
  get parameters() {
    return this.privParameters;
  }
  get Context() {
    return this.privContext;
  }
}
exports.SpeakerRecognitionConfig = SpeakerRecognitionConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerRecognitionConnectionFactory.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerRecognitionConnectionFactory.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceProfileConnectionFactory = exports.SpeakerRecognitionConnectionFactory = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
class SpeakerRecognitionConnectionFactoryBase extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  create(config, authInfo, endpointPath, connectionId) {
    let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint);
    if (!endpoint) {
      const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, `wss://${region}.spr-frontend.speech${hostSuffix}`);
      const scenario = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
      endpoint = `${host}/speaker/ws/${this.scenarioToPath(scenario)}/${endpointPath}`;
    }
    const queryParams = {
      format: "simple",
      language: config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage)
    };
    this.setCommonUrlParams(config, queryParams, endpoint);
    const headers = {};
    if (authInfo.token !== undefined && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    headers[HeaderNames_js_1.HeaderNames.SpIDAuthKey] = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key);
    config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    return new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
  }
  scenarioToPath(mode) {
    switch (mode) {
      case "TextIndependentVerification":
      case "2":
        return "verification/text-independent";
      case "TextDependentVerification":
      case "1":
        return "verification/text-dependent";
      default:
        return "identification/text-independent";
    }
  }
}
class SpeakerRecognitionConnectionFactory extends SpeakerRecognitionConnectionFactoryBase {
  create(config, authInfo, connectionId) {
    return super.create(config, authInfo, "recognition", connectionId);
  }
}
exports.SpeakerRecognitionConnectionFactory = SpeakerRecognitionConnectionFactory;
class VoiceProfileConnectionFactory extends SpeakerRecognitionConnectionFactoryBase {
  create(config, authInfo, connectionId) {
    return super.create(config, authInfo, "profile", connectionId);
  }
}
exports.VoiceProfileConnectionFactory = VoiceProfileConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerServiceRecognizer.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeakerServiceRecognizer.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeakerServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const SpeechConnectionMessage_Internal_js_1 = __webpack_require__(/*! ./SpeechConnectionMessage.Internal.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js");
// eslint-disable-next-line max-classes-per-file
class SpeakerServiceRecognizer extends Exports_js_4.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
    this.privSpeakerRecognizer = recognizer;
    this.privSpeakerAudioSource = audioSource;
    this.recognizeSpeaker = model => this.recognizeSpeakerOnce(model);
    this.sendPrePayloadJSONOverride = () => this.noOp();
  }
  processTypeSpecificMessages(connectionMessage) {
    let processed = false;
    const resultProps = new Exports_js_3.PropertyCollection();
    if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {
      resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
    }
    switch (connectionMessage.path.toLowerCase()) {
      case "speaker.response":
        const response = JSON.parse(connectionMessage.textBody);
        let result;
        if (response.status.statusCode.toLowerCase() !== "success") {
          result = new Exports_js_3.SpeakerRecognitionResult(response, Exports_js_3.ResultReason.Canceled, Exports_js_3.CancellationErrorCode.ServiceError, response.status.reason);
        } else {
          result = new Exports_js_3.SpeakerRecognitionResult(response, Exports_js_3.ResultReason.RecognizedSpeaker);
        }
        if (!!this.privResultDeferral) {
          this.privResultDeferral.resolve(result);
        }
        processed = true;
        break;
      default:
        break;
    }
    const defferal = new Exports_js_2.Deferred();
    defferal.resolve(processed);
    return defferal.promise;
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    const properties = new Exports_js_3.PropertyCollection();
    properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);
    if (!!this.privResultDeferral) {
      const result = new Exports_js_3.SpeakerRecognitionResult({
        scenario: this.privSpeakerModel.scenario,
        status: {
          statusCode: error,
          reason: error
        }
      }, Exports_js_3.ResultReason.Canceled, errorCode, error);
      try {
        this.privResultDeferral.resolve(result);
      } catch (error) {
        this.privResultDeferral.reject(error);
      }
    }
  }
  async recognizeSpeakerOnce(model) {
    this.privSpeakerModel = model;
    this.voiceProfileType = model.scenario;
    if (!this.privResultDeferral) {
      this.privResultDeferral = new Exports_js_2.Deferred();
    }
    this.privRequestSession.startNewRecognition();
    this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);
    this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
    // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
    const conPromise = this.connectImpl();
    const preAudioPromise = this.sendPreAudioMessages(this.extractSpeakerContext(model));
    const node = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);
    const format = await this.privSpeakerAudioSource.format;
    const deviceInfo = await this.privSpeakerAudioSource.deviceInfo;
    const audioNode = new Exports_js_1.ReplayableAudioNode(node, format.avgBytesPerSec);
    await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
    this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
      source: deviceInfo
    };
    try {
      await conPromise;
      await preAudioPromise;
    } catch (err) {
      this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, err);
    }
    const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
    if (!!this.privRecognizer.sessionStarted) {
      this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
    }
    void this.receiveMessage();
    const audioSendPromise = this.sendAudio(audioNode);
    // /* eslint-disable no-empty */
    audioSendPromise.then(() => {}, error => {
      this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
    });
    return this.privResultDeferral.promise;
  }
  async sendPreAudioMessages(context) {
    const connection = await this.fetchConnection();
    await this.sendSpeakerRecognition(connection, context);
    // await this.sendWaveHeader(connection);
  }
  async sendSpeakerRecognition(connection, context) {
    const speakerContextJson = JSON.stringify(context);
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", speakerContextJson));
  }
  extractSpeakerContext(model) {
    return {
      features: {
        interimResult: "enabled",
        progressiveDetection: "disabled"
      },
      profileIds: model.profileIds,
      scenario: model.scenario
    };
  }
}
exports.SpeakerServiceRecognizer = SpeakerServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionFactory.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionFactory.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ./QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
class SpeechConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  constructor() {
    super(...arguments);
    this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1";
    this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1";
    this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1";
    this.universalUri = "/speech/universal/v";
  }
  create(config, authInfo, connectionId) {
    let endpoint = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint, undefined);
    const region = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Region, undefined);
    const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
    const host = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Host, "wss://" + region + ".stt.speech" + hostSuffix);
    const queryParams = {};
    const endpointId = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_EndpointId, undefined);
    const language = config.parameters.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage, undefined);
    if (endpointId) {
      if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId) === -1) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
      }
    } else if (language) {
      if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.Language) === -1) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
      }
    }
    if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.Format) === -1) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = config.parameters.getProperty(Exports_js_2.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]).toLowerCase();
    }
    if (config.autoDetectSourceLanguages !== undefined) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableLanguageId] = "true";
    }
    this.setCommonUrlParams(config, queryParams, endpoint);
    if (!endpoint) {
      switch (config.recognitionMode) {
        case Exports_js_4.RecognitionMode.Conversation:
          if (config.parameters.getProperty(Exports_js_2.ForceDictationPropertyName, "false") === "true") {
            endpoint = host + this.dictationRelativeUri;
          } else {
            if (config.recognitionEndpointVersion !== undefined && parseInt(config.recognitionEndpointVersion, 10) > 1) {
              endpoint = `${host}${this.universalUri}${config.recognitionEndpointVersion}`;
            } else {
              endpoint = host + this.conversationRelativeUri;
            }
          }
          break;
        case Exports_js_4.RecognitionMode.Dictation:
          endpoint = host + this.dictationRelativeUri;
          break;
        default:
          if (config.recognitionEndpointVersion !== undefined && parseInt(config.recognitionEndpointVersion, 10) > 1) {
            endpoint = `${host}${this.universalUri}${config.recognitionEndpointVersion}`;
          } else {
            endpoint = host + this.interactiveRelativeUri; // default is interactive
          }
          break;
      }
    }
    const headers = {};
    if (authInfo.token !== undefined && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    const webSocketConnection = new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_4.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
    // Set the value of SpeechServiceConnection_Url to webSocketConnection.uri (and not to `endpoint`), since this value is the final
    // URI that was used to make the connection (including query parameters).
    const uri = webSocketConnection.uri;
    config.parameters.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Url, uri);
    return webSocketConnection;
  }
}
exports.SpeechConnectionFactory = SpeechConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechConnectionMessage = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
class SpeechConnectionMessage extends Exports_js_1.ConnectionMessage {
  constructor(messageType, path, requestId, contentType, body, streamId, additionalHeaders, id) {
    if (!path) {
      throw new Exports_js_1.ArgumentNullError("path");
    }
    if (!requestId) {
      throw new Exports_js_1.ArgumentNullError("requestId");
    }
    const headers = {};
    headers[HeaderNames_js_1.HeaderNames.Path] = path;
    headers[HeaderNames_js_1.HeaderNames.RequestId] = requestId;
    headers[HeaderNames_js_1.HeaderNames.RequestTimestamp] = new Date().toISOString();
    if (contentType) {
      headers[HeaderNames_js_1.HeaderNames.ContentType] = contentType;
    }
    if (streamId) {
      headers[HeaderNames_js_1.HeaderNames.RequestStreamId] = streamId;
    }
    if (additionalHeaders) {
      for (const headerName in additionalHeaders) {
        if (headerName) {
          headers[headerName] = additionalHeaders[headerName];
        }
      }
    }
    if (id) {
      super(messageType, body, headers, id);
    } else {
      super(messageType, body, headers);
    }
    this.privPath = path;
    this.privRequestId = requestId;
    this.privContentType = contentType;
    this.privStreamId = streamId;
    this.privAdditionalHeaders = additionalHeaders;
  }
  get path() {
    return this.privPath;
  }
  get requestId() {
    return this.privRequestId;
  }
  get contentType() {
    return this.privContentType;
  }
  get streamId() {
    return this.privStreamId;
  }
  get additionalHeaders() {
    return this.privAdditionalHeaders;
  }
  static fromConnectionMessage(message) {
    let path = null;
    let requestId = null;
    let contentType = null;
    // let requestTimestamp = null;
    let streamId = null;
    const additionalHeaders = {};
    if (message.headers) {
      for (const headerName in message.headers) {
        if (headerName) {
          if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.Path.toLowerCase()) {
            path = message.headers[headerName];
          } else if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.RequestId.toLowerCase()) {
            requestId = message.headers[headerName];
            // } else if (headerName.toLowerCase() === HeaderNames.RequestTimestamp.toLowerCase()) {
            //  requestTimestamp = message.headers[headerName];
          } else if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.ContentType.toLowerCase()) {
            contentType = message.headers[headerName];
          } else if (headerName.toLowerCase() === HeaderNames_js_1.HeaderNames.RequestStreamId.toLowerCase()) {
            streamId = message.headers[headerName];
          } else {
            additionalHeaders[headerName] = message.headers[headerName];
          }
        }
      }
    }
    return new SpeechConnectionMessage(message.messageType, path, requestId, contentType, message.body, streamId, additionalHeaders, message.id);
  }
}
exports.SpeechConnectionMessage = SpeechConnectionMessage;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechContext.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechContext.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechContext = void 0;
/**
 * Represents the JSON used in the speech.context message sent to the speech service.
 * The dynamic grammar is always refreshed from the encapsulated dynamic grammar object.
 */
class SpeechContext {
  constructor(dynamicGrammar) {
    this.privContext = {};
    this.privDynamicGrammar = dynamicGrammar;
  }
  /**
   * Gets a section of the speech.context object.
   * @param sectionName Name of the section to get.
   * @return string or Context JSON serializable object that represents the value.
   */
  getSection(sectionName) {
    return this.privContext[sectionName] || {};
  }
  /**
   * Adds a section to the speech.context object.
   * @param sectionName Name of the section to add.
   * @param value JSON serializable object that represents the value.
   */
  setSection(sectionName, value) {
    this.privContext[sectionName] = value;
  }
  /**
   * @Internal
   * This is only used by pronunciation assessment config.
   * Do not use externally, object returned will change without warning or notice.
   */
  setPronunciationAssessmentParams(params, contentAssessmentTopic, isSpeakerDiarizationEnabled = false) {
    if (this.privContext.phraseDetection === undefined) {
      this.privContext.phraseDetection = {
        enrichment: {
          pronunciationAssessment: {}
        }
      };
    }
    if (this.privContext.phraseDetection.enrichment === undefined) {
      this.privContext.phraseDetection.enrichment = {
        pronunciationAssessment: {}
      };
    }
    this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(params);
    if (isSpeakerDiarizationEnabled) {
      this.privContext.phraseDetection.mode = "Conversation";
    }
    this.setWordLevelTimings();
    this.privContext.phraseOutput.detailed.options.push("PronunciationAssessment");
    if (this.privContext.phraseOutput.detailed.options.indexOf("SNR") === -1) {
      this.privContext.phraseOutput.detailed.options.push("SNR");
    }
    if (!!contentAssessmentTopic) {
      this.privContext.phraseDetection.enrichment.contentAssessment = {
        topic: contentAssessmentTopic
      };
      this.privContext.phraseOutput.detailed.options.push("ContentAssessment");
    }
  }
  setDetailedOutputFormat() {
    if (this.privContext.phraseOutput === undefined) {
      this.privContext.phraseOutput = {
        detailed: {
          options: []
        },
        format: {}
      };
    }
    if (this.privContext.phraseOutput.detailed === undefined) {
      this.privContext.phraseOutput.detailed = {
        options: []
      };
    }
    this.privContext.phraseOutput.format = "Detailed";
  }
  setWordLevelTimings() {
    if (this.privContext.phraseOutput === undefined) {
      this.privContext.phraseOutput = {
        detailed: {
          options: []
        },
        format: {}
      };
    }
    if (this.privContext.phraseOutput.detailed === undefined) {
      this.privContext.phraseOutput.detailed = {
        options: []
      };
    }
    this.privContext.phraseOutput.format = "Detailed";
    if (this.privContext.phraseOutput.detailed.options.indexOf("WordTimings") === -1) {
      this.privContext.phraseOutput.detailed.options.push("WordTimings");
    }
  }
  setSpeakerDiarizationAudioOffsetMs(audioOffsetMs) {
    this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = audioOffsetMs;
  }
  toJSON() {
    const dgi = this.privDynamicGrammar.generateGrammarObject();
    this.setSection("dgi", dgi);
    const ret = JSON.stringify(this.privContext);
    return ret;
  }
}
exports.SpeechContext = SpeechContext;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceConfig.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceConfig.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.type = exports.connectivity = exports.Device = exports.OS = exports.System = exports.Context = exports.SpeechServiceConfig = void 0;
/* eslint-disable max-classes-per-file */
// The config is serialized and sent as the Speech.Config
class SpeechServiceConfig {
  constructor(context) {
    this.context = context;
  }
  serialize() {
    return JSON.stringify(this, (key, value) => {
      if (value && typeof value === "object" && !Array.isArray(value)) {
        const replacement = {};
        for (const k in value) {
          if (Object.hasOwnProperty.call(value, k)) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            replacement[k && k.charAt(0).toLowerCase() + k.substring(1)] = value[k];
          }
        }
        return replacement;
      }
      return value;
    });
  }
  get Context() {
    return this.context;
  }
  get Recognition() {
    return this.recognition;
  }
  set Recognition(value) {
    this.recognition = value.toLowerCase();
  }
}
exports.SpeechServiceConfig = SpeechServiceConfig;
class Context {
  constructor(os) {
    this.system = new System();
    this.os = os;
  }
}
exports.Context = Context;
class System {
  constructor() {
    // Note: below will be patched for official builds.
    const SPEECHSDK_CLIENTSDK_VERSION = "1.43.0";
    this.name = "SpeechSDK";
    this.version = SPEECHSDK_CLIENTSDK_VERSION;
    this.build = "JavaScript";
    this.lang = "JavaScript";
  }
}
exports.System = System;
class OS {
  constructor(platform, name, version) {
    this.platform = platform;
    this.name = name;
    this.version = version;
  }
}
exports.OS = OS;
class Device {
  constructor(manufacturer, model, version) {
    this.manufacturer = manufacturer;
    this.model = model;
    this.version = version;
  }
}
exports.Device = Device;
var connectivity;
(function (connectivity) {
  connectivity["Bluetooth"] = "Bluetooth";
  connectivity["Wired"] = "Wired";
  connectivity["WiFi"] = "WiFi";
  connectivity["Cellular"] = "Cellular";
  connectivity["InBuilt"] = "InBuilt";
  connectivity["Unknown"] = "Unknown";
})(connectivity = exports.connectivity || (exports.connectivity = {}));
var type;
(function (type) {
  type["Phone"] = "Phone";
  type["Speaker"] = "Speaker";
  type["Car"] = "Car";
  type["Headset"] = "Headset";
  type["Thermostat"] = "Thermostat";
  type["Microphones"] = "Microphones";
  type["Deskphone"] = "Deskphone";
  type["RemoteControl"] = "RemoteControl";
  type["Unknown"] = "Unknown";
  type["File"] = "File";
  type["Stream"] = "Stream";
})(type = exports.type || (exports.type = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceInterfaces.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceInterfaces.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceRecognizer.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechServiceRecognizer.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
// eslint-disable-next-line max-classes-per-file
class SpeechServiceRecognizer extends Exports_js_2.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, speechRecognizer);
    this.privSpeechRecognizer = speechRecognizer;
  }
  async processTypeSpecificMessages(connectionMessage) {
    let result;
    const resultProps = new Exports_js_1.PropertyCollection();
    let processed = false;
    switch (connectionMessage.path.toLowerCase()) {
      case "speech.hypothesis":
      case "speech.fragment":
        const hypothesis = Exports_js_2.SpeechHypothesis.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, hypothesis.asJson());
        result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, Exports_js_1.ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, hypothesis.Offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined,
        // Speaker Id
        undefined, hypothesis.asJson(), resultProps);
        this.privRequestSession.onHypothesis(hypothesis.Offset);
        const ev = new Exports_js_1.SpeechRecognitionEventArgs(result, hypothesis.Offset, this.privRequestSession.sessionId);
        if (!!this.privSpeechRecognizer.recognizing) {
          try {
            this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, ev);
            /* eslint-disable no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        processed = true;
        break;
      case "speech.phrase":
        const simple = Exports_js_2.SimpleSpeechPhrase.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
        resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, simple.asJson());
        const resultReason = Exports_js_2.EnumTranslation.implTranslateRecognitionResult(simple.RecognitionStatus, this.privExpectContentAssessmentResponse);
        this.privRequestSession.onPhraseRecognized(simple.Offset + simple.Duration);
        if (Exports_js_1.ResultReason.Canceled === resultReason) {
          const cancelReason = Exports_js_2.EnumTranslation.implTranslateCancelResult(simple.RecognitionStatus);
          const cancellationErrorCode = Exports_js_2.EnumTranslation.implTranslateCancelErrorCode(simple.RecognitionStatus);
          await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_2.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
        } else {
          // Like the native SDK's, don't event / return an EndOfDictation message.
          if (simple.RecognitionStatus === Exports_js_2.RecognitionStatus.EndOfDictation) {
            break;
          }
          if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.OutputFormatPropertyName) === Exports_js_1.OutputFormat[Exports_js_1.OutputFormat.Simple]) {
            result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, simple.DisplayText, simple.Duration, simple.Offset, simple.Language, simple.LanguageDetectionConfidence, undefined,
            // Speaker Id
            undefined, simple.asJson(), resultProps);
          } else {
            const detailed = Exports_js_2.DetailedSpeechPhrase.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset);
            resultProps.setProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult, detailed.asJson());
            result = new Exports_js_1.SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, detailed.RecognitionStatus === Exports_js_2.RecognitionStatus.Success ? detailed.NBest[0].Display : "", detailed.Duration, detailed.Offset, detailed.Language, detailed.LanguageDetectionConfidence, undefined,
            // Speaker Id
            undefined, detailed.asJson(), resultProps);
          }
          const event = new Exports_js_1.SpeechRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
          if (!!this.privSpeechRecognizer.recognized) {
            try {
              this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, event);
              /* eslint-disable no-empty */
            } catch (error) {
              // Not going to let errors in the event handler
              // trip things up.
            }
          }
          if (!!this.privSuccessCallback) {
            try {
              this.privSuccessCallback(result);
            } catch (e) {
              if (!!this.privErrorCallback) {
                this.privErrorCallback(e);
              }
            }
            // Only invoke the call back once.
            // and if it's successful don't invoke the
            // error after that.
            this.privSuccessCallback = undefined;
            this.privErrorCallback = undefined;
          }
        }
        processed = true;
        break;
      default:
        break;
    }
    return processed;
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    const properties = new Exports_js_1.PropertyCollection();
    properties.setProperty(Exports_js_2.CancellationErrorCodePropertyName, Exports_js_1.CancellationErrorCode[errorCode]);
    if (!!this.privSpeechRecognizer.canceled) {
      const cancelEvent = new Exports_js_1.SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
      try {
        this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, cancelEvent);
        /* eslint-disable no-empty */
      } catch {}
    }
    if (!!this.privSuccessCallback) {
      const result = new Exports_js_1.SpeechRecognitionResult(requestId, Exports_js_1.ResultReason.Canceled, undefined,
      // Text
      undefined,
      // Duration
      undefined,
      // Offset
      undefined,
      // Language
      undefined,
      // Language Detection Confidence
      undefined,
      // Speaker Id
      error, undefined,
      // Json
      properties);
      try {
        this.privSuccessCallback(result);
        this.privSuccessCallback = undefined;
        /* eslint-disable no-empty */
      } catch {}
    }
  }
}
exports.SpeechServiceRecognizer = SpeechServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechSynthesisAdapter.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechSynthesisAdapter.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisAdapter = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class SpeechSynthesisAdapter extends Exports_js_2.SynthesisAdapterBase {
  constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {
    super(authentication, connectionFactory, synthesizerConfig, audioDestination);
    this.privSpeechSynthesizer = speechSynthesizer;
    this.privSynthesizer = speechSynthesizer;
  }
  setSynthesisContextSynthesisSection() {
    this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
  }
  onSynthesisStarted(requestId) {
    const synthesisStartEventArgs = new Exports_js_1.SpeechSynthesisEventArgs(new Exports_js_1.SpeechSynthesisResult(requestId, Exports_js_1.ResultReason.SynthesizingAudioStarted));
    if (!!this.privSpeechSynthesizer.synthesisStarted) {
      this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);
    }
  }
  onSynthesizing(audio) {
    if (!!this.privSpeechSynthesizer.synthesizing) {
      try {
        const audioWithHeader = this.privSynthesisTurn.audioOutputFormat.addHeader(audio);
        const ev = new Exports_js_1.SpeechSynthesisEventArgs(new Exports_js_1.SpeechSynthesisResult(this.privSynthesisTurn.requestId, Exports_js_1.ResultReason.SynthesizingAudio, audioWithHeader));
        this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);
      } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
      }
    }
  }
  onSynthesisCancelled(result) {
    if (!!this.privSpeechSynthesizer.SynthesisCanceled) {
      const cancelEvent = new Exports_js_1.SpeechSynthesisEventArgs(result);
      try {
        this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);
        /* eslint-disable no-empty */
      } catch {}
    }
  }
  onSynthesisCompleted(result) {
    if (this.privSpeechSynthesizer.synthesisCompleted) {
      try {
        this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new Exports_js_1.SpeechSynthesisEventArgs(result));
      } catch (e) {
        // Not going to let errors in the event handler
        // trip things up.
      }
    }
  }
  onWordBoundary(wordBoundaryEventArgs) {
    if (!!this.privSpeechSynthesizer.wordBoundary) {
      try {
        this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);
      } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
      }
    }
  }
  onVisemeReceived(visemeEventArgs) {
    if (!!this.privSpeechSynthesizer.visemeReceived) {
      try {
        this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);
      } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
      }
    }
  }
  onBookmarkReached(bookmarkEventArgs) {
    if (!!this.privSpeechSynthesizer.bookmarkReached) {
      try {
        this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);
      } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
      }
    }
  }
}
exports.SpeechSynthesisAdapter = SpeechSynthesisAdapter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechSynthesisConnectionFactory.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechSynthesisConnectionFactory.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ./QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
class SpeechSynthesisConnectionFactory {
  constructor() {
    this.synthesisUri = "/cognitiveservices/websocket/v1";
  }
  create(config, authInfo, connectionId) {
    let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
    const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, undefined);
    const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
    const endpointId = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, undefined);
    const hostPrefix = endpointId === undefined ? "tts" : "voice";
    const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://" + region + "." + hostPrefix + ".speech" + hostSuffix);
    const queryParams = {};
    const headers = {};
    if (authInfo.token !== undefined && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    if (endpointId !== undefined && endpointId !== "") {
      if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.CustomVoiceDeploymentId) === -1) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomVoiceDeploymentId] = endpointId;
      }
    }
    if (config.avatarEnabled) {
      if (!endpoint || endpoint.search(QueryParameterNames_js_1.QueryParameterNames.EnableAvatar) === -1) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableAvatar] = "true";
      }
    }
    if (!endpoint) {
      endpoint = host + this.synthesisUri;
    }
    config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    return new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromParameters(config.parameters), enableCompression, connectionId);
  }
}
exports.SpeechSynthesisConnectionFactory = SpeechSynthesisConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisAdapterBase.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisAdapterBase.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisAdapterBase = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const SpeechConnectionMessage_Internal_js_1 = __webpack_require__(/*! ./SpeechConnectionMessage.Internal.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js");
class SynthesisAdapterBase {
  constructor(authentication, connectionFactory, synthesizerConfig, audioDestination) {
    this.speakOverride = undefined;
    this.receiveMessageOverride = undefined;
    this.connectImplOverride = undefined;
    this.configConnectionOverride = undefined;
    // A promise for a configured connection.
    // Do not consume directly, call fetchConnection instead.
    this.privConnectionConfigurationPromise = undefined;
    if (!authentication) {
      throw new Exports_js_1.ArgumentNullError("authentication");
    }
    if (!connectionFactory) {
      throw new Exports_js_1.ArgumentNullError("connectionFactory");
    }
    if (!synthesizerConfig) {
      throw new Exports_js_1.ArgumentNullError("synthesizerConfig");
    }
    this.privAuthentication = authentication;
    this.privConnectionFactory = connectionFactory;
    this.privSynthesizerConfig = synthesizerConfig;
    this.privIsDisposed = false;
    this.privSessionAudioDestination = audioDestination;
    this.privSynthesisTurn = new Exports_js_3.SynthesisTurn();
    this.privConnectionEvents = new Exports_js_1.EventSource();
    this.privServiceEvents = new Exports_js_1.EventSource();
    this.privSynthesisContext = new Exports_js_3.SynthesisContext();
    this.privAgentConfig = new Exports_js_3.AgentConfig();
    this.connectionEvents.attach(connectionEvent => {
      if (connectionEvent.name === "ConnectionClosedEvent") {
        const connectionClosedEvent = connectionEvent;
        if (connectionClosedEvent.statusCode !== 1000) {
          this.cancelSynthesisLocal(Exports_js_2.CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? Exports_js_2.CancellationErrorCode.BadRequestParameters : Exports_js_2.CancellationErrorCode.ConnectionFailure, `${connectionClosedEvent.reason} websocket error code: ${connectionClosedEvent.statusCode}`);
        }
      }
    });
  }
  get synthesisContext() {
    return this.privSynthesisContext;
  }
  get agentConfig() {
    return this.privAgentConfig;
  }
  get connectionEvents() {
    return this.privConnectionEvents;
  }
  get serviceEvents() {
    return this.privServiceEvents;
  }
  set activityTemplate(messagePayload) {
    this.privActivityTemplate = messagePayload;
  }
  get activityTemplate() {
    return this.privActivityTemplate;
  }
  set audioOutputFormat(format) {
    this.privAudioOutputFormat = format;
    this.privSynthesisTurn.audioOutputFormat = format;
    if (this.privSessionAudioDestination !== undefined) {
      this.privSessionAudioDestination.format = format;
    }
    if (this.synthesisContext !== undefined) {
      this.synthesisContext.audioOutputFormat = format;
    }
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  async dispose(reason) {
    this.privIsDisposed = true;
    if (this.privSessionAudioDestination !== undefined) {
      this.privSessionAudioDestination.close();
    }
    if (this.privConnectionConfigurationPromise !== undefined) {
      const connection = await this.privConnectionConfigurationPromise;
      await connection.dispose(reason);
    }
  }
  async connect() {
    await this.connectImpl();
  }
  async sendNetworkMessage(path, payload) {
    const type = typeof payload === "string" ? Exports_js_1.MessageType.Text : Exports_js_1.MessageType.Binary;
    const contentType = typeof payload === "string" ? "application/json" : "";
    const connection = await this.fetchConnection();
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));
  }
  async Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {
    let ssml;
    if (isSSML) {
      ssml = text;
    } else {
      ssml = this.privSynthesizer.buildSsml(text);
    }
    if (this.speakOverride !== undefined) {
      return this.speakOverride(ssml, requestId, successCallback, errorCallBack);
    }
    this.privSuccessCallback = successCallback;
    this.privErrorCallback = errorCallBack;
    this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);
    try {
      await this.connectImpl();
      const connection = await this.fetchConnection();
      await this.sendSynthesisContext(connection);
      await this.sendSsmlMessage(connection, ssml, requestId);
      this.onSynthesisStarted(requestId);
      void this.receiveMessage();
    } catch (e) {
      this.cancelSynthesisLocal(Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.ConnectionFailure, e);
      return Promise.reject(e);
    }
  }
  async stopSpeaking() {
    await this.connectImpl();
    const connection = await this.fetchConnection();
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
      action: "stop"
    })));
  }
  // Cancels synthesis.
  cancelSynthesis(requestId, _cancellationReason, errorCode, error) {
    const properties = new Exports_js_2.PropertyCollection();
    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
    const result = new Exports_js_2.SpeechSynthesisResult(requestId, Exports_js_2.ResultReason.Canceled, undefined, error, properties);
    this.onSynthesisCancelled(result);
    if (!!this.privSuccessCallback) {
      try {
        this.privSuccessCallback(result);
        /* eslint-disable no-empty */
      } catch {}
    }
  }
  // Cancels synthesis.
  cancelSynthesisLocal(cancellationReason, errorCode, error) {
    if (!!this.privSynthesisTurn.isSynthesizing) {
      this.privSynthesisTurn.onStopSynthesizing();
      this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  processTypeSpecificMessages(_connectionMessage) {
    return true;
  }
  async receiveMessage() {
    try {
      const connection = await this.fetchConnection();
      const message = await connection.read();
      if (this.receiveMessageOverride !== undefined) {
        return this.receiveMessageOverride();
      }
      if (this.privIsDisposed) {
        // We're done.
        return;
      }
      // indicates we are draining the queue and it came with no message;
      if (!message) {
        if (!this.privSynthesisTurn.isSynthesizing) {
          return;
        } else {
          return this.receiveMessage();
        }
      }
      const connectionMessage = SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage.fromConnectionMessage(message);
      if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {
        switch (connectionMessage.path.toLowerCase()) {
          case "turn.start":
            this.privSynthesisTurn.onServiceTurnStartResponse(connectionMessage.textBody);
            break;
          case "response":
            this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);
            break;
          case "audio":
            if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {
              this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);
              this.onSynthesizing(connectionMessage.binaryBody);
              if (this.privSessionAudioDestination !== undefined) {
                this.privSessionAudioDestination.write(connectionMessage.binaryBody);
              }
            }
            break;
          case "audio.metadata":
            const metadataList = Exports_js_3.SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;
            for (const metadata of metadataList) {
              switch (metadata.Type) {
                case Exports_js_3.MetadataType.WordBoundary:
                case Exports_js_3.MetadataType.SentenceBoundary:
                  this.privSynthesisTurn.onTextBoundaryEvent(metadata);
                  const wordBoundaryEventArgs = new Exports_js_2.SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.Duration, metadata.Data.text.Text, metadata.Data.text.Length, metadata.Type === Exports_js_3.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, metadata.Data.text.BoundaryType);
                  this.onWordBoundary(wordBoundaryEventArgs);
                  break;
                case Exports_js_3.MetadataType.Bookmark:
                  const bookmarkEventArgs = new Exports_js_2.SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);
                  this.onBookmarkReached(bookmarkEventArgs);
                  break;
                case Exports_js_3.MetadataType.Viseme:
                  this.privSynthesisTurn.onVisemeMetadataReceived(metadata);
                  if (metadata.Data.IsLastAnimation) {
                    const visemeEventArgs = new Exports_js_2.SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                    this.onVisemeReceived(visemeEventArgs);
                  }
                  break;
                case Exports_js_3.MetadataType.AvatarSignal:
                  this.onAvatarEvent(metadata);
                  break;
                case Exports_js_3.MetadataType.SessionEnd:
                  this.privSynthesisTurn.onSessionEnd(metadata);
                  break;
              }
            }
            break;
          case "turn.end":
            this.privSynthesisTurn.onServiceTurnEndResponse();
            let result;
            try {
              result = await this.privSynthesisTurn.constructSynthesisResult();
              if (!!this.privSuccessCallback) {
                this.privSuccessCallback(result);
              }
            } catch (error) {
              if (!!this.privErrorCallback) {
                this.privErrorCallback(error);
              }
            }
            this.onSynthesisCompleted(result);
            break;
          default:
            if (!this.processTypeSpecificMessages(connectionMessage)) {
              // here are some messages that the derived class has not processed, dispatch them to connect class
              if (!!this.privServiceEvents) {
                this.serviceEvents.onEvent(new Exports_js_1.ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));
              }
            }
        }
      }
      return this.receiveMessage();
    } catch (e) {
      // TODO: What goes here?
    }
  }
  sendSynthesisContext(connection) {
    this.setSynthesisContextSynthesisSection();
    const synthesisContextJson = this.synthesisContext.toJSON();
    if (synthesisContextJson) {
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", synthesisContextJson));
    }
    return;
  }
  setSpeechConfigSynthesisSection() {
    return;
  }
  connectImpl(isUnAuthorized = false) {
    if (this.privConnectionPromise != null) {
      return this.privConnectionPromise.then(connection => {
        if (connection.state() === Exports_js_1.ConnectionState.Disconnected) {
          this.privConnectionId = null;
          this.privConnectionPromise = null;
          return this.connectImpl();
        }
        return this.privConnectionPromise;
      }, () => {
        this.privConnectionId = null;
        this.privConnectionPromise = null;
        return this.connectImpl();
      });
    }
    this.privAuthFetchEventId = Exports_js_1.createNoDashGuid();
    this.privConnectionId = Exports_js_1.createNoDashGuid();
    this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
    const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
    this.privConnectionPromise = authPromise.then(async result => {
      this.privSynthesisTurn.onAuthCompleted(false);
      const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);
      // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,
      // it'll stop sending events.
      connection.events.attach(event => {
        this.connectionEvents.onEvent(event);
      });
      const response = await connection.open();
      if (response.statusCode === 200) {
        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);
        return Promise.resolve(connection);
      } else if (response.statusCode === 403 && !isUnAuthorized) {
        return this.connectImpl(true);
      } else {
        this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);
        return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url)} Reason: ${response.reason}`);
      }
    }, error => {
      this.privSynthesisTurn.onAuthCompleted(true);
      throw new Error(error);
    });
    // Attach an empty handler to allow the promise to run in the background while
    // other startup events happen. It'll eventually be awaited on.
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    this.privConnectionPromise.catch(() => {});
    return this.privConnectionPromise;
  }
  sendSpeechServiceConfig(connection, SpeechServiceConfigJson) {
    if (SpeechServiceConfigJson) {
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", SpeechServiceConfigJson));
    }
  }
  sendSsmlMessage(connection, ssml, requestId) {
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, "ssml", requestId, "application/ssml+xml", ssml));
  }
  async fetchConnection() {
    if (this.privConnectionConfigurationPromise !== undefined) {
      return this.privConnectionConfigurationPromise.then(connection => {
        if (connection.state() === Exports_js_1.ConnectionState.Disconnected) {
          this.privConnectionId = null;
          this.privConnectionConfigurationPromise = undefined;
          return this.fetchConnection();
        }
        return this.privConnectionConfigurationPromise;
      }, () => {
        this.privConnectionId = null;
        this.privConnectionConfigurationPromise = undefined;
        return this.fetchConnection();
      });
    }
    this.privConnectionConfigurationPromise = this.configureConnection();
    return await this.privConnectionConfigurationPromise;
  }
  // Takes an established websocket connection to the endpoint and sends speech configuration information.
  async configureConnection() {
    const connection = await this.connectImpl();
    if (this.configConnectionOverride !== undefined) {
      return this.configConnectionOverride(connection);
    }
    this.setSpeechConfigSynthesisSection();
    await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());
    return connection;
  }
  onAvatarEvent(_metadata) {
    return;
  }
  onSynthesisStarted(_requestId) {
    return;
  }
  onSynthesizing(_audio) {
    return;
  }
  onSynthesisCancelled(_result) {
    return;
  }
  onSynthesisCompleted(_result) {
    return;
  }
  onWordBoundary(_wordBoundaryEventArgs) {
    return;
  }
  onVisemeReceived(_visemeEventArgs) {
    return;
  }
  onBookmarkReached(_bookmarkEventArgs) {
    return;
  }
}
exports.SynthesisAdapterBase = SynthesisAdapterBase;
SynthesisAdapterBase.telemetryDataEnabled = true;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisContext.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisContext.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisContext = void 0;
const Exports_js_1 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Represents the JSON used in the synthesis.context message sent to the speech service.
 * The dynamic grammar is always refreshed from the encapsulated dynamic grammar object.
 */
class SynthesisContext {
  constructor() {
    this.privContext = {};
  }
  /**
   * Adds a section to the synthesis.context object.
   * @param sectionName Name of the section to add.
   * @param value JSON serializable object that represents the value.
   */
  setSection(sectionName, value) {
    this.privContext[sectionName] = value;
  }
  /**
   * Sets the audio output format for synthesis context generation.
   * @param format {AudioOutputFormatImpl} the output format
   */
  set audioOutputFormat(format) {
    this.privAudioOutputFormat = format;
  }
  toJSON() {
    return JSON.stringify(this.privContext);
  }
  setSynthesisSection(speechSynthesizer) {
    const synthesisSection = this.buildSynthesisContext(speechSynthesizer);
    this.setSection("synthesis", synthesisSection);
  }
  buildSynthesisContext(speechSynthesizer) {
    return {
      audio: {
        metadataOptions: {
          bookmarkEnabled: !!speechSynthesizer?.bookmarkReached,
          punctuationBoundaryEnabled: speechSynthesizer?.properties.getProperty(Exports_js_1.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!speechSynthesizer?.wordBoundary),
          sentenceBoundaryEnabled: speechSynthesizer?.properties.getProperty(Exports_js_1.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, false),
          sessionEndEnabled: true,
          visemeEnabled: !!speechSynthesizer?.visemeReceived,
          wordBoundaryEnabled: speechSynthesizer?.properties.getProperty(Exports_js_1.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!speechSynthesizer?.wordBoundary)
        },
        outputFormat: this.privAudioOutputFormat.requestAudioFormatString
      },
      language: {
        autoDetection: speechSynthesizer?.autoDetectSourceLanguage
      }
    };
  }
}
exports.SynthesisContext = SynthesisContext;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisEvents.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisEvents.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisStartedEvent = exports.ConnectingToSynthesisServiceEvent = exports.SynthesisTriggeredEvent = exports.SpeechSynthesisEvent = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
class SpeechSynthesisEvent extends Exports_js_1.PlatformEvent {
  constructor(eventName, requestId, eventType = Exports_js_1.EventType.Info) {
    super(eventName, eventType);
    this.privRequestId = requestId;
  }
  get requestId() {
    return this.privRequestId;
  }
}
exports.SpeechSynthesisEvent = SpeechSynthesisEvent;
class SynthesisTriggeredEvent extends SpeechSynthesisEvent {
  constructor(requestId, sessionAudioDestinationId, turnAudioDestinationId) {
    super("SynthesisTriggeredEvent", requestId);
    this.privSessionAudioDestinationId = sessionAudioDestinationId;
    this.privTurnAudioDestinationId = turnAudioDestinationId;
  }
  get audioSessionDestinationId() {
    return this.privSessionAudioDestinationId;
  }
  get audioTurnDestinationId() {
    return this.privTurnAudioDestinationId;
  }
}
exports.SynthesisTriggeredEvent = SynthesisTriggeredEvent;
class ConnectingToSynthesisServiceEvent extends SpeechSynthesisEvent {
  constructor(requestId, authFetchEventId) {
    super("ConnectingToSynthesisServiceEvent", requestId);
    this.privAuthFetchEventId = authFetchEventId;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
exports.ConnectingToSynthesisServiceEvent = ConnectingToSynthesisServiceEvent;
class SynthesisStartedEvent extends SpeechSynthesisEvent {
  constructor(requestId, authFetchEventId) {
    super("SynthesisStartedEvent", requestId);
    this.privAuthFetchEventId = authFetchEventId;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
exports.SynthesisStartedEvent = SynthesisStartedEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisRestAdapter.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisRestAdapter.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisRestAdapter = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
/**
 * Implements methods for speaker recognition classes, sending requests to endpoint
 * and parsing response into expected format
 * @class SynthesisRestAdapter
 */
class SynthesisRestAdapter {
  constructor(config, authentication) {
    let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
    if (!endpoint) {
      const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, "westus");
      const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
      endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, `https://${region}.tts.speech${hostSuffix}`);
    }
    this.privUri = `${endpoint}/cognitiveservices/voices/list`;
    const options = Exports_js_1.RestConfigBase.requestOptions;
    this.privRestAdapter = new Exports_js_1.RestMessageAdapter(options);
    this.privAuthentication = authentication;
  }
  /**
   * Sends list voices request to endpoint.
   * @function
   * @public
   * @param connectionId - guid for connectionId
   * @returns {Promise<IRestResponse>} rest response to status request
   */
  getVoicesList(connectionId) {
    this.privRestAdapter.setHeaders(HeaderNames_js_1.HeaderNames.ConnectionId, connectionId);
    return this.privAuthentication.fetch(connectionId).then(authInfo => {
      this.privRestAdapter.setHeaders(authInfo.headerName, authInfo.token);
      return this.privRestAdapter.request(Exports_js_1.RestRequestType.Get, this.privUri);
    });
  }
}
exports.SynthesisRestAdapter = SynthesisRestAdapter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisTurn.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisTurn = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const AudioOutputStream_js_1 = __webpack_require__(/*! ../sdk/Audio/AudioOutputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const SynthesisAudioMetadata_js_1 = __webpack_require__(/*! ./ServiceMessages/SynthesisAudioMetadata.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/SynthesisAudioMetadata.js");
const SynthesisEvents_js_1 = __webpack_require__(/*! ./SynthesisEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesisEvents.js");
class SynthesisTurn {
  constructor() {
    this.privIsDisposed = false;
    this.privIsSynthesizing = false;
    this.privIsSynthesisEnded = false;
    this.privBytesReceived = 0;
    this.privInTurn = false;
    this.privTextOffset = 0;
    this.privNextSearchTextIndex = 0;
    this.privSentenceOffset = 0;
    this.privNextSearchSentenceIndex = 0;
    this.privRequestId = Exports_js_1.createNoDashGuid();
    this.privTurnDeferral = new Exports_js_1.Deferred();
    // We're not in a turn, so resolve.
    this.privTurnDeferral.resolve();
  }
  get requestId() {
    return this.privRequestId;
  }
  get streamId() {
    return this.privStreamId;
  }
  set streamId(value) {
    this.privStreamId = value;
  }
  get audioOutputFormat() {
    return this.privAudioOutputFormat;
  }
  set audioOutputFormat(format) {
    this.privAudioOutputFormat = format;
  }
  get turnCompletionPromise() {
    return this.privTurnDeferral.promise;
  }
  get isSynthesisEnded() {
    return this.privIsSynthesisEnded;
  }
  get isSynthesizing() {
    return this.privIsSynthesizing;
  }
  get currentTextOffset() {
    return this.privTextOffset;
  }
  get currentSentenceOffset() {
    return this.privSentenceOffset;
  }
  // The number of bytes received for current turn
  get bytesReceived() {
    return this.privBytesReceived;
  }
  get audioDuration() {
    return this.privAudioDuration;
  }
  get extraProperties() {
    if (!!this.privWebRTCSDP) {
      const properties = new Exports_js_2.PropertyCollection();
      properties.setProperty(Exports_js_2.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP);
      return properties;
    }
    return undefined;
  }
  async getAllReceivedAudio() {
    if (!!this.privReceivedAudio) {
      return Promise.resolve(this.privReceivedAudio);
    }
    if (!this.privIsSynthesisEnded) {
      return null;
    }
    await this.readAllAudioFromStream();
    return Promise.resolve(this.privReceivedAudio);
  }
  async getAllReceivedAudioWithHeader() {
    if (!!this.privReceivedAudioWithHeader) {
      return this.privReceivedAudioWithHeader;
    }
    if (!this.privIsSynthesisEnded) {
      return null;
    }
    if (this.audioOutputFormat.hasHeader) {
      const audio = await this.getAllReceivedAudio();
      this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(audio);
      return this.privReceivedAudioWithHeader;
    } else {
      return this.getAllReceivedAudio();
    }
  }
  startNewSynthesis(requestId, rawText, isSSML, audioDestination) {
    this.privIsSynthesisEnded = false;
    this.privIsSynthesizing = true;
    this.privRequestId = requestId;
    this.privRawText = rawText;
    this.privIsSSML = isSSML;
    this.privAudioOutputStream = new AudioOutputStream_js_1.PullAudioOutputStreamImpl();
    this.privAudioOutputStream.format = this.privAudioOutputFormat;
    this.privReceivedAudio = null;
    this.privReceivedAudioWithHeader = null;
    this.privBytesReceived = 0;
    this.privTextOffset = 0;
    this.privNextSearchTextIndex = 0;
    this.privSentenceOffset = 0;
    this.privNextSearchSentenceIndex = 0;
    this.privPartialVisemeAnimation = "";
    this.privWebRTCSDP = "";
    if (audioDestination !== undefined) {
      this.privTurnAudioDestination = audioDestination;
      this.privTurnAudioDestination.format = this.privAudioOutputFormat;
    }
    this.onEvent(new SynthesisEvents_js_1.SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));
  }
  onPreConnectionStart(authFetchEventId) {
    this.privAuthFetchEventId = authFetchEventId;
    this.onEvent(new SynthesisEvents_js_1.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
  }
  onAuthCompleted(isError) {
    if (isError) {
      this.onComplete();
    }
  }
  onConnectionEstablishCompleted(statusCode) {
    if (statusCode === 200) {
      this.onEvent(new SynthesisEvents_js_1.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));
      this.privBytesReceived = 0;
      return;
    } else if (statusCode === 403) {
      this.onComplete();
    }
  }
  onServiceResponseMessage(responseJson) {
    const response = JSON.parse(responseJson);
    this.streamId = response.audio.streamId;
  }
  onServiceTurnEndResponse() {
    this.privInTurn = false;
    this.privTurnDeferral.resolve();
    this.onComplete();
  }
  onServiceTurnStartResponse(responseJson) {
    if (!!this.privTurnDeferral && !!this.privInTurn) {
      // What? How are we starting a turn with another not done?
      this.privTurnDeferral.reject("Another turn started before current completed.");
      // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      this.privTurnDeferral.promise.then().catch(() => {});
    }
    this.privInTurn = true;
    this.privTurnDeferral = new Exports_js_1.Deferred();
    const response = JSON.parse(responseJson);
    if (!!response.webrtc) {
      this.privWebRTCSDP = response.webrtc.connectionString;
    }
  }
  onAudioChunkReceived(data) {
    if (this.isSynthesizing) {
      this.privAudioOutputStream.write(data);
      this.privBytesReceived += data.byteLength;
      if (this.privTurnAudioDestination !== undefined) {
        this.privTurnAudioDestination.write(data);
      }
    }
  }
  onTextBoundaryEvent(metadata) {
    this.updateTextOffset(metadata.Data.text.Text, metadata.Type);
  }
  onVisemeMetadataReceived(metadata) {
    if (metadata.Data.AnimationChunk !== undefined) {
      this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;
    }
  }
  onSessionEnd(metadata) {
    this.privAudioDuration = metadata.Data.Offset;
  }
  async constructSynthesisResult() {
    const audioBuffer = await this.getAllReceivedAudioWithHeader();
    return new Exports_js_2.SpeechSynthesisResult(this.requestId, Exports_js_2.ResultReason.SynthesizingAudioCompleted, audioBuffer, undefined, this.extraProperties, this.audioDuration);
  }
  dispose() {
    if (!this.privIsDisposed) {
      // we should have completed by now. If we did not its an unknown error.
      this.privIsDisposed = true;
    }
  }
  onStopSynthesizing() {
    this.onComplete();
  }
  /**
   * Gets the viseme animation string (merged from animation chunk), and clears the internal
   * partial animation.
   */
  getAndClearVisemeAnimation() {
    const animation = this.privPartialVisemeAnimation;
    this.privPartialVisemeAnimation = "";
    return animation;
  }
  onEvent(event) {
    Exports_js_1.Events.instance.onEvent(event);
  }
  /**
   * Check if the text is an XML(SSML) tag
   * @param text
   * @private
   */
  static isXmlTag(text) {
    return text.length >= 2 && text[0] === "<" && text[text.length - 1] === ">";
  }
  updateTextOffset(text, type) {
    if (type === SynthesisAudioMetadata_js_1.MetadataType.WordBoundary) {
      this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);
      if (this.privTextOffset >= 0) {
        this.privNextSearchTextIndex = this.privTextOffset + text.length;
        if (this.privIsSSML) {
          if (this.withinXmlTag(this.privTextOffset) && !SynthesisTurn.isXmlTag(text)) {
            this.updateTextOffset(text, type);
          }
        }
      }
    } else {
      this.privSentenceOffset = this.privRawText.indexOf(text, this.privNextSearchSentenceIndex);
      if (this.privSentenceOffset >= 0) {
        this.privNextSearchSentenceIndex = this.privSentenceOffset + text.length;
        if (this.privIsSSML) {
          if (this.withinXmlTag(this.privSentenceOffset) && !SynthesisTurn.isXmlTag(text)) {
            this.updateTextOffset(text, type);
          }
        }
      }
    }
  }
  onComplete() {
    if (this.privIsSynthesizing) {
      this.privIsSynthesizing = false;
      this.privIsSynthesisEnded = true;
      this.privAudioOutputStream.close();
      this.privInTurn = false;
      if (this.privTurnAudioDestination !== undefined) {
        this.privTurnAudioDestination.close();
        this.privTurnAudioDestination = undefined;
      }
    }
  }
  async readAllAudioFromStream() {
    if (this.privIsSynthesisEnded) {
      this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
      try {
        await this.privAudioOutputStream.read(this.privReceivedAudio);
      } catch (e) {
        this.privReceivedAudio = new ArrayBuffer(0);
      }
    }
  }
  /**
   * Check if current idx is in XML(SSML) tag
   * @param idx
   * @private
   */
  withinXmlTag(idx) {
    return this.privRawText.indexOf("<", idx + 1) > this.privRawText.indexOf(">", idx + 1);
  }
}
exports.SynthesisTurn = SynthesisTurn;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesizerConfig.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SynthesizerConfig.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesizerConfig = exports.SynthesisServiceType = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
var SynthesisServiceType;
(function (SynthesisServiceType) {
  SynthesisServiceType[SynthesisServiceType["Standard"] = 0] = "Standard";
  SynthesisServiceType[SynthesisServiceType["Custom"] = 1] = "Custom";
})(SynthesisServiceType = exports.SynthesisServiceType || (exports.SynthesisServiceType = {}));
class SynthesizerConfig {
  constructor(speechServiceConfig, parameters) {
    this.privSynthesisServiceType = SynthesisServiceType.Standard;
    this.avatarEnabled = false;
    this.privSpeechServiceConfig = speechServiceConfig ? speechServiceConfig : new Exports_js_1.SpeechServiceConfig(new Exports_js_1.Context(null));
    this.privParameters = parameters;
  }
  get parameters() {
    return this.privParameters;
  }
  get synthesisServiceType() {
    return this.privSynthesisServiceType;
  }
  set synthesisServiceType(value) {
    this.privSynthesisServiceType = value;
  }
  set synthesisVideoSection(value) {
    this.privSpeechServiceConfig.Context.synthesis = {
      video: value
    };
  }
  get SpeechServiceConfig() {
    return this.privSpeechServiceConfig;
  }
}
exports.SynthesizerConfig = SynthesizerConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranscriberConnectionFactory.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranscriberConnectionFactory.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranscriberConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ./QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
class TranscriberConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  constructor() {
    super(...arguments);
    this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
  }
  create(config, authInfo, connectionId) {
    let endpoint = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
    const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, "centralus");
    const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
    const hostDefault = "wss://transcribe." + region + ".cts.speech" + hostSuffix + this.multiaudioRelativeUri;
    const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, hostDefault);
    const queryParams = {};
    this.setQueryParams(queryParams, config, endpoint);
    if (!endpoint) {
      endpoint = host;
    }
    const headers = {};
    if (authInfo.token !== undefined && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    return new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
  }
  setQueryParams(queryParams, config, endpointUrl) {
    const endpointId = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, undefined);
    const language = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, undefined);
    if (endpointId && !(QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId in queryParams)) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.CustomSpeechDeploymentId] = endpointId;
    }
    if (language && !(QueryParameterNames_js_1.QueryParameterNames.Language in queryParams)) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.Language] = language;
    }
    const wordLevelTimings = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true";
    const detailed = config.parameters.getProperty(Exports_js_3.OutputFormatPropertyName, Exports_js_2.OutputFormat[Exports_js_2.OutputFormat.Simple]) !== Exports_js_2.OutputFormat[Exports_js_2.OutputFormat.Simple];
    if (wordLevelTimings || detailed) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = Exports_js_2.OutputFormat[Exports_js_2.OutputFormat.Detailed].toLowerCase();
    }
    this.setCommonUrlParams(config, queryParams, endpointUrl);
  }
}
exports.TranscriberConnectionFactory = TranscriberConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionConfig.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionConfig.js ***!
  \*****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationConnectionConfig = void 0;
const RestConfigBase_js_1 = __webpack_require__(/*! ../../common.browser/RestConfigBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/RestConfigBase.js");
class ConversationConnectionConfig extends RestConfigBase_js_1.RestConfigBase {
  static get host() {
    return ConversationConnectionConfig.privHost;
  }
  static get apiVersion() {
    return ConversationConnectionConfig.privApiVersion;
  }
  static get clientAppId() {
    return ConversationConnectionConfig.privClientAppId;
  }
  static get defaultLanguageCode() {
    return ConversationConnectionConfig.privDefaultLanguageCode;
  }
  static get restPath() {
    return ConversationConnectionConfig.privRestPath;
  }
  static get webSocketPath() {
    return ConversationConnectionConfig.privWebSocketPath;
  }
  static get transcriptionEventKeys() {
    return ConversationConnectionConfig.privTranscriptionEventKeys;
  }
}
exports.ConversationConnectionConfig = ConversationConnectionConfig;
ConversationConnectionConfig.privHost = "dev.microsofttranslator.com";
ConversationConnectionConfig.privRestPath = "/capito/room";
ConversationConnectionConfig.privApiVersion = "2.0";
ConversationConnectionConfig.privDefaultLanguageCode = "en-US";
ConversationConnectionConfig.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15";
ConversationConnectionConfig.privWebSocketPath = "/capito/translate";
ConversationConnectionConfig.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"];

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionFactory.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionFactory.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ../../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ../ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const ConversationConnectionConfig_js_1 = __webpack_require__(/*! ./ConversationConnectionConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionConfig.js");
const ConversationWebsocketMessageFormatter_js_1 = __webpack_require__(/*! ./ConversationWebsocketMessageFormatter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationWebsocketMessageFormatter.js");
/**
 * Create a connection to the Conversation Translator websocket for sending instant messages and commands, and for receiving translated messages.
 * The conversation must already have been started or joined.
 */
class ConversationConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  create(config, authInfo, connectionId) {
    const endpointHost = config.parameters.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Host, ConversationConnectionConfig_js_1.ConversationConnectionConfig.host);
    const correlationId = config.parameters.getProperty(Exports_js_3.PropertyId.ConversationTranslator_CorrelationId, Exports_js_2.createGuid());
    const endpoint = `wss://${endpointHost}${ConversationConnectionConfig_js_1.ConversationConnectionConfig.webSocketPath}`;
    const token = config.parameters.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Token, undefined);
    Contracts_js_1.Contracts.throwIfNullOrUndefined(token, "token");
    const queryParams = {};
    queryParams[ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams.apiVersion] = ConversationConnectionConfig_js_1.ConversationConnectionConfig.apiVersion;
    queryParams[ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams.token] = token;
    queryParams[ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams.correlationId] = correlationId;
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    return new Exports_js_1.WebsocketConnection(endpoint, queryParams, {}, new ConversationWebsocketMessageFormatter_js_1.ConversationWebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
  }
}
exports.ConversationConnectionFactory = ConversationConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionMessage.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionMessage.js ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationConnectionMessage = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
class ConversationConnectionMessage extends Exports_js_1.ConnectionMessage {
  constructor(messageType, body, headers, id) {
    super(messageType, body, headers, id);
    const json = JSON.parse(this.textBody);
    if (json.type !== undefined) {
      this.privConversationMessageType = json.type;
    }
  }
  get conversationMessageType() {
    return this.privConversationMessageType;
  }
}
exports.ConversationConnectionMessage = ConversationConnectionMessage;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationManager.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationManager.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationManager = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ../../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConversationConnectionConfig_js_1 = __webpack_require__(/*! ./ConversationConnectionConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionConfig.js");
class ConversationManager {
  constructor() {
    //
    this.privRequestParams = ConversationConnectionConfig_js_1.ConversationConnectionConfig.configParams;
    this.privErrors = ConversationConnectionConfig_js_1.ConversationConnectionConfig.restErrors;
    this.privHost = ConversationConnectionConfig_js_1.ConversationConnectionConfig.host;
    this.privApiVersion = ConversationConnectionConfig_js_1.ConversationConnectionConfig.apiVersion;
    this.privRestPath = ConversationConnectionConfig_js_1.ConversationConnectionConfig.restPath;
    this.privRestAdapter = new Exports_js_1.RestMessageAdapter({});
  }
  /**
   * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
   * @param args
   * @param conversationCode
   * @param callback
   * @param errorCallback
   */
  createOrJoin(args, conversationCode, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfNullOrUndefined(args, "args");
      const languageCode = args.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, ConversationConnectionConfig_js_1.ConversationConnectionConfig.defaultLanguageCode);
      const nickname = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_Name, "conversation_host");
      const endpointHost = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_Host, this.privHost);
      const correlationId = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_CorrelationId);
      const subscriptionKey = args.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key);
      const subscriptionRegion = args.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
      const authToken = args.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(languageCode, "languageCode");
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(endpointHost, "endpointHost");
      const queryParams = {};
      queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;
      queryParams[this.privRequestParams.languageCode] = languageCode;
      queryParams[this.privRequestParams.nickname] = nickname;
      const headers = {};
      if (correlationId) {
        headers[this.privRequestParams.correlationId] = correlationId;
      }
      headers[this.privRequestParams.clientAppId] = ConversationConnectionConfig_js_1.ConversationConnectionConfig.clientAppId;
      if (conversationCode !== undefined) {
        queryParams[this.privRequestParams.roomId] = conversationCode;
      } else {
        Contracts_js_1.Contracts.throwIfNullOrUndefined(subscriptionRegion, this.privErrors.authInvalidSubscriptionRegion);
        headers[this.privRequestParams.subscriptionRegion] = subscriptionRegion;
        if (subscriptionKey) {
          headers[this.privRequestParams.subscriptionKey] = subscriptionKey;
        } else if (authToken) {
          headers[this.privRequestParams.authorization] = `Bearer ${authToken}`;
        } else {
          Contracts_js_1.Contracts.throwIfNullOrUndefined(subscriptionKey, this.privErrors.authInvalidSubscriptionKey);
        }
      }
      const config = {};
      config.headers = headers;
      this.privRestAdapter.options = config;
      const endpoint = `https://${endpointHost}${this.privRestPath}`;
      // TODO: support a proxy and certificate validation
      this.privRestAdapter.request(Exports_js_1.RestRequestType.Post, endpoint, queryParams, null).then(response => {
        const requestId = Exports_js_1.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, response.headers);
        if (!response.ok) {
          if (!!err) {
            // get the error
            let errorMessage = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", response.status.toString());
            let errMessageRaw;
            try {
              errMessageRaw = JSON.parse(response.data);
              errorMessage += ` [${errMessageRaw.error.code}: ${errMessageRaw.error.message}]`;
            } catch (e) {
              errorMessage += ` [${response.data}]`;
            }
            if (requestId) {
              errorMessage += ` ${requestId}`;
            }
            err(errorMessage);
          }
          return;
        }
        const conversation = JSON.parse(response.data);
        if (conversation) {
          conversation.requestId = requestId;
        }
        if (!!cb) {
          try {
            cb(conversation);
          } catch (e) {
            if (!!err) {
              err(e);
            }
          }
          cb = undefined;
        }
        // eslint-disable-next-line @typescript-eslint/no-empty-function
      }).catch(() => {});
    } catch (error) {
      if (!!err) {
        if (error instanceof Error) {
          const typedError = error;
          err(typedError.name + ": " + typedError.message);
        } else {
          err(error);
        }
      }
    }
  }
  /**
   * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
   * @param args
   * @param sessionToken
   * @param callback
   */
  leave(args, sessionToken) {
    return new Promise((resolve, reject) => {
      try {
        Contracts_js_1.Contracts.throwIfNullOrUndefined(args, this.privErrors.invalidArgs.replace("{arg}", "config"));
        Contracts_js_1.Contracts.throwIfNullOrWhitespace(sessionToken, this.privErrors.invalidArgs.replace("{arg}", "token"));
        const endpointHost = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_Host, this.privHost);
        const correlationId = args.getProperty(Exports_js_2.PropertyId.ConversationTranslator_CorrelationId);
        const queryParams = {};
        queryParams[this.privRequestParams.apiVersion] = this.privApiVersion;
        queryParams[this.privRequestParams.sessionToken] = sessionToken;
        const headers = {};
        if (correlationId) {
          headers[this.privRequestParams.correlationId] = correlationId;
        }
        const config = {};
        config.headers = headers;
        this.privRestAdapter.options = config;
        const endpoint = `https://${endpointHost}${this.privRestPath}`;
        // TODO: support a proxy and certificate validation
        this.privRestAdapter.request(Exports_js_1.RestRequestType.Delete, endpoint, queryParams, null).then(response => {
          if (!response.ok) {
            // ignore errors on delete
          }
          resolve();
          // eslint-disable-next-line @typescript-eslint/no-empty-function
        }).catch(() => {});
      } catch (error) {
        if (error instanceof Error) {
          const typedError = error;
          reject(typedError.name + ": " + typedError.message);
        } else {
          reject(error);
        }
      }
    });
  }
}
exports.ConversationManager = ConversationManager;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationRequestSession.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationRequestSession.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationRequestSession = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
/**
 * Placeholder class for the Conversation Request Session. Based off RequestSession.
 * TODO: define what telemetry is required.
 */
class ConversationRequestSession {
  constructor(sessionId) {
    this.privIsDisposed = false;
    this.privDetachables = new Array();
    this.privSessionId = sessionId;
    this.privRequestId = Exports_js_1.createNoDashGuid();
    this.privRequestCompletionDeferral = new Exports_js_1.Deferred();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get completionPromise() {
    return this.privRequestCompletionDeferral.promise;
  }
  onPreConnectionStart(authFetchEventId, connectionId) {
    this.privSessionId = connectionId;
  }
  onAuthCompleted(isError) {
    if (isError) {
      this.onComplete();
    }
  }
  onConnectionEstablishCompleted(statusCode) {
    if (statusCode === 200) {
      return;
    } else if (statusCode === 403) {
      this.onComplete();
    }
  }
  onServiceTurnEndResponse(continuousRecognition) {
    if (!continuousRecognition) {
      this.onComplete();
    } else {
      this.privRequestId = Exports_js_1.createNoDashGuid();
    }
  }
  async dispose() {
    if (!this.privIsDisposed) {
      // we should have completed by now. If we did not its an unknown error.
      this.privIsDisposed = true;
      for (const detachable of this.privDetachables) {
        await detachable.detach();
      }
    }
  }
  onComplete() {
    //
  }
}
exports.ConversationRequestSession = ConversationRequestSession;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationServiceAdapter.js":
/*!***************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationServiceAdapter.js ***!
  \***************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationServiceAdapter = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const ConversationConnectionMessage_js_1 = __webpack_require__(/*! ./ConversationConnectionMessage.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionMessage.js");
const ConversationRequestSession_js_1 = __webpack_require__(/*! ./ConversationRequestSession.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationRequestSession.js");
const ConversationTranslatorEventArgs_js_1 = __webpack_require__(/*! ./ConversationTranslatorEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorEventArgs.js");
const ConversationTranslatorInterfaces_js_1 = __webpack_require__(/*! ./ConversationTranslatorInterfaces.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorInterfaces.js");
const Exports_js_4 = __webpack_require__(/*! ./ServiceMessages/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/Exports.js");
/**
 * The service adapter handles sending and receiving messages to the Conversation Translator websocket.
 */
class ConversationServiceAdapter extends Exports_js_3.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);
    this.privConnectionConfigPromise = undefined;
    this.privLastPartialUtteranceId = "";
    this.privConversationServiceConnector = conversationServiceConnector;
    this.privConversationAuthentication = authentication;
    this.receiveMessageOverride = () => this.receiveConversationMessageOverride();
    this.recognizeOverride = () => this.noOp();
    this.postConnectImplOverride = connection => this.conversationConnectImpl(connection);
    this.configConnectionOverride = () => this.configConnection();
    this.disconnectOverride = () => this.privDisconnect();
    this.privConversationRequestSession = new ConversationRequestSession_js_1.ConversationRequestSession(Exports_js_1.createNoDashGuid());
    this.privConversationConnectionFactory = connectionFactory;
    this.privConversationIsDisposed = false;
  }
  isDisposed() {
    return super.isDisposed() || this.privConversationIsDisposed;
  }
  async dispose(reason) {
    this.privConversationIsDisposed = true;
    if (this.privConnectionConfigPromise !== undefined) {
      const connection = await this.privConnectionConfigPromise;
      await connection.dispose(reason);
    }
    await super.dispose(reason);
  }
  async sendMessage(message) {
    const connection = await this.fetchConnection();
    return connection.send(new ConversationConnectionMessage_js_1.ConversationConnectionMessage(Exports_js_1.MessageType.Text, message));
  }
  async sendMessageAsync(message) {
    const connection = await this.fetchConnection();
    await connection.send(new ConversationConnectionMessage_js_1.ConversationConnectionMessage(Exports_js_1.MessageType.Text, message));
  }
  privDisconnect() {
    if (this.terminateMessageLoop) {
      return;
    }
    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.NoError, "Disconnecting");
    this.terminateMessageLoop = true;
    return Promise.resolve();
  }
  // eslint-disable-next-line @typescript-eslint/require-await
  async processTypeSpecificMessages() {
    return true;
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    this.terminateMessageLoop = true;
    const cancelEvent = new Exports_js_2.ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
    try {
      if (!!this.privConversationServiceConnector.canceled) {
        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);
      }
    } catch {
      // continue on error
    }
  }
  /**
   * Establishes a websocket connection to the end point.
   */
  async conversationConnectImpl(connection) {
    this.privConnectionLoop = this.startMessageLoop();
    return connection;
  }
  /**
   * Process incoming websocket messages
   */
  async receiveConversationMessageOverride() {
    if (this.isDisposed() || this.terminateMessageLoop) {
      return Promise.resolve();
    }
    // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages
    const communicationCustodian = new Exports_js_1.Deferred();
    try {
      const connection = await this.fetchConnection();
      const message = await connection.read();
      if (this.isDisposed() || this.terminateMessageLoop) {
        // We're done.
        communicationCustodian.resolve();
        return Promise.resolve();
      }
      if (!message) {
        return this.receiveConversationMessageOverride();
      }
      const sessionId = this.privConversationRequestSession.sessionId;
      const conversationMessageType = message.conversationMessageType.toLowerCase();
      let sendFinal = false;
      try {
        switch (conversationMessageType) {
          case "info":
          case "participant_command":
          case "command":
            const commandPayload = Exports_js_4.CommandResponsePayload.fromJSON(message.textBody);
            switch (commandPayload.command.toLowerCase()) {
              /**
               * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.
               * The consuming client must wait for this message to arrive
               * before starting to send their own data.
               */
              case "participantlist":
                const participantsPayload = Exports_js_4.ParticipantsListPayloadResponse.fromJSON(message.textBody);
                const participantsResult = participantsPayload.participants.map(p => {
                  const participant = {
                    avatar: p.avatar,
                    displayName: p.nickname,
                    id: p.participantId,
                    isHost: p.ishost,
                    isMuted: p.ismuted,
                    isUsingTts: p.usetts,
                    preferredLanguage: p.locale
                  };
                  return participant;
                });
                if (!!this.privConversationServiceConnector.participantsListReceived) {
                  this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));
                }
                break;
              /**
               * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).
               * This is sent at the start of the Conversation
               */
              case "settranslatetolanguages":
                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                  this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));
                }
                break;
              /**
               * 'SetProfanityFiltering' lets the client set the level of profanity filtering.
               * If sent by the participant the setting will effect only their own profanity level.
               * If sent by the host, the setting will effect all participants including the host.
               * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'
               */
              case "setprofanityfiltering":
                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                  this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));
                }
                break;
              /**
               * 'SetMute' is sent if the participant has been muted by the host.
               * Check the 'participantId' to determine if the current user has been muted.
               */
              case "setmute":
                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                  this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));
                }
                break;
              /**
               * 'SetMuteAll' is sent if the Conversation has been muted by the host.
               */
              case "setmuteall":
                if (!!this.privConversationServiceConnector.muteAllCommandReceived) {
                  this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.MuteAllEventArgs(commandPayload.value, sessionId));
                }
                break;
              /**
               * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.
               */
              case "roomexpirationwarning":
                if (!!this.privConversationServiceConnector.conversationExpiration) {
                  this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new Exports_js_2.ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));
                }
                break;
              /**
               * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.
               */
              case "setusetts":
                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                  this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));
                }
                break;
              /**
               * 'SetLockState' is set if the host has locked or unlocked the Conversation.
               */
              case "setlockstate":
                if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {
                  this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.LockRoomEventArgs(commandPayload.value, sessionId));
                }
                break;
              /**
               * 'ChangeNickname' is received if a user changes their display name.
               * Any cached particpiants list should be updated to reflect the display name.
               */
              case "changenickname":
                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {
                  this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes.changeNickname, commandPayload.value, sessionId));
                }
                break;
              /**
               * 'JoinSession' is sent when a user joins the Conversation.
               */
              case "joinsession":
                const joinParticipantPayload = Exports_js_4.ParticipantPayloadResponse.fromJSON(message.textBody);
                const joiningParticipant = {
                  avatar: joinParticipantPayload.avatar,
                  displayName: joinParticipantPayload.nickname,
                  id: joinParticipantPayload.participantId,
                  isHost: joinParticipantPayload.ishost,
                  isMuted: joinParticipantPayload.ismuted,
                  isUsingTts: joinParticipantPayload.usetts,
                  preferredLanguage: joinParticipantPayload.locale
                };
                if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {
                  this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantEventArgs(joiningParticipant, sessionId));
                }
                break;
              /**
               * 'LeaveSession' is sent when a user leaves the Conversation'.
               */
              case "leavesession":
                const leavingParticipant = {
                  id: commandPayload.participantId
                };
                if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {
                  this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ParticipantEventArgs(leavingParticipant, sessionId));
                }
                break;
              /**
               * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).
               * Check the 'ParticipantId' to check whether the message is for the current user.
               */
              case "disconnectsession":
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const disconnectParticipant = {
                  id: commandPayload.participantId
                };
                break;
              case "token":
                const token = new Exports_js_3.CognitiveTokenAuthentication(() => {
                  const authorizationToken = commandPayload.token;
                  return Promise.resolve(authorizationToken);
                }, () => {
                  const authorizationToken = commandPayload.token;
                  return Promise.resolve(authorizationToken);
                });
                this.authentication = token;
                this.privConversationServiceConnector.onToken(token);
                break;
              /**
               * Message not recognized.
               */
              default:
                break;
            }
            break;
          /**
           * 'partial' (or 'hypothesis') represents a unfinalized speech message.
           */
          case "partial":
          /**
           * 'final' (or 'phrase') represents a finalized speech message.
           */
          case "final":
            const speechPayload = Exports_js_4.SpeechResponsePayload.fromJSON(message.textBody);
            const conversationResultReason = conversationMessageType === "final" ? Exports_js_2.ResultReason.TranslatedParticipantSpeech : Exports_js_2.ResultReason.TranslatingParticipantSpeech;
            const speechResult = new Exports_js_2.ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, speechPayload.id, conversationResultReason, speechPayload.recognition, undefined, undefined, message.textBody, undefined);
            if (speechPayload.isFinal) {
              // check the length, sometimes empty finals are returned
              if (speechResult.text !== undefined && speechResult.text.length > 0) {
                sendFinal = true;
              } else if (speechPayload.id === this.privLastPartialUtteranceId) {
                // send final as normal. We had a non-empty partial for this same utterance
                // so sending the empty final is important
                sendFinal = true;
              } else {
                // suppress unneeded final
              }
              if (sendFinal) {
                if (!!this.privConversationServiceConnector.translationReceived) {
                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.final, speechResult, sessionId));
                }
              }
            } else if (speechResult.text !== undefined) {
              this.privLastPartialUtteranceId = speechPayload.id;
              if (!!this.privConversationServiceConnector.translationReceived) {
                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.partial, speechResult, sessionId));
              }
            }
            break;
          /**
           * "translated_message" is a text message or instant message (IM).
           */
          case "translated_message":
            const textPayload = Exports_js_4.TextResponsePayload.fromJSON(message.textBody);
            // TODO: (Native parity) a result reason should be set based whether the participantId is ours or not
            const textResult = new Exports_js_2.ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);
            if (!!this.privConversationServiceConnector.translationReceived) {
              this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));
            }
            break;
          default:
            // ignore any unsupported message types
            break;
        }
      } catch (e) {
        // continue
      }
      return this.receiveConversationMessageOverride();
    } catch (e) {
      this.terminateMessageLoop = true;
    }
    return communicationCustodian.promise;
  }
  async startMessageLoop() {
    if (this.isDisposed()) {
      return Promise.resolve();
    }
    this.terminateMessageLoop = false;
    const messageRetrievalPromise = this.receiveConversationMessageOverride();
    try {
      const r = await messageRetrievalPromise;
      return r;
    } catch (error) {
      this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", Exports_js_2.CancellationReason.Error, Exports_js_2.CancellationErrorCode.RuntimeError, error);
      return null;
    }
  }
  // Takes an established websocket connection to the endpoint
  configConnection() {
    if (this.isDisposed()) {
      return Promise.resolve(undefined);
    }
    if (this.privConnectionConfigPromise !== undefined) {
      return this.privConnectionConfigPromise.then(connection => {
        if (connection.state() === Exports_js_1.ConnectionState.Disconnected) {
          this.privConnectionId = null;
          this.privConnectionConfigPromise = undefined;
          return this.configConnection();
        }
        return this.privConnectionConfigPromise;
      }, () => {
        this.privConnectionId = null;
        this.privConnectionConfigPromise = undefined;
        return this.configConnection();
      });
    }
    if (this.terminateMessageLoop) {
      return Promise.resolve(undefined);
    }
    this.privConnectionConfigPromise = this.connectImpl().then(connection => connection);
    return this.privConnectionConfigPromise;
  }
  getTranslations(serviceResultTranslations) {
    let translations;
    if (undefined !== serviceResultTranslations) {
      translations = new Exports_js_2.Translations();
      for (const translation of serviceResultTranslations) {
        translations.set(translation.lang, translation.translation);
      }
    }
    return translations;
  }
}
exports.ConversationServiceAdapter = ConversationServiceAdapter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorConnectionFactory.js":
/*!****************************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorConnectionFactory.js ***!
  \****************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranslatorConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const StringUtils_js_1 = __webpack_require__(/*! ../../common/StringUtils.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/StringUtils.js");
const Contracts_js_1 = __webpack_require__(/*! ../../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ../../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ../HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ../QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./../ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_3 = __webpack_require__(/*! ./../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
/**
 * Connection factory for the conversation translator. Handles connecting to the regular translator endpoint,
 * as well as the virtual microphone array transcription endpoint
 */
class ConversationTranslatorConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  constructor(convGetter) {
    super();
    Contracts_js_1.Contracts.throwIfNullOrUndefined(convGetter, "convGetter");
    this.privConvGetter = convGetter;
  }
  create(config, authInfo, connectionId) {
    const isVirtMicArrayEndpoint = config.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE";
    const convInfo = this.privConvGetter().room;
    const region = convInfo.cognitiveSpeechRegion || config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, "");
    const replacementValues = {
      hostSuffix: ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region),
      path: ConversationTranslatorConnectionFactory.CTS_VIRT_MIC_PATH,
      region: encodeURIComponent(region)
    };
    replacementValues[QueryParameterNames_js_1.QueryParameterNames.Language] = encodeURIComponent(config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, ""));
    replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsMeetingId] = encodeURIComponent(convInfo.roomId);
    replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsDeviceId] = encodeURIComponent(convInfo.participantId);
    replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsIsParticipant] = convInfo.isHost ? "" : "&" + QueryParameterNames_js_1.QueryParameterNames.CtsIsParticipant;
    let endpointUrl = "";
    const queryParams = {};
    const headers = {};
    if (isVirtMicArrayEndpoint) {
      // connecting to the conversation transcription virtual microphone array endpoint
      endpointUrl = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint);
      if (!endpointUrl) {
        const hostName = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}");
        endpointUrl = "wss://" + hostName + "{path}";
      }
      // because the region can change during a session, we support being passed a format string which we can then
      // replace with the correct information.
      endpointUrl = StringUtils_js_1.StringUtils.formatString(endpointUrl, replacementValues);
      const parsedUrl = new URL(endpointUrl);
      parsedUrl.searchParams.forEach((val, key) => {
        queryParams[key] = val;
      });
      const connFactory = new Exports_js_3.TranscriberConnectionFactory();
      connFactory.setQueryParams(queryParams, config, endpointUrl);
      // Some query parameters are required for the CTS endpoint, let's explicity set them here
      queryParams[QueryParameterNames_js_1.QueryParameterNames.CtsMeetingId] = replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsMeetingId];
      queryParams[QueryParameterNames_js_1.QueryParameterNames.CtsDeviceId] = replacementValues[QueryParameterNames_js_1.QueryParameterNames.CtsDeviceId];
      if (!convInfo.isHost) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.CtsIsParticipant] = ""; // this doesn't have a value so set to an empty string
      }
      if (!(QueryParameterNames_js_1.QueryParameterNames.Format in queryParams)) {
        queryParams[QueryParameterNames_js_1.QueryParameterNames.Format] = "simple";
      }
      parsedUrl.searchParams.forEach((val, key) => {
        parsedUrl.searchParams.set(key, queryParams[key]);
        delete queryParams[key];
      });
      endpointUrl = parsedUrl.toString();
    } else {
      // connecting to regular translation endpoint
      const connFactory = new Exports_js_3.TranslationConnectionFactory();
      endpointUrl = connFactory.getEndpointUrl(config, true);
      endpointUrl = StringUtils_js_1.StringUtils.formatString(endpointUrl, replacementValues);
      connFactory.setQueryParams(queryParams, config, endpointUrl);
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    headers[Exports_js_1.RestConfigBase.configParams.token] = convInfo.token;
    if (!!authInfo.token) {
      headers[authInfo.headerName] = authInfo.token;
    }
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
    return new Exports_js_1.WebsocketConnection(endpointUrl, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
  }
}
exports.ConversationTranslatorConnectionFactory = ConversationTranslatorConnectionFactory;
ConversationTranslatorConnectionFactory.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio";

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorEventArgs.js":
/*!********************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorEventArgs.js ***!
  \********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationReceivedTranslationEventArgs = exports.ParticipantsListEventArgs = exports.ParticipantAttributeEventArgs = exports.ParticipantEventArgs = exports.LockRoomEventArgs = exports.MuteAllEventArgs = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class MuteAllEventArgs extends Exports_js_1.SessionEventArgs {
  constructor(isMuted, sessionId) {
    super(sessionId);
    this.privIsMuted = isMuted;
  }
  get isMuted() {
    return this.privIsMuted;
  }
}
exports.MuteAllEventArgs = MuteAllEventArgs;
class LockRoomEventArgs extends Exports_js_1.SessionEventArgs {
  constructor(isLocked, sessionId) {
    super(sessionId);
    this.privIsLocked = isLocked;
  }
  get isMuted() {
    return this.privIsLocked;
  }
}
exports.LockRoomEventArgs = LockRoomEventArgs;
class ParticipantEventArgs extends Exports_js_1.SessionEventArgs {
  constructor(participant, sessionId) {
    super(sessionId);
    this.privParticipant = participant;
  }
  get participant() {
    return this.privParticipant;
  }
}
exports.ParticipantEventArgs = ParticipantEventArgs;
class ParticipantAttributeEventArgs extends Exports_js_1.SessionEventArgs {
  constructor(participantId, key, value, sessionId) {
    super(sessionId);
    this.privKey = key;
    this.privValue = value;
    this.privParticipantId = participantId;
  }
  get value() {
    return this.privValue;
  }
  get key() {
    return this.privKey;
  }
  get id() {
    return this.privParticipantId;
  }
}
exports.ParticipantAttributeEventArgs = ParticipantAttributeEventArgs;
class ParticipantsListEventArgs extends Exports_js_1.SessionEventArgs {
  constructor(conversationId, token, translateTo, profanityFilter, roomProfanityFilter, isRoomLocked, isMuteAll, participants, sessionId) {
    super(sessionId);
    this.privRoomId = conversationId;
    this.privSessionToken = token;
    this.privTranslateTo = translateTo;
    this.privProfanityFilter = profanityFilter;
    this.privRoomProfanityFilter = roomProfanityFilter;
    this.privIsRoomLocked = isRoomLocked;
    this.privIsRoomLocked = isMuteAll;
    this.privParticipants = participants;
  }
  get sessionToken() {
    return this.privSessionToken;
  }
  get conversationId() {
    return this.privRoomId;
  }
  get translateTo() {
    return this.privTranslateTo;
  }
  get profanityFilter() {
    return this.privProfanityFilter;
  }
  get roomProfanityFilter() {
    return this.privRoomProfanityFilter;
  }
  get isRoomLocked() {
    return this.privIsRoomLocked;
  }
  get isMuteAll() {
    return this.privIsMuteAll;
  }
  get participants() {
    return this.privParticipants;
  }
}
exports.ParticipantsListEventArgs = ParticipantsListEventArgs;
class ConversationReceivedTranslationEventArgs {
  constructor(command, payload, sessionId) {
    this.privPayload = payload;
    this.privCommand = command;
    this.privSessionId = sessionId;
  }
  get payload() {
    return this.privPayload;
  }
  get command() {
    return this.privCommand;
  }
  get sessionId() {
    return this.privSessionId;
  }
}
exports.ConversationReceivedTranslationEventArgs = ConversationReceivedTranslationEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorInterfaces.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorInterfaces.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranslatorCommandTypes = exports.ConversationTranslatorMessageTypes = exports.InternalParticipants = void 0;
/** Users participating in the conversation */
class InternalParticipants {
  constructor(participants = [], meId) {
    this.participants = participants;
    this.meId = meId;
  }
  /**
   * Add or update a participant
   * @param value
   */
  addOrUpdateParticipant(value) {
    if (value === undefined) {
      return;
    }
    const exists = this.getParticipantIndex(value.id);
    if (exists > -1) {
      this.participants.splice(exists, 1, value);
    } else {
      this.participants.push(value);
    }
    // ensure it was added ok
    return this.getParticipant(value.id);
  }
  /**
   * Find the participant's position in the participants list.
   * @param id
   */
  getParticipantIndex(id) {
    return this.participants.findIndex(p => p.id === id);
  }
  /**
   * Find the participant by id.
   * @param id
   */
  getParticipant(id) {
    return this.participants.find(p => p.id === id);
  }
  /**
   * Remove a participant from the participants list.
   */
  deleteParticipant(id) {
    this.participants = this.participants.filter(p => p.id !== id);
  }
  /**
   * Helper to return the conversation host.
   */
  get host() {
    return this.participants.find(p => p.isHost === true);
  }
  /**
   * Helper to return the current user.
   */
  get me() {
    return this.getParticipant(this.meId);
  }
}
exports.InternalParticipants = InternalParticipants;
/**
 * List of command message types
 */
exports.ConversationTranslatorMessageTypes = {
  command: "command",
  final: "final",
  info: "info",
  instantMessage: "instant_message",
  keepAlive: "keep_alive",
  partial: "partial",
  participantCommand: "participant_command",
  translatedMessage: "translated_message"
};
/**
 * List of command types
 */
exports.ConversationTranslatorCommandTypes = {
  changeNickname: "ChangeNickname",
  disconnectSession: "DisconnectSession",
  ejectParticipant: "EjectParticipant",
  instant_message: "instant_message",
  joinSession: "JoinSession",
  leaveSession: "LeaveSession",
  participantList: "ParticipantList",
  roomExpirationWarning: "RoomExpirationWarning",
  setLockState: "SetLockState",
  setMute: "SetMute",
  setMuteAll: "SetMuteAll",
  setProfanityFiltering: "SetProfanityFiltering",
  setTranslateToLanguages: "SetTranslateToLanguages",
  setUseTTS: "SetUseTTS"
};

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorRecognizer.js":
/*!*********************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorRecognizer.js ***!
  \*********************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranslatorRecognizer = exports.ConversationRecognizerFactory = void 0;
// eslint-disable-next-line max-classes-per-file
const Exports_js_1 = __webpack_require__(/*! ../../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ../../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConversationConnectionFactory_js_1 = __webpack_require__(/*! ./ConversationConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionFactory.js");
const ConversationServiceAdapter_js_1 = __webpack_require__(/*! ./ConversationServiceAdapter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationServiceAdapter.js");
class ConversationRecognizerFactory {
  static fromConfig(conversation, speechConfig, audioConfig) {
    return new ConversationTranslatorRecognizer(conversation, speechConfig, audioConfig);
  }
}
exports.ConversationRecognizerFactory = ConversationRecognizerFactory;
/**
 * Sends messages to the Conversation Translator websocket and listens for incoming events containing websocket messages.
 * Based off the recognizers in the SDK folder.
 */
class ConversationTranslatorRecognizer extends Exports_js_3.Recognizer {
  constructor(conversation, speechConfig, audioConfig) {
    const serviceConfigImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(serviceConfigImpl, "speechConfig");
    const conversationImpl = conversation;
    Contracts_js_1.Contracts.throwIfNull(conversationImpl, "conversationImpl");
    super(audioConfig, serviceConfigImpl.properties, new ConversationConnectionFactory_js_1.ConversationConnectionFactory());
    this.privConversation = conversationImpl;
    this.privIsDisposed = false;
    this.privProperties = serviceConfigImpl.properties.clone();
    this.privConnection = Exports_js_3.Connection.fromRecognizer(this);
    const webWorkerLoadType = this.privProperties.getProperty(Exports_js_3.PropertyId.WebWorkerLoadType, "on").toLowerCase();
    if (webWorkerLoadType === "on" && typeof Blob !== "undefined" && typeof Worker !== "undefined") {
      this.privSetTimeout = Exports_js_2.Timeout.setTimeout;
      this.privClearTimeout = Exports_js_2.Timeout.clearTimeout;
    } else {
      if (typeof window !== "undefined") {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.privSetTimeout = window.setTimeout.bind(window);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.privClearTimeout = window.clearTimeout.bind(window);
      } else {
        this.privSetTimeout = setTimeout;
        this.privClearTimeout = clearTimeout;
      }
    }
  }
  set connected(cb) {
    this.privConnection.connected = cb;
  }
  set disconnected(cb) {
    this.privConnection.disconnected = cb;
  }
  /**
   * Return the speech language used by the recognizer
   */
  get speechRecognitionLanguage() {
    return this.privSpeechRecognitionLanguage;
  }
  /**
   * Return the properties for the recognizer
   */
  get properties() {
    return this.privProperties;
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  /**
   * Connect to the recognizer
   * @param token
   */
  connect(token, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
      this.privReco.conversationTranslatorToken = token;
      this.resetConversationTimeout();
      this.privReco.connectAsync(cb, err);
    } catch (error) {
      if (!!err) {
        if (error instanceof Error) {
          const typedError = error;
          err(typedError.name + ": " + typedError.message);
        } else {
          err(error);
        }
      }
    }
  }
  /**
   * Disconnect from the recognizer
   */
  disconnect(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      if (this.privTimeoutToken !== undefined) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        this.privClearTimeout(this.privTimeoutToken);
      }
      this.privReco.disconnect().then(() => {
        if (!!cb) {
          cb();
        }
      }, error => {
        if (!!err) {
          err(error);
        }
      });
    } catch (error) {
      if (!!err) {
        if (error instanceof Error) {
          const typedError = error;
          err(typedError.name + ": " + typedError.message);
        } else {
          err(error);
        }
      }
      // Destroy the recognizer.
      this.dispose(true).catch(reason => {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));
      });
    }
  }
  /**
   * Send the mute all participants command to the websocket
   * @param conversationId
   * @param participantId
   * @param isMuted
   */
  sendRequest(command, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      this.sendMessage(command, cb, err);
    } catch (error) {
      if (!!err) {
        if (error instanceof Error) {
          const typedError = error;
          err(typedError.name + ": " + typedError.message);
        } else {
          err(error);
        }
      }
      // Destroy the recognizer.
      this.dispose(true).catch(reason => {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.BackgroundEvent(reason));
      });
    }
  }
  /**
   * Handle update of service auth token (#694)
   */
  onToken(token) {
    this.privConversation.onToken(token);
  }
  /**
   * Close and dispose the recognizer
   */
  async close() {
    if (!this.privIsDisposed) {
      if (!!this.privConnection) {
        this.privConnection.closeConnection();
        this.privConnection.close();
      }
      this.privConnection = undefined;
      await this.dispose(true);
    }
  }
  /**
   * Dispose the recognizer
   * @param disposing
   */
  async dispose(disposing) {
    if (this.privIsDisposed) {
      return;
    }
    if (disposing) {
      if (this.privTimeoutToken !== undefined) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        this.privClearTimeout(this.privTimeoutToken);
      }
      this.privIsDisposed = true;
      if (!!this.privConnection) {
        this.privConnection.closeConnection();
        this.privConnection.close();
        this.privConnection = undefined;
      }
      await super.dispose(disposing);
    }
  }
  /**
   * Create the config for the recognizer
   * @param speechConfig
   */
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);
  }
  /**
   * Create the service recognizer.
   * The audio source is redundnant here but is required by the implementation.
   * @param authentication
   * @param connectionFactory
   * @param audioConfig
   * @param recognizerConfig
   */
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const audioSource = audioConfig;
    return new ConversationServiceAdapter_js_1.ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);
  }
  sendMessage(msg, cb, err) {
    const withAsync = this.privReco;
    const PromiseToEmptyCallback = (promise, cb, err) => {
      if (promise !== undefined) {
        promise.then(() => {
          try {
            if (!!cb) {
              cb();
            }
          } catch (e) {
            if (!!err) {
              err(`'Unhandled error on promise callback: ${e}'`);
            }
          }
        }, reason => {
          try {
            if (!!err) {
              err(reason);
            }
            // eslint-disable-next-line no-empty
          } catch (error) {}
        });
      } else {
        if (!!err) {
          err("Null promise");
        }
      }
    };
    PromiseToEmptyCallback(withAsync.sendMessageAsync(msg), cb, err);
    this.resetConversationTimeout();
  }
  resetConversationTimeout() {
    if (this.privTimeoutToken !== undefined) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      this.privClearTimeout(this.privTimeoutToken);
    }
    this.privTimeoutToken = this.privSetTimeout(() => {
      this.sendRequest(this.privConversation.getKeepAlive());
    }, 60000);
  }
}
exports.ConversationTranslatorRecognizer = ConversationTranslatorRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationWebsocketMessageFormatter.js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationWebsocketMessageFormatter.js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationWebsocketMessageFormatter = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const ConversationConnectionMessage_js_1 = __webpack_require__(/*! ./ConversationConnectionMessage.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionMessage.js");
/**
 * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.
 */
class ConversationWebsocketMessageFormatter {
  /**
   * Format incoming messages: text (speech partial/final, IM) or binary (tts)
   */
  toConnectionMessage(message) {
    const deferral = new Exports_js_1.Deferred();
    try {
      if (message.messageType === Exports_js_1.MessageType.Text) {
        const incomingMessage = new ConversationConnectionMessage_js_1.ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);
        deferral.resolve(incomingMessage);
      } else if (message.messageType === Exports_js_1.MessageType.Binary) {
        deferral.resolve(new ConversationConnectionMessage_js_1.ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. Error: ${e}`);
    }
    return deferral.promise;
  }
  /**
   * Format outgoing messages: text (commands or IM)
   */
  fromConnectionMessage(message) {
    const deferral = new Exports_js_1.Deferred();
    try {
      if (message.messageType === Exports_js_1.MessageType.Text) {
        const payload = `${message.textBody ? message.textBody : ""}`;
        deferral.resolve(new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Text, payload, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. ${e}`);
    }
    return deferral.promise;
  }
}
exports.ConversationWebsocketMessageFormatter = ConversationWebsocketMessageFormatter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/Exports.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/Exports.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var ConversationManager_js_1 = __webpack_require__(/*! ./ConversationManager.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationManager.js");
Object.defineProperty(exports, "ConversationManager", ({
  enumerable: true,
  get: function () {
    return ConversationManager_js_1.ConversationManager;
  }
}));
var ConversationConnectionConfig_js_1 = __webpack_require__(/*! ./ConversationConnectionConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationConnectionConfig.js");
Object.defineProperty(exports, "ConversationConnectionConfig", ({
  enumerable: true,
  get: function () {
    return ConversationConnectionConfig_js_1.ConversationConnectionConfig;
  }
}));
var ConversationTranslatorRecognizer_js_1 = __webpack_require__(/*! ./ConversationTranslatorRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorRecognizer.js");
Object.defineProperty(exports, "ConversationRecognizerFactory", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorRecognizer_js_1.ConversationRecognizerFactory;
  }
}));
var TranscriberRecognizer_js_1 = __webpack_require__(/*! ./TranscriberRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/TranscriberRecognizer.js");
Object.defineProperty(exports, "TranscriberRecognizer", ({
  enumerable: true,
  get: function () {
    return TranscriberRecognizer_js_1.TranscriberRecognizer;
  }
}));
var ConversationTranslatorEventArgs_js_1 = __webpack_require__(/*! ./ConversationTranslatorEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorEventArgs.js");
Object.defineProperty(exports, "ConversationReceivedTranslationEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorEventArgs_js_1.ConversationReceivedTranslationEventArgs;
  }
}));
Object.defineProperty(exports, "LockRoomEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorEventArgs_js_1.LockRoomEventArgs;
  }
}));
Object.defineProperty(exports, "MuteAllEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorEventArgs_js_1.MuteAllEventArgs;
  }
}));
Object.defineProperty(exports, "ParticipantAttributeEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorEventArgs_js_1.ParticipantAttributeEventArgs;
  }
}));
Object.defineProperty(exports, "ParticipantEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorEventArgs_js_1.ParticipantEventArgs;
  }
}));
Object.defineProperty(exports, "ParticipantsListEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorEventArgs_js_1.ParticipantsListEventArgs;
  }
}));
var ConversationTranslatorInterfaces_js_1 = __webpack_require__(/*! ./ConversationTranslatorInterfaces.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorInterfaces.js");
Object.defineProperty(exports, "ConversationTranslatorCommandTypes", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorInterfaces_js_1.ConversationTranslatorCommandTypes;
  }
}));
Object.defineProperty(exports, "ConversationTranslatorMessageTypes", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorInterfaces_js_1.ConversationTranslatorMessageTypes;
  }
}));
Object.defineProperty(exports, "InternalParticipants", ({
  enumerable: true,
  get: function () {
    return ConversationTranslatorInterfaces_js_1.InternalParticipants;
  }
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/CommandResponsePayload.js":
/*!***************************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/CommandResponsePayload.js ***!
  \***************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CommandResponsePayload = void 0;
const parseCommandResponse = json => JSON.parse(json);
class CommandResponsePayload {
  constructor(json) {
    this.privCommandResponse = parseCommandResponse(json);
  }
  get type() {
    return this.privCommandResponse.type;
  }
  get command() {
    return this.privCommandResponse.command;
  }
  get id() {
    return this.privCommandResponse.id;
  }
  get nickname() {
    return this.privCommandResponse.nickname;
  }
  get participantId() {
    return this.privCommandResponse.participantId;
  }
  get roomid() {
    return this.privCommandResponse.roomid;
  }
  get value() {
    return this.privCommandResponse.value;
  }
  get token() {
    return this.privCommandResponse.token;
  }
  static fromJSON(json) {
    return new CommandResponsePayload(json);
  }
}
exports.CommandResponsePayload = CommandResponsePayload;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/Exports.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/Exports.js ***!
  \************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var CommandResponsePayload_js_1 = __webpack_require__(/*! ./CommandResponsePayload.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/CommandResponsePayload.js");
Object.defineProperty(exports, "CommandResponsePayload", ({
  enumerable: true,
  get: function () {
    return CommandResponsePayload_js_1.CommandResponsePayload;
  }
}));
var ParticipantResponsePayload_js_1 = __webpack_require__(/*! ./ParticipantResponsePayload.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/ParticipantResponsePayload.js");
Object.defineProperty(exports, "ParticipantsListPayloadResponse", ({
  enumerable: true,
  get: function () {
    return ParticipantResponsePayload_js_1.ParticipantsListPayloadResponse;
  }
}));
Object.defineProperty(exports, "ParticipantPayloadResponse", ({
  enumerable: true,
  get: function () {
    return ParticipantResponsePayload_js_1.ParticipantPayloadResponse;
  }
}));
var TranslationResponsePayload_js_1 = __webpack_require__(/*! ./TranslationResponsePayload.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/TranslationResponsePayload.js");
Object.defineProperty(exports, "SpeechResponsePayload", ({
  enumerable: true,
  get: function () {
    return TranslationResponsePayload_js_1.SpeechResponsePayload;
  }
}));
Object.defineProperty(exports, "TextResponsePayload", ({
  enumerable: true,
  get: function () {
    return TranslationResponsePayload_js_1.TextResponsePayload;
  }
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/ParticipantResponsePayload.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/ParticipantResponsePayload.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ParticipantPayloadResponse = exports.ParticipantsListPayloadResponse = void 0;
const parseListResponse = json => JSON.parse(json);
const parseParticipantResponse = json => JSON.parse(json);
class ParticipantsListPayloadResponse {
  constructor(json) {
    this.privParticipantsPayloadResponse = parseListResponse(json);
  }
  get roomid() {
    return this.privParticipantsPayloadResponse.roomid;
  }
  get id() {
    return this.privParticipantsPayloadResponse.id;
  }
  get command() {
    return this.privParticipantsPayloadResponse.command;
  }
  get participants() {
    return this.privParticipantsPayloadResponse.participants;
  }
  get token() {
    return this.privParticipantsPayloadResponse.token;
  }
  get translateTo() {
    return this.privParticipantsPayloadResponse.translateTo;
  }
  get profanityFilter() {
    return this.privParticipantsPayloadResponse.profanityFilter;
  }
  get roomProfanityFilter() {
    return this.privParticipantsPayloadResponse.roomProfanityFilter;
  }
  get roomLocked() {
    return this.privParticipantsPayloadResponse.roomLocked;
  }
  get muteAll() {
    return this.privParticipantsPayloadResponse.muteAll;
  }
  get type() {
    return this.privParticipantsPayloadResponse.type;
  }
  static fromJSON(json) {
    return new ParticipantsListPayloadResponse(json);
  }
}
exports.ParticipantsListPayloadResponse = ParticipantsListPayloadResponse;
class ParticipantPayloadResponse {
  constructor(json) {
    this.privParticipantPayloadResponse = parseParticipantResponse(json);
  }
  get nickname() {
    return this.privParticipantPayloadResponse.nickname;
  }
  get locale() {
    return this.privParticipantPayloadResponse.locale;
  }
  get usetts() {
    return this.privParticipantPayloadResponse.usetts;
  }
  get ismuted() {
    return this.privParticipantPayloadResponse.ismuted;
  }
  get ishost() {
    return this.privParticipantPayloadResponse.ishost;
  }
  get participantId() {
    return this.privParticipantPayloadResponse.participantId;
  }
  get avatar() {
    return this.privParticipantPayloadResponse.avatar;
  }
  static fromJSON(json) {
    return new ParticipantPayloadResponse(json);
  }
}
exports.ParticipantPayloadResponse = ParticipantPayloadResponse;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/TranslationResponsePayload.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ServiceMessages/TranslationResponsePayload.js ***!
  \*******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TextResponsePayload = exports.SpeechResponsePayload = void 0;
const parseSpeechResponse = json => JSON.parse(json);
const parseTextResponse = json => JSON.parse(json);
class SpeechResponsePayload {
  constructor(json) {
    this.privSpeechResponse = parseSpeechResponse(json);
  }
  get recognition() {
    return this.privSpeechResponse.recognition;
  }
  get translations() {
    return this.privSpeechResponse.translations;
  }
  get id() {
    return this.privSpeechResponse.id;
  }
  get language() {
    return this.privSpeechResponse.language;
  }
  get nickname() {
    return this.privSpeechResponse.nickname;
  }
  get participantId() {
    return this.privSpeechResponse.participantId;
  }
  get roomid() {
    return this.privSpeechResponse.roomid;
  }
  get timestamp() {
    return this.privSpeechResponse.timestamp;
  }
  get type() {
    return this.privSpeechResponse.type;
  }
  get isFinal() {
    return this.privSpeechResponse.type === "final";
  }
  static fromJSON(json) {
    return new SpeechResponsePayload(json);
  }
}
exports.SpeechResponsePayload = SpeechResponsePayload;
class TextResponsePayload {
  constructor(json) {
    this.privTextResponse = parseTextResponse(json);
  }
  get originalText() {
    return this.privTextResponse.originalText;
  }
  get translations() {
    return this.privTextResponse.translations;
  }
  get id() {
    return this.privTextResponse.id;
  }
  get language() {
    return this.privTextResponse.language;
  }
  get nickname() {
    return this.privTextResponse.nickname;
  }
  get participantId() {
    return this.privTextResponse.participantId;
  }
  get roomid() {
    return this.privTextResponse.roomid;
  }
  get timestamp() {
    return this.privTextResponse.timestamp;
  }
  get type() {
    return this.privTextResponse.type;
  }
  static fromJSON(json) {
    return new TextResponsePayload(json);
  }
}
exports.TextResponsePayload = TextResponsePayload;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/TranscriberRecognizer.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/TranscriberRecognizer.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranscriberRecognizer = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
const Exports_js_1 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../../sdk/Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ../../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
class TranscriberRecognizer extends Exports_js_2.Recognizer {
  /**
   * TranscriberRecognizer constructor.
   * @constructor
   * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
   * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
   */
  constructor(speechTranslationConfig, audioConfig) {
    const speechTranslationConfigImpl = speechTranslationConfig;
    Contracts_js_1.Contracts.throwIfNull(speechTranslationConfigImpl, "speechTranslationConfig");
    const audioConfigImpl = audioConfig;
    Contracts_js_1.Contracts.throwIfNull(audioConfigImpl, "audioConfigImpl");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(speechTranslationConfigImpl.speechRecognitionLanguage, Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage]);
    super(audioConfig, speechTranslationConfigImpl.properties, new Exports_js_3.TranscriberConnectionFactory());
    this.privDisposedRecognizer = false;
    this.isMeetingRecognizer = false;
  }
  get speechRecognitionLanguage() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage);
  }
  get properties() {
    return this.privProperties;
  }
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
  }
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  set conversation(c) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(c, "Conversation");
    this.isMeetingRecognizer = false;
    this.privConversation = c;
  }
  getConversationInfo() {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation");
    return this.privConversation.conversationInfo;
  }
  set meeting(m) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(m, "Meeting");
    this.isMeetingRecognizer = true;
    this.privMeeting = m;
  }
  getMeetingInfo() {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting");
    return this.privMeeting.meetingInfo;
  }
  IsMeetingRecognizer() {
    return this.isMeetingRecognizer;
  }
  startContinuousRecognitionAsync(cb, err) {
    Exports_js_1.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_3.RecognitionMode.Conversation), cb, err);
  }
  stopContinuousRecognitionAsync(cb, err) {
    Exports_js_1.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
  }
  async close() {
    if (!this.privDisposedRecognizer) {
      await this.dispose(true);
    }
  }
  // Push async join/leave conversation message via serviceRecognizer
  async pushConversationEvent(conversationInfo, command) {
    const reco = this.privReco;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(reco, "serviceRecognizer");
    await reco.sendSpeechEventAsync(conversationInfo, command);
  }
  // Push async join/leave meeting message via serviceRecognizer
  async pushMeetingEvent(meetingInfo, command) {
    const reco = this.privReco;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(reco, "serviceRecognizer");
    await reco.sendMeetingSpeechEventAsync(meetingInfo, command);
  }
  async enforceAudioGating() {
    const audioConfigImpl = this.audioConfig;
    const format = await audioConfigImpl.format;
    const channels = format.channels;
    if (channels === 1) {
      if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true") {
        throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
      }
    } else if (channels !== 8) {
      throw new Error(`Unsupported audio configuration: Detected ${channels}-channel audio`);
    }
    return;
  }
  connectMeetingCallbacks(transcriber) {
    this.isMeetingRecognizer = true;
    this.canceled = (s, e) => {
      if (!!transcriber.canceled) {
        transcriber.canceled(transcriber, e);
      }
    };
    this.recognizing = (s, e) => {
      if (!!transcriber.transcribing) {
        transcriber.transcribing(transcriber, e);
      }
    };
    this.recognized = (s, e) => {
      if (!!transcriber.transcribed) {
        transcriber.transcribed(transcriber, e);
      }
    };
    this.sessionStarted = (s, e) => {
      if (!!transcriber.sessionStarted) {
        transcriber.sessionStarted(transcriber, e);
      }
    };
    this.sessionStopped = (s, e) => {
      if (!!transcriber.sessionStopped) {
        transcriber.sessionStopped(transcriber, e);
      }
    };
  }
  disconnectCallbacks() {
    this.canceled = undefined;
    this.recognizing = undefined;
    this.recognized = undefined;
    this.sessionStarted = undefined;
    this.sessionStopped = undefined;
  }
  /**
   * Disposes any resources held by the object.
   * @member ConversationTranscriber.prototype.dispose
   * @function
   * @public
   * @param {boolean} disposing - true if disposing the object.
   */
  async dispose(disposing) {
    if (this.privDisposedRecognizer) {
      return;
    }
    if (disposing) {
      this.privDisposedRecognizer = true;
      await this.implRecognizerStop();
    }
    await super.dispose(disposing);
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_3.RecognizerConfig(speechConfig, this.properties);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const configImpl = audioConfig;
    return new Exports_js_3.TranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
  }
}
exports.TranscriberRecognizer = TranscriberRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranscriptionServiceRecognizer.js":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranscriptionServiceRecognizer.js ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranscriptionServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const SpeechConnectionMessage_Internal_js_1 = __webpack_require__(/*! ./SpeechConnectionMessage.Internal.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js");
// eslint-disable-next-line max-classes-per-file
class TranscriptionServiceRecognizer extends Exports_js_3.ConversationServiceRecognizer {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, transcriber) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, transcriber);
    this.privTranscriberRecognizer = transcriber;
    this.sendPrePayloadJSONOverride = connection => this.sendTranscriptionStartJSON(connection);
    if (this.privRecognizerConfig.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true") {
      this.privSpeechContext.setWordLevelTimings();
    }
  }
  async sendSpeechEventAsync(info, command) {
    if (!!this.privRequestSession.isRecognizing) {
      const connection = await this.fetchConnection();
      await this.sendSpeechEvent(connection, this.createSpeechEventPayload(info, command));
    }
  }
  async sendMeetingSpeechEventAsync(info, command) {
    if (!!this.privRequestSession.isRecognizing) {
      const connection = await this.fetchConnection();
      await this.sendSpeechEvent(connection, this.createMeetingSpeechEventPayload(info, command));
    }
  }
  processTypeSpecificMessages(connectionMessage) {
    return this.processSpeechMessages(connectionMessage);
  }
  handleRecognizedCallback(result, offset, sessionId) {
    try {
      const event = new Exports_js_2.SpeechRecognitionEventArgs(result, offset, sessionId);
      this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, event);
      if (!!this.privSuccessCallback) {
        try {
          this.privSuccessCallback(result);
        } catch (e) {
          if (!!this.privErrorCallback) {
            this.privErrorCallback(e);
          }
        }
        // Only invoke the call back once.
        // and if it's successful don't invoke the
        // error after that.
        this.privSuccessCallback = undefined;
        this.privErrorCallback = undefined;
      }
      /* eslint-disable no-empty */
    } catch (error) {
      // Not going to let errors in the event handler
      // trip things up.
    }
  }
  handleRecognizingCallback(result, duration, sessionId) {
    try {
      const ev = new Exports_js_2.SpeechRecognitionEventArgs(result, duration, sessionId);
      this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, ev);
      /* eslint-disable no-empty */
    } catch (error) {
      // Not going to let errors in the event handler
      // trip things up.
    }
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    const properties = new Exports_js_2.PropertyCollection();
    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
    if (this.privTranscriberRecognizer.IsMeetingRecognizer()) {
      if (!!this.privTranscriberRecognizer.canceled) {
        const cancelEvent = new Exports_js_2.MeetingTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);
          /* eslint-disable no-empty */
        } catch {}
      }
    } else {
      if (!!this.privTranscriberRecognizer.canceled) {
        const cancelEvent = new Exports_js_2.ConversationTranscriptionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, cancelEvent);
          /* eslint-disable no-empty */
        } catch {}
      }
    }
    if (!!this.privSuccessCallback) {
      const result = new Exports_js_2.SpeechRecognitionResult(requestId, Exports_js_2.ResultReason.Canceled, undefined,
      // Text
      undefined,
      // Duration
      undefined,
      // Offset
      undefined,
      // Language
      undefined,
      // Language Detection Confidence
      undefined,
      // Speaker Id
      error, undefined,
      // Json
      properties);
      try {
        this.privSuccessCallback(result);
        this.privSuccessCallback = undefined;
        /* eslint-disable no-empty */
      } catch {}
    }
  }
  // Encapsulated for derived service recognizers that need to send additional JSON
  async sendTranscriptionStartJSON(connection) {
    await this.sendSpeechContext(connection, true);
    if (this.privTranscriberRecognizer.IsMeetingRecognizer()) {
      const info = this.privTranscriberRecognizer.getMeetingInfo();
      const payload = this.createMeetingSpeechEventPayload(info, "start");
      await this.sendSpeechEvent(connection, payload);
    } else {
      const info = this.privTranscriberRecognizer.getConversationInfo();
      const payload = this.createSpeechEventPayload(info, "start");
      await this.sendSpeechEvent(connection, payload);
    }
    await this.sendWaveHeader(connection);
    return;
  }
  sendSpeechEvent(connection, payload) {
    const speechEventJson = JSON.stringify(payload);
    if (speechEventJson) {
      return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_1.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", speechEventJson));
    }
    return;
  }
  createSpeechEventPayload(info, command) {
    const eventDict = {
      id: "meeting",
      name: command,
      meeting: info.conversationProperties
    };
    eventDict.meeting.id = info.id;
    eventDict.meeting.attendees = info.participants;
    return eventDict;
  }
  createMeetingSpeechEventPayload(info, command) {
    const eventDict = {
      id: "meeting",
      name: command,
      meeting: info.meetingProperties
    };
    eventDict.meeting.id = info.id;
    eventDict.meeting.attendees = info.participants;
    return eventDict;
  }
}
exports.TranscriptionServiceRecognizer = TranscriptionServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationConnectionFactory.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationConnectionFactory.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationConnectionFactory = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const StringUtils_js_1 = __webpack_require__(/*! ../common/StringUtils.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/StringUtils.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const ConnectionFactoryBase_js_1 = __webpack_require__(/*! ./ConnectionFactoryBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ConnectionFactoryBase.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const HeaderNames_js_1 = __webpack_require__(/*! ./HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const QueryParameterNames_js_1 = __webpack_require__(/*! ./QueryParameterNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/QueryParameterNames.js");
class TranslationConnectionFactory extends ConnectionFactoryBase_js_1.ConnectionFactoryBase {
  create(config, authInfo, connectionId) {
    const endpoint = this.getEndpointUrl(config);
    const queryParams = {};
    if (config.autoDetectSourceLanguages !== undefined) {
      queryParams[QueryParameterNames_js_1.QueryParameterNames.EnableLanguageId] = "true";
    }
    this.setQueryParams(queryParams, config, endpoint);
    const headers = {};
    if (authInfo.token !== undefined && authInfo.token !== "") {
      headers[authInfo.headerName] = authInfo.token;
    }
    headers[HeaderNames_js_1.HeaderNames.ConnectionId] = connectionId;
    config.parameters.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Url, endpoint);
    const enableCompression = config.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
    return new Exports_js_1.WebsocketConnection(endpoint, queryParams, headers, new Exports_js_3.WebsocketMessageFormatter(), Exports_js_1.ProxyInfo.fromRecognizerConfig(config), enableCompression, connectionId);
  }
  getEndpointUrl(config, returnRegionPlaceholder) {
    const region = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
    const hostSuffix = ConnectionFactoryBase_js_1.ConnectionFactoryBase.getHostSuffix(region);
    let endpointUrl = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, undefined);
    if (!endpointUrl) {
      if (config.autoDetectSourceLanguages !== undefined) {
        const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + hostSuffix);
        endpointUrl = host + "/speech/universal/v2";
      } else {
        const host = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + hostSuffix);
        endpointUrl = host + "/speech/translation/cognitiveservices/v1";
      }
    }
    if (returnRegionPlaceholder === true) {
      return endpointUrl;
    }
    return StringUtils_js_1.StringUtils.formatString(endpointUrl, {
      region
    });
  }
  setQueryParams(queryParams, config, endpointUrl) {
    queryParams.from = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage);
    queryParams.to = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages);
    queryParams.scenario = config.recognitionMode === Exports_js_3.RecognitionMode.Interactive ? "interactive" : config.recognitionMode === Exports_js_3.RecognitionMode.Conversation ? "conversation" : "";
    this.setCommonUrlParams(config, queryParams, endpointUrl);
    this.setUrlParameter(Exports_js_2.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, QueryParameterNames_js_1.QueryParameterNames.StableTranslation, config, queryParams, endpointUrl);
    const translationVoice = config.parameters.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationVoice, undefined);
    if (translationVoice !== undefined) {
      queryParams.voice = translationVoice;
      queryParams.features = "texttospeech";
    }
  }
}
exports.TranslationConnectionFactory = TranslationConnectionFactory;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationServiceRecognizer.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationServiceRecognizer.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
// eslint-disable-next-line max-classes-per-file
class TranslationServiceRecognizer extends Exports_js_3.ConversationServiceRecognizer {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, translationRecognizer);
    this.privTranslationRecognizer = translationRecognizer;
    this.connectionEvents.attach(connectionEvent => {
      if (connectionEvent.name === "ConnectionEstablishedEvent") {
        this.privTranslationRecognizer.onConnection();
      }
    });
  }
  async processTypeSpecificMessages(connectionMessage) {
    const resultProps = new Exports_js_2.PropertyCollection();
    let processed = await this.processSpeechMessages(connectionMessage);
    if (processed) {
      return true;
    }
    const handleTranslationPhrase = async translatedPhrase => {
      resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, translatedPhrase.asJson());
      this.privRequestSession.onPhraseRecognized(translatedPhrase.Offset + translatedPhrase.Duration);
      if (translatedPhrase.RecognitionStatus === Exports_js_3.RecognitionStatus.Success) {
        // OK, the recognition was successful. How'd the translation do?
        const result = this.fireEventForResult(translatedPhrase, resultProps);
        if (!!this.privTranslationRecognizer.recognized) {
          try {
            this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, result);
            /* eslint-disable no-empty */
          } catch (error) {
            // Not going to let errors in the event handler
            // trip things up.
          }
        }
        // report result to promise.
        if (!!this.privSuccessCallback) {
          try {
            this.privSuccessCallback(result.result);
          } catch (e) {
            if (!!this.privErrorCallback) {
              this.privErrorCallback(e);
            }
          }
          // Only invoke the call back once.
          // and if it's successful don't invoke the
          // error after that.
          this.privSuccessCallback = undefined;
          this.privErrorCallback = undefined;
        }
      } else {
        const reason = Exports_js_3.EnumTranslation.implTranslateRecognitionResult(translatedPhrase.RecognitionStatus);
        const result = new Exports_js_2.TranslationRecognitionResult(undefined, this.privRequestSession.requestId, reason, translatedPhrase.Text, translatedPhrase.Duration, translatedPhrase.Offset, translatedPhrase.Language, translatedPhrase.Confidence, undefined, translatedPhrase.asJson(), resultProps);
        if (reason === Exports_js_2.ResultReason.Canceled) {
          const cancelReason = Exports_js_3.EnumTranslation.implTranslateCancelResult(translatedPhrase.RecognitionStatus);
          const cancellationErrorCode = Exports_js_3.EnumTranslation.implTranslateCancelErrorCode(translatedPhrase.RecognitionStatus);
          await this.cancelRecognitionLocal(cancelReason, cancellationErrorCode, Exports_js_3.EnumTranslation.implTranslateErrorDetails(cancellationErrorCode));
        } else {
          if (translatedPhrase.RecognitionStatus !== Exports_js_3.RecognitionStatus.EndOfDictation) {
            const ev = new Exports_js_2.TranslationRecognitionEventArgs(result, result.offset, this.privRequestSession.sessionId);
            if (!!this.privTranslationRecognizer.recognized) {
              try {
                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);
                /* eslint-disable no-empty */
              } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
              }
            }
            // report result to promise.
            if (!!this.privSuccessCallback) {
              try {
                this.privSuccessCallback(result);
              } catch (e) {
                if (!!this.privErrorCallback) {
                  this.privErrorCallback(e);
                }
              }
              // Only invoke the call back once.
              // and if it's successful don't invoke the
              // error after that.
              this.privSuccessCallback = undefined;
              this.privErrorCallback = undefined;
            }
          }
        }
        processed = true;
      }
    };
    const handleTranslationHypothesis = hypothesis => {
      resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, hypothesis.asJson());
      const result = this.fireEventForResult(hypothesis, resultProps);
      this.privRequestSession.onHypothesis(result.offset);
      if (!!this.privTranslationRecognizer.recognizing) {
        try {
          this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, result);
          /* eslint-disable no-empty */
        } catch (error) {
          // Not going to let errors in the event handler
          // trip things up.
        }
      }
      processed = true;
    };
    if (connectionMessage.messageType === Exports_js_1.MessageType.Text) {
      resultProps.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
    }
    switch (connectionMessage.path.toLowerCase()) {
      case "translation.hypothesis":
        handleTranslationHypothesis(Exports_js_3.TranslationHypothesis.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset));
        break;
      case "translation.response":
        const phrase = JSON.parse(connectionMessage.textBody);
        if (!!phrase.SpeechPhrase) {
          await handleTranslationPhrase(Exports_js_3.TranslationPhrase.fromTranslationResponse(phrase, this.privRequestSession.currentTurnAudioOffset));
        } else {
          const hypothesis = JSON.parse(connectionMessage.textBody);
          if (!!hypothesis.SpeechHypothesis) {
            handleTranslationHypothesis(Exports_js_3.TranslationHypothesis.fromTranslationResponse(hypothesis, this.privRequestSession.currentTurnAudioOffset));
          }
        }
        break;
      case "translation.phrase":
        await handleTranslationPhrase(Exports_js_3.TranslationPhrase.fromJSON(connectionMessage.textBody, this.privRequestSession.currentTurnAudioOffset));
        break;
      case "translation.synthesis":
        this.sendSynthesisAudio(connectionMessage.binaryBody, this.privRequestSession.sessionId);
        processed = true;
        break;
      case "audio.end":
      case "translation.synthesis.end":
        const synthEnd = Exports_js_3.TranslationSynthesisEnd.fromJSON(connectionMessage.textBody);
        switch (synthEnd.SynthesisStatus) {
          case Exports_js_3.SynthesisStatus.Error:
            if (!!this.privTranslationRecognizer.synthesizing) {
              const result = new Exports_js_2.TranslationSynthesisResult(Exports_js_2.ResultReason.Canceled, undefined);
              const retEvent = new Exports_js_2.TranslationSynthesisEventArgs(result, this.privRequestSession.sessionId);
              try {
                this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);
                /* eslint-disable no-empty */
              } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
              }
            }
            if (!!this.privTranslationRecognizer.canceled) {
              // And raise a canceled event to send the rich(er) error message back.
              const canceledResult = new Exports_js_2.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, Exports_js_2.CancellationReason.Error, synthEnd.FailureReason, Exports_js_2.CancellationErrorCode.ServiceError, null);
              try {
                this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, canceledResult);
                /* eslint-disable no-empty */
              } catch (error) {
                // Not going to let errors in the event handler
                // trip things up.
              }
            }
            break;
          case Exports_js_3.SynthesisStatus.Success:
            this.sendSynthesisAudio(undefined, this.privRequestSession.sessionId);
            break;
          default:
            break;
        }
        processed = true;
        break;
      default:
        break;
    }
    return processed;
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    const properties = new Exports_js_2.PropertyCollection();
    properties.setProperty(Exports_js_3.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[errorCode]);
    if (!!this.privTranslationRecognizer.canceled) {
      const cancelEvent = new Exports_js_2.TranslationRecognitionCanceledEventArgs(sessionId, cancellationReason, error, errorCode, undefined);
      try {
        this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, cancelEvent);
        /* eslint-disable no-empty */
      } catch {}
    }
    if (!!this.privSuccessCallback) {
      const result = new Exports_js_2.TranslationRecognitionResult(undefined,
      // Translations
      requestId, Exports_js_2.ResultReason.Canceled, undefined,
      // Text
      undefined,
      // Druation
      undefined,
      // Offset
      undefined,
      // Language
      undefined,
      // LanguageDetectionConfidence
      error, undefined,
      // Json
      properties);
      try {
        this.privSuccessCallback(result);
        /* eslint-disable no-empty */
        this.privSuccessCallback = undefined;
      } catch {}
    }
  }
  handleRecognizingCallback(result, offset, sessionId) {
    try {
      const ev = new Exports_js_2.TranslationRecognitionEventArgs(Exports_js_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), offset, sessionId);
      this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, ev);
      /* eslint-disable no-empty */
    } catch (error) {
      // Not going to let errors in the event handler
      // trip things up.
    }
  }
  handleRecognizedCallback(result, offset, sessionId) {
    try {
      const ev = new Exports_js_2.TranslationRecognitionEventArgs(Exports_js_2.TranslationRecognitionResult.fromSpeechRecognitionResult(result), offset, sessionId);
      this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, ev);
    } catch (error) {
      // Not going to let errors in the event handler
      // trip things up.
    }
  }
  fireEventForResult(serviceResult, properties) {
    let translations;
    if (undefined !== serviceResult.Translation.Translations) {
      translations = new Exports_js_2.Translations();
      for (const translation of serviceResult.Translation.Translations) {
        translations.set(translation.Language, translation.Text || translation.DisplayText);
      }
    }
    let resultReason;
    let confidence;
    if (serviceResult instanceof Exports_js_3.TranslationPhrase) {
      if (!!serviceResult.Translation && serviceResult.Translation.TranslationStatus === Exports_js_1.TranslationStatus.Success) {
        resultReason = Exports_js_2.ResultReason.TranslatedSpeech;
      } else {
        resultReason = Exports_js_2.ResultReason.RecognizedSpeech;
      }
      confidence = serviceResult.Confidence;
    } else {
      resultReason = Exports_js_2.ResultReason.TranslatingSpeech;
    }
    const language = serviceResult.Language;
    const result = new Exports_js_2.TranslationRecognitionResult(translations, this.privRequestSession.requestId, resultReason, serviceResult.Text, serviceResult.Duration, serviceResult.Offset, language, confidence, serviceResult.Translation.FailureReason, serviceResult.asJson(), properties);
    const ev = new Exports_js_2.TranslationRecognitionEventArgs(result, serviceResult.Offset, this.privRequestSession.sessionId);
    return ev;
  }
  sendSynthesisAudio(audio, sessionId) {
    const reason = undefined === audio ? Exports_js_2.ResultReason.SynthesizingAudioCompleted : Exports_js_2.ResultReason.SynthesizingAudio;
    const result = new Exports_js_2.TranslationSynthesisResult(reason, audio);
    const retEvent = new Exports_js_2.TranslationSynthesisEventArgs(result, sessionId);
    if (!!this.privTranslationRecognizer.synthesizing) {
      try {
        this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, retEvent);
        /* eslint-disable no-empty */
      } catch (error) {
        // Not going to let errors in the event handler
        // trip things up.
      }
    }
  }
}
exports.TranslationServiceRecognizer = TranslationServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationStatus.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationStatus.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationStatus = void 0;
/**
 * Defines translation status.
 * @class TranslationStatus
 */
var TranslationStatus;
(function (TranslationStatus) {
  /**
   * @member TranslationStatus.Success
   */
  TranslationStatus[TranslationStatus["Success"] = 0] = "Success";
  /**
   * @member TranslationStatus.Error
   */
  TranslationStatus[TranslationStatus["Error"] = 1] = "Error";
})(TranslationStatus = exports.TranslationStatus || (exports.TranslationStatus = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/VoiceServiceRecognizer.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/VoiceServiceRecognizer.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceServiceRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Exports_js_3 = __webpack_require__(/*! ../sdk/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const SpeechConnectionMessage_Internal_js_1 = __webpack_require__(/*! ./SpeechConnectionMessage.Internal.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechConnectionMessage.Internal.js");
// eslint-disable-next-line max-classes-per-file
class VoiceServiceRecognizer extends Exports_js_4.ServiceRecognizerBase {
  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {
    super(authentication, connectionFactory, audioSource, recognizerConfig, recognizer);
    this.privDeferralMap = new Exports_js_2.DeferralMap();
    this.privSpeakerAudioSource = audioSource;
    this.sendPrePayloadJSONOverride = () => this.noOp();
  }
  set SpeakerAudioSource(audioSource) {
    this.privSpeakerAudioSource = audioSource;
  }
  processTypeSpecificMessages(connectionMessage) {
    let processed = false;
    const resultProps = new Exports_js_3.PropertyCollection();
    if (connectionMessage.messageType === Exports_js_2.MessageType.Text) {
      resultProps.setProperty(Exports_js_3.PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);
    }
    switch (connectionMessage.path.toLowerCase()) {
      // Profile management response for create, fetch, delete, reset
      case "speaker.profiles":
        const response = JSON.parse(connectionMessage.textBody);
        switch (response.operation.toLowerCase()) {
          case "create":
            this.handleCreateResponse(response, connectionMessage.requestId);
            break;
          case "delete":
          case "reset":
            this.handleResultResponse(response, connectionMessage.requestId);
            break;
          case "fetch":
            const enrollmentResponse = JSON.parse(connectionMessage.textBody);
            this.handleFetchResponse(enrollmentResponse, connectionMessage.requestId);
            break;
          default:
            break;
        }
        processed = true;
        break;
      // Activation and authorization phrase response
      case "speaker.phrases":
        const phraseResponse = JSON.parse(connectionMessage.textBody);
        this.handlePhrasesResponse(phraseResponse, connectionMessage.requestId);
        processed = true;
        break;
      // Enrollment response
      case "speaker.profile.enrollment":
        const enrollmentResponse = JSON.parse(connectionMessage.textBody);
        const result = new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(!!enrollmentResponse.enrollment ? enrollmentResponse.enrollment.enrollmentStatus : enrollmentResponse.status.statusCode), !!enrollmentResponse.enrollment ? JSON.stringify(enrollmentResponse.enrollment) : undefined, enrollmentResponse.status.reason);
        if (!!this.privDeferralMap.getId(connectionMessage.requestId)) {
          this.privDeferralMap.complete(connectionMessage.requestId, result);
        }
        this.privRequestSession.onSpeechEnded();
        processed = true;
        break;
      default:
        break;
    }
    const defferal = new Exports_js_2.Deferred();
    defferal.resolve(processed);
    return defferal.promise;
  }
  // Cancels recognition.
  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {
    const properties = new Exports_js_3.PropertyCollection();
    // const enrollmentResponse: EnrollmentResponse = JSON.parse(connectionMessage.textBody) as EnrollmentResponse;
    properties.setProperty(Exports_js_4.CancellationErrorCodePropertyName, Exports_js_3.CancellationErrorCode[errorCode]);
    const result = new Exports_js_3.VoiceProfileEnrollmentResult(Exports_js_3.ResultReason.Canceled, error, error);
    if (!!this.privDeferralMap.getId(requestId)) {
      this.privDeferralMap.complete(requestId, result);
    }
  }
  async createProfile(profileType, locale) {
    // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
    this.voiceProfileType = profileType.toString();
    const conPromise = this.connectImpl();
    try {
      const createProfileDeferral = new Exports_js_2.Deferred();
      await conPromise;
      await this.sendCreateProfile(createProfileDeferral, profileType, locale);
      void this.receiveMessage();
      return createProfileDeferral.promise;
    } catch (err) {
      throw err;
    }
  }
  async resetProfile(profile) {
    this.voiceProfileType = profile.profileType.toString();
    return this.sendCommonRequest("reset", profile.profileType, profile);
  }
  async deleteProfile(profile) {
    this.voiceProfileType = profile.profileType.toString();
    return this.sendCommonRequest("delete", profile.profileType, profile);
  }
  async retrieveEnrollmentResult(profile) {
    this.voiceProfileType = profile.profileType.toString();
    this.privExpectedProfileId = profile.profileId;
    return this.sendCommonRequest("fetch", profile.profileType, profile);
  }
  async getAllProfiles(profileType) {
    this.voiceProfileType = profileType.toString();
    return this.sendCommonRequest("fetch", profileType);
  }
  async getActivationPhrases(profileType, lang) {
    this.voiceProfileType = profileType.toString();
    // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
    const conPromise = this.connectImpl();
    try {
      const getPhrasesDeferral = new Exports_js_2.Deferred();
      await conPromise;
      await this.sendPhrasesRequest(getPhrasesDeferral, profileType, lang);
      void this.receiveMessage();
      return getPhrasesDeferral.promise;
    } catch (err) {
      throw err;
    }
  }
  async enrollProfile(profile) {
    this.voiceProfileType = profile.profileType.toString();
    const enrollmentDeferral = new Exports_js_2.Deferred();
    this.privRequestSession.startNewRecognition();
    this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events);
    this.privRecognizerConfig.parameters.setProperty(Exports_js_3.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
    // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
    const conPromise = this.connectImpl();
    const preAudioPromise = this.sendPreAudioMessages(profile, enrollmentDeferral);
    const node = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId);
    const format = await this.privSpeakerAudioSource.format;
    const deviceInfo = await this.privSpeakerAudioSource.deviceInfo;
    const audioNode = new Exports_js_1.ReplayableAudioNode(node, format.avgBytesPerSec);
    await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);
    this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {
      source: deviceInfo
    };
    try {
      await conPromise;
      await preAudioPromise;
    } catch (err) {
      this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.ConnectionFailure, err);
    }
    const sessionStartEventArgs = new Exports_js_3.SessionEventArgs(this.privRequestSession.sessionId);
    if (!!this.privRecognizer.sessionStarted) {
      this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);
    }
    void this.receiveMessage();
    const audioSendPromise = this.sendAudio(audioNode);
    // /* eslint-disable no-empty */
    audioSendPromise.then(() => {}, error => {
      this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, Exports_js_3.CancellationReason.Error, Exports_js_3.CancellationErrorCode.RuntimeError, error);
    });
    return enrollmentDeferral.promise;
  }
  async sendPreAudioMessages(profile, enrollmentDeferral) {
    const connection = await this.fetchConnection();
    this.privRequestSession.onSpeechContext();
    this.privDeferralMap.add(this.privRequestSession.requestId, enrollmentDeferral);
    await this.sendBaseRequest(connection, "enroll", this.scenarioFrom(profile.profileType), profile);
  }
  async sendPhrasesRequest(getPhrasesDeferral, profileType, locale) {
    const connection = await this.fetchConnection();
    this.privRequestSession.onSpeechContext();
    this.privDeferralMap.add(this.privRequestSession.requestId, getPhrasesDeferral);
    const scenario = this.scenarioFrom(profileType);
    const profileCreateRequest = {
      locale,
      scenario
    };
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileCreateRequest)));
  }
  async sendCreateProfile(createProfileDeferral, profileType, locale) {
    const connection = await this.fetchConnection();
    this.privRequestSession.onSpeechContext();
    this.privDeferralMap.add(this.privRequestSession.requestId, createProfileDeferral);
    const scenario = profileType === Exports_js_3.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : profileType === Exports_js_3.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    const profileCreateRequest = {
      locale,
      number: "1",
      scenario
    };
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileCreateRequest)));
  }
  async sendCommonRequest(operation, profileType, profile = undefined) {
    // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().
    const conPromise = this.connectImpl();
    try {
      const deferral = new Exports_js_2.Deferred();
      this.privRequestSession.onSpeechContext();
      await conPromise;
      const connection = await this.fetchConnection();
      this.privDeferralMap.add(this.privRequestSession.requestId, deferral);
      await this.sendBaseRequest(connection, operation, this.scenarioFrom(profileType), profile);
      void this.receiveMessage();
      return deferral.promise;
    } catch (err) {
      throw err;
    }
  }
  async sendBaseRequest(connection, operation, scenario, profile) {
    const profileRequest = {
      scenario
    };
    if (!!profile) {
      profileRequest.profileIds = [profile.profileId];
    } else {
      profileRequest.maxPageSize = -1;
    }
    return connection.send(new SpeechConnectionMessage_Internal_js_1.SpeechConnectionMessage(Exports_js_2.MessageType.Text, `speaker.profile.${operation}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(profileRequest)));
  }
  extractSpeakerContext(model) {
    return {
      features: {
        interimResult: "enabled",
        progressiveDetection: "disabled"
      },
      profileIds: model.profileIds,
      scenario: model.scenario
    };
  }
  handlePhrasesResponse(response, requestId) {
    if (!!this.privDeferralMap.getId(requestId)) {
      if (response.status.statusCode.toLowerCase() !== "success") {
        const reason = Exports_js_3.ResultReason.Canceled;
        const result = new Exports_js_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, []);
        this.privDeferralMap.complete(requestId, result);
      } else if (!!response.phrases && response.phrases.length > 0) {
        const reason = Exports_js_3.ResultReason.EnrollingVoiceProfile;
        const result = new Exports_js_3.VoiceProfilePhraseResult(reason, response.status.statusCode, response.passPhraseType, response.phrases);
        this.privDeferralMap.complete(requestId, result);
      } else {
        throw new Error("Voice Profile get activation phrases failed, no phrases received");
      }
    } else {
      throw new Error(`Voice Profile get activation phrases request for requestID ${requestId} not found`);
    }
  }
  handleCreateResponse(response, requestId) {
    if (!!response.profiles && response.profiles.length > 0) {
      if (!!this.privDeferralMap.getId(requestId)) {
        const profileIds = response.profiles.map(profile => profile.profileId);
        this.privDeferralMap.complete(requestId, profileIds);
      } else {
        throw new Error(`Voice Profile create request for requestID ${requestId} not found`);
      }
    } else {
      throw new Error("Voice Profile create failed, no profile id received");
    }
  }
  handleResultResponse(response, requestId) {
    if (!!this.privDeferralMap.getId(requestId)) {
      const successReason = response.operation.toLowerCase() === "delete" ? Exports_js_3.ResultReason.DeletedVoiceProfile : Exports_js_3.ResultReason.ResetVoiceProfile;
      const reason = response.status.statusCode.toLowerCase() === "success" ? successReason : Exports_js_3.ResultReason.Canceled;
      const result = new Exports_js_3.VoiceProfileResult(reason, `statusCode: ${response.status.statusCode}, errorDetails: ${response.status.reason}`);
      this.privDeferralMap.complete(requestId, result);
    } else {
      throw new Error(`Voice Profile create request for requestID ${requestId} not found`);
    }
  }
  handleFetchResponse(enrollmentResponse, requestId) {
    if (!!this.privDeferralMap.getId(requestId) && !!enrollmentResponse.profiles[0]) {
      if (!!this.privExpectedProfileId && enrollmentResponse.profiles.length === 1 && enrollmentResponse.profiles[0].profileId === this.privExpectedProfileId) {
        this.privExpectedProfileId = undefined;
        const profileInfo = enrollmentResponse.profiles[0];
        const result = new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profileInfo.enrollmentStatus), JSON.stringify(profileInfo), enrollmentResponse.status.reason);
        this.privDeferralMap.complete(requestId, result);
      } else if (enrollmentResponse.profiles.length > 0) {
        const iProfiles = enrollmentResponse.profiles;
        const profileResults = [];
        for (const profile of iProfiles) {
          profileResults.push(new Exports_js_3.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(profile.enrollmentStatus), JSON.stringify(profile), enrollmentResponse.status.reason));
        }
        this.privDeferralMap.complete(requestId, profileResults);
      }
    } else {
      throw new Error(`Voice Profile fetch request for requestID ${requestId} not found`);
    }
  }
  enrollmentReasonFrom(statusCode) {
    switch (statusCode.toLowerCase()) {
      case "enrolled":
        return Exports_js_3.ResultReason.EnrolledVoiceProfile;
      case "invalidlocale":
      case "invalidphrase":
      case "invalidaudioformat":
      case "invalidscenario":
      case "invalidprofilecount":
      case "invalidoperation":
      case "audiotooshort":
      case "audiotoolong":
      case "toomanyenrollments":
      case "storageconflict":
      case "profilenotfound":
      case "incompatibleprofiles":
      case "incompleteenrollment":
        return Exports_js_3.ResultReason.Canceled;
      default:
        return Exports_js_3.ResultReason.EnrollingVoiceProfile;
    }
  }
  scenarioFrom(profileType) {
    return profileType === Exports_js_3.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : profileType === Exports_js_3.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
  }
}
exports.VoiceServiceRecognizer = VoiceServiceRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/WebsocketMessageFormatter.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/WebsocketMessageFormatter.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebsocketMessageFormatter = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const CRLF = "\r\n";
class WebsocketMessageFormatter {
  toConnectionMessage(message) {
    const deferral = new Exports_js_1.Deferred();
    try {
      if (message.messageType === Exports_js_1.MessageType.Text) {
        const textMessage = message.textContent;
        let headers = {};
        let body = null;
        if (textMessage) {
          const headerBodySplit = textMessage.split("\r\n\r\n");
          if (headerBodySplit && headerBodySplit.length > 0) {
            headers = this.parseHeaders(headerBodySplit[0]);
            if (headerBodySplit.length > 1) {
              body = headerBodySplit[1];
            }
          }
        }
        deferral.resolve(new Exports_js_1.ConnectionMessage(message.messageType, body, headers, message.id));
      } else if (message.messageType === Exports_js_1.MessageType.Binary) {
        const binaryMessage = message.binaryContent;
        let headers = {};
        let body = null;
        if (!binaryMessage || binaryMessage.byteLength < 2) {
          throw new Error("Invalid binary message format. Header length missing.");
        }
        const dataView = new DataView(binaryMessage);
        const headerLength = dataView.getInt16(0);
        if (binaryMessage.byteLength < headerLength + 2) {
          throw new Error("Invalid binary message format. Header content missing.");
        }
        let headersString = "";
        for (let i = 0; i < headerLength; i++) {
          headersString += String.fromCharCode(dataView.getInt8(i + 2));
        }
        headers = this.parseHeaders(headersString);
        if (binaryMessage.byteLength > headerLength + 2) {
          body = binaryMessage.slice(2 + headerLength);
        }
        deferral.resolve(new Exports_js_1.ConnectionMessage(message.messageType, body, headers, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. Error: ${e}`);
    }
    return deferral.promise;
  }
  fromConnectionMessage(message) {
    const deferral = new Exports_js_1.Deferred();
    try {
      if (message.messageType === Exports_js_1.MessageType.Text) {
        const payload = `${this.makeHeaders(message)}${CRLF}${message.textBody ? message.textBody : ""}`;
        deferral.resolve(new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Text, payload, message.id));
      } else if (message.messageType === Exports_js_1.MessageType.Binary) {
        const headersString = this.makeHeaders(message);
        const content = message.binaryBody;
        const headerBuffer = this.stringToArrayBuffer(headersString);
        const headerInt8Array = new Int8Array(headerBuffer);
        const headerLength = headerInt8Array.byteLength;
        const payloadInt8Array = new Int8Array(2 + headerLength + (content ? content.byteLength : 0));
        payloadInt8Array[0] = headerLength >> 8 & 0xff;
        payloadInt8Array[1] = headerLength & 0xff;
        payloadInt8Array.set(headerInt8Array, 2);
        if (content) {
          const bodyInt8Array = new Int8Array(content);
          payloadInt8Array.set(bodyInt8Array, 2 + headerLength);
        }
        const payload = payloadInt8Array.buffer;
        deferral.resolve(new Exports_js_1.RawWebsocketMessage(Exports_js_1.MessageType.Binary, payload, message.id));
      }
    } catch (e) {
      deferral.reject(`Error formatting the message. ${e}`);
    }
    return deferral.promise;
  }
  makeHeaders(message) {
    let headersString = "";
    if (message.headers) {
      for (const header in message.headers) {
        if (header) {
          headersString += `${header}: ${message.headers[header]}${CRLF}`;
        }
      }
    }
    return headersString;
  }
  parseHeaders(headersString) {
    const headers = {};
    if (headersString) {
      const headerMatches = headersString.match(/[^\r\n]+/g);
      if (headers) {
        for (const header of headerMatches) {
          if (header) {
            const separatorIndex = header.indexOf(":");
            const headerName = separatorIndex > 0 ? header.substr(0, separatorIndex).trim().toLowerCase() : header;
            const headerValue = separatorIndex > 0 && header.length > separatorIndex + 1 ? header.substr(separatorIndex + 1).trim() : "";
            headers[headerName] = headerValue;
          }
        }
      }
    }
    return headers;
  }
  stringToArrayBuffer(str) {
    const buffer = new ArrayBuffer(str.length);
    const view = new DataView(buffer);
    for (let i = 0; i < str.length; i++) {
      view.setUint8(i, str.charCodeAt(i));
    }
    return buffer;
  }
}
exports.WebsocketMessageFormatter = WebsocketMessageFormatter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/AudioSourceEvents.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/AudioSourceEvents.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AudioStreamNodeErrorEvent = exports.AudioStreamNodeDetachedEvent = exports.AudioStreamNodeAttachedEvent = exports.AudioStreamNodeAttachingEvent = exports.AudioStreamNodeEvent = exports.AudioSourceErrorEvent = exports.AudioSourceOffEvent = exports.AudioSourceReadyEvent = exports.AudioSourceInitializingEvent = exports.AudioSourceEvent = void 0;
/* eslint-disable max-classes-per-file */
const PlatformEvent_js_1 = __webpack_require__(/*! ./PlatformEvent.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/PlatformEvent.js");
class AudioSourceEvent extends PlatformEvent_js_1.PlatformEvent {
  constructor(eventName, audioSourceId, eventType = PlatformEvent_js_1.EventType.Info) {
    super(eventName, eventType);
    this.privAudioSourceId = audioSourceId;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
}
exports.AudioSourceEvent = AudioSourceEvent;
class AudioSourceInitializingEvent extends AudioSourceEvent {
  constructor(audioSourceId) {
    super("AudioSourceInitializingEvent", audioSourceId);
  }
}
exports.AudioSourceInitializingEvent = AudioSourceInitializingEvent;
class AudioSourceReadyEvent extends AudioSourceEvent {
  constructor(audioSourceId) {
    super("AudioSourceReadyEvent", audioSourceId);
  }
}
exports.AudioSourceReadyEvent = AudioSourceReadyEvent;
class AudioSourceOffEvent extends AudioSourceEvent {
  constructor(audioSourceId) {
    super("AudioSourceOffEvent", audioSourceId);
  }
}
exports.AudioSourceOffEvent = AudioSourceOffEvent;
class AudioSourceErrorEvent extends AudioSourceEvent {
  constructor(audioSourceId, error) {
    super("AudioSourceErrorEvent", audioSourceId, PlatformEvent_js_1.EventType.Error);
    this.privError = error;
  }
  get error() {
    return this.privError;
  }
}
exports.AudioSourceErrorEvent = AudioSourceErrorEvent;
class AudioStreamNodeEvent extends AudioSourceEvent {
  constructor(eventName, audioSourceId, audioNodeId) {
    super(eventName, audioSourceId);
    this.privAudioNodeId = audioNodeId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
}
exports.AudioStreamNodeEvent = AudioStreamNodeEvent;
class AudioStreamNodeAttachingEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId) {
    super("AudioStreamNodeAttachingEvent", audioSourceId, audioNodeId);
  }
}
exports.AudioStreamNodeAttachingEvent = AudioStreamNodeAttachingEvent;
class AudioStreamNodeAttachedEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId) {
    super("AudioStreamNodeAttachedEvent", audioSourceId, audioNodeId);
  }
}
exports.AudioStreamNodeAttachedEvent = AudioStreamNodeAttachedEvent;
class AudioStreamNodeDetachedEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId) {
    super("AudioStreamNodeDetachedEvent", audioSourceId, audioNodeId);
  }
}
exports.AudioStreamNodeDetachedEvent = AudioStreamNodeDetachedEvent;
class AudioStreamNodeErrorEvent extends AudioStreamNodeEvent {
  constructor(audioSourceId, audioNodeId, error) {
    super("AudioStreamNodeErrorEvent", audioSourceId, audioNodeId);
    this.privError = error;
  }
  get error() {
    return this.privError;
  }
}
exports.AudioStreamNodeErrorEvent = AudioStreamNodeErrorEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/BackgroundError.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/BackgroundError.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BackgroundEvent = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
class BackgroundEvent extends Exports_js_1.PlatformEvent {
  constructor(error) {
    super("BackgroundEvent", Exports_js_1.EventType.Error);
    this.privError = error;
  }
  get error() {
    return this.privError;
  }
}
exports.BackgroundEvent = BackgroundEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ChunkedArrayBufferStream.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ChunkedArrayBufferStream.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChunkedArrayBufferStream = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
class ChunkedArrayBufferStream extends Exports_js_1.Stream {
  constructor(targetChunkSize, streamId) {
    super(streamId);
    this.privTargetChunkSize = Math.round(targetChunkSize);
    this.privNextBufferReadyBytes = 0;
  }
  writeStreamChunk(chunk) {
    // No pending write, and the buffer is the right size so write it.
    if (chunk.isEnd || 0 === this.privNextBufferReadyBytes && chunk.buffer.byteLength === this.privTargetChunkSize) {
      super.writeStreamChunk(chunk);
      return;
    }
    let bytesCopiedFromBuffer = 0;
    while (bytesCopiedFromBuffer < chunk.buffer.byteLength) {
      // Fill the next buffer.
      if (undefined === this.privNextBufferToWrite) {
        this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize);
        this.privNextBufferStartTime = chunk.timeReceived;
      }
      // Find out how many bytes we can copy into the read buffer.
      const bytesToCopy = Math.min(chunk.buffer.byteLength - bytesCopiedFromBuffer, this.privTargetChunkSize - this.privNextBufferReadyBytes);
      const targetView = new Uint8Array(this.privNextBufferToWrite);
      const sourceView = new Uint8Array(chunk.buffer.slice(bytesCopiedFromBuffer, bytesToCopy + bytesCopiedFromBuffer));
      targetView.set(sourceView, this.privNextBufferReadyBytes);
      this.privNextBufferReadyBytes += bytesToCopy;
      bytesCopiedFromBuffer += bytesToCopy;
      // Are we ready to write?
      if (this.privNextBufferReadyBytes === this.privTargetChunkSize) {
        super.writeStreamChunk({
          buffer: this.privNextBufferToWrite,
          isEnd: false,
          timeReceived: this.privNextBufferStartTime
        });
        this.privNextBufferReadyBytes = 0;
        this.privNextBufferToWrite = undefined;
      }
    }
  }
  close() {
    // Send whatever is pending, then close the base class.
    if (0 !== this.privNextBufferReadyBytes && !this.isClosed) {
      super.writeStreamChunk({
        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
        isEnd: false,
        timeReceived: this.privNextBufferStartTime
      });
    }
    super.close();
  }
}
exports.ChunkedArrayBufferStream = ChunkedArrayBufferStream;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionEvents.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionEvents.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionMessageSentEvent = exports.ConnectionMessageReceivedEvent = exports.ConnectionEstablishErrorEvent = exports.ConnectionErrorEvent = exports.ConnectionClosedEvent = exports.ConnectionEstablishedEvent = exports.ConnectionStartEvent = exports.ConnectionEvent = exports.ServiceEvent = void 0;
const PlatformEvent_js_1 = __webpack_require__(/*! ./PlatformEvent.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/PlatformEvent.js");
class ServiceEvent extends PlatformEvent_js_1.PlatformEvent {
  constructor(eventName, jsonstring, eventType = PlatformEvent_js_1.EventType.Info) {
    super(eventName, eventType);
    this.privJsonResult = jsonstring;
  }
  get jsonString() {
    return this.privJsonResult;
  }
}
exports.ServiceEvent = ServiceEvent;
class ConnectionEvent extends PlatformEvent_js_1.PlatformEvent {
  constructor(eventName, connectionId, eventType = PlatformEvent_js_1.EventType.Info) {
    super(eventName, eventType);
    this.privConnectionId = connectionId;
  }
  get connectionId() {
    return this.privConnectionId;
  }
}
exports.ConnectionEvent = ConnectionEvent;
class ConnectionStartEvent extends ConnectionEvent {
  constructor(connectionId, uri, headers) {
    super("ConnectionStartEvent", connectionId);
    this.privUri = uri;
    this.privHeaders = headers;
  }
  get uri() {
    return this.privUri;
  }
  get headers() {
    return this.privHeaders;
  }
}
exports.ConnectionStartEvent = ConnectionStartEvent;
class ConnectionEstablishedEvent extends ConnectionEvent {
  constructor(connectionId) {
    super("ConnectionEstablishedEvent", connectionId);
  }
}
exports.ConnectionEstablishedEvent = ConnectionEstablishedEvent;
class ConnectionClosedEvent extends ConnectionEvent {
  constructor(connectionId, statusCode, reason) {
    super("ConnectionClosedEvent", connectionId, PlatformEvent_js_1.EventType.Debug);
    this.privReason = reason;
    this.privStatusCode = statusCode;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
exports.ConnectionClosedEvent = ConnectionClosedEvent;
class ConnectionErrorEvent extends ConnectionEvent {
  constructor(connectionId, message, type) {
    super("ConnectionErrorEvent", connectionId, PlatformEvent_js_1.EventType.Debug);
    this.privMessage = message;
    this.privType = type;
  }
  get message() {
    return this.privMessage;
  }
  get type() {
    return this.privType;
  }
}
exports.ConnectionErrorEvent = ConnectionErrorEvent;
class ConnectionEstablishErrorEvent extends ConnectionEvent {
  constructor(connectionId, statuscode, reason) {
    super("ConnectionEstablishErrorEvent", connectionId, PlatformEvent_js_1.EventType.Error);
    this.privStatusCode = statuscode;
    this.privReason = reason;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
exports.ConnectionEstablishErrorEvent = ConnectionEstablishErrorEvent;
class ConnectionMessageReceivedEvent extends ConnectionEvent {
  constructor(connectionId, networkReceivedTimeISO, message) {
    super("ConnectionMessageReceivedEvent", connectionId);
    this.privNetworkReceivedTime = networkReceivedTimeISO;
    this.privMessage = message;
  }
  get networkReceivedTime() {
    return this.privNetworkReceivedTime;
  }
  get message() {
    return this.privMessage;
  }
}
exports.ConnectionMessageReceivedEvent = ConnectionMessageReceivedEvent;
class ConnectionMessageSentEvent extends ConnectionEvent {
  constructor(connectionId, networkSentTimeISO, message) {
    super("ConnectionMessageSentEvent", connectionId);
    this.privNetworkSentTime = networkSentTimeISO;
    this.privMessage = message;
  }
  get networkSentTime() {
    return this.privNetworkSentTime;
  }
  get message() {
    return this.privMessage;
  }
}
exports.ConnectionMessageSentEvent = ConnectionMessageSentEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionMessage.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionMessage.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/* eslint-disable @typescript-eslint/no-unsafe-return */
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionMessage = exports.MessageType = void 0;
const Error_js_1 = __webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const Guid_js_1 = __webpack_require__(/*! ./Guid.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js");
var MessageType;
(function (MessageType) {
  MessageType[MessageType["Text"] = 0] = "Text";
  MessageType[MessageType["Binary"] = 1] = "Binary";
})(MessageType = exports.MessageType || (exports.MessageType = {}));
class ConnectionMessage {
  constructor(messageType, body, headers, id) {
    this.privBody = null;
    if (messageType === MessageType.Text && body && !(typeof body === "string")) {
      throw new Error_js_1.InvalidOperationError("Payload must be a string");
    }
    if (messageType === MessageType.Binary && body && !(body instanceof ArrayBuffer)) {
      throw new Error_js_1.InvalidOperationError("Payload must be ArrayBuffer");
    }
    this.privMessageType = messageType;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    this.privBody = body;
    this.privHeaders = headers ? headers : {};
    this.privId = id ? id : Guid_js_1.createNoDashGuid();
    switch (this.messageType) {
      case MessageType.Binary:
        this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
        break;
      case MessageType.Text:
        this.privSize = this.textBody.length;
    }
  }
  get messageType() {
    return this.privMessageType;
  }
  get headers() {
    return this.privHeaders;
  }
  get body() {
    return this.privBody;
  }
  get textBody() {
    if (this.privMessageType === MessageType.Binary) {
      throw new Error_js_1.InvalidOperationError("Not supported for binary message");
    }
    return this.privBody;
  }
  get binaryBody() {
    if (this.privMessageType === MessageType.Text) {
      throw new Error_js_1.InvalidOperationError("Not supported for text message");
    }
    return this.privBody;
  }
  get id() {
    return this.privId;
  }
}
exports.ConnectionMessage = ConnectionMessage;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionOpenResponse.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionOpenResponse.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionOpenResponse = void 0;
class ConnectionOpenResponse {
  constructor(statusCode, reason) {
    this.privStatusCode = statusCode;
    this.privReason = reason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
  get reason() {
    return this.privReason;
  }
}
exports.ConnectionOpenResponse = ConnectionOpenResponse;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DeferralMap.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DeferralMap.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DeferralMap = void 0;
/**
 * The error that is thrown when an argument passed in is null.
 *
 * @export
 * @class DefferalMap
 */
class DeferralMap {
  constructor() {
    this.privMap = {};
  }
  add(id, deferral) {
    this.privMap[id] = deferral;
  }
  getId(id) {
    return this.privMap[id];
  }
  complete(id, result) {
    try {
      this.privMap[id].resolve(result);
    } catch (error) {
      this.privMap[id].reject(error);
    } finally {
      this.privMap[id] = undefined;
    }
  }
}
exports.DeferralMap = DeferralMap;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DialogEvents.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DialogEvents.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SendingAgentContextMessageEvent = exports.DialogEvent = void 0;
const PlatformEvent_js_1 = __webpack_require__(/*! ./PlatformEvent.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/PlatformEvent.js");
class DialogEvent extends PlatformEvent_js_1.PlatformEvent {
  constructor(eventName, eventType = PlatformEvent_js_1.EventType.Info) {
    super(eventName, eventType);
  }
}
exports.DialogEvent = DialogEvent;
class SendingAgentContextMessageEvent extends DialogEvent {
  constructor(agentConfig) {
    super("SendingAgentContextMessageEvent");
    this.privAgentConfig = agentConfig;
  }
  get agentConfig() {
    return this.privAgentConfig;
  }
}
exports.SendingAgentContextMessageEvent = SendingAgentContextMessageEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ObjectDisposedError = exports.InvalidOperationError = exports.ArgumentNullError = void 0;
/* eslint-disable max-classes-per-file */
/**
 * The error that is thrown when an argument passed in is null.
 *
 * @export
 * @class ArgumentNullError
 * @extends {Error}
 */
class ArgumentNullError extends Error {
  /**
   * Creates an instance of ArgumentNullError.
   *
   * @param {string} argumentName - Name of the argument that is null
   *
   * @memberOf ArgumentNullError
   */
  constructor(argumentName) {
    super(argumentName);
    this.name = "ArgumentNull";
    this.message = argumentName;
  }
}
exports.ArgumentNullError = ArgumentNullError;
/**
 * The error that is thrown when an invalid operation is performed in the code.
 *
 * @export
 * @class InvalidOperationError
 * @extends {Error}
 */
class InvalidOperationError extends Error {
  /**
   * Creates an instance of InvalidOperationError.
   *
   * @param {string} error - The error
   *
   * @memberOf InvalidOperationError
   */
  constructor(error) {
    super(error);
    this.name = "InvalidOperation";
    this.message = error;
  }
}
exports.InvalidOperationError = InvalidOperationError;
/**
 * The error that is thrown when an object is disposed.
 *
 * @export
 * @class ObjectDisposedError
 * @extends {Error}
 */
class ObjectDisposedError extends Error {
  /**
   * Creates an instance of ObjectDisposedError.
   *
   * @param {string} objectName - The object that is disposed
   * @param {string} error - The error
   *
   * @memberOf ObjectDisposedError
   */
  constructor(objectName, error) {
    super(error);
    this.name = objectName + "ObjectDisposed";
    this.message = error;
  }
}
exports.ObjectDisposedError = ObjectDisposedError;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/EventSource.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/EventSource.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.EventSource = void 0;
const Error_js_1 = __webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const Guid_js_1 = __webpack_require__(/*! ./Guid.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js");
class EventSource {
  constructor(metadata) {
    this.privEventListeners = {};
    this.privIsDisposed = false;
    this.privConsoleListener = undefined;
    this.privMetadata = metadata;
  }
  onEvent(event) {
    if (this.isDisposed()) {
      throw new Error_js_1.ObjectDisposedError("EventSource");
    }
    if (this.metadata) {
      for (const paramName in this.metadata) {
        if (paramName) {
          if (event.metadata) {
            if (!event.metadata[paramName]) {
              event.metadata[paramName] = this.metadata[paramName];
            }
          }
        }
      }
    }
    for (const eventId in this.privEventListeners) {
      if (eventId && this.privEventListeners[eventId]) {
        this.privEventListeners[eventId](event);
      }
    }
  }
  attach(onEventCallback) {
    const id = Guid_js_1.createNoDashGuid();
    this.privEventListeners[id] = onEventCallback;
    return {
      detach: () => {
        delete this.privEventListeners[id];
        return Promise.resolve();
      }
    };
  }
  attachListener(listener) {
    return this.attach(e => listener.onEvent(e));
  }
  attachConsoleListener(listener) {
    if (!!this.privConsoleListener) {
      void this.privConsoleListener.detach(); // Detach implementation for eventListeners is synchronous
    }
    this.privConsoleListener = this.attach(e => listener.onEvent(e));
    return this.privConsoleListener;
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  dispose() {
    this.privEventListeners = null;
    this.privIsDisposed = true;
  }
  get metadata() {
    return this.privMetadata;
  }
}
exports.EventSource = EventSource;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Events.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Events.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Events = void 0;
const Error_js_1 = __webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const EventSource_js_1 = __webpack_require__(/*! ./EventSource.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/EventSource.js");
class Events {
  static setEventSource(eventSource) {
    if (!eventSource) {
      throw new Error_js_1.ArgumentNullError("eventSource");
    }
    Events.privInstance = eventSource;
  }
  static get instance() {
    return Events.privInstance;
  }
}
exports.Events = Events;
Events.privInstance = new EventSource_js_1.EventSource();

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
__exportStar(__webpack_require__(/*! ./AudioSourceEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/AudioSourceEvents.js"), exports);
__exportStar(__webpack_require__(/*! ./ConnectionEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionEvents.js"), exports);
__exportStar(__webpack_require__(/*! ./ConnectionMessage.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionMessage.js"), exports);
__exportStar(__webpack_require__(/*! ./ConnectionOpenResponse.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionOpenResponse.js"), exports);
__exportStar(__webpack_require__(/*! ./DeferralMap.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DeferralMap.js"), exports);
__exportStar(__webpack_require__(/*! ./DialogEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/DialogEvents.js"), exports);
__exportStar(__webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js"), exports);
__exportStar(__webpack_require__(/*! ./Events.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Events.js"), exports);
__exportStar(__webpack_require__(/*! ./EventSource.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/EventSource.js"), exports);
__exportStar(__webpack_require__(/*! ./Guid.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js"), exports);
__exportStar(__webpack_require__(/*! ./IAudioSource.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IAudioSource.js"), exports);
__exportStar(__webpack_require__(/*! ./IConnection.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IConnection.js"), exports);
__exportStar(__webpack_require__(/*! ./IDetachable.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDetachable.js"), exports);
__exportStar(__webpack_require__(/*! ./IDictionary.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDictionary.js"), exports);
__exportStar(__webpack_require__(/*! ./IDisposable.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDisposable.js"), exports);
__exportStar(__webpack_require__(/*! ./IEventListener.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IEventListener.js"), exports);
__exportStar(__webpack_require__(/*! ./IEventSource.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IEventSource.js"), exports);
__exportStar(__webpack_require__(/*! ./IErrorMessages.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IErrorMessages.js"), exports);
__exportStar(__webpack_require__(/*! ./ITimer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ITimer.js"), exports);
__exportStar(__webpack_require__(/*! ./IWebsocketMessageFormatter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IWebsocketMessageFormatter.js"), exports);
__exportStar(__webpack_require__(/*! ./List.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/List.js"), exports);
__exportStar(__webpack_require__(/*! ./PlatformEvent.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/PlatformEvent.js"), exports);
__exportStar(__webpack_require__(/*! ./Promise.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Promise.js"), exports);
__exportStar(__webpack_require__(/*! ./Queue.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js"), exports);
__exportStar(__webpack_require__(/*! ./RawWebsocketMessage.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/RawWebsocketMessage.js"), exports);
__exportStar(__webpack_require__(/*! ./RiffPcmEncoder.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/RiffPcmEncoder.js"), exports);
__exportStar(__webpack_require__(/*! ./Stream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Stream.js"), exports);
var TranslationStatus_js_1 = __webpack_require__(/*! ../common.speech/TranslationStatus.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/TranslationStatus.js");
Object.defineProperty(exports, "TranslationStatus", ({
  enumerable: true,
  get: function () {
    return TranslationStatus_js_1.TranslationStatus;
  }
}));
__exportStar(__webpack_require__(/*! ./ChunkedArrayBufferStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ChunkedArrayBufferStream.js"), exports);
__exportStar(__webpack_require__(/*! ./IAudioDestination.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IAudioDestination.js"), exports);
__exportStar(__webpack_require__(/*! ./Timeout.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Timeout.js"), exports);
__exportStar(__webpack_require__(/*! ./OCSPEvents.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/OCSPEvents.js"), exports);
__exportStar(__webpack_require__(/*! ./BackgroundError.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/BackgroundError.js"), exports);

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createNoDashGuid = exports.createGuid = void 0;
const uuid_1 = __webpack_require__(/*! uuid */ "./node_modules/uuid/dist/commonjs-browser/index.js");
const createGuid = () => uuid_1.v4();
exports.createGuid = createGuid;
const createNoDashGuid = () => createGuid().replace(new RegExp("-", "g"), "").toUpperCase();
exports.createNoDashGuid = createNoDashGuid;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IAudioDestination.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IAudioDestination.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IAudioSource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IAudioSource.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IConnection.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IConnection.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionState = void 0;
var ConnectionState;
(function (ConnectionState) {
  ConnectionState[ConnectionState["None"] = 0] = "None";
  ConnectionState[ConnectionState["Connected"] = 1] = "Connected";
  ConnectionState[ConnectionState["Connecting"] = 2] = "Connecting";
  ConnectionState[ConnectionState["Disconnected"] = 3] = "Disconnected";
})(ConnectionState = exports.ConnectionState || (exports.ConnectionState = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDetachable.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDetachable.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDictionary.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDictionary.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDisposable.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IDisposable.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IErrorMessages.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IErrorMessages.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IEventListener.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IEventListener.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IEventSource.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IEventSource.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ITimer.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ITimer.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IWebsocketMessageFormatter.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/IWebsocketMessageFormatter.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/List.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/List.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.List = void 0;
const Error_js_1 = __webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
class List {
  constructor(list) {
    this.privSubscriptionIdCounter = 0;
    this.privAddSubscriptions = {};
    this.privRemoveSubscriptions = {};
    this.privDisposedSubscriptions = {};
    this.privDisposeReason = null;
    this.privList = [];
    // copy the list rather than taking as is.
    if (list) {
      for (const item of list) {
        this.privList.push(item);
      }
    }
  }
  get(itemIndex) {
    this.throwIfDisposed();
    return this.privList[itemIndex];
  }
  first() {
    return this.get(0);
  }
  last() {
    return this.get(this.length() - 1);
  }
  add(item) {
    this.throwIfDisposed();
    this.insertAt(this.privList.length, item);
  }
  insertAt(index, item) {
    this.throwIfDisposed();
    if (index === 0) {
      this.privList.unshift(item);
    } else if (index === this.privList.length) {
      this.privList.push(item);
    } else {
      this.privList.splice(index, 0, item);
    }
    this.triggerSubscriptions(this.privAddSubscriptions);
  }
  removeFirst() {
    this.throwIfDisposed();
    return this.removeAt(0);
  }
  removeLast() {
    this.throwIfDisposed();
    return this.removeAt(this.length() - 1);
  }
  removeAt(index) {
    this.throwIfDisposed();
    return this.remove(index, 1)[0];
  }
  remove(index, count) {
    this.throwIfDisposed();
    const removedElements = this.privList.splice(index, count);
    this.triggerSubscriptions(this.privRemoveSubscriptions);
    return removedElements;
  }
  clear() {
    this.throwIfDisposed();
    this.remove(0, this.length());
  }
  length() {
    this.throwIfDisposed();
    return this.privList.length;
  }
  onAdded(addedCallback) {
    this.throwIfDisposed();
    const subscriptionId = this.privSubscriptionIdCounter++;
    this.privAddSubscriptions[subscriptionId] = addedCallback;
    return {
      detach: () => {
        delete this.privAddSubscriptions[subscriptionId];
        return Promise.resolve();
      }
    };
  }
  onRemoved(removedCallback) {
    this.throwIfDisposed();
    const subscriptionId = this.privSubscriptionIdCounter++;
    this.privRemoveSubscriptions[subscriptionId] = removedCallback;
    return {
      detach: () => {
        delete this.privRemoveSubscriptions[subscriptionId];
        return Promise.resolve();
      }
    };
  }
  onDisposed(disposedCallback) {
    this.throwIfDisposed();
    const subscriptionId = this.privSubscriptionIdCounter++;
    this.privDisposedSubscriptions[subscriptionId] = disposedCallback;
    return {
      detach: () => {
        delete this.privDisposedSubscriptions[subscriptionId];
        return Promise.resolve();
      }
    };
  }
  join(seperator) {
    this.throwIfDisposed();
    return this.privList.join(seperator);
  }
  toArray() {
    const cloneCopy = Array();
    this.privList.forEach(val => {
      cloneCopy.push(val);
    });
    return cloneCopy;
  }
  any(callback) {
    this.throwIfDisposed();
    if (callback) {
      return this.where(callback).length() > 0;
    } else {
      return this.length() > 0;
    }
  }
  all(callback) {
    this.throwIfDisposed();
    return this.where(callback).length() === this.length();
  }
  forEach(callback) {
    this.throwIfDisposed();
    for (let i = 0; i < this.length(); i++) {
      callback(this.privList[i], i);
    }
  }
  select(callback) {
    this.throwIfDisposed();
    const selectList = [];
    for (let i = 0; i < this.privList.length; i++) {
      selectList.push(callback(this.privList[i], i));
    }
    return new List(selectList);
  }
  where(callback) {
    this.throwIfDisposed();
    const filteredList = new List();
    for (let i = 0; i < this.privList.length; i++) {
      if (callback(this.privList[i], i)) {
        filteredList.add(this.privList[i]);
      }
    }
    return filteredList;
  }
  orderBy(compareFn) {
    this.throwIfDisposed();
    const clonedArray = this.toArray();
    const orderedArray = clonedArray.sort(compareFn);
    return new List(orderedArray);
  }
  orderByDesc(compareFn) {
    this.throwIfDisposed();
    return this.orderBy((a, b) => compareFn(b, a));
  }
  clone() {
    this.throwIfDisposed();
    return new List(this.toArray());
  }
  concat(list) {
    this.throwIfDisposed();
    return new List(this.privList.concat(list.toArray()));
  }
  concatArray(array) {
    this.throwIfDisposed();
    return new List(this.privList.concat(array));
  }
  isDisposed() {
    return this.privList == null;
  }
  dispose(reason) {
    if (!this.isDisposed()) {
      this.privDisposeReason = reason;
      this.privList = null;
      this.privAddSubscriptions = null;
      this.privRemoveSubscriptions = null;
      this.triggerSubscriptions(this.privDisposedSubscriptions);
    }
  }
  throwIfDisposed() {
    if (this.isDisposed()) {
      throw new Error_js_1.ObjectDisposedError("List", this.privDisposeReason);
    }
  }
  triggerSubscriptions(subscriptions) {
    if (subscriptions) {
      for (const subscriptionId in subscriptions) {
        if (subscriptionId) {
          subscriptions[subscriptionId]();
        }
      }
    }
  }
}
exports.List = List;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/OCSPEvents.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/OCSPEvents.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OCSPCacheUpdateErrorEvent = exports.OCSPResponseRetrievedEvent = exports.OCSPCacheFetchErrorEvent = exports.OCSPVerificationFailedEvent = exports.OCSPCacheHitEvent = exports.OCSPCacheEntryNeedsRefreshEvent = exports.OCSPCacheEntryExpiredEvent = exports.OCSPWSUpgradeStartedEvent = exports.OCSPStapleReceivedEvent = exports.OCSPCacheUpdateCompleteEvent = exports.OCSPDiskCacheStoreEvent = exports.OCSPMemoryCacheStoreEvent = exports.OCSPCacheUpdateNeededEvent = exports.OCSPDiskCacheHitEvent = exports.OCSPCacheMissEvent = exports.OCSPMemoryCacheHitEvent = exports.OCSPEvent = void 0;
/* eslint-disable max-classes-per-file */
const PlatformEvent_js_1 = __webpack_require__(/*! ./PlatformEvent.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/PlatformEvent.js");
class OCSPEvent extends PlatformEvent_js_1.PlatformEvent {
  constructor(eventName, eventType, signature) {
    super(eventName, eventType);
    this.privSignature = signature;
  }
}
exports.OCSPEvent = OCSPEvent;
class OCSPMemoryCacheHitEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPMemoryCacheHitEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
exports.OCSPMemoryCacheHitEvent = OCSPMemoryCacheHitEvent;
class OCSPCacheMissEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPCacheMissEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
exports.OCSPCacheMissEvent = OCSPCacheMissEvent;
class OCSPDiskCacheHitEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPDiskCacheHitEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
exports.OCSPDiskCacheHitEvent = OCSPDiskCacheHitEvent;
class OCSPCacheUpdateNeededEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPCacheUpdateNeededEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
exports.OCSPCacheUpdateNeededEvent = OCSPCacheUpdateNeededEvent;
class OCSPMemoryCacheStoreEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPMemoryCacheStoreEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
exports.OCSPMemoryCacheStoreEvent = OCSPMemoryCacheStoreEvent;
class OCSPDiskCacheStoreEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPDiskCacheStoreEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
exports.OCSPDiskCacheStoreEvent = OCSPDiskCacheStoreEvent;
class OCSPCacheUpdateCompleteEvent extends OCSPEvent {
  constructor(signature) {
    super("OCSPCacheUpdateCompleteEvent", PlatformEvent_js_1.EventType.Debug, signature);
  }
}
exports.OCSPCacheUpdateCompleteEvent = OCSPCacheUpdateCompleteEvent;
class OCSPStapleReceivedEvent extends OCSPEvent {
  constructor() {
    super("OCSPStapleReceivedEvent", PlatformEvent_js_1.EventType.Debug, "");
  }
}
exports.OCSPStapleReceivedEvent = OCSPStapleReceivedEvent;
class OCSPWSUpgradeStartedEvent extends OCSPEvent {
  constructor(serialNumber) {
    super("OCSPWSUpgradeStartedEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
  }
}
exports.OCSPWSUpgradeStartedEvent = OCSPWSUpgradeStartedEvent;
class OCSPCacheEntryExpiredEvent extends OCSPEvent {
  constructor(serialNumber, expireTime) {
    super("OCSPCacheEntryExpiredEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privExpireTime = expireTime;
  }
}
exports.OCSPCacheEntryExpiredEvent = OCSPCacheEntryExpiredEvent;
class OCSPCacheEntryNeedsRefreshEvent extends OCSPEvent {
  constructor(serialNumber, startTime, expireTime) {
    super("OCSPCacheEntryNeedsRefreshEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privExpireTime = expireTime;
    this.privStartTime = startTime;
  }
}
exports.OCSPCacheEntryNeedsRefreshEvent = OCSPCacheEntryNeedsRefreshEvent;
class OCSPCacheHitEvent extends OCSPEvent {
  constructor(serialNumber, startTime, expireTime) {
    super("OCSPCacheHitEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privExpireTime = expireTime;
    this.privExpireTimeString = new Date(expireTime).toLocaleDateString();
    this.privStartTime = startTime;
    this.privStartTimeString = new Date(startTime).toLocaleTimeString();
  }
}
exports.OCSPCacheHitEvent = OCSPCacheHitEvent;
class OCSPVerificationFailedEvent extends OCSPEvent {
  constructor(serialNumber, error) {
    super("OCSPVerificationFailedEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privError = error;
  }
}
exports.OCSPVerificationFailedEvent = OCSPVerificationFailedEvent;
class OCSPCacheFetchErrorEvent extends OCSPEvent {
  constructor(serialNumber, error) {
    super("OCSPCacheFetchErrorEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privError = error;
  }
}
exports.OCSPCacheFetchErrorEvent = OCSPCacheFetchErrorEvent;
class OCSPResponseRetrievedEvent extends OCSPEvent {
  constructor(serialNumber) {
    super("OCSPResponseRetrievedEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
  }
}
exports.OCSPResponseRetrievedEvent = OCSPResponseRetrievedEvent;
class OCSPCacheUpdateErrorEvent extends OCSPEvent {
  constructor(serialNumber, error) {
    super("OCSPCacheUpdateErrorEvent", PlatformEvent_js_1.EventType.Debug, serialNumber);
    this.privError = error;
  }
}
exports.OCSPCacheUpdateErrorEvent = OCSPCacheUpdateErrorEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/PlatformEvent.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/PlatformEvent.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PlatformEvent = exports.EventType = void 0;
const Guid_js_1 = __webpack_require__(/*! ./Guid.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js");
var EventType;
(function (EventType) {
  EventType[EventType["Debug"] = 0] = "Debug";
  EventType[EventType["Info"] = 1] = "Info";
  EventType[EventType["Warning"] = 2] = "Warning";
  EventType[EventType["Error"] = 3] = "Error";
  EventType[EventType["None"] = 4] = "None";
})(EventType = exports.EventType || (exports.EventType = {}));
class PlatformEvent {
  constructor(eventName, eventType) {
    this.privName = eventName;
    this.privEventId = Guid_js_1.createNoDashGuid();
    this.privEventTime = new Date().toISOString();
    this.privEventType = eventType;
    this.privMetadata = {};
  }
  get name() {
    return this.privName;
  }
  get eventId() {
    return this.privEventId;
  }
  get eventTime() {
    return this.privEventTime;
  }
  get eventType() {
    return this.privEventType;
  }
  get metadata() {
    return this.privMetadata;
  }
}
exports.PlatformEvent = PlatformEvent;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Promise.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Promise.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.marshalPromiseToCallbacks = exports.Sink = exports.Deferred = exports.PromiseResultEventSource = exports.PromiseResult = exports.PromiseState = void 0;
/* eslint-disable max-classes-per-file, @typescript-eslint/typedef */
var PromiseState;
(function (PromiseState) {
  PromiseState[PromiseState["None"] = 0] = "None";
  PromiseState[PromiseState["Resolved"] = 1] = "Resolved";
  PromiseState[PromiseState["Rejected"] = 2] = "Rejected";
})(PromiseState = exports.PromiseState || (exports.PromiseState = {}));
class PromiseResult {
  constructor(promiseResultEventSource) {
    this.throwIfError = () => {
      if (this.isError) {
        throw this.error;
      }
    };
    promiseResultEventSource.on(result => {
      if (!this.privIsCompleted) {
        this.privIsCompleted = true;
        this.privIsError = false;
        this.privResult = result;
      }
    }, error => {
      if (!this.privIsCompleted) {
        this.privIsCompleted = true;
        this.privIsError = true;
        this.privError = error;
      }
    });
  }
  get isCompleted() {
    return this.privIsCompleted;
  }
  get isError() {
    return this.privIsError;
  }
  get error() {
    return this.privError;
  }
  get result() {
    return this.privResult;
  }
}
exports.PromiseResult = PromiseResult;
class PromiseResultEventSource {
  constructor() {
    this.setResult = result => {
      this.privOnSetResult(result);
    };
    this.setError = error => {
      this.privOnSetError(error);
    };
    this.on = (onSetResult, onSetError) => {
      this.privOnSetResult = onSetResult;
      this.privOnSetError = onSetError;
    };
  }
}
exports.PromiseResultEventSource = PromiseResultEventSource;
class Deferred {
  constructor() {
    this.resolve = result => {
      this.privResolve(result);
      return this;
    };
    this.reject = error => {
      this.privReject(error);
      return this;
    };
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    this.privPromise = new Promise((resolve, reject) => {
      this.privResolve = resolve;
      this.privReject = reject;
    });
  }
  get promise() {
    return this.privPromise;
  }
}
exports.Deferred = Deferred;
class Sink {
  constructor() {
    this.privState = PromiseState.None;
    this.privPromiseResult = null;
    this.privPromiseResultEvents = null;
    this.privSuccessHandlers = [];
    this.privErrorHandlers = [];
    this.privPromiseResultEvents = new PromiseResultEventSource();
    this.privPromiseResult = new PromiseResult(this.privPromiseResultEvents);
  }
  get state() {
    return this.privState;
  }
  get result() {
    return this.privPromiseResult;
  }
  resolve(result) {
    if (this.privState !== PromiseState.None) {
      throw new Error("'Cannot resolve a completed promise'");
    }
    this.privState = PromiseState.Resolved;
    this.privPromiseResultEvents.setResult(result);
    for (let i = 0; i < this.privSuccessHandlers.length; i++) {
      this.executeSuccessCallback(result, this.privSuccessHandlers[i], this.privErrorHandlers[i]);
    }
    this.detachHandlers();
  }
  reject(error) {
    if (this.privState !== PromiseState.None) {
      throw new Error("'Cannot reject a completed promise'");
    }
    this.privState = PromiseState.Rejected;
    this.privPromiseResultEvents.setError(error);
    for (const errorHandler of this.privErrorHandlers) {
      this.executeErrorCallback(error, errorHandler);
    }
    this.detachHandlers();
  }
  on(successCallback, errorCallback) {
    if (successCallback == null) {
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      successCallback = () => {};
    }
    if (this.privState === PromiseState.None) {
      this.privSuccessHandlers.push(successCallback);
      this.privErrorHandlers.push(errorCallback);
    } else {
      if (this.privState === PromiseState.Resolved) {
        this.executeSuccessCallback(this.privPromiseResult.result, successCallback, errorCallback);
      } else if (this.privState === PromiseState.Rejected) {
        this.executeErrorCallback(this.privPromiseResult.error, errorCallback);
      }
      this.detachHandlers();
    }
  }
  executeSuccessCallback(result, successCallback, errorCallback) {
    try {
      successCallback(result);
    } catch (e) {
      this.executeErrorCallback(`'Unhandled callback error: ${e}'`, errorCallback);
    }
  }
  executeErrorCallback(error, errorCallback) {
    if (errorCallback) {
      try {
        errorCallback(error);
      } catch (e) {
        throw new Error(`'Unhandled callback error: ${e}. InnerError: ${error}'`);
      }
    } else {
      throw new Error(`'Unhandled error: ${error}'`);
    }
  }
  detachHandlers() {
    this.privErrorHandlers = [];
    this.privSuccessHandlers = [];
  }
}
exports.Sink = Sink;
// eslint-disable-next-line prefer-arrow/prefer-arrow-functions
function marshalPromiseToCallbacks(promise, cb, err) {
  promise.then(val => {
    try {
      if (!!cb) {
        cb(val);
      }
    } catch (error) {
      if (!!err) {
        try {
          if (error instanceof Error) {
            const typedError = error;
            err(typedError.name + ": " + typedError.message);
          } else {
            err(error);
          }
          // eslint-disable-next-line no-empty
        } catch (error) {}
      }
    }
  }, error => {
    if (!!err) {
      try {
        if (error instanceof Error) {
          const typedError = error;
          err(typedError.name + ": " + typedError.message);
        } else {
          err(error);
        }
        // eslint-disable-next-line no-empty
      } catch (error) {}
    }
  });
}
exports.marshalPromiseToCallbacks = marshalPromiseToCallbacks;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Queue = void 0;
const Error_js_1 = __webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const List_js_1 = __webpack_require__(/*! ./List.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/List.js");
const Promise_js_1 = __webpack_require__(/*! ./Promise.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Promise.js");
var SubscriberType;
(function (SubscriberType) {
  SubscriberType[SubscriberType["Dequeue"] = 0] = "Dequeue";
  SubscriberType[SubscriberType["Peek"] = 1] = "Peek";
})(SubscriberType || (SubscriberType = {}));
class Queue {
  constructor(list) {
    this.privPromiseStore = new List_js_1.List();
    this.privIsDrainInProgress = false;
    this.privIsDisposing = false;
    this.privDisposeReason = null;
    this.privList = list ? list : new List_js_1.List();
    this.privDetachables = [];
    this.privSubscribers = new List_js_1.List();
    this.privDetachables.push(this.privList.onAdded(() => this.drain()));
  }
  enqueue(item) {
    this.throwIfDispose();
    this.enqueueFromPromise(new Promise(resolve => resolve(item)));
  }
  enqueueFromPromise(promise) {
    this.throwIfDispose();
    promise.then(val => {
      this.privList.add(val);
      // eslint-disable-next-line @typescript-eslint/no-empty-function
    }, () => {});
  }
  dequeue() {
    this.throwIfDispose();
    const deferredSubscriber = new Promise_js_1.Deferred();
    if (this.privSubscribers) {
      this.privSubscribers.add({
        deferral: deferredSubscriber,
        type: SubscriberType.Dequeue
      });
      this.drain();
    }
    return deferredSubscriber.promise;
  }
  peek() {
    this.throwIfDispose();
    const deferredSubscriber = new Promise_js_1.Deferred();
    const subs = this.privSubscribers;
    if (subs) {
      this.privSubscribers.add({
        deferral: deferredSubscriber,
        type: SubscriberType.Peek
      });
      this.drain();
    }
    return deferredSubscriber.promise;
  }
  length() {
    this.throwIfDispose();
    return this.privList.length();
  }
  isDisposed() {
    return this.privSubscribers == null;
  }
  async drainAndDispose(pendingItemProcessor, reason) {
    if (!this.isDisposed() && !this.privIsDisposing) {
      this.privDisposeReason = reason;
      this.privIsDisposing = true;
      const subs = this.privSubscribers;
      if (subs) {
        while (subs.length() > 0) {
          const subscriber = subs.removeFirst();
          // TODO: this needs work (Resolve(null) instead?).
          subscriber.deferral.resolve(undefined);
          // subscriber.deferral.reject("Disposed");
        }
        // note: this block assumes cooperative multitasking, i.e.,
        // between the if-statement and the assignment there are no
        // thread switches.
        // Reason is that between the initial const = this.; and this
        // point there is the derral.resolve() operation that might have
        // caused recursive calls to the Queue, especially, calling
        // Dispose() on the queue alredy (which would reset the var
        // here to null!).
        // That should generally hold true for javascript...
        if (this.privSubscribers === subs) {
          this.privSubscribers = subs;
        }
      }
      for (const detachable of this.privDetachables) {
        await detachable.detach();
      }
      if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {
        const promiseArray = [];
        this.privPromiseStore.toArray().forEach(wrapper => {
          promiseArray.push(wrapper);
        });
        return Promise.all(promiseArray).finally(() => {
          this.privSubscribers = null;
          this.privList.forEach(item => {
            pendingItemProcessor(item);
          });
          this.privList = null;
          return;
        }).then();
      } else {
        this.privSubscribers = null;
        this.privList = null;
      }
    }
  }
  async dispose(reason) {
    await this.drainAndDispose(null, reason);
  }
  drain() {
    if (!this.privIsDrainInProgress && !this.privIsDisposing) {
      this.privIsDrainInProgress = true;
      const subs = this.privSubscribers;
      const lists = this.privList;
      if (subs && lists) {
        while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {
          const subscriber = subs.removeFirst();
          if (subscriber.type === SubscriberType.Peek) {
            subscriber.deferral.resolve(lists.first());
          } else {
            const dequeuedItem = lists.removeFirst();
            subscriber.deferral.resolve(dequeuedItem);
          }
        }
        // note: this block assumes cooperative multitasking, i.e.,
        // between the if-statement and the assignment there are no
        // thread switches.
        // Reason is that between the initial const = this.; and this
        // point there is the derral.resolve() operation that might have
        // caused recursive calls to the Queue, especially, calling
        // Dispose() on the queue alredy (which would reset the var
        // here to null!).
        // That should generally hold true for javascript...
        if (this.privSubscribers === subs) {
          this.privSubscribers = subs;
        }
        // note: this block assumes cooperative multitasking, i.e.,
        // between the if-statement and the assignment there are no
        // thread switches.
        // Reason is that between the initial const = this.; and this
        // point there is the derral.resolve() operation that might have
        // caused recursive calls to the Queue, especially, calling
        // Dispose() on the queue alredy (which would reset the var
        // here to null!).
        // That should generally hold true for javascript...
        if (this.privList === lists) {
          this.privList = lists;
        }
      }
      this.privIsDrainInProgress = false;
    }
  }
  throwIfDispose() {
    if (this.isDisposed()) {
      if (this.privDisposeReason) {
        throw new Error_js_1.InvalidOperationError(this.privDisposeReason);
      }
      throw new Error_js_1.ObjectDisposedError("Queue");
    } else if (this.privIsDisposing) {
      throw new Error_js_1.InvalidOperationError("Queue disposing");
    }
  }
}
exports.Queue = Queue;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/RawWebsocketMessage.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/RawWebsocketMessage.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


/* eslint-disable @typescript-eslint/no-unsafe-assignment */
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RawWebsocketMessage = void 0;
const ConnectionMessage_js_1 = __webpack_require__(/*! ./ConnectionMessage.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/ConnectionMessage.js");
const Error_js_1 = __webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const Guid_js_1 = __webpack_require__(/*! ./Guid.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js");
class RawWebsocketMessage {
  constructor(messageType, payload, id) {
    this.privPayload = null;
    if (!payload) {
      throw new Error_js_1.ArgumentNullError("payload");
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    if (messageType === ConnectionMessage_js_1.MessageType.Binary && Object.getPrototypeOf(payload).constructor.name !== "ArrayBuffer") {
      throw new Error_js_1.InvalidOperationError("Payload must be ArrayBuffer");
    }
    if (messageType === ConnectionMessage_js_1.MessageType.Text && !(typeof payload === "string")) {
      throw new Error_js_1.InvalidOperationError("Payload must be a string");
    }
    this.privMessageType = messageType;
    this.privPayload = payload;
    this.privId = id ? id : Guid_js_1.createNoDashGuid();
  }
  get messageType() {
    return this.privMessageType;
  }
  get payload() {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return this.privPayload;
  }
  get textContent() {
    if (this.privMessageType === ConnectionMessage_js_1.MessageType.Binary) {
      throw new Error_js_1.InvalidOperationError("Not supported for binary message");
    }
    return this.privPayload;
  }
  get binaryContent() {
    if (this.privMessageType === ConnectionMessage_js_1.MessageType.Text) {
      throw new Error_js_1.InvalidOperationError("Not supported for text message");
    }
    return this.privPayload;
  }
  get id() {
    return this.privId;
  }
}
exports.RawWebsocketMessage = RawWebsocketMessage;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/RiffPcmEncoder.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/RiffPcmEncoder.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RiffPcmEncoder = void 0;
class RiffPcmEncoder {
  constructor(actualSampleRate, desiredSampleRate) {
    this.privActualSampleRate = actualSampleRate;
    this.privDesiredSampleRate = desiredSampleRate;
  }
  encode(actualAudioFrame) {
    const audioFrame = this.downSampleAudioFrame(actualAudioFrame, this.privActualSampleRate, this.privDesiredSampleRate);
    if (!audioFrame) {
      return null;
    }
    const audioLength = audioFrame.length * 2;
    const buffer = new ArrayBuffer(audioLength);
    const view = new DataView(buffer);
    this.floatTo16BitPCM(view, 0, audioFrame);
    return buffer;
  }
  setString(view, offset, str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset + i, str.charCodeAt(i));
    }
  }
  floatTo16BitPCM(view, offset, input) {
    for (let i = 0; i < input.length; i++, offset += 2) {
      const s = Math.max(-1, Math.min(1, input[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
  }
  downSampleAudioFrame(srcFrame, srcRate, dstRate) {
    if (!srcFrame) {
      return null;
    }
    if (dstRate === srcRate || dstRate > srcRate) {
      return srcFrame;
    }
    const ratio = srcRate / dstRate;
    const dstLength = Math.round(srcFrame.length / ratio);
    const dstFrame = new Float32Array(dstLength);
    let srcOffset = 0;
    let dstOffset = 0;
    while (dstOffset < dstLength) {
      const nextSrcOffset = Math.round((dstOffset + 1) * ratio);
      let accum = 0;
      let count = 0;
      while (srcOffset < nextSrcOffset && srcOffset < srcFrame.length) {
        accum += srcFrame[srcOffset++];
        count++;
      }
      dstFrame[dstOffset++] = accum / count;
    }
    return dstFrame;
  }
}
exports.RiffPcmEncoder = RiffPcmEncoder;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Stream.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Stream.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Stream = void 0;
const Error_js_1 = __webpack_require__(/*! ./Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const Guid_js_1 = __webpack_require__(/*! ./Guid.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js");
const Queue_js_1 = __webpack_require__(/*! ./Queue.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Queue.js");
class Stream {
  constructor(streamId) {
    this.privIsWriteEnded = false;
    this.privIsReadEnded = false;
    this.privId = streamId ? streamId : Guid_js_1.createNoDashGuid();
    this.privReaderQueue = new Queue_js_1.Queue();
  }
  get isClosed() {
    return this.privIsWriteEnded;
  }
  get isReadEnded() {
    return this.privIsReadEnded;
  }
  get id() {
    return this.privId;
  }
  close() {
    if (!this.privIsWriteEnded) {
      this.writeStreamChunk({
        buffer: null,
        isEnd: true,
        timeReceived: Date.now()
      });
      this.privIsWriteEnded = true;
    }
  }
  writeStreamChunk(streamChunk) {
    this.throwIfClosed();
    if (!this.privReaderQueue.isDisposed()) {
      try {
        this.privReaderQueue.enqueue(streamChunk);
      } catch (e) {
        // Do nothing
      }
    }
  }
  read() {
    if (this.privIsReadEnded) {
      throw new Error_js_1.InvalidOperationError("Stream read has already finished");
    }
    return this.privReaderQueue.dequeue().then(async streamChunk => {
      if (streamChunk === undefined || streamChunk.isEnd) {
        await this.privReaderQueue.dispose("End of stream reached");
      }
      return streamChunk;
    });
  }
  readEnded() {
    if (!this.privIsReadEnded) {
      this.privIsReadEnded = true;
      this.privReaderQueue = new Queue_js_1.Queue();
    }
  }
  throwIfClosed() {
    if (this.privIsWriteEnded) {
      throw new Error_js_1.InvalidOperationError("Stream closed");
    }
  }
}
exports.Stream = Stream;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/StringUtils.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/StringUtils.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StringUtils = void 0;
/**
 * String helper functions
 */
class StringUtils {
  /**
   * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
   * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
   * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
   * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
   * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
   */
  static formatString(format, replacements) {
    if (!format) {
      return "";
    }
    if (!replacements) {
      return format;
    }
    let formatted = "";
    let key = "";
    const appendToFormatted = str => {
      formatted += str;
    };
    const appendToKey = str => {
      key += str;
    };
    let appendFunc = appendToFormatted;
    for (let i = 0; i < format.length; i++) {
      const c = format[i];
      const next = i + 1 < format.length ? format[i + 1] : "";
      switch (c) {
        case "{":
          if (next === "{") {
            appendFunc("{");
            i++;
          } else {
            appendFunc = appendToKey;
          }
          break;
        case "}":
          if (next === "}") {
            appendFunc("}");
            i++;
          } else {
            if (replacements.hasOwnProperty(key)) {
              formatted += replacements[key];
            }
            appendFunc = appendToFormatted;
            key = "";
          }
          break;
        default:
          appendFunc(c);
          break;
      }
    }
    return formatted;
  }
}
exports.StringUtils = StringUtils;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Timeout.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Timeout.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Timeout = void 0;
class Timeout {
  static load() {
    // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.
    const scheduledTimeoutFunctions = new Map([[0, () => {}]]); // eslint-disable-line @typescript-eslint/no-empty-function
    const unhandledRequests = new Map();
    // eslint-disable-next-line
    const workerScript = `!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`;
    const workerUrl = "data:text/javascript;base64," + btoa(workerScript);
    const worker = new Worker(workerUrl);
    worker.addEventListener("message", ({
      data
    }) => {
      if (Timeout.isCallNotification(data)) {
        const {
          params: {
            timerId
          }
        } = data;
        const idOrFunc = scheduledTimeoutFunctions.get(timerId);
        if (typeof idOrFunc === "number") {
          const unhandledTimerId = unhandledRequests.get(idOrFunc);
          if (unhandledTimerId === undefined || unhandledTimerId !== timerId) {
            throw new Error("The timer is in an undefined state.");
          }
        } else if (typeof idOrFunc !== "undefined") {
          idOrFunc();
          // A timeout can be safely deleted because it is only called once.
          scheduledTimeoutFunctions.delete(timerId);
        } else {
          throw new Error("The timer is in an undefined state.");
        }
      } else if (Timeout.isClearResponse(data)) {
        const {
          id
        } = data;
        const unhandledTimerId = unhandledRequests.get(id);
        if (unhandledTimerId === undefined) {
          throw new Error("The timer is in an undefined state.");
        }
        unhandledRequests.delete(id);
        scheduledTimeoutFunctions.delete(unhandledTimerId);
      } else {
        const {
          error: {
            message
          }
        } = data;
        throw new Error(message);
      }
    });
    const clearTimeout = timerId => {
      const id = Math.random();
      unhandledRequests.set(id, timerId);
      scheduledTimeoutFunctions.set(timerId, id);
      worker.postMessage({
        id,
        method: "clear",
        params: {
          timerId
        }
      });
    };
    const setTimeout = (func, delay) => {
      const timerId = Math.random();
      scheduledTimeoutFunctions.set(timerId, func);
      worker.postMessage({
        id: null,
        method: "set",
        params: {
          delay,
          now: performance.now(),
          timerId
        }
      });
      return timerId;
    };
    return {
      clearTimeout,
      setTimeout
    };
  }
  static loadWorkerTimers() {
    return () => {
      if (Timeout.workerTimers !== null) {
        return Timeout.workerTimers;
      }
      Timeout.workerTimers = Timeout.load();
      return Timeout.workerTimers;
    };
  }
  static isCallNotification(message) {
    return message.method !== undefined && message.method === "call";
  }
  static isClearResponse(message) {
    return message.error === null && typeof message.id === "number";
  }
}
exports.Timeout = Timeout;
Timeout.workerTimers = null;
Timeout.clearTimeout = timerId => Timeout.timers().clearTimeout(timerId);
Timeout.setTimeout = (func, delay) => Timeout.timers().setTimeout(func, delay);
Timeout.timers = Timeout.loadWorkerTimers();

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ActivityReceivedEventArgs.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ActivityReceivedEventArgs.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ActivityReceivedEventArgs = void 0;
/**
 * Defines contents of received message/events.
 * @class ActivityReceivedEventArgs
 */
class ActivityReceivedEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {any} activity - The activity..
   */
  constructor(activity, audioStream) {
    this.privActivity = activity;
    this.privAudioStream = audioStream;
  }
  /**
   * Gets the received activity
   * @member ActivityReceivedEventArgs.prototype.activity
   * @function
   * @public
   * @returns {any} the received activity.
   */
  get activity() {
    return this.privActivity;
  }
  get audioStream() {
    return this.privAudioStream;
  }
}
exports.ActivityReceivedEventArgs = ActivityReceivedEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioConfig.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioConfig.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AudioOutputConfigImpl = exports.AudioConfigImpl = exports.AudioConfig = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const AudioFileWriter_js_1 = __webpack_require__(/*! ./AudioFileWriter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioFileWriter.js");
const AudioInputStream_js_1 = __webpack_require__(/*! ./AudioInputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioInputStream.js");
const AudioOutputStream_js_1 = __webpack_require__(/*! ./AudioOutputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js");
/**
 * Represents audio input configuration used for specifying what type of input to use (microphone, file, stream).
 * @class AudioConfig
 * Updated in version 1.11.0
 */
class AudioConfig {
  /**
   * Creates an AudioConfig object representing the default microphone on the system.
   * @member AudioConfig.fromDefaultMicrophoneInput
   * @function
   * @public
   * @returns {AudioConfig} The audio input configuration being created.
   */
  static fromDefaultMicrophoneInput() {
    const pcmRecorder = new Exports_js_1.PcmRecorder(true);
    return new AudioConfigImpl(new Exports_js_1.MicAudioSource(pcmRecorder));
  }
  /**
   * Creates an AudioConfig object representing a microphone with the specified device ID.
   * @member AudioConfig.fromMicrophoneInput
   * @function
   * @public
   * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
   * Default microphone is used the value is omitted.
   * @returns {AudioConfig} The audio input configuration being created.
   */
  static fromMicrophoneInput(deviceId) {
    const pcmRecorder = new Exports_js_1.PcmRecorder(true);
    return new AudioConfigImpl(new Exports_js_1.MicAudioSource(pcmRecorder, deviceId));
  }
  /**
   * Creates an AudioConfig object representing the specified file.
   * @member AudioConfig.fromWavFileInput
   * @function
   * @public
   * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
   * @returns {AudioConfig} The audio input configuration being created.
   */
  static fromWavFileInput(file, name = "unnamedBuffer.wav") {
    return new AudioConfigImpl(new Exports_js_1.FileAudioSource(file, name));
  }
  /**
   * Creates an AudioConfig object representing the specified stream.
   * @member AudioConfig.fromStreamInput
   * @function
   * @public
   * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
   * stream. Currently, only WAV / PCM is supported.
   * @returns {AudioConfig} The audio input configuration being created.
   */
  static fromStreamInput(audioStream) {
    if (audioStream instanceof Exports_js_2.PullAudioInputStreamCallback) {
      return new AudioConfigImpl(new AudioInputStream_js_1.PullAudioInputStreamImpl(audioStream));
    }
    if (audioStream instanceof Exports_js_2.AudioInputStream) {
      return new AudioConfigImpl(audioStream);
    }
    if (typeof MediaStream !== "undefined" && audioStream instanceof MediaStream) {
      const pcmRecorder = new Exports_js_1.PcmRecorder(false);
      return new AudioConfigImpl(new Exports_js_1.MicAudioSource(pcmRecorder, null, null, audioStream));
    }
    throw new Error("Not Supported Type");
  }
  /**
   * Creates an AudioConfig object representing the default speaker.
   * @member AudioConfig.fromDefaultSpeakerOutput
   * @function
   * @public
   * @returns {AudioConfig} The audio output configuration being created.
   * Added in version 1.11.0
   */
  static fromDefaultSpeakerOutput() {
    return new AudioOutputConfigImpl(new Exports_js_2.SpeakerAudioDestination());
  }
  /**
   * Creates an AudioConfig object representing the custom IPlayer object.
   * You can use the IPlayer object to control pause, resume, etc.
   * @member AudioConfig.fromSpeakerOutput
   * @function
   * @public
   * @param {IPlayer} player - the IPlayer object for playback.
   * @returns {AudioConfig} The audio output configuration being created.
   * Added in version 1.12.0
   */
  static fromSpeakerOutput(player) {
    if (player === undefined) {
      return AudioConfig.fromDefaultSpeakerOutput();
    }
    if (player instanceof Exports_js_2.SpeakerAudioDestination) {
      return new AudioOutputConfigImpl(player);
    }
    throw new Error("Not Supported Type");
  }
  /**
   * Creates an AudioConfig object representing a specified output audio file
   * @member AudioConfig.fromAudioFileOutput
   * @function
   * @public
   * @param {PathLike} filename - the filename of the output audio file
   * @returns {AudioConfig} The audio output configuration being created.
   * Added in version 1.11.0
   */
  static fromAudioFileOutput(filename) {
    return new AudioOutputConfigImpl(new AudioFileWriter_js_1.AudioFileWriter(filename));
  }
  /**
   * Creates an AudioConfig object representing a specified audio output stream
   * @member AudioConfig.fromStreamOutput
   * @function
   * @public
   * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
   * stream.
   * @returns {AudioConfig} The audio output configuration being created.
   * Added in version 1.11.0
   */
  static fromStreamOutput(audioStream) {
    if (audioStream instanceof Exports_js_2.PushAudioOutputStreamCallback) {
      return new AudioOutputConfigImpl(new AudioOutputStream_js_1.PushAudioOutputStreamImpl(audioStream));
    }
    if (audioStream instanceof Exports_js_2.PushAudioOutputStream) {
      return new AudioOutputConfigImpl(audioStream);
    }
    if (audioStream instanceof Exports_js_2.PullAudioOutputStream) {
      return new AudioOutputConfigImpl(audioStream);
    }
    throw new Error("Not Supported Type");
  }
}
exports.AudioConfig = AudioConfig;
/**
 * Represents audio input stream used for custom audio input configurations.
 * @private
 * @class AudioConfigImpl
 */
class AudioConfigImpl extends AudioConfig {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {IAudioSource} source - An audio source.
   */
  constructor(source) {
    super();
    this.privSource = source;
  }
  /**
   * Format information for the audio
   */
  get format() {
    return this.privSource.format;
  }
  /**
   * @member AudioConfigImpl.prototype.close
   * @function
   * @public
   */
  close(cb, err) {
    this.privSource.turnOff().then(() => {
      if (!!cb) {
        cb();
      }
    }, error => {
      if (!!err) {
        err(error);
      }
    });
  }
  /**
   * @member AudioConfigImpl.prototype.id
   * @function
   * @public
   */
  id() {
    return this.privSource.id();
  }
  /**
   * @member AudioConfigImpl.prototype.turnOn
   * @function
   * @public
   * @returns {Promise<void>} A promise.
   */
  turnOn() {
    return this.privSource.turnOn();
  }
  /**
   * @member AudioConfigImpl.prototype.attach
   * @function
   * @public
   * @param {string} audioNodeId - The audio node id.
   * @returns {Promise<IAudioStreamNode>} A promise.
   */
  attach(audioNodeId) {
    return this.privSource.attach(audioNodeId);
  }
  /**
   * @member AudioConfigImpl.prototype.detach
   * @function
   * @public
   * @param {string} audioNodeId - The audio node id.
   */
  detach(audioNodeId) {
    return this.privSource.detach(audioNodeId);
  }
  /**
   * @member AudioConfigImpl.prototype.turnOff
   * @function
   * @public
   * @returns {Promise<void>} A promise.
   */
  turnOff() {
    return this.privSource.turnOff();
  }
  /**
   * @member AudioConfigImpl.prototype.events
   * @function
   * @public
   * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
   */
  get events() {
    return this.privSource.events;
  }
  setProperty(name, value) {
    Contracts_js_1.Contracts.throwIfNull(value, "value");
    if (undefined !== this.privSource.setProperty) {
      this.privSource.setProperty(name, value);
    } else {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
  }
  getProperty(name, def) {
    if (undefined !== this.privSource.getProperty) {
      return this.privSource.getProperty(name, def);
    } else {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
    return def;
  }
  get deviceInfo() {
    return this.privSource.deviceInfo;
  }
}
exports.AudioConfigImpl = AudioConfigImpl;
class AudioOutputConfigImpl extends AudioConfig {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {IAudioDestination} destination - An audio destination.
   */
  constructor(destination) {
    super();
    this.privDestination = destination;
  }
  set format(format) {
    this.privDestination.format = format;
  }
  write(buffer) {
    this.privDestination.write(buffer);
  }
  close() {
    this.privDestination.close();
  }
  id() {
    return this.privDestination.id();
  }
  setProperty() {
    throw new Error("This AudioConfig instance does not support setting properties.");
  }
  getProperty() {
    throw new Error("This AudioConfig instance does not support getting properties.");
  }
}
exports.AudioOutputConfigImpl = AudioOutputConfigImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioFileWriter.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioFileWriter.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AudioFileWriter = void 0;
const fs = __importStar(__webpack_require__(/*! fs */ "?c417"));
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
class AudioFileWriter {
  constructor(filename) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(fs.openSync, "\nFile System access not available, please use Push or PullAudioOutputStream");
    this.privFd = fs.openSync(filename, "w");
  }
  set format(format) {
    Contracts_js_1.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set");
    this.privAudioFormat = format;
    let headerOffset = 0;
    if (this.privAudioFormat.hasHeader) {
      headerOffset = this.privAudioFormat.header.byteLength;
    }
    if (this.privFd !== undefined) {
      this.privWriteStream = fs.createWriteStream("", {
        fd: this.privFd,
        start: headerOffset,
        autoClose: false
      });
    }
  }
  write(buffer) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing.");
    if (this.privWriteStream !== undefined) {
      this.privWriteStream.write(new Uint8Array(buffer.slice(0)));
    }
  }
  close() {
    if (this.privFd !== undefined) {
      this.privWriteStream.on("finish", () => {
        if (this.privAudioFormat.hasHeader) {
          this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten);
          fs.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0);
        }
        fs.closeSync(this.privFd);
        this.privFd = undefined;
      });
      this.privWriteStream.end();
    }
  }
  id() {
    return this.privId;
  }
}
exports.AudioFileWriter = AudioFileWriter;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioInputStream.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioInputStream.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PullAudioInputStreamImpl = exports.PullAudioInputStream = exports.PushAudioInputStreamImpl = exports.PushAudioInputStream = exports.AudioInputStream = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Guid_js_1 = __webpack_require__(/*! ../../common/Guid.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Guid.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const AudioStreamFormat_js_1 = __webpack_require__(/*! ./AudioStreamFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js");
/**
 * Represents audio input stream used for custom audio input configurations.
 * @class AudioInputStream
 */
class AudioInputStream {
  /**
   * Creates and initializes an instance.
   * @constructor
   */
  constructor() {
    return;
  }
  /**
   * Creates a memory backed PushAudioInputStream with the specified audio format.
   * @member AudioInputStream.createPushStream
   * @function
   * @public
   * @param {AudioStreamFormat} format - The audio data format in which audio will be
   * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
   * @returns {PushAudioInputStream} The audio input stream being created.
   */
  static createPushStream(format) {
    return PushAudioInputStream.create(format);
  }
  /**
   * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
   * and close() methods.
   * @member AudioInputStream.createPullStream
   * @function
   * @public
   * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
   * PullAudioInputStreamCallback
   * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
   * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
   * @returns {PullAudioInputStream} The audio input stream being created.
   */
  static createPullStream(callback, format) {
    return PullAudioInputStream.create(callback, format);
    // throw new Error("Oops");
  }
}
exports.AudioInputStream = AudioInputStream;
/**
 * Represents memory backed push audio input stream used for custom audio input configurations.
 * @class PushAudioInputStream
 */
class PushAudioInputStream extends AudioInputStream {
  /**
   * Creates a memory backed PushAudioInputStream with the specified audio format.
   * @member PushAudioInputStream.create
   * @function
   * @public
   * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
   * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
   * @returns {PushAudioInputStream} The push audio input stream being created.
   */
  static create(format) {
    return new PushAudioInputStreamImpl(format);
  }
}
exports.PushAudioInputStream = PushAudioInputStream;
/**
 * Represents memory backed push audio input stream used for custom audio input configurations.
 * @private
 * @class PushAudioInputStreamImpl
 */
class PushAudioInputStreamImpl extends PushAudioInputStream {
  /**
   * Creates and initalizes an instance with the given values.
   * @constructor
   * @param {AudioStreamFormat} format - The audio stream format.
   */
  constructor(format) {
    super();
    if (format === undefined) {
      this.privFormat = AudioStreamFormat_js_1.AudioStreamFormatImpl.getDefaultInputFormat();
    } else {
      this.privFormat = format;
    }
    this.privEvents = new Exports_js_2.EventSource();
    this.privId = Guid_js_1.createNoDashGuid();
    this.privStream = new Exports_js_2.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
  }
  /**
   * Format information for the audio
   */
  get format() {
    return Promise.resolve(this.privFormat);
  }
  /**
   * Writes the audio data specified by making an internal copy of the data.
   * @member PushAudioInputStreamImpl.prototype.write
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
   */
  write(dataBuffer) {
    this.privStream.writeStreamChunk({
      buffer: dataBuffer,
      isEnd: false,
      timeReceived: Date.now()
    });
  }
  /**
   * Closes the stream.
   * @member PushAudioInputStreamImpl.prototype.close
   * @function
   * @public
   */
  close() {
    this.privStream.close();
  }
  id() {
    return this.privId;
  }
  turnOn() {
    this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId)); // no stream id
    this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
    return;
  }
  async attach(audioNodeId) {
    this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
    await this.turnOn();
    const stream = this.privStream;
    this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
    return {
      detach: async () => {
        this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
        return this.turnOff();
      },
      id: () => audioNodeId,
      read: () => stream.read()
    };
  }
  detach(audioNodeId) {
    this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
  }
  turnOff() {
    return;
  }
  get events() {
    return this.privEvents;
  }
  get deviceInfo() {
    return Promise.resolve({
      bitspersample: this.privFormat.bitsPerSample,
      channelcount: this.privFormat.channels,
      connectivity: Exports_js_1.connectivity.Unknown,
      manufacturer: "Speech SDK",
      model: "PushStream",
      samplerate: this.privFormat.samplesPerSec,
      type: Exports_js_1.type.Stream
    });
  }
  onEvent(event) {
    this.privEvents.onEvent(event);
    Exports_js_2.Events.instance.onEvent(event);
  }
  toBuffer(arrayBuffer) {
    const buf = Buffer.alloc(arrayBuffer.byteLength);
    const view = new Uint8Array(arrayBuffer);
    for (let i = 0; i < buf.length; ++i) {
      buf[i] = view[i];
    }
    return buf;
  }
}
exports.PushAudioInputStreamImpl = PushAudioInputStreamImpl;
/*
 * Represents audio input stream used for custom audio input configurations.
 * @class PullAudioInputStream
 */
class PullAudioInputStream extends AudioInputStream {
  /**
   * Creates and initializes and instance.
   * @constructor
   */
  constructor() {
    super();
  }
  /**
   * Creates a PullAudioInputStream that delegates to the specified callback interface for
   * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
   * @member PullAudioInputStream.create
   * @function
   * @public
   * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
   * derived from PullAudioInputStreamCustomCallback
   * @param {AudioStreamFormat} format - The audio data format in which audio will be
   * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
   * @returns {PullAudioInputStream} The push audio input stream being created.
   */
  static create(callback, format) {
    return new PullAudioInputStreamImpl(callback, format);
  }
}
exports.PullAudioInputStream = PullAudioInputStream;
/**
 * Represents audio input stream used for custom audio input configurations.
 * @private
 * @class PullAudioInputStreamImpl
 */
class PullAudioInputStreamImpl extends PullAudioInputStream {
  /**
   * Creates a PullAudioInputStream that delegates to the specified callback interface for
   * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
   * @constructor
   * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
   * derived from PullAudioInputStreamCustomCallback
   * @param {AudioStreamFormat} format - The audio data format in which audio will be
   * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
   */
  constructor(callback, format) {
    super();
    if (undefined === format) {
      this.privFormat = Exports_js_3.AudioStreamFormat.getDefaultInputFormat();
    } else {
      this.privFormat = format;
    }
    this.privEvents = new Exports_js_2.EventSource();
    this.privId = Guid_js_1.createNoDashGuid();
    this.privCallback = callback;
    this.privIsClosed = false;
    this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
  }
  /**
   * Format information for the audio
   */
  get format() {
    return Promise.resolve(this.privFormat);
  }
  /**
   * Closes the stream.
   * @member PullAudioInputStreamImpl.prototype.close
   * @function
   * @public
   */
  close() {
    this.privIsClosed = true;
    this.privCallback.close();
  }
  id() {
    return this.privId;
  }
  turnOn() {
    this.onEvent(new Exports_js_2.AudioSourceInitializingEvent(this.privId)); // no stream id
    this.onEvent(new Exports_js_2.AudioSourceReadyEvent(this.privId));
    return;
  }
  async attach(audioNodeId) {
    this.onEvent(new Exports_js_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));
    await this.turnOn();
    this.onEvent(new Exports_js_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));
    return {
      detach: () => {
        this.privCallback.close();
        this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
        return this.turnOff();
      },
      id: () => audioNodeId,
      read: () => {
        let totalBytes = 0;
        let transmitBuff;
        // Until we have the minimum number of bytes to send in a transmission, keep asking for more.
        while (totalBytes < this.privBufferSize) {
          // Sizing the read buffer to the delta between the perfect size and what's left means we won't ever get too much
          // data back.
          const readBuff = new ArrayBuffer(this.privBufferSize - totalBytes);
          const pulledBytes = this.privCallback.read(readBuff);
          // If there is no return buffer yet defined, set the return buffer to the that was just populated.
          // This was, if we have enough data there's no copy penalty, but if we don't we have a buffer that's the
          // preferred size allocated.
          if (undefined === transmitBuff) {
            transmitBuff = readBuff;
          } else {
            // Not the first bite at the apple, so fill the return buffer with the data we got back.
            const intView = new Int8Array(transmitBuff);
            intView.set(new Int8Array(readBuff), totalBytes);
          }
          // If there are no bytes to read, just break out and be done.
          if (0 === pulledBytes) {
            break;
          }
          totalBytes += pulledBytes;
        }
        return Promise.resolve({
          buffer: transmitBuff.slice(0, totalBytes),
          isEnd: this.privIsClosed || totalBytes === 0,
          timeReceived: Date.now()
        });
      }
    };
  }
  detach(audioNodeId) {
    this.onEvent(new Exports_js_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));
  }
  turnOff() {
    return;
  }
  get events() {
    return this.privEvents;
  }
  get deviceInfo() {
    return Promise.resolve({
      bitspersample: this.privFormat.bitsPerSample,
      channelcount: this.privFormat.channels,
      connectivity: Exports_js_1.connectivity.Unknown,
      manufacturer: "Speech SDK",
      model: "PullStream",
      samplerate: this.privFormat.samplesPerSec,
      type: Exports_js_1.type.Stream
    });
  }
  onEvent(event) {
    this.privEvents.onEvent(event);
    Exports_js_2.Events.instance.onEvent(event);
  }
}
exports.PullAudioInputStreamImpl = PullAudioInputStreamImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AudioOutputFormatImpl = void 0;
const SpeechSynthesisOutputFormat_js_1 = __webpack_require__(/*! ../SpeechSynthesisOutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisOutputFormat.js");
const AudioStreamFormat_js_1 = __webpack_require__(/*! ./AudioStreamFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js");
/**
 * @private
 * @class AudioOutputFormatImpl
 * Updated in version 1.17.0
 */
// eslint-disable-next-line max-classes-per-file
class AudioOutputFormatImpl extends AudioStreamFormat_js_1.AudioStreamFormatImpl {
  /**
   * Creates an instance with the given values.
   * @constructor
   * @param formatTag
   * @param {number} channels - Number of channels.
   * @param {number} samplesPerSec - Samples per second.
   * @param {number} avgBytesPerSec - Average bytes per second.
   * @param {number} blockAlign - Block alignment.
   * @param {number} bitsPerSample - Bits per sample.
   * @param {string} audioFormatString - Audio format string
   * @param {string} requestAudioFormatString - Audio format string sent to service.
   * @param {boolean} hasHeader - If the format has header or not.
   */
  constructor(formatTag, channels, samplesPerSec, avgBytesPerSec, blockAlign, bitsPerSample, audioFormatString, requestAudioFormatString, hasHeader) {
    super(samplesPerSec, bitsPerSample, channels, formatTag);
    this.formatTag = formatTag;
    this.avgBytesPerSec = avgBytesPerSec;
    this.blockAlign = blockAlign;
    this.priAudioFormatString = audioFormatString;
    this.priRequestAudioFormatString = requestAudioFormatString;
    this.priHasHeader = hasHeader;
  }
  static fromSpeechSynthesisOutputFormat(speechSynthesisOutputFormat) {
    if (speechSynthesisOutputFormat === undefined) {
      return AudioOutputFormatImpl.getDefaultOutputFormat();
    }
    return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString[speechSynthesisOutputFormat]);
  }
  static fromSpeechSynthesisOutputFormatString(speechSynthesisOutputFormatString) {
    switch (speechSynthesisOutputFormatString) {
      case "raw-8khz-8bit-mono-mulaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MuLaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-16khz-16kbps-mono-siren":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.Siren, 1, 16000, 2000, 40, 0, speechSynthesisOutputFormatString, "audio-16khz-16kbps-mono-siren", true);
      case "audio-16khz-16kbps-mono-siren":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.Siren, 1, 16000, 2000, 40, 0, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-32kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 16000, 32 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-128kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 16000, 128 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-64kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 16000, 64 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-48kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 24000, 48 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-96kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 24000, 96 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-160kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 24000, 160 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-16khz-16bit-mono-truesilk":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.SILKSkype, 1, 16000, 32000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-8khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 8000, 16000, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", true);
      case "riff-24khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", true);
      case "riff-8khz-8bit-mono-mulaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MuLaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-mulaw", true);
      case "raw-16khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 16000, 32000, 2, 16, speechSynthesisOutputFormatString, "raw-16khz-16bit-mono-pcm", false);
      case "raw-24khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, "raw-24khz-16bit-mono-pcm", false);
      case "raw-8khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 8000, 16000, 2, 16, speechSynthesisOutputFormatString, "raw-8khz-16bit-mono-pcm", false);
      case "ogg-16khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.OGG_OPUS, 1, 16000, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "ogg-24khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.OGG_OPUS, 1, 24000, 8192, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-48khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 48000, 96000, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", false);
      case "riff-48khz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 48000, 96000, 2, 16, speechSynthesisOutputFormatString, "raw-48khz-16bit-mono-pcm", true);
      case "audio-48khz-96kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 48000, 96 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-48khz-192kbitrate-mono-mp3":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.MP3, 1, 48000, 192 << 7, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "ogg-48khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.OGG_OPUS, 1, 48000, 12000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "webm-16khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.WEBM_OPUS, 1, 16000, 4000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "webm-24khz-16bit-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.WEBM_OPUS, 1, 24000, 6000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "webm-24khz-16bit-24kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.WEBM_OPUS, 1, 24000, 3000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-16khz-16bit-32kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.OPUS, 1, 16000, 4000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-16bit-48kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.OPUS, 1, 24000, 6000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-16bit-24kbps-mono-opus":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.OPUS, 1, 24000, 3000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-24khz-16bit-mono-flac":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.FLAC, 1, 24000, 24000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "audio-48khz-16bit-mono-flac":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.FLAC, 1, 48000, 30000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-24khz-16bit-mono-truesilk":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.SILKSkype, 1, 24000, 48000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "raw-8khz-8bit-mono-alaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.ALaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-8khz-8bit-mono-alaw":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.ALaw, 1, 8000, 8000, 1, 8, speechSynthesisOutputFormatString, "raw-8khz-8bit-mono-alaw", true);
      case "raw-22050hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-22050hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, speechSynthesisOutputFormatString, "raw-22050hz-16bit-mono-pcm", true);
      case "raw-44100hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-44100hz-16bit-mono-pcm":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, speechSynthesisOutputFormatString, "raw-44100hz-16bit-mono-pcm", true);
      case "amr-wb-16000h":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.AMR_WB, 1, 16000, 3052, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "g722-16khz-64kbps":
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.G722, 1, 16000, 8000, 2, 16, speechSynthesisOutputFormatString, speechSynthesisOutputFormatString, false);
      case "riff-16khz-16bit-mono-pcm":
      default:
        return new AudioOutputFormatImpl(AudioStreamFormat_js_1.AudioFormatTag.PCM, 1, 16000, 32000, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", true);
    }
  }
  static getDefaultOutputFormat() {
    return AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(typeof window !== "undefined" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
  }
  /**
   * Specifies if this audio output format has a header
   * @boolean AudioOutputFormatImpl.prototype.hasHeader
   * @function
   * @public
   */
  get hasHeader() {
    return this.priHasHeader;
  }
  /**
   * Specifies the header of this format
   * @ArrayBuffer AudioOutputFormatImpl.prototype.header
   * @function
   * @public
   */
  get header() {
    if (this.hasHeader) {
      return this.privHeader;
    }
    return undefined;
  }
  /**
   * Updates the header based on the audio length
   * @member AudioOutputFormatImpl.updateHeader
   * @function
   * @public
   * @param {number} audioLength - the audio length
   */
  updateHeader(audioLength) {
    if (this.priHasHeader) {
      const view = new DataView(this.privHeader);
      view.setUint32(4, audioLength + this.privHeader.byteLength - 8, true);
      view.setUint32(40, audioLength, true);
    }
  }
  /**
   * Specifies the audio format string to be sent to the service
   * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
   * @function
   * @public
   */
  get requestAudioFormatString() {
    return this.priRequestAudioFormatString;
  }
  /**
   * Adds audio header
   * @param audio the raw audio without header
   * @returns the audio with header if applicable
   */
  addHeader(audio) {
    if (!this.hasHeader) {
      return audio;
    }
    this.updateHeader(audio.byteLength);
    const tmp = new Uint8Array(audio.byteLength + this.header.byteLength);
    tmp.set(new Uint8Array(this.header), 0);
    tmp.set(new Uint8Array(audio), this.header.byteLength);
    return tmp.buffer;
  }
}
exports.AudioOutputFormatImpl = AudioOutputFormatImpl;
AudioOutputFormatImpl.SpeechSynthesisOutputFormatToString = {
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
  [SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
};

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PushAudioOutputStreamImpl = exports.PushAudioOutputStream = exports.PullAudioOutputStreamImpl = exports.PullAudioOutputStream = exports.AudioOutputStream = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const AudioOutputFormat_js_1 = __webpack_require__(/*! ./AudioOutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js");
/**
 * Represents audio output stream used for custom audio output configurations.
 * @class AudioOutputStream
 */
class AudioOutputStream {
  /**
   * Creates and initializes an instance.
   * @constructor
   */
  constructor() {
    return;
  }
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member AudioOutputStream.createPullStream
   * @function
   * @public
   * @returns {PullAudioOutputStream} The audio output stream being created.
   */
  static createPullStream() {
    return PullAudioOutputStream.create();
  }
}
exports.AudioOutputStream = AudioOutputStream;
/**
 * Represents memory backed push audio output stream used for custom audio output configurations.
 * @class PullAudioOutputStream
 */
class PullAudioOutputStream extends AudioOutputStream {
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member PullAudioOutputStream.create
   * @function
   * @public
   * @returns {PullAudioOutputStream} The push audio output stream being created.
   */
  static create() {
    return new PullAudioOutputStreamImpl();
  }
}
exports.PullAudioOutputStream = PullAudioOutputStream;
/**
 * Represents memory backed push audio output stream used for custom audio output configurations.
 * @private
 * @class PullAudioOutputStreamImpl
 */
class PullAudioOutputStreamImpl extends PullAudioOutputStream {
  /**
   * Creates and initializes an instance with the given values.
   * @constructor
   */
  constructor() {
    super();
    this.privId = Exports_js_1.createNoDashGuid();
    this.privStream = new Exports_js_1.Stream();
  }
  /**
   * Sets the format information to the stream. For internal use only.
   * @param {AudioStreamFormat} format - the format to be set.
   */
  set format(format) {
    if (format === undefined || format === null) {
      this.privFormat = AudioOutputFormat_js_1.AudioOutputFormatImpl.getDefaultOutputFormat();
    }
    this.privFormat = format;
  }
  /**
   * Format information for the audio
   */
  get format() {
    return this.privFormat;
  }
  /**
   * Checks if the stream is closed
   * @member PullAudioOutputStreamImpl.prototype.isClosed
   * @property
   * @public
   */
  get isClosed() {
    return this.privStream.isClosed;
  }
  /**
   * Gets the id of the stream
   * @member PullAudioOutputStreamImpl.prototype.id
   * @property
   * @public
   */
  id() {
    return this.privId;
  }
  /**
   * Reads audio data from the internal buffer.
   * @member PullAudioOutputStreamImpl.prototype.read
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
   * @returns {Promise<number>} - Audio buffer length has been read.
   */
  async read(dataBuffer) {
    const intView = new Int8Array(dataBuffer);
    let totalBytes = 0;
    if (this.privLastChunkView !== undefined) {
      if (this.privLastChunkView.length > dataBuffer.byteLength) {
        intView.set(this.privLastChunkView.slice(0, dataBuffer.byteLength));
        this.privLastChunkView = this.privLastChunkView.slice(dataBuffer.byteLength);
        return Promise.resolve(dataBuffer.byteLength);
      }
      intView.set(this.privLastChunkView);
      totalBytes = this.privLastChunkView.length;
      this.privLastChunkView = undefined;
    }
    // Until we have the minimum number of bytes to send in a transmission, keep asking for more.
    while (totalBytes < dataBuffer.byteLength && !this.privStream.isReadEnded) {
      const chunk = await this.privStream.read();
      if (chunk !== undefined && !chunk.isEnd) {
        let tmpBuffer;
        if (chunk.buffer.byteLength > dataBuffer.byteLength - totalBytes) {
          tmpBuffer = chunk.buffer.slice(0, dataBuffer.byteLength - totalBytes);
          this.privLastChunkView = new Int8Array(chunk.buffer.slice(dataBuffer.byteLength - totalBytes));
        } else {
          tmpBuffer = chunk.buffer;
        }
        intView.set(new Int8Array(tmpBuffer), totalBytes);
        totalBytes += tmpBuffer.byteLength;
      } else {
        this.privStream.readEnded();
      }
    }
    return totalBytes;
  }
  /**
   * Writes the audio data specified by making an internal copy of the data.
   * @member PullAudioOutputStreamImpl.prototype.write
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
   */
  write(dataBuffer) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing");
    this.privStream.writeStreamChunk({
      buffer: dataBuffer,
      isEnd: false,
      timeReceived: Date.now()
    });
  }
  /**
   * Closes the stream.
   * @member PullAudioOutputStreamImpl.prototype.close
   * @function
   * @public
   */
  close() {
    this.privStream.close();
  }
}
exports.PullAudioOutputStreamImpl = PullAudioOutputStreamImpl;
/*
 * Represents audio output stream used for custom audio output configurations.
 * @class PushAudioOutputStream
 */
class PushAudioOutputStream extends AudioOutputStream {
  /**
   * Creates and initializes and instance.
   * @constructor
   */
  constructor() {
    super();
  }
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * write() and close() methods.
   * @member PushAudioOutputStream.create
   * @function
   * @public
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   * @returns {PushAudioOutputStream} The push audio output stream being created.
   */
  static create(callback) {
    return new PushAudioOutputStreamImpl(callback);
  }
}
exports.PushAudioOutputStream = PushAudioOutputStream;
/**
 * Represents audio output stream used for custom audio output configurations.
 * @private
 * @class PushAudioOutputStreamImpl
 */
class PushAudioOutputStreamImpl extends PushAudioOutputStream {
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * read() and close() methods.
   * @constructor
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   */
  constructor(callback) {
    super();
    this.privId = Exports_js_1.createNoDashGuid();
    this.privCallback = callback;
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  set format(format) {}
  write(buffer) {
    if (!!this.privCallback.write) {
      this.privCallback.write(buffer);
    }
  }
  close() {
    if (!!this.privCallback.close) {
      this.privCallback.close();
    }
  }
  id() {
    return this.privId;
  }
}
exports.PushAudioOutputStreamImpl = PushAudioOutputStreamImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AudioStreamFormatImpl = exports.AudioStreamFormat = exports.AudioFormatTag = void 0;
// eslint-disable-next-line max-classes-per-file
var AudioFormatTag;
(function (AudioFormatTag) {
  AudioFormatTag[AudioFormatTag["PCM"] = 1] = "PCM";
  AudioFormatTag[AudioFormatTag["MuLaw"] = 2] = "MuLaw";
  AudioFormatTag[AudioFormatTag["Siren"] = 3] = "Siren";
  AudioFormatTag[AudioFormatTag["MP3"] = 4] = "MP3";
  AudioFormatTag[AudioFormatTag["SILKSkype"] = 5] = "SILKSkype";
  AudioFormatTag[AudioFormatTag["OGG_OPUS"] = 6] = "OGG_OPUS";
  AudioFormatTag[AudioFormatTag["WEBM_OPUS"] = 7] = "WEBM_OPUS";
  AudioFormatTag[AudioFormatTag["ALaw"] = 8] = "ALaw";
  AudioFormatTag[AudioFormatTag["FLAC"] = 9] = "FLAC";
  AudioFormatTag[AudioFormatTag["OPUS"] = 10] = "OPUS";
  AudioFormatTag[AudioFormatTag["AMR_WB"] = 11] = "AMR_WB";
  AudioFormatTag[AudioFormatTag["G722"] = 12] = "G722";
})(AudioFormatTag = exports.AudioFormatTag || (exports.AudioFormatTag = {}));
/**
 * Represents audio stream format used for custom audio input configurations.
 * @class AudioStreamFormat
 */
class AudioStreamFormat {
  /**
   * Creates an audio stream format object representing the default audio stream
   * format (16KHz 16bit mono PCM).
   * @member AudioStreamFormat.getDefaultInputFormat
   * @function
   * @public
   * @returns {AudioStreamFormat} The audio stream format being created.
   */
  static getDefaultInputFormat() {
    return AudioStreamFormatImpl.getDefaultInputFormat();
  }
  /**
   * Creates an audio stream format object with the specified format characteristics.
   * @member AudioStreamFormat.getWaveFormat
   * @function
   * @public
   * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
   * @param {number} bitsPerSample - Bits per sample, typically 16.
   * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
   * uses one channel and stereo data uses two channels.
   * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
   * @returns {AudioStreamFormat} The audio stream format being created.
   */
  static getWaveFormat(samplesPerSecond, bitsPerSample, channels, format) {
    return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels, format);
  }
  /**
   * Creates an audio stream format object with the specified pcm waveformat characteristics.
   * @member AudioStreamFormat.getWaveFormatPCM
   * @function
   * @public
   * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
   * @param {number} bitsPerSample - Bits per sample, typically 16.
   * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
   * uses one channel and stereo data uses two channels.
   * @returns {AudioStreamFormat} The audio stream format being created.
   */
  static getWaveFormatPCM(samplesPerSecond, bitsPerSample, channels) {
    return new AudioStreamFormatImpl(samplesPerSecond, bitsPerSample, channels);
  }
}
exports.AudioStreamFormat = AudioStreamFormat;
/**
 * @private
 * @class AudioStreamFormatImpl
 */
class AudioStreamFormatImpl extends AudioStreamFormat {
  /**
   * Creates an instance with the given values.
   * @constructor
   * @param {number} samplesPerSec - Samples per second.
   * @param {number} bitsPerSample - Bits per sample.
   * @param {number} channels - Number of channels.
   * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
   */
  constructor(samplesPerSec = 16000, bitsPerSample = 16, channels = 1, format = AudioFormatTag.PCM) {
    super();
    let isWavFormat = true;
    /* 1 for PCM; 6 for alaw; 7 for mulaw */
    switch (format) {
      case AudioFormatTag.PCM:
        this.formatTag = 1;
        break;
      case AudioFormatTag.ALaw:
        this.formatTag = 6;
        break;
      case AudioFormatTag.MuLaw:
        this.formatTag = 7;
        break;
      default:
        isWavFormat = false;
    }
    this.bitsPerSample = bitsPerSample;
    this.samplesPerSec = samplesPerSec;
    this.channels = channels;
    this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8);
    this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8);
    if (isWavFormat) {
      this.privHeader = new ArrayBuffer(44);
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView
      const view = new DataView(this.privHeader);
      /* RIFF identifier */
      this.setString(view, 0, "RIFF");
      /* file length */
      view.setUint32(4, 0, true);
      /* RIFF type & Format */
      this.setString(view, 8, "WAVEfmt ");
      /* format chunk length */
      view.setUint32(16, 16, true);
      /* audio format */
      view.setUint16(20, this.formatTag, true);
      /* channel count */
      view.setUint16(22, this.channels, true);
      /* sample rate */
      view.setUint32(24, this.samplesPerSec, true);
      /* byte rate (sample rate * block align) */
      view.setUint32(28, this.avgBytesPerSec, true);
      /* block align (channel count * bytes per sample) */
      view.setUint16(32, this.channels * (this.bitsPerSample / 8), true);
      /* bits per sample */
      view.setUint16(34, this.bitsPerSample, true);
      /* data chunk identifier */
      this.setString(view, 36, "data");
      /* data chunk length */
      view.setUint32(40, 0, true);
    }
  }
  /**
   * Retrieves the default input format.
   * @member AudioStreamFormatImpl.getDefaultInputFormat
   * @function
   * @public
   * @returns {AudioStreamFormatImpl} The default input format.
   */
  static getDefaultInputFormat() {
    return new AudioStreamFormatImpl();
  }
  /**
   * Creates an audio context appropriate to current browser
   * @member AudioStreamFormatImpl.getAudioContext
   * @function
   * @public
   * @returns {AudioContext} An audio context instance
   */
  /* eslint-disable */
  static getAudioContext(sampleRate) {
    // Workaround for Speech SDK bug in Safari.
    const AudioContext = window.AudioContext // our preferred impl
    || window.webkitAudioContext // fallback, mostly when on Safari
    || false; // could not find.
    // https://developer.mozilla.org/en-US/docs/Web/API/AudioContext
    if (!!AudioContext) {
      if (sampleRate !== undefined && navigator.mediaDevices.getSupportedConstraints().sampleRate) {
        return new AudioContext({
          sampleRate
        });
      } else {
        return new AudioContext();
      }
    } else {
      throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
    }
  }
  /* eslint-enable */
  /**
   * Closes the configuration object.
   * @member AudioStreamFormatImpl.prototype.close
   * @function
   * @public
   */
  close() {
    return;
  }
  get header() {
    return this.privHeader;
  }
  setString(view, offset, str) {
    for (let i = 0; i < str.length; i++) {
      view.setUint8(offset + i, str.charCodeAt(i));
    }
  }
}
exports.AudioStreamFormatImpl = AudioStreamFormatImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/BaseAudioPlayer.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/BaseAudioPlayer.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseAudioPlayer = void 0;
const Error_js_1 = __webpack_require__(/*! ../../common/Error.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Error.js");
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const AudioStreamFormat_js_1 = __webpack_require__(/*! ./AudioStreamFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js");
/**
 * Base audio player class
 * TODO: Plays only PCM for now.
 * @class
 */
class BaseAudioPlayer {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
   */
  constructor(audioFormat) {
    this.audioContext = null;
    this.gainNode = null;
    this.autoUpdateBufferTimer = 0;
    if (audioFormat === undefined) {
      audioFormat = Exports_js_1.AudioStreamFormat.getDefaultInputFormat();
    }
    this.init(audioFormat);
  }
  /**
   * play Audio sample
   * @param newAudioData audio data to be played.
   */
  playAudioSample(newAudioData, cb, err) {
    try {
      this.ensureInitializedContext();
      const audioData = this.formatAudioData(newAudioData);
      const newSamplesData = new Float32Array(this.samples.length + audioData.length);
      newSamplesData.set(this.samples, 0);
      newSamplesData.set(audioData, this.samples.length);
      this.samples = newSamplesData;
      if (!!cb) {
        cb();
      }
    } catch (e) {
      if (!!err) {
        err(e);
      }
    }
  }
  /**
   * stops audio and clears the buffers
   */
  stopAudio(cb, err) {
    if (this.audioContext !== null) {
      this.samples = new Float32Array();
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      clearInterval(this.autoUpdateBufferTimer);
      this.audioContext.close().then(() => {
        if (!!cb) {
          cb();
        }
      }, error => {
        if (!!err) {
          err(error);
        }
      });
      this.audioContext = null;
    }
  }
  init(audioFormat) {
    this.audioFormat = audioFormat;
    this.samples = new Float32Array();
  }
  ensureInitializedContext() {
    if (this.audioContext === null) {
      this.createAudioContext();
      const timerPeriod = 200;
      this.autoUpdateBufferTimer = setInterval(() => {
        this.updateAudioBuffer();
      }, timerPeriod);
    }
  }
  createAudioContext() {
    // new ((window as any).AudioContext || (window as any).webkitAudioContext)();
    this.audioContext = AudioStreamFormat_js_1.AudioStreamFormatImpl.getAudioContext();
    // TODO: Various examples shows this gain node, it does not seem to be needed unless we plan
    // to control the volume, not likely
    this.gainNode = this.audioContext.createGain();
    this.gainNode.gain.value = 1;
    this.gainNode.connect(this.audioContext.destination);
    this.startTime = this.audioContext.currentTime;
  }
  formatAudioData(audioData) {
    switch (this.audioFormat.bitsPerSample) {
      case 8:
        return this.formatArrayBuffer(new Int8Array(audioData), 128);
      case 16:
        return this.formatArrayBuffer(new Int16Array(audioData), 32768);
      case 32:
        return this.formatArrayBuffer(new Int32Array(audioData), 2147483648);
      default:
        throw new Error_js_1.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
    }
  }
  formatArrayBuffer(audioData, maxValue) {
    const float32Data = new Float32Array(audioData.length);
    for (let i = 0; i < audioData.length; i++) {
      float32Data[i] = audioData[i] / maxValue;
    }
    return float32Data;
  }
  updateAudioBuffer() {
    if (this.samples.length === 0) {
      return;
    }
    const channelCount = this.audioFormat.channels;
    const bufferSource = this.audioContext.createBufferSource();
    const frameCount = this.samples.length / channelCount;
    const audioBuffer = this.audioContext.createBuffer(channelCount, frameCount, this.audioFormat.samplesPerSec);
    // TODO: Should we do the conversion in the pushAudioSample instead?
    for (let channel = 0; channel < channelCount; channel++) {
      // Fill in individual channel data
      let channelOffset = channel;
      const audioData = audioBuffer.getChannelData(channel);
      for (let i = 0; i < this.samples.length; i++, channelOffset += channelCount) {
        audioData[i] = this.samples[channelOffset];
      }
    }
    if (this.startTime < this.audioContext.currentTime) {
      this.startTime = this.audioContext.currentTime;
    }
    bufferSource.buffer = audioBuffer;
    bufferSource.connect(this.gainNode);
    bufferSource.start(this.startTime);
    // Make sure we play the next sample after the current one.
    this.startTime += audioBuffer.duration;
    // Clear the samples for the next pushed data.
    this.samples = new Float32Array();
  }
  async playAudio(audioData) {
    if (this.audioContext === null) {
      this.createAudioContext();
    }
    const source = this.audioContext.createBufferSource();
    const destination = this.audioContext.destination;
    await this.audioContext.decodeAudioData(audioData, newBuffer => {
      source.buffer = newBuffer;
      source.connect(destination);
      source.start(0);
    });
  }
}
exports.BaseAudioPlayer = BaseAudioPlayer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/PullAudioInputStreamCallback.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/PullAudioInputStreamCallback.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PullAudioInputStreamCallback = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/**
 * An abstract base class that defines callback methods (read() and close()) for
 * custom audio input streams).
 * @class PullAudioInputStreamCallback
 */
class PullAudioInputStreamCallback {}
exports.PullAudioInputStreamCallback = PullAudioInputStreamCallback;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/PushAudioOutputStreamCallback.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/PushAudioOutputStreamCallback.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PushAudioOutputStreamCallback = void 0;
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/**
 * An abstract base class that defines callback methods (write() and close()) for
 * custom audio output streams).
 * @class PushAudioOutputStreamCallback
 */
class PushAudioOutputStreamCallback {}
exports.PushAudioOutputStreamCallback = PushAudioOutputStreamCallback;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeakerAudioDestination = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const AudioOutputStream_js_1 = __webpack_require__(/*! ./AudioOutputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js");
const AudioStreamFormat_js_1 = __webpack_require__(/*! ./AudioStreamFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js");
const MediaDurationPlaceholderSeconds = 60 * 30;
const AudioFormatToMimeType = {
  [AudioStreamFormat_js_1.AudioFormatTag.PCM]: "audio/wav",
  [AudioStreamFormat_js_1.AudioFormatTag.MuLaw]: "audio/x-wav",
  [AudioStreamFormat_js_1.AudioFormatTag.MP3]: "audio/mpeg",
  [AudioStreamFormat_js_1.AudioFormatTag.OGG_OPUS]: "audio/ogg",
  [AudioStreamFormat_js_1.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
  [AudioStreamFormat_js_1.AudioFormatTag.ALaw]: "audio/x-wav",
  [AudioStreamFormat_js_1.AudioFormatTag.FLAC]: "audio/flac",
  [AudioStreamFormat_js_1.AudioFormatTag.AMR_WB]: "audio/amr-wb",
  [AudioStreamFormat_js_1.AudioFormatTag.G722]: "audio/G722"
};
/**
 * Represents the speaker playback audio destination, which only works in browser.
 * Note: the SDK will try to use <a href="https://www.w3.org/TR/media-source/">Media Source Extensions</a> to play audio.
 * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.
 * @class SpeakerAudioDestination
 * Updated in version 1.17.0
 */
class SpeakerAudioDestination {
  constructor(audioDestinationId) {
    this.privPlaybackStarted = false;
    this.privAppendingToBuffer = false;
    this.privMediaSourceOpened = false;
    this.privBytesReceived = 0;
    this.privId = audioDestinationId ? audioDestinationId : Exports_js_1.createNoDashGuid();
    this.privIsPaused = false;
    this.privIsClosed = false;
  }
  id() {
    return this.privId;
  }
  write(buffer, cb, err) {
    if (this.privAudioBuffer !== undefined) {
      this.privAudioBuffer.push(buffer);
      this.updateSourceBuffer().then(() => {
        if (!!cb) {
          cb();
        }
      }, error => {
        if (!!err) {
          err(error);
        }
      });
    } else if (this.privAudioOutputStream !== undefined) {
      this.privAudioOutputStream.write(buffer);
      this.privBytesReceived += buffer.byteLength;
    }
  }
  close(cb, err) {
    this.privIsClosed = true;
    if (this.privSourceBuffer !== undefined) {
      this.handleSourceBufferUpdateEnd().then(() => {
        if (!!cb) {
          cb();
        }
      }, error => {
        if (!!err) {
          err(error);
        }
      });
    } else if (this.privAudioOutputStream !== undefined && typeof window !== "undefined") {
      if ((this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.PCM || this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.MuLaw || this.privFormat.formatTag === AudioStreamFormat_js_1.AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {
        // eslint-disable-next-line no-console
        console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header.");
        if (!!this.onAudioEnd) {
          this.onAudioEnd(this);
        }
      } else {
        let receivedAudio = new ArrayBuffer(this.privBytesReceived);
        this.privAudioOutputStream.read(receivedAudio).then(() => {
          receivedAudio = this.privFormat.addHeader(receivedAudio);
          const audioBlob = new Blob([receivedAudio], {
            type: AudioFormatToMimeType[this.privFormat.formatTag]
          });
          this.privAudio.src = window.URL.createObjectURL(audioBlob);
          this.notifyPlayback().then(() => {
            if (!!cb) {
              cb();
            }
          }, error => {
            if (!!err) {
              err(error);
            }
          });
        }, error => {
          if (!!err) {
            err(error);
          }
        });
      }
    } else {
      // unsupported format, call onAudioEnd directly.
      if (!!this.onAudioEnd) {
        this.onAudioEnd(this);
      }
    }
  }
  set format(format) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    if (typeof AudioContext !== "undefined" || typeof window !== "undefined" && typeof window.webkitAudioContext !== "undefined") {
      this.privFormat = format;
      const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];
      if (mimeType === undefined) {
        // eslint-disable-next-line no-console
        console.warn(`Unknown mimeType for format ${AudioStreamFormat_js_1.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);
      } else if (typeof MediaSource !== "undefined" && MediaSource.isTypeSupported(mimeType)) {
        this.privAudio = new Audio();
        this.privAudioBuffer = [];
        this.privMediaSource = new MediaSource();
        this.privAudio.src = URL.createObjectURL(this.privMediaSource);
        this.privAudio.load();
        this.privMediaSource.onsourceopen = () => {
          this.privMediaSourceOpened = true;
          this.privMediaSource.duration = MediaDurationPlaceholderSeconds;
          this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);
          this.privSourceBuffer.onupdate = () => {
            this.updateSourceBuffer().catch(reason => {
              Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));
            });
          };
          this.privSourceBuffer.onupdateend = () => {
            this.handleSourceBufferUpdateEnd().catch(reason => {
              Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));
            });
          };
          this.privSourceBuffer.onupdatestart = () => {
            this.privAppendingToBuffer = false;
          };
        };
        this.updateSourceBuffer().catch(reason => {
          Exports_js_1.Events.instance.onEvent(new Exports_js_1.BackgroundEvent(reason));
        });
      } else {
        // eslint-disable-next-line no-console
        console.warn(`Format ${AudioStreamFormat_js_1.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);
        this.privAudioOutputStream = new AudioOutputStream_js_1.PullAudioOutputStreamImpl();
        this.privAudioOutputStream.format = this.privFormat;
        this.privAudio = new Audio();
      }
    }
  }
  get volume() {
    return this.privAudio?.volume ?? -1;
  }
  set volume(volume) {
    if (!!this.privAudio) {
      this.privAudio.volume = volume;
    }
  }
  mute() {
    if (!!this.privAudio) {
      this.privAudio.muted = true;
    }
  }
  unmute() {
    if (!!this.privAudio) {
      this.privAudio.muted = false;
    }
  }
  get isClosed() {
    return this.privIsClosed;
  }
  get currentTime() {
    if (this.privAudio !== undefined) {
      return this.privAudio.currentTime;
    }
    return -1;
  }
  pause() {
    if (!this.privIsPaused && this.privAudio !== undefined) {
      this.privAudio.pause();
      this.privIsPaused = true;
    }
  }
  resume(cb, err) {
    if (this.privIsPaused && this.privAudio !== undefined) {
      this.privAudio.play().then(() => {
        if (!!cb) {
          cb();
        }
      }, error => {
        if (!!err) {
          err(error);
        }
      });
      this.privIsPaused = false;
    }
  }
  get internalAudio() {
    return this.privAudio;
  }
  async updateSourceBuffer() {
    if (this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
      this.privAppendingToBuffer = true;
      const binary = this.privAudioBuffer.shift();
      try {
        this.privSourceBuffer.appendBuffer(binary);
      } catch (error) {
        this.privAudioBuffer.unshift(binary);
        // eslint-disable-next-line no-console
        console.log("buffer filled, pausing addition of binaries until space is made");
        return;
      }
      await this.notifyPlayback();
    } else if (this.canEndStream()) {
      await this.handleSourceBufferUpdateEnd();
    }
  }
  async handleSourceBufferUpdateEnd() {
    if (this.canEndStream() && this.sourceBufferAvailable()) {
      this.privMediaSource.endOfStream();
      await this.notifyPlayback();
    }
  }
  async notifyPlayback() {
    if (!this.privPlaybackStarted && this.privAudio !== undefined) {
      this.privPlaybackStarted = true;
      if (!!this.onAudioStart) {
        this.onAudioStart(this);
      }
      this.privAudio.onended = () => {
        if (!!this.onAudioEnd) {
          this.onAudioEnd(this);
        }
      };
      if (!this.privIsPaused) {
        await this.privAudio.play();
      }
    }
  }
  canEndStream() {
    return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
  }
  sourceBufferAvailable() {
    return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;
  }
}
exports.SpeakerAudioDestination = SpeakerAudioDestination;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AutoDetectSourceLanguageConfig.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AutoDetectSourceLanguageConfig.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AutoDetectSourceLanguageConfig = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const LanguageIdMode_js_1 = __webpack_require__(/*! ./LanguageIdMode.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LanguageIdMode.js");
/**
 * Language auto detect configuration.
 * @class AutoDetectSourceLanguageConfig
 * Added in version 1.13.0.
 */
class AutoDetectSourceLanguageConfig {
  constructor() {
    this.privProperties = new Exports_js_2.PropertyCollection();
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart");
    this.privLanguageIdMode = LanguageIdMode_js_1.LanguageIdMode.AtStart;
  }
  /**
   * @member AutoDetectSourceLanguageConfig.fromOpenRange
   * @function
   * @public
   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
   * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
   * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
   */
  static fromOpenRange() {
    const config = new AutoDetectSourceLanguageConfig();
    config.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, Exports_js_1.AutoDetectSourceLanguagesOpenRangeOptionName);
    return config;
  }
  /**
   * @member AutoDetectSourceLanguageConfig.fromLanguages
   * @function
   * @public
   * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
   */
  static fromLanguages(languages) {
    Contracts_js_1.Contracts.throwIfArrayEmptyOrWhitespace(languages, "languages");
    const config = new AutoDetectSourceLanguageConfig();
    config.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, languages.join());
    return config;
  }
  /**
   * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
   * @function
   * @public
   * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
   * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
   * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
   */
  static fromSourceLanguageConfigs(configs) {
    if (configs.length < 1) {
      throw new Error("Expected non-empty SourceLanguageConfig array.");
    }
    const autoConfig = new AutoDetectSourceLanguageConfig();
    const langs = [];
    configs.forEach(config => {
      langs.push(config.language);
      if (config.endpointId !== undefined && config.endpointId !== "") {
        const customProperty = config.language + Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId.toString();
        autoConfig.properties.setProperty(customProperty, config.endpointId);
      }
    });
    autoConfig.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, langs.join());
    return autoConfig;
  }
  /**
   * @member AutoDetectSourceLanguageConfig.prototype.properties
   * @function
   * @public
   * @return {PropertyCollection} Properties of the config.
   * @summary Gets an auto detected language config properties
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * @member AutoDetectSourceLanguageConfig.prototype.mode
   * @function
   * @public
   * @param {LanguageIdMode} mode LID mode desired.
   * @summary Sets LID operation to desired mode
   */
  set mode(mode) {
    if (mode === LanguageIdMode_js_1.LanguageIdMode.Continuous) {
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous");
    } else {
      // LanguageIdMode.AtStart
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1");
      this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart");
    }
    this.privLanguageIdMode = mode;
  }
}
exports.AutoDetectSourceLanguageConfig = AutoDetectSourceLanguageConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AutoDetectSourceLanguageResult.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AutoDetectSourceLanguageResult.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AutoDetectSourceLanguageResult = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
/**
 * Output format
 * @class AutoDetectSourceLanguageResult
 */
class AutoDetectSourceLanguageResult {
  constructor(language, languageDetectionConfidence) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(language, "language");
    Contracts_js_1.Contracts.throwIfNullOrUndefined(languageDetectionConfidence, "languageDetectionConfidence");
    this.privLanguage = language;
    this.privLanguageDetectionConfidence = languageDetectionConfidence;
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
   * @member AutoDetectSourceLanguageResult.fromResult
   * @function
   * @public
   * @param {SpeechRecognitionResult} result - The recognition result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromResult(result) {
    return new AutoDetectSourceLanguageResult(result.language, result.languageDetectionConfidence);
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
   * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
   * @function
   * @public
   * @param {ConversationTranscriptionResult} result - The transcription result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromConversationTranscriptionResult(result) {
    return new AutoDetectSourceLanguageResult(result.language, result.languageDetectionConfidence);
  }
  get language() {
    return this.privLanguage;
  }
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
}
exports.AutoDetectSourceLanguageResult = AutoDetectSourceLanguageResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarConfig.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarConfig.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AvatarConfig = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines the talking avatar configuration.
 * @class AvatarConfig
 * Added in version 1.33.0
 *
 * @experimental This feature is experimental and might change or have limited support.
 */
class AvatarConfig {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} character - The avatar character.
   * @param {string} style - The avatar style.
   * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
   */
  constructor(character, style, videoFormat) {
    this.privCustomized = false;
    this.privUseBuiltInVoice = false;
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(character, "character");
    this.character = character;
    this.style = style;
    if (videoFormat === undefined) {
      videoFormat = new Exports_js_1.AvatarVideoFormat();
    }
    this.videoFormat = videoFormat;
  }
  /**
   * Indicates if the talking avatar is customized.
   */
  get customized() {
    return this.privCustomized;
  }
  /**
   * Sets if the talking avatar is customized.
   */
  set customized(value) {
    this.privCustomized = value;
  }
  /**
   * Indicates whether to use built-in voice for custom avatar.
   */
  get useBuiltInVoice() {
    return this.privUseBuiltInVoice;
  }
  /**
   * Sets whether to use built-in voice for custom avatar.
   */
  set useBuiltInVoice(value) {
    this.privUseBuiltInVoice = value;
  }
  /**
   * Gets the background color.
   */
  get backgroundColor() {
    return this.privBackgroundColor;
  }
  /**
   * Sets the background color.
   */
  set backgroundColor(value) {
    this.privBackgroundColor = value;
  }
  /**
   * Gets the background image.
   */
  get backgroundImage() {
    return this.privBackgroundImage;
  }
  /**
   * Sets the background image.
   * @param {URL} value - The background image.
   */
  set backgroundImage(value) {
    this.privBackgroundImage = value;
  }
  /**
   * Gets the remote ICE servers.
   * @remarks This method is designed to be used internally in the SDK.
   * @returns {RTCIceServer[]} The remote ICE servers.
   */
  get remoteIceServers() {
    return this.privRemoteIceServers;
  }
  /**
   * Sets the remote ICE servers.
   * @remarks Normally, the ICE servers are gathered from the PeerConnection,
   * set this property to override the ICE servers. E.g., the ICE servers are
   * different in client and server side.
   * @param {RTCIceServer[]} value - The remote ICE servers.
   */
  set remoteIceServers(value) {
    this.privRemoteIceServers = value;
  }
}
exports.AvatarConfig = AvatarConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarEventArgs.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarEventArgs.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AvatarEventArgs = exports.AvatarEventTypes = void 0;
var AvatarEventTypes;
(function (AvatarEventTypes) {
  AvatarEventTypes["SwitchedToSpeaking"] = "SwitchedToSpeaking";
  AvatarEventTypes["SwitchedToIdle"] = "SwitchedToIdle";
  AvatarEventTypes["SessionClosed"] = "SessionClosed";
})(AvatarEventTypes = exports.AvatarEventTypes || (exports.AvatarEventTypes = {}));
/**
 * Defines content for talking avatar events.
 * @class AvatarEventArgs
 * Added in version 1.33.0
 *
 * @experimental This feature is experimental and might change or have limited support.
 */
class AvatarEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {string} description - The description of the event.
   */
  constructor(audioOffset, description) {
    this.privOffset = audioOffset;
    this.privDescription = description;
  }
  /**
   * The type of the event.
   * @public
   * @returns {AvatarEventTypes} The type of the event.
   */
  get type() {
    return this.privType;
  }
  /**
   * The time offset associated with this event.
   * @public
   * @returns {number} The time offset associated with this event.
   */
  get offset() {
    return this.privOffset;
  }
  /**
   * The description of the event.
   * @public
   * @returns {string} The description of the event.
   */
  get description() {
    return this.privDescription;
  }
}
exports.AvatarEventArgs = AvatarEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarSynthesizer.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarSynthesizer.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AvatarSynthesizer = void 0;
const SpeechSynthesisConnectionFactory_js_1 = __webpack_require__(/*! ../common.speech/SpeechSynthesisConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/SpeechSynthesisConnectionFactory.js");
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const AudioOutputFormat_js_1 = __webpack_require__(/*! ./Audio/AudioOutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Synthesizer_js_1 = __webpack_require__(/*! ./Synthesizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Synthesizer.js");
/**
 * Defines the avatar synthesizer.
 * @class AvatarSynthesizer
 * Added in version 1.33.0
 *
 * @experimental This feature is experimental and might change or have limited support.
 */
class AvatarSynthesizer extends Exports_js_3.Synthesizer {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {SpeechConfig} speechConfig - The speech config.
   * @param {AvatarConfig} avatarConfig - The talking avatar config.
   */
  constructor(speechConfig, avatarConfig) {
    super(speechConfig);
    Contracts_js_1.Contracts.throwIfNullOrUndefined(avatarConfig, "avatarConfig");
    this.privConnectionFactory = new SpeechSynthesisConnectionFactory_js_1.SpeechSynthesisConnectionFactory();
    this.privAvatarConfig = avatarConfig;
    this.implCommonSynthesizeSetup();
  }
  implCommonSynthesizeSetup() {
    super.implCommonSynthesizeSetup();
    // The service checks the audio format setting while it ignores it in avatar synthesis.
    this.privAdapter.audioOutputFormat = AudioOutputFormat_js_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(Exports_js_3.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
  }
  /**
   * Starts the talking avatar session and establishes the WebRTC connection.
   * @member AvatarSynthesizer.prototype.startAvatarAsync
   * @function
   * @public
   * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
   * @returns {Promise<SynthesisResult>} The promise of the connection result.
   */
  async startAvatarAsync(peerConnection) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(peerConnection, "peerConnection");
    this.privIceServers = peerConnection.getConfiguration().iceServers;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
    const iceGatheringDone = new Exports_js_2.Deferred();
    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/icegatheringstatechange_event
    peerConnection.onicegatheringstatechange = () => {
      Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice gathering state: " + peerConnection.iceGatheringState, Exports_js_2.EventType.Debug));
      if (peerConnection.iceGatheringState === "complete") {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice gathering complete.", Exports_js_2.EventType.Info));
        iceGatheringDone.resolve();
      }
    };
    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice candidate: " + event.candidate.candidate, Exports_js_2.EventType.Debug));
      } else {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice candidate: complete", Exports_js_2.EventType.Debug));
        iceGatheringDone.resolve();
      }
    };
    // Set a timeout for ice gathering, currently 2 seconds.
    setTimeout(() => {
      if (peerConnection.iceGatheringState !== "complete") {
        Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: ice gathering timeout.", Exports_js_2.EventType.Warning));
        iceGatheringDone.resolve();
      }
    }, 2000);
    const sdp = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(sdp);
    await iceGatheringDone.promise;
    Exports_js_2.Events.instance.onEvent(new Exports_js_2.PlatformEvent("peer connection: got local SDP.", Exports_js_2.EventType.Info));
    this.privProperties.setProperty(Exports_js_3.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(peerConnection.localDescription));
    const result = await this.speak("", false);
    if (result.reason !== Exports_js_3.ResultReason.SynthesizingAudioCompleted) {
      return new Exports_js_3.SynthesisResult(result.resultId, result.reason, result.errorDetails, result.properties);
    }
    const sdpAnswerString = atob(result.properties.getProperty(Exports_js_3.PropertyId.TalkingAvatarService_WebRTC_SDP));
    const sdpAnswer = new RTCSessionDescription(JSON.parse(sdpAnswerString));
    await peerConnection.setRemoteDescription(sdpAnswer);
    return new Exports_js_3.SynthesisResult(result.resultId, result.reason, undefined, result.properties);
  }
  /**
   * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
   * @member AvatarSynthesizer.prototype.speakTextAsync
   * @function
   * @public
   * @param {string} text - The plain text to speak.
   * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
   */
  async speakTextAsync(text) {
    const r = await this.speak(text, false);
    return new Exports_js_3.SynthesisResult(r.resultId, r.reason, r.errorDetails, r.properties);
  }
  /**
   * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
   * @member AvatarSynthesizer.prototype.speakSsmlAsync
   * @function
   * @public
   * @param {string} ssml - The SSML text to speak.
   * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
   */
  async speakSsmlAsync(ssml) {
    const r = await this.speak(ssml, true);
    return new Exports_js_3.SynthesisResult(r.resultId, r.reason, r.errorDetails, r.properties);
  }
  /**
   * Speaks text asynchronously. The avatar will switch to idle state.
   * @member AvatarSynthesizer.prototype.stopSpeakingAsync
   * @function
   * @public
   * @returns {Promise<void>} The promise of the void result.
   */
  async stopSpeakingAsync() {
    while (this.synthesisRequestQueue.length() > 0) {
      const request = await this.synthesisRequestQueue.dequeue();
      request.err("Synthesis is canceled by user.");
    }
    return this.privAdapter.stopSpeaking();
  }
  /**
   * Stops the talking avatar session and closes the WebRTC connection.
   * For now, this is the same as close().
   * You need to create a new AvatarSynthesizer instance to start a new session.
   * @member AvatarSynthesizer.prototype.stopAvatarAsync
   * @function
   * @public
   * @returns {Promise<void>} The promise of the void result.
   */
  async stopAvatarAsync() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);
    return this.dispose(true);
  }
  /**
   * Dispose of associated resources.
   * @member AvatarSynthesizer.prototype.close
   * @function
   * @public
   */
  async close() {
    if (this.privDisposed) {
      return;
    }
    return this.dispose(true);
  }
  /**
   * Gets the ICE servers. Internal use only.
   */
  get iceServers() {
    return this.privIceServers;
  }
  // Creates the synthesis adapter
  createSynthesisAdapter(authentication, connectionFactory, synthesizerConfig) {
    return new Exports_js_1.AvatarSynthesisAdapter(authentication, connectionFactory, synthesizerConfig, this, this.privAvatarConfig);
  }
  createRestSynthesisAdapter(_authentication, _synthesizerConfig) {
    return undefined;
  }
  createSynthesizerConfig(speechConfig) {
    const config = super.createSynthesizerConfig(speechConfig);
    config.avatarEnabled = true;
    return config;
  }
  async speak(text, isSSML) {
    const requestId = Exports_js_2.createNoDashGuid();
    const deferredResult = new Exports_js_2.Deferred();
    this.synthesisRequestQueue.enqueue(new Synthesizer_js_1.SynthesisRequest(requestId, text, isSSML, e => {
      deferredResult.resolve(e);
      this.privSynthesizing = false;
      void this.adapterSpeak();
    }, e => {
      deferredResult.reject(e);
      this.privSynthesizing = false;
    }));
    void this.adapterSpeak();
    return deferredResult.promise;
  }
}
exports.AvatarSynthesizer = AvatarSynthesizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarVideoFormat.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarVideoFormat.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AvatarVideoFormat = exports.Coordinate = void 0;
/* eslint-disable max-classes-per-file */
/**
 * Defines a coordinate in 2D space.
 * @class Coordinate
 * Added in version 1.33.0
 */
class Coordinate {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}
exports.Coordinate = Coordinate;
/**
 * Defines the avatar output video format.
 * @class AvatarVideoFormat
 * Added in version 1.33.0
 *
 * @experimental This feature is experimental and might change in the future.
 */
class AvatarVideoFormat {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} codec - The video codec.
   * @param {number} bitrate - The video bitrate.
   * @param {number} width - The video width.
   * @param {number} height - The video height.
   */
  constructor(codec = "H264", bitrate = 2000000, width = 1920, height = 1080) {
    this.codec = codec;
    this.bitrate = bitrate;
    this.width = width;
    this.height = height;
  }
  /**
   * Sets the video crop range.
   */
  setCropRange(topLeft, bottomRight) {
    this.cropRange = {
      bottomRight,
      topLeft
    };
  }
}
exports.AvatarVideoFormat = AvatarVideoFormat;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarWebRTCConnectionResult.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarWebRTCConnectionResult.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AvatarWebRTCConnectionResult = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines the avatar WebRTC connection result.
 * @class AvatarWebRTCConnectionResult
 * Added in version 1.33.0
 *
 * @experimental This feature is experimental and might change in the future.
 */
class AvatarWebRTCConnectionResult extends Exports_js_1.SynthesisResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(SDPAnswer, resultId, reason, errorDetails, properties) {
    super(resultId, reason, errorDetails, properties);
    this.privSDPAnswer = SDPAnswer;
  }
  /**
   * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
   * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
   * @function
   * @public
   * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
   */
  get SDPAnswer() {
    return this.privSDPAnswer;
  }
}
exports.AvatarWebRTCConnectionResult = AvatarWebRTCConnectionResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/BotFrameworkConfig.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/BotFrameworkConfig.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BotFrameworkConfig = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const DialogServiceConfig_js_1 = __webpack_require__(/*! ./DialogServiceConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConfig.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Class that defines configurations for the dialog service connector object for using a Bot Framework backend.
 * @class BotFrameworkConfig
 */
class BotFrameworkConfig extends DialogServiceConfig_js_1.DialogServiceConfigImpl {
  /**
   * Creates an instance of BotFrameworkConfig.
   */
  constructor() {
    super();
  }
  /**
   * Creates a bot framework configuration instance with the provided subscription information.
   * @member BotFrameworkConfig.fromSubscription
   * @function
   * @public
   * @param subscription Subscription key associated with the bot
   * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
   * resource name.
   * @returns {BotFrameworkConfig} A new bot framework configuration instance.
   */
  static fromSubscription(subscription, region, botId) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(subscription, "subscription");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Key, subscription);
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Region, region);
    if (botId) {
      botFrameworkConfig.setProperty(Exports_js_1.PropertyId.Conversation_ApplicationId, botId);
    }
    return botFrameworkConfig;
  }
  /**
   * Creates a bot framework configuration instance for the specified authorization token and region.
   * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
   * caller must refresh it by setting the authorizationToken property on the corresponding
   * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
   * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
   * original configuration's authorization token. Create a new configuration instance or set the
   * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
   * further DialogServiceConnectors.
   * @member BotFrameworkConfig.fromAuthorizationToken
   * @function
   * @public
   * @param authorizationToken The authorization token associated with the bot
   * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
   * resource name.
   * @returns {BotFrameworkConfig} A new bot framework configuration instance.
   */
  static fromAuthorizationToken(authorizationToken, region, botId) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Region, region);
    if (botId) {
      botFrameworkConfig.setProperty(Exports_js_1.PropertyId.Conversation_ApplicationId, botId);
    }
    return botFrameworkConfig;
  }
  /**
   * Creates an instance of a BotFrameworkConfig.
   * This method is intended only for users who use a non-default service host. The standard resource path will be
   * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
   * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
   * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
   * property on the created BotFrameworkConfig instance.
   * Note: Added in version 1.15.0.
   * @member BotFrameworkConfig.fromHost
   * @function
   * @public
   * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
   * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
   * wss://{host}.convai.speech.azure.us.
   * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
   * token must be set.
   * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
   * resource name.
   * @returns {BotFrameworkConfig} A new bot framework configuration instance.
   */
  static fromHost(host, subscriptionKey, botId) {
    void botId;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(host, "host");
    const resolvedHost = host instanceof URL ? host : new URL(`wss://${host}.convai.speech.azure.us`);
    Contracts_js_1.Contracts.throwIfNullOrUndefined(resolvedHost, "resolvedHost");
    const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Host, resolvedHost.toString());
    if (undefined !== subscriptionKey) {
      botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    }
    return botFrameworkConfig;
  }
  /**
   * Creates an instance of a BotFrameworkConfig.
   * This method is intended only for users who use a non-standard service endpoint or parameters.
   * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
   * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
   * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
   * use the authorization token.
   * Note: Added in version 1.15.0.
   * @member BotFrameworkConfig.fromEndpoint
   * @function
   * @public
   * @param {URL} endpoint - The service endpoint to connect to.
   * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
   * token must be set.
   * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
   */
  static fromEndpoint(endpoint, subscriptionKey) {
    Contracts_js_1.Contracts.throwIfNull(endpoint, "endpoint");
    const botFrameworkConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.BotFramework);
    botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Endpoint, endpoint.toString());
    if (undefined !== subscriptionKey) {
      botFrameworkConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    }
    return botFrameworkConfig;
  }
}
exports.BotFrameworkConfig = BotFrameworkConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationDetails.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationDetails.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CancellationDetails = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const CancellationDetailsBase_js_1 = __webpack_require__(/*! ./CancellationDetailsBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationDetailsBase.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Contains detailed information about why a result was canceled.
 * @class CancellationDetails
 */
class CancellationDetails extends CancellationDetailsBase_js_1.CancellationDetailsBase {
  constructor(reason, errorDetails, errorCode) {
    super(reason, errorDetails, errorCode);
  }
  /**
   * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
   * @member CancellationDetails.fromResult
   * @function
   * @public
   * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
   * @returns {CancellationDetails} The cancellation details object being created.
   */
  static fromResult(result) {
    let reason = Exports_js_2.CancellationReason.Error;
    let errorCode = Exports_js_2.CancellationErrorCode.NoError;
    if (result instanceof Exports_js_2.RecognitionResult && !!result.json) {
      const simpleSpeech = Exports_js_1.SimpleSpeechPhrase.fromJSON(result.json, 0); // Offset fixups are already done.
      reason = Exports_js_1.EnumTranslation.implTranslateCancelResult(simpleSpeech.RecognitionStatus);
    }
    if (!!result.properties) {
      errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_1.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])];
    }
    return new CancellationDetails(reason, result.errorDetails || Exports_js_1.EnumTranslation.implTranslateErrorDetails(errorCode), errorCode);
  }
}
exports.CancellationDetails = CancellationDetails;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationDetailsBase.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationDetailsBase.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CancellationDetailsBase = void 0;
/**
 * Contains detailed information about why a result was canceled.
 * @class CancellationDetailsBase
 */
class CancellationDetailsBase {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {CancellationReason} reason - The cancellation reason.
   * @param {string} errorDetails - The error details, if provided.
   */
  constructor(reason, errorDetails, errorCode) {
    this.privReason = reason;
    this.privErrorDetails = errorDetails;
    this.privErrorCode = errorCode;
  }
  /**
   * The reason the recognition was canceled.
   * @member CancellationDetailsBase.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member CancellationDetailsBase.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get ErrorCode() {
    return this.privErrorCode;
  }
}
exports.CancellationDetailsBase = CancellationDetailsBase;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationErrorCodes.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationErrorCodes.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CancellationErrorCode = void 0;
/**
 * Defines error code in case that CancellationReason is Error.
 * Added in version 1.1.0.
 */
var CancellationErrorCode;
(function (CancellationErrorCode) {
  /**
   * Indicates that no error occurred during speech recognition.
   */
  CancellationErrorCode[CancellationErrorCode["NoError"] = 0] = "NoError";
  /**
   * Indicates an authentication error.
   */
  CancellationErrorCode[CancellationErrorCode["AuthenticationFailure"] = 1] = "AuthenticationFailure";
  /**
   * Indicates that one or more recognition parameters are invalid.
   */
  CancellationErrorCode[CancellationErrorCode["BadRequestParameters"] = 2] = "BadRequestParameters";
  /**
   * Indicates that the number of parallel requests exceeded the number of allowed
   * concurrent transcriptions for the subscription.
   */
  CancellationErrorCode[CancellationErrorCode["TooManyRequests"] = 3] = "TooManyRequests";
  /**
   * Indicates a connection error.
   */
  CancellationErrorCode[CancellationErrorCode["ConnectionFailure"] = 4] = "ConnectionFailure";
  /**
   * Indicates a time-out error when waiting for response from service.
   */
  CancellationErrorCode[CancellationErrorCode["ServiceTimeout"] = 5] = "ServiceTimeout";
  /**
   * Indicates that an error is returned by the service.
   */
  CancellationErrorCode[CancellationErrorCode["ServiceError"] = 6] = "ServiceError";
  /**
   * Indicates an unexpected runtime error.
   */
  CancellationErrorCode[CancellationErrorCode["RuntimeError"] = 7] = "RuntimeError";
  /**
   * Indicates an quota overrun on existing key.
   */
  CancellationErrorCode[CancellationErrorCode["Forbidden"] = 8] = "Forbidden";
})(CancellationErrorCode = exports.CancellationErrorCode || (exports.CancellationErrorCode = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationEventArgsBase.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationEventArgsBase.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CancellationEventArgsBase = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines content of a CancellationEvent.
 * @class CancellationEventArgsBase
 */
class CancellationEventArgsBase extends Exports_js_1.RecognitionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {CancellationReason} reason - The cancellation reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {number} offset - The offset.
   * @param {string} sessionId - The session id.
   */
  constructor(reason, errorDetails, errorCode, offset, sessionId) {
    super(offset, sessionId);
    this.privReason = reason;
    this.privErrorDetails = errorDetails;
    this.privErrorCode = errorCode;
  }
  /**
   * The reason the recognition was canceled.
   * @member CancellationEventArgsBase.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * The error code in case of an unsuccessful operation.
   * @return An error code that represents the error reason.
   */
  get errorCode() {
    return this.privErrorCode;
  }
  /**
   * In case of an unsuccessful operation, provides details of the occurred error.
   * @member CancellationEventArgsBase.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
}
exports.CancellationEventArgsBase = CancellationEventArgsBase;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationReason.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationReason.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CancellationReason = void 0;
/**
 * Defines the possible reasons a recognition result might be canceled.
 * @class CancellationReason
 */
var CancellationReason;
(function (CancellationReason) {
  /**
   * Indicates that an error occurred during speech recognition.
   * @member CancellationReason.Error
   */
  CancellationReason[CancellationReason["Error"] = 0] = "Error";
  /**
   * Indicates that the end of the audio stream was reached.
   * @member CancellationReason.EndOfStream
   */
  CancellationReason[CancellationReason["EndOfStream"] = 1] = "EndOfStream";
})(CancellationReason = exports.CancellationReason || (exports.CancellationReason = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Connection.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Connection.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Connection = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const ConnectionMessage_js_1 = __webpack_require__(/*! ./ConnectionMessage.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionMessage.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Connection is a proxy class for managing connection to the speech service of the specified Recognizer.
 * By default, a Recognizer autonomously manages connection to service when needed.
 * The Connection class provides additional methods for users to explicitly open or close a connection and
 * to subscribe to connection status changes.
 * The use of Connection is optional, and mainly for scenarios where fine tuning of application
 * behavior based on connection status is needed. Users can optionally call Open() to manually set up a connection
 * in advance before starting recognition on the Recognizer associated with this Connection.
 * If the Recognizer needs to connect or disconnect to service, it will
 * setup or shutdown the connection independently. In this case the Connection will be notified by change of connection
 * status via Connected/Disconnected events.
 * Added in version 1.2.1.
 */
class Connection {
  /**
   * Gets the Connection instance from the specified recognizer.
   * @param recognizer The recognizer associated with the connection.
   * @return The Connection instance of the recognizer.
   */
  static fromRecognizer(recognizer) {
    const recoBase = recognizer.internalData;
    const ret = new Connection();
    ret.privInternalData = recoBase;
    ret.setupEvents();
    return ret;
  }
  /**
   * Gets the Connection instance from the specified synthesizer.
   * @param synthesizer The synthesizer associated with the connection.
   * @return The Connection instance of the synthesizer.
   */
  static fromSynthesizer(synthesizer) {
    const synthBase = synthesizer.internalData;
    const ret = new Connection();
    ret.privInternalData = synthBase;
    ret.setupEvents();
    return ret;
  }
  /**
   * Starts to set up connection to the service.
   * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
   * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
   *
   * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
   * be notified when the connection is established.
   */
  openConnection(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.connect(), cb, err);
  }
  /**
   * Closes the connection the service.
   * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
   *
   * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
   */
  closeConnection(cb, err) {
    if (this.privInternalData instanceof Exports_js_1.SynthesisAdapterBase) {
      throw new Error("Disconnecting a synthesizer's connection is currently not supported");
    } else {
      Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.disconnect(), cb, err);
    }
  }
  /**
   * Appends a parameter in a message to service.
   * Added in version 1.12.1.
   * @param path The path of the network message.
   * @param propertyName Name of the property
   * @param propertyValue Value of the property. This is a json string.
   */
  setMessageProperty(path, propertyName, propertyValue) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(propertyName, "propertyName");
    if (this.privInternalData instanceof Exports_js_1.ServiceRecognizerBase) {
      if (path.toLowerCase() !== "speech.context") {
        throw new Error("Only speech.context message property sets are currently supported for recognizer");
      } else {
        this.privInternalData.speechContext.setSection(propertyName, propertyValue);
      }
    } else if (this.privInternalData instanceof Exports_js_1.SynthesisAdapterBase) {
      if (path.toLowerCase() !== "synthesis.context") {
        throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
      } else {
        this.privInternalData.synthesisContext.setSection(propertyName, propertyValue);
      }
    }
  }
  /**
   * Sends a message to the speech service.
   * Added in version 1.13.0.
   * @param path The WebSocket path of the message
   * @param payload The payload of the message. This is a json string or a ArrayBuffer.
   * @param success A callback to indicate success.
   * @param error A callback to indicate an error.
   */
  sendMessageAsync(path, payload, success, error) {
    Exports_js_2.marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(path, payload), success, error);
  }
  /**
   * Dispose of associated resources.
   */
  close() {
    /* eslint-disable no-empty */
  }
  setupEvents() {
    this.privEventListener = this.privInternalData.connectionEvents.attach(connectionEvent => {
      if (connectionEvent.name === "ConnectionEstablishedEvent") {
        if (!!this.connected) {
          this.connected(new Exports_js_3.ConnectionEventArgs(connectionEvent.connectionId));
        }
      } else if (connectionEvent.name === "ConnectionClosedEvent") {
        if (!!this.disconnected) {
          this.disconnected(new Exports_js_3.ConnectionEventArgs(connectionEvent.connectionId));
        }
      } else if (connectionEvent.name === "ConnectionMessageSentEvent") {
        if (!!this.messageSent) {
          this.messageSent(new Exports_js_3.ConnectionMessageEventArgs(new ConnectionMessage_js_1.ConnectionMessageImpl(connectionEvent.message)));
        }
      } else if (connectionEvent.name === "ConnectionMessageReceivedEvent") {
        if (!!this.messageReceived) {
          this.messageReceived(new Exports_js_3.ConnectionMessageEventArgs(new ConnectionMessage_js_1.ConnectionMessageImpl(connectionEvent.message)));
        }
      }
    });
    this.privServiceEventListener = this.privInternalData.serviceEvents.attach(e => {
      if (!!this.receivedServiceMessage) {
        this.receivedServiceMessage(new Exports_js_3.ServiceEventArgs(e.jsonString, e.name));
      }
    });
  }
}
exports.Connection = Connection;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionEventArgs.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionEventArgs.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines payload for connection events like Connected/Disconnected.
 * Added in version 1.2.0
 */
class ConnectionEventArgs extends Exports_js_1.SessionEventArgs {}
exports.ConnectionEventArgs = ConnectionEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionMessage.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionMessage.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionMessageImpl = exports.ConnectionMessage = void 0;
// eslint-disable-next-line max-classes-per-file
const HeaderNames_js_1 = __webpack_require__(/*! ../common.speech/HeaderNames.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/HeaderNames.js");
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const PropertyCollection_js_1 = __webpack_require__(/*! ./PropertyCollection.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyCollection.js");
const PropertyId_js_1 = __webpack_require__(/*! ./PropertyId.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyId.js");
/**
 * ConnectionMessage represents implementation specific messages sent to and received from
 * the speech service. These messages are provided for debugging purposes and should not
 * be used for production use cases with the Azure Cognitive Services Speech Service.
 * Messages sent to and received from the Speech Service are subject to change without
 * notice. This includes message contents, headers, payloads, ordering, etc.
 * Added in version 1.11.0.
 */
class ConnectionMessage {}
exports.ConnectionMessage = ConnectionMessage;
class ConnectionMessageImpl {
  constructor(message) {
    this.privConnectionMessage = message;
    this.privProperties = new PropertyCollection_js_1.PropertyCollection();
    if (!!this.privConnectionMessage.headers[HeaderNames_js_1.HeaderNames.ConnectionId]) {
      this.privProperties.setProperty(PropertyId_js_1.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames_js_1.HeaderNames.ConnectionId]);
    }
    Object.keys(this.privConnectionMessage.headers).forEach(header => {
      this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);
    });
  }
  /**
   * The message path.
   */
  get path() {
    return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find(key => key.toLowerCase() === "path".toLowerCase())];
  }
  /**
   * Checks to see if the ConnectionMessage is a text message.
   * See also IsBinaryMessage().
   */
  get isTextMessage() {
    return this.privConnectionMessage.messageType === Exports_js_1.MessageType.Text;
  }
  /**
   * Checks to see if the ConnectionMessage is a binary message.
   * See also GetBinaryMessage().
   */
  get isBinaryMessage() {
    return this.privConnectionMessage.messageType === Exports_js_1.MessageType.Binary;
  }
  /**
   * Gets the text message payload. Typically the text message content-type is
   * application/json. To determine other content-types use
   * Properties.GetProperty("Content-Type").
   */
  get TextMessage() {
    return this.privConnectionMessage.textBody;
  }
  /**
   * Gets the binary message payload.
   */
  get binaryMessage() {
    return this.privConnectionMessage.binaryBody;
  }
  /**
   * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
   * Message headers can be accessed via this collection (e.g. "Content-Type").
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Returns a string that represents the connection message.
   */
  toString() {
    return "";
  }
}
exports.ConnectionMessageImpl = ConnectionMessageImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionMessageEventArgs.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionMessageEventArgs.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectionMessageEventArgs = void 0;
class ConnectionMessageEventArgs {
  constructor(message) {
    this.privConnectionMessage = message;
  }
  /**
   * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
   */
  get message() {
    return this.privConnectionMessage;
  }
  /**
   * Returns a string that represents the connection message event.
   */
  toString() {
    return "Message: " + this.privConnectionMessage.toString();
  }
}
exports.ConnectionMessageEventArgs = ConnectionMessageEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Contracts = void 0;
/**
 * @class Contracts
 * @private
 */
class Contracts {
  static throwIfNullOrUndefined(param, name) {
    if (param === undefined || param === null) {
      throw new Error("throwIfNullOrUndefined:" + name);
    }
  }
  static throwIfNull(param, name) {
    if (param === null) {
      throw new Error("throwIfNull:" + name);
    }
  }
  static throwIfNullOrWhitespace(param, name) {
    Contracts.throwIfNullOrUndefined(param, name);
    if (("" + param).trim().length < 1) {
      throw new Error("throwIfNullOrWhitespace:" + name);
    }
  }
  static throwIfNullOrTooLong(param, name, maxLength) {
    Contracts.throwIfNullOrUndefined(param, name);
    if (("" + param).length > maxLength) {
      throw new Error("throwIfNullOrTooLong:" + name + " (more than " + maxLength.toString() + " characters)");
    }
  }
  static throwIfNullOrTooShort(param, name, minLength) {
    Contracts.throwIfNullOrUndefined(param, name);
    if (("" + param).length < minLength) {
      throw new Error("throwIfNullOrTooShort:" + name + " (less than " + minLength.toString() + " characters)");
    }
  }
  static throwIfDisposed(isDisposed) {
    if (isDisposed) {
      throw new Error("the object is already disposed");
    }
  }
  static throwIfArrayEmptyOrWhitespace(array, name) {
    Contracts.throwIfNullOrUndefined(array, name);
    if (array.length === 0) {
      throw new Error("throwIfArrayEmptyOrWhitespace:" + name);
    }
    for (const item of array) {
      Contracts.throwIfNullOrWhitespace(item, name);
    }
  }
  static throwIfFileDoesNotExist(param, name) {
    Contracts.throwIfNullOrWhitespace(param, name);
    // TODO check for file existence.
  }
  static throwIfNotUndefined(param, name) {
    if (param !== undefined) {
      throw new Error("throwIfNotUndefined:" + name);
    }
  }
}
exports.Contracts = Contracts;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConversationTranscriptionCanceledEventArgs.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConversationTranscriptionCanceledEventArgs.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranscriptionCanceledEventArgs = void 0;
const CancellationEventArgsBase_js_1 = __webpack_require__(/*! ./CancellationEventArgsBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationEventArgsBase.js");
/**
 * Defines content of a RecognitionErrorEvent.
 * @class ConversationTranscriptionCanceledEventArgs
 */
class ConversationTranscriptionCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {}
exports.ConversationTranscriptionCanceledEventArgs = ConversationTranscriptionCanceledEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CustomCommandsConfig.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CustomCommandsConfig.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CustomCommandsConfig = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const DialogServiceConfig_js_1 = __webpack_require__(/*! ./DialogServiceConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConfig.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Class that defines configurations for the dialog service connector object for using a CustomCommands backend.
 * @class CustomCommandsConfig
 */
class CustomCommandsConfig extends DialogServiceConfig_js_1.DialogServiceConfigImpl {
  /**
   * Creates an instance of CustomCommandsConfig.
   */
  constructor() {
    super();
  }
  /**
   * Creates an instance of the bot framework config with the specified subscription and region.
   * @member CustomCommandsConfig.fromSubscription
   * @function
   * @public
   * @param applicationId Speech Commands application id.
   * @param subscription Subscription key associated with the bot
   * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {CustomCommandsConfig} A new bot framework config.
   */
  static fromSubscription(applicationId, subscription, region) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(applicationId, "applicationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(subscription, "subscription");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const customCommandsConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.CustomCommands);
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.Conversation_ApplicationId, applicationId);
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Key, subscription);
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Region, region);
    return customCommandsConfig;
  }
  /**
   * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
   * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
   * expires, the caller needs to refresh it by calling this setter with a new valid token.
   * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
   * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
   * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
   * @member CustomCommandsConfig.fromAuthorizationToken
   * @function
   * @public
   * @param applicationId Speech Commands application id.
   * @param authorizationToken The authorization token associated with the application.
   * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {CustomCommandsConfig} A new speech commands config.
   */
  static fromAuthorizationToken(applicationId, authorizationToken, region) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(applicationId, "applicationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const customCommandsConfig = new DialogServiceConfig_js_1.DialogServiceConfigImpl();
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.Conversation_DialogType, DialogServiceConfig_js_1.DialogServiceConfig.DialogTypes.CustomCommands);
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.Conversation_ApplicationId, applicationId);
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
    customCommandsConfig.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_Region, region);
    return customCommandsConfig;
  }
  /**
   * Sets the corresponding backend application identifier.
   * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
   * @function
   * @public
   * @param {string} value - The application identifier to set.
   */
  set applicationId(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "value");
    this.setProperty(Exports_js_1.PropertyId.Conversation_ApplicationId, value);
  }
  /**
   * Gets the corresponding backend application identifier.
   * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
   * @function
   * @public
   * @param {string} value - The application identifier to get.
   */
  get applicationId() {
    return this.getProperty(Exports_js_1.PropertyId.Conversation_ApplicationId);
  }
}
exports.CustomCommandsConfig = CustomCommandsConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Diagnostics.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Diagnostics.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Diagnostics = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.browser/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.browser/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
/**
 * Defines diagnostics API for managing console output
 * Added in version 1.21.0
 */
class Diagnostics {
  static SetLoggingLevel(logLevel) {
    this.privListener = new Exports_js_1.ConsoleLoggingListener(logLevel);
    Exports_js_2.Events.instance.attachConsoleListener(this.privListener);
  }
  static StartConsoleOutput() {
    if (!!this.privListener) {
      this.privListener.enableConsoleOutput = true;
    }
  }
  static StopConsoleOutput() {
    if (!!this.privListener) {
      this.privListener.enableConsoleOutput = false;
    }
  }
  static SetLogOutputPath(path) {
    if (typeof window === "undefined") {
      if (!!this.privListener) {
        this.privListener.logPath = path;
      }
    } else {
      throw new Error("File system logging not available in browser.");
    }
  }
  static set onLogOutput(callback) {
    if (!!this.privListener) {
      this.privListener.logCallback = callback;
    }
  }
}
exports.Diagnostics = Diagnostics;
Diagnostics.privListener = undefined;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConfig.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConfig.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DialogServiceConfigImpl = exports.DialogServiceConfig = void 0;
/* eslint-disable max-classes-per-file */
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Class that defines base configurations for dialog service connector
 * @class DialogServiceConfig
 */
class DialogServiceConfig {
  /**
   * Creates an instance of DialogService config.
   * @constructor
   */
  constructor() {
    return;
  }
  /**
   * Sets the corresponding backend application identifier.
   * @member DialogServiceConfig.prototype.Conversation_ApplicationId
   * @function
   * @public
   * @param {string} value - The application identifier to set.
   */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  set applicationId(value) {}
  static get DialogTypes() {
    return {
      BotFramework: "bot_framework",
      CustomCommands: "custom_commands"
    };
  }
}
exports.DialogServiceConfig = DialogServiceConfig;
/**
 * Dialog Service configuration.
 * @class DialogServiceConfigImpl
 */
class DialogServiceConfigImpl extends DialogServiceConfig {
  /**
   * Creates an instance of dialogService config.
   */
  constructor() {
    super();
    this.privSpeechConfig = new Exports_js_1.SpeechConfigImpl();
  }
  /**
   * Provides access to custom properties.
   * @member DialogServiceConfigImpl.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The properties.
   */
  get properties() {
    return this.privSpeechConfig.properties;
  }
  /**
   * Gets the speech recognition language.
   * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
   * @function
   * @public
   */
  get speechRecognitionLanguage() {
    return this.privSpeechConfig.speechRecognitionLanguage;
  }
  /**
   * Sets the speech recognition language.
   * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @param {string} value - The language to set.
   */
  set speechRecognitionLanguage(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "value");
    this.privSpeechConfig.speechRecognitionLanguage = value;
  }
  get outputFormat() {
    return this.privSpeechConfig.outputFormat;
  }
  set outputFormat(value) {
    this.privSpeechConfig.outputFormat = value;
  }
  /**
   * Sets a named property as value
   * @member DialogServiceConfigImpl.prototype.setProperty
   * @function
   * @public
   * @param {PropertyId | string} name - The property to set.
   * @param {string} value - The value.
   */
  setProperty(name, value) {
    this.privSpeechConfig.setProperty(name, value);
  }
  /**
   * Sets a named property as value
   * @member DialogServiceConfigImpl.prototype.getProperty
   * @function
   * @public
   * @param {PropertyId | string} name - The property to get.
   * @param {string} def - The default value to return in case the property is not known.
   * @returns {string} The current value, or provided default, of the given property.
   */
  getProperty(name, def) {
    void def;
    return this.privSpeechConfig.getProperty(name);
  }
  /**
   * Sets the proxy configuration.
   * Only relevant in Node.js environments.
   * Added in version 1.4.0.
   * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
   * @param proxyPort The port number of the proxy server.
   * @param proxyUserName The user name of the proxy server.
   * @param proxyPassword The password of the proxy server.
   */
  setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
    this.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyHostName, proxyHostName);
    this.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyPort, `${proxyPort}`);
    if (proxyUserName) {
      this.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyUserName, proxyUserName);
    }
    if (proxyPassword) {
      this.setProperty(Exports_js_1.PropertyId.SpeechServiceConnection_ProxyPassword, proxyPassword);
    }
  }
  setServiceProperty(name, value, channel) {
    void channel;
    this.privSpeechConfig.setServiceProperty(name, value);
  }
  /**
   * Dispose of associated resources.
   * @member DialogServiceConfigImpl.prototype.close
   * @function
   * @public
   */
  close() {
    return;
  }
}
exports.DialogServiceConfigImpl = DialogServiceConfigImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConnector.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConnector.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DialogServiceConnector = void 0;
const DialogConnectorFactory_js_1 = __webpack_require__(/*! ../common.speech/DialogConnectorFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/DialogConnectorFactory.js");
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const PropertyId_js_1 = __webpack_require__(/*! ./PropertyId.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyId.js");
/**
 * Dialog Service Connector
 * @class DialogServiceConnector
 */
class DialogServiceConnector extends Exports_js_3.Recognizer {
  /**
   * Initializes an instance of the DialogServiceConnector.
   * @constructor
   * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
   * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
   */
  constructor(dialogConfig, audioConfig) {
    const dialogServiceConfigImpl = dialogConfig;
    Contracts_js_1.Contracts.throwIfNull(dialogConfig, "dialogConfig");
    super(audioConfig, dialogServiceConfigImpl.properties, new DialogConnectorFactory_js_1.DialogConnectionFactory());
    this.isTurnComplete = true;
    this.privIsDisposed = false;
    this.privProperties = dialogServiceConfigImpl.properties.clone();
    const agentConfig = this.buildAgentConfig();
    this.privReco.agentConfig.set(agentConfig);
  }
  /**
   * Starts a connection to the service.
   * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
   *
   * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
   * be notified when the connection is established.
   * @member DialogServiceConnector.prototype.connect
   * @function
   * @public
   */
  connect(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.privReco.connect(), cb, err);
  }
  /**
   * Closes the connection the service.
   * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
   *
   * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
   */
  disconnect(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.privReco.disconnect(), cb, err);
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member DialogServiceConnector.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(PropertyId_js_1.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Sets the authorization token used to communicate with the service.
   * @member DialogServiceConnector.prototype.authorizationToken
   * @function
   * @public
   * @param {string} token - Authorization token.
   */
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(PropertyId_js_1.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  /**
   * The collection of properties and their values defined for this DialogServiceConnector.
   * @member DialogServiceConnector.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
   */
  get properties() {
    return this.privProperties;
  }
  /** Gets the template for the activity generated by service from speech.
   * Properties from the template will be stamped on the generated activity.
   * It can be empty
   */
  get speechActivityTemplate() {
    return this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_Speech_Activity_Template);
  }
  /** Sets the template for the activity generated by service from speech.
   * Properties from the template will be stamped on the generated activity.
   * It can be null or empty.
   * Note: it has to be a valid Json object.
   */
  set speechActivityTemplate(speechActivityTemplate) {
    this.properties.setProperty(PropertyId_js_1.PropertyId.Conversation_Speech_Activity_Template, speechActivityTemplate);
  }
  /**
   * Starts recognition and stops after the first utterance is recognized.
   * @member DialogServiceConnector.prototype.listenOnceAsync
   * @function
   * @public
   * @param cb - Callback that received the result when the reco has completed.
   * @param err - Callback invoked in case of an error.
   */
  listenOnceAsync(cb, err) {
    if (this.isTurnComplete) {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      const callbackHolder = async () => {
        await this.privReco.connect();
        await this.implRecognizerStop();
        this.isTurnComplete = false;
        const ret = new Exports_js_2.Deferred();
        await this.privReco.recognize(Exports_js_1.RecognitionMode.Conversation, ret.resolve, ret.reject);
        const e = await ret.promise;
        await this.implRecognizerStop();
        return e;
      };
      const retPromise = callbackHolder();
      retPromise.catch(() => {
        // Destroy the recognizer.
        // We've done all we can here.
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.dispose(true).catch(() => {});
      });
      Exports_js_2.marshalPromiseToCallbacks(retPromise.finally(() => {
        this.isTurnComplete = true;
      }), cb, err);
    }
  }
  sendActivityAsync(activity, cb, errCb) {
    Exports_js_2.marshalPromiseToCallbacks(this.privReco.sendMessage(activity), cb, errCb);
  }
  /**
   * closes all external resources held by an instance of this class.
   * @member DialogServiceConnector.prototype.close
   * @function
   * @public
   */
  close(cb, err) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, err);
  }
  async dispose(disposing) {
    if (this.privIsDisposed) {
      return;
    }
    if (disposing) {
      this.privIsDisposed = true;
      await this.implRecognizerStop();
      await super.dispose(disposing);
    }
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const audioSource = audioConfig;
    return new Exports_js_1.DialogServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, this);
  }
  buildAgentConfig() {
    const communicationType = this.properties.getProperty("Conversation_Communication_Type", "Default");
    return {
      botInfo: {
        commType: communicationType,
        commandsCulture: undefined,
        connectionId: this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_Agent_Connection_Id),
        conversationId: this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_Conversation_Id, undefined),
        fromId: this.properties.getProperty(PropertyId_js_1.PropertyId.Conversation_From_Id, undefined),
        ttsAudioFormat: this.properties.getProperty(PropertyId_js_1.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)
      },
      version: 0.2
    };
  }
}
exports.DialogServiceConnector = DialogServiceConnector;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var AudioConfig_js_1 = __webpack_require__(/*! ./Audio/AudioConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioConfig.js");
Object.defineProperty(exports, "AudioConfig", ({
  enumerable: true,
  get: function () {
    return AudioConfig_js_1.AudioConfig;
  }
}));
var AudioStreamFormat_js_1 = __webpack_require__(/*! ./Audio/AudioStreamFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioStreamFormat.js");
Object.defineProperty(exports, "AudioStreamFormat", ({
  enumerable: true,
  get: function () {
    return AudioStreamFormat_js_1.AudioStreamFormat;
  }
}));
Object.defineProperty(exports, "AudioFormatTag", ({
  enumerable: true,
  get: function () {
    return AudioStreamFormat_js_1.AudioFormatTag;
  }
}));
var AudioInputStream_js_1 = __webpack_require__(/*! ./Audio/AudioInputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioInputStream.js");
Object.defineProperty(exports, "AudioInputStream", ({
  enumerable: true,
  get: function () {
    return AudioInputStream_js_1.AudioInputStream;
  }
}));
Object.defineProperty(exports, "PullAudioInputStream", ({
  enumerable: true,
  get: function () {
    return AudioInputStream_js_1.PullAudioInputStream;
  }
}));
Object.defineProperty(exports, "PushAudioInputStream", ({
  enumerable: true,
  get: function () {
    return AudioInputStream_js_1.PushAudioInputStream;
  }
}));
var AudioOutputStream_js_1 = __webpack_require__(/*! ./Audio/AudioOutputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js");
Object.defineProperty(exports, "AudioOutputStream", ({
  enumerable: true,
  get: function () {
    return AudioOutputStream_js_1.AudioOutputStream;
  }
}));
Object.defineProperty(exports, "PullAudioOutputStream", ({
  enumerable: true,
  get: function () {
    return AudioOutputStream_js_1.PullAudioOutputStream;
  }
}));
Object.defineProperty(exports, "PushAudioOutputStream", ({
  enumerable: true,
  get: function () {
    return AudioOutputStream_js_1.PushAudioOutputStream;
  }
}));
var CancellationReason_js_1 = __webpack_require__(/*! ./CancellationReason.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationReason.js");
Object.defineProperty(exports, "CancellationReason", ({
  enumerable: true,
  get: function () {
    return CancellationReason_js_1.CancellationReason;
  }
}));
var PullAudioInputStreamCallback_js_1 = __webpack_require__(/*! ./Audio/PullAudioInputStreamCallback.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/PullAudioInputStreamCallback.js");
Object.defineProperty(exports, "PullAudioInputStreamCallback", ({
  enumerable: true,
  get: function () {
    return PullAudioInputStreamCallback_js_1.PullAudioInputStreamCallback;
  }
}));
var PushAudioOutputStreamCallback_js_1 = __webpack_require__(/*! ./Audio/PushAudioOutputStreamCallback.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/PushAudioOutputStreamCallback.js");
Object.defineProperty(exports, "PushAudioOutputStreamCallback", ({
  enumerable: true,
  get: function () {
    return PushAudioOutputStreamCallback_js_1.PushAudioOutputStreamCallback;
  }
}));
var KeywordRecognitionModel_js_1 = __webpack_require__(/*! ./KeywordRecognitionModel.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/KeywordRecognitionModel.js");
Object.defineProperty(exports, "KeywordRecognitionModel", ({
  enumerable: true,
  get: function () {
    return KeywordRecognitionModel_js_1.KeywordRecognitionModel;
  }
}));
var SessionEventArgs_js_1 = __webpack_require__(/*! ./SessionEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SessionEventArgs.js");
Object.defineProperty(exports, "SessionEventArgs", ({
  enumerable: true,
  get: function () {
    return SessionEventArgs_js_1.SessionEventArgs;
  }
}));
var RecognitionEventArgs_js_1 = __webpack_require__(/*! ./RecognitionEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/RecognitionEventArgs.js");
Object.defineProperty(exports, "RecognitionEventArgs", ({
  enumerable: true,
  get: function () {
    return RecognitionEventArgs_js_1.RecognitionEventArgs;
  }
}));
var OutputFormat_js_1 = __webpack_require__(/*! ./OutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/OutputFormat.js");
Object.defineProperty(exports, "OutputFormat", ({
  enumerable: true,
  get: function () {
    return OutputFormat_js_1.OutputFormat;
  }
}));
var IntentRecognitionEventArgs_js_1 = __webpack_require__(/*! ./IntentRecognitionEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionEventArgs.js");
Object.defineProperty(exports, "IntentRecognitionEventArgs", ({
  enumerable: true,
  get: function () {
    return IntentRecognitionEventArgs_js_1.IntentRecognitionEventArgs;
  }
}));
var RecognitionResult_js_1 = __webpack_require__(/*! ./RecognitionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/RecognitionResult.js");
Object.defineProperty(exports, "RecognitionResult", ({
  enumerable: true,
  get: function () {
    return RecognitionResult_js_1.RecognitionResult;
  }
}));
var SpeechRecognitionResult_js_1 = __webpack_require__(/*! ./SpeechRecognitionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionResult.js");
Object.defineProperty(exports, "SpeechRecognitionResult", ({
  enumerable: true,
  get: function () {
    return SpeechRecognitionResult_js_1.SpeechRecognitionResult;
  }
}));
var IntentRecognitionResult_js_1 = __webpack_require__(/*! ./IntentRecognitionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionResult.js");
Object.defineProperty(exports, "IntentRecognitionResult", ({
  enumerable: true,
  get: function () {
    return IntentRecognitionResult_js_1.IntentRecognitionResult;
  }
}));
var LanguageUnderstandingModel_js_1 = __webpack_require__(/*! ./LanguageUnderstandingModel.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LanguageUnderstandingModel.js");
Object.defineProperty(exports, "LanguageUnderstandingModel", ({
  enumerable: true,
  get: function () {
    return LanguageUnderstandingModel_js_1.LanguageUnderstandingModel;
  }
}));
var SpeechRecognitionEventArgs_js_1 = __webpack_require__(/*! ./SpeechRecognitionEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionEventArgs.js");
Object.defineProperty(exports, "SpeechRecognitionEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechRecognitionEventArgs_js_1.SpeechRecognitionEventArgs;
  }
}));
Object.defineProperty(exports, "ConversationTranscriptionEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechRecognitionEventArgs_js_1.ConversationTranscriptionEventArgs;
  }
}));
Object.defineProperty(exports, "MeetingTranscriptionEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechRecognitionEventArgs_js_1.MeetingTranscriptionEventArgs;
  }
}));
var SpeechRecognitionCanceledEventArgs_js_1 = __webpack_require__(/*! ./SpeechRecognitionCanceledEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionCanceledEventArgs.js");
Object.defineProperty(exports, "SpeechRecognitionCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechRecognitionCanceledEventArgs_js_1.SpeechRecognitionCanceledEventArgs;
  }
}));
var TranslationRecognitionEventArgs_js_1 = __webpack_require__(/*! ./TranslationRecognitionEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionEventArgs.js");
Object.defineProperty(exports, "TranslationRecognitionEventArgs", ({
  enumerable: true,
  get: function () {
    return TranslationRecognitionEventArgs_js_1.TranslationRecognitionEventArgs;
  }
}));
var TranslationSynthesisEventArgs_js_1 = __webpack_require__(/*! ./TranslationSynthesisEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationSynthesisEventArgs.js");
Object.defineProperty(exports, "TranslationSynthesisEventArgs", ({
  enumerable: true,
  get: function () {
    return TranslationSynthesisEventArgs_js_1.TranslationSynthesisEventArgs;
  }
}));
var TranslationRecognitionResult_js_1 = __webpack_require__(/*! ./TranslationRecognitionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionResult.js");
Object.defineProperty(exports, "TranslationRecognitionResult", ({
  enumerable: true,
  get: function () {
    return TranslationRecognitionResult_js_1.TranslationRecognitionResult;
  }
}));
var TranslationSynthesisResult_js_1 = __webpack_require__(/*! ./TranslationSynthesisResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationSynthesisResult.js");
Object.defineProperty(exports, "TranslationSynthesisResult", ({
  enumerable: true,
  get: function () {
    return TranslationSynthesisResult_js_1.TranslationSynthesisResult;
  }
}));
var ResultReason_js_1 = __webpack_require__(/*! ./ResultReason.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ResultReason.js");
Object.defineProperty(exports, "ResultReason", ({
  enumerable: true,
  get: function () {
    return ResultReason_js_1.ResultReason;
  }
}));
var SpeechConfig_js_1 = __webpack_require__(/*! ./SpeechConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechConfig.js");
Object.defineProperty(exports, "SpeechConfig", ({
  enumerable: true,
  get: function () {
    return SpeechConfig_js_1.SpeechConfig;
  }
}));
Object.defineProperty(exports, "SpeechConfigImpl", ({
  enumerable: true,
  get: function () {
    return SpeechConfig_js_1.SpeechConfigImpl;
  }
}));
var SpeechTranslationConfig_js_1 = __webpack_require__(/*! ./SpeechTranslationConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechTranslationConfig.js");
Object.defineProperty(exports, "SpeechTranslationConfig", ({
  enumerable: true,
  get: function () {
    return SpeechTranslationConfig_js_1.SpeechTranslationConfig;
  }
}));
Object.defineProperty(exports, "SpeechTranslationConfigImpl", ({
  enumerable: true,
  get: function () {
    return SpeechTranslationConfig_js_1.SpeechTranslationConfigImpl;
  }
}));
var PropertyCollection_js_1 = __webpack_require__(/*! ./PropertyCollection.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyCollection.js");
Object.defineProperty(exports, "PropertyCollection", ({
  enumerable: true,
  get: function () {
    return PropertyCollection_js_1.PropertyCollection;
  }
}));
var PropertyId_js_1 = __webpack_require__(/*! ./PropertyId.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyId.js");
Object.defineProperty(exports, "PropertyId", ({
  enumerable: true,
  get: function () {
    return PropertyId_js_1.PropertyId;
  }
}));
var Recognizer_js_1 = __webpack_require__(/*! ./Recognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Recognizer.js");
Object.defineProperty(exports, "Recognizer", ({
  enumerable: true,
  get: function () {
    return Recognizer_js_1.Recognizer;
  }
}));
var SpeechRecognizer_js_1 = __webpack_require__(/*! ./SpeechRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognizer.js");
Object.defineProperty(exports, "SpeechRecognizer", ({
  enumerable: true,
  get: function () {
    return SpeechRecognizer_js_1.SpeechRecognizer;
  }
}));
var IntentRecognizer_js_1 = __webpack_require__(/*! ./IntentRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognizer.js");
Object.defineProperty(exports, "IntentRecognizer", ({
  enumerable: true,
  get: function () {
    return IntentRecognizer_js_1.IntentRecognizer;
  }
}));
var VoiceProfileType_js_1 = __webpack_require__(/*! ./VoiceProfileType.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileType.js");
Object.defineProperty(exports, "VoiceProfileType", ({
  enumerable: true,
  get: function () {
    return VoiceProfileType_js_1.VoiceProfileType;
  }
}));
var TranslationRecognizer_js_1 = __webpack_require__(/*! ./TranslationRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognizer.js");
Object.defineProperty(exports, "TranslationRecognizer", ({
  enumerable: true,
  get: function () {
    return TranslationRecognizer_js_1.TranslationRecognizer;
  }
}));
var Translations_js_1 = __webpack_require__(/*! ./Translations.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Translations.js");
Object.defineProperty(exports, "Translations", ({
  enumerable: true,
  get: function () {
    return Translations_js_1.Translations;
  }
}));
var NoMatchReason_js_1 = __webpack_require__(/*! ./NoMatchReason.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/NoMatchReason.js");
Object.defineProperty(exports, "NoMatchReason", ({
  enumerable: true,
  get: function () {
    return NoMatchReason_js_1.NoMatchReason;
  }
}));
var NoMatchDetails_js_1 = __webpack_require__(/*! ./NoMatchDetails.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/NoMatchDetails.js");
Object.defineProperty(exports, "NoMatchDetails", ({
  enumerable: true,
  get: function () {
    return NoMatchDetails_js_1.NoMatchDetails;
  }
}));
var TranslationRecognitionCanceledEventArgs_js_1 = __webpack_require__(/*! ./TranslationRecognitionCanceledEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionCanceledEventArgs.js");
Object.defineProperty(exports, "TranslationRecognitionCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return TranslationRecognitionCanceledEventArgs_js_1.TranslationRecognitionCanceledEventArgs;
  }
}));
var IntentRecognitionCanceledEventArgs_js_1 = __webpack_require__(/*! ./IntentRecognitionCanceledEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionCanceledEventArgs.js");
Object.defineProperty(exports, "IntentRecognitionCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return IntentRecognitionCanceledEventArgs_js_1.IntentRecognitionCanceledEventArgs;
  }
}));
var CancellationDetailsBase_js_1 = __webpack_require__(/*! ./CancellationDetailsBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationDetailsBase.js");
Object.defineProperty(exports, "CancellationDetailsBase", ({
  enumerable: true,
  get: function () {
    return CancellationDetailsBase_js_1.CancellationDetailsBase;
  }
}));
var CancellationDetails_js_1 = __webpack_require__(/*! ./CancellationDetails.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationDetails.js");
Object.defineProperty(exports, "CancellationDetails", ({
  enumerable: true,
  get: function () {
    return CancellationDetails_js_1.CancellationDetails;
  }
}));
var CancellationErrorCodes_js_1 = __webpack_require__(/*! ./CancellationErrorCodes.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationErrorCodes.js");
Object.defineProperty(exports, "CancellationErrorCode", ({
  enumerable: true,
  get: function () {
    return CancellationErrorCodes_js_1.CancellationErrorCode;
  }
}));
var ConnectionEventArgs_js_1 = __webpack_require__(/*! ./ConnectionEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionEventArgs.js");
Object.defineProperty(exports, "ConnectionEventArgs", ({
  enumerable: true,
  get: function () {
    return ConnectionEventArgs_js_1.ConnectionEventArgs;
  }
}));
var ServiceEventArgs_js_1 = __webpack_require__(/*! ./ServiceEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ServiceEventArgs.js");
Object.defineProperty(exports, "ServiceEventArgs", ({
  enumerable: true,
  get: function () {
    return ServiceEventArgs_js_1.ServiceEventArgs;
  }
}));
var Connection_js_1 = __webpack_require__(/*! ./Connection.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Connection.js");
Object.defineProperty(exports, "Connection", ({
  enumerable: true,
  get: function () {
    return Connection_js_1.Connection;
  }
}));
var PhraseListGrammar_js_1 = __webpack_require__(/*! ./PhraseListGrammar.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PhraseListGrammar.js");
Object.defineProperty(exports, "PhraseListGrammar", ({
  enumerable: true,
  get: function () {
    return PhraseListGrammar_js_1.PhraseListGrammar;
  }
}));
var DialogServiceConfig_js_1 = __webpack_require__(/*! ./DialogServiceConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConfig.js");
Object.defineProperty(exports, "DialogServiceConfig", ({
  enumerable: true,
  get: function () {
    return DialogServiceConfig_js_1.DialogServiceConfig;
  }
}));
var BotFrameworkConfig_js_1 = __webpack_require__(/*! ./BotFrameworkConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/BotFrameworkConfig.js");
Object.defineProperty(exports, "BotFrameworkConfig", ({
  enumerable: true,
  get: function () {
    return BotFrameworkConfig_js_1.BotFrameworkConfig;
  }
}));
var CustomCommandsConfig_js_1 = __webpack_require__(/*! ./CustomCommandsConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CustomCommandsConfig.js");
Object.defineProperty(exports, "CustomCommandsConfig", ({
  enumerable: true,
  get: function () {
    return CustomCommandsConfig_js_1.CustomCommandsConfig;
  }
}));
var DialogServiceConnector_js_1 = __webpack_require__(/*! ./DialogServiceConnector.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/DialogServiceConnector.js");
Object.defineProperty(exports, "DialogServiceConnector", ({
  enumerable: true,
  get: function () {
    return DialogServiceConnector_js_1.DialogServiceConnector;
  }
}));
var ActivityReceivedEventArgs_js_1 = __webpack_require__(/*! ./ActivityReceivedEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ActivityReceivedEventArgs.js");
Object.defineProperty(exports, "ActivityReceivedEventArgs", ({
  enumerable: true,
  get: function () {
    return ActivityReceivedEventArgs_js_1.ActivityReceivedEventArgs;
  }
}));
var TurnStatusReceivedEventArgs_js_1 = __webpack_require__(/*! ./TurnStatusReceivedEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TurnStatusReceivedEventArgs.js");
Object.defineProperty(exports, "TurnStatusReceivedEventArgs", ({
  enumerable: true,
  get: function () {
    return TurnStatusReceivedEventArgs_js_1.TurnStatusReceivedEventArgs;
  }
}));
var ServicePropertyChannel_js_1 = __webpack_require__(/*! ./ServicePropertyChannel.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ServicePropertyChannel.js");
Object.defineProperty(exports, "ServicePropertyChannel", ({
  enumerable: true,
  get: function () {
    return ServicePropertyChannel_js_1.ServicePropertyChannel;
  }
}));
var ProfanityOption_js_1 = __webpack_require__(/*! ./ProfanityOption.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ProfanityOption.js");
Object.defineProperty(exports, "ProfanityOption", ({
  enumerable: true,
  get: function () {
    return ProfanityOption_js_1.ProfanityOption;
  }
}));
var BaseAudioPlayer_js_1 = __webpack_require__(/*! ./Audio/BaseAudioPlayer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/BaseAudioPlayer.js");
Object.defineProperty(exports, "BaseAudioPlayer", ({
  enumerable: true,
  get: function () {
    return BaseAudioPlayer_js_1.BaseAudioPlayer;
  }
}));
var ConnectionMessageEventArgs_js_1 = __webpack_require__(/*! ./ConnectionMessageEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionMessageEventArgs.js");
Object.defineProperty(exports, "ConnectionMessageEventArgs", ({
  enumerable: true,
  get: function () {
    return ConnectionMessageEventArgs_js_1.ConnectionMessageEventArgs;
  }
}));
var ConnectionMessage_js_1 = __webpack_require__(/*! ./ConnectionMessage.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConnectionMessage.js");
Object.defineProperty(exports, "ConnectionMessage", ({
  enumerable: true,
  get: function () {
    return ConnectionMessage_js_1.ConnectionMessage;
  }
}));
var VoiceProfile_js_1 = __webpack_require__(/*! ./VoiceProfile.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfile.js");
Object.defineProperty(exports, "VoiceProfile", ({
  enumerable: true,
  get: function () {
    return VoiceProfile_js_1.VoiceProfile;
  }
}));
var VoiceProfileEnrollmentResult_js_1 = __webpack_require__(/*! ./VoiceProfileEnrollmentResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileEnrollmentResult.js");
Object.defineProperty(exports, "VoiceProfileEnrollmentResult", ({
  enumerable: true,
  get: function () {
    return VoiceProfileEnrollmentResult_js_1.VoiceProfileEnrollmentResult;
  }
}));
Object.defineProperty(exports, "VoiceProfileEnrollmentCancellationDetails", ({
  enumerable: true,
  get: function () {
    return VoiceProfileEnrollmentResult_js_1.VoiceProfileEnrollmentCancellationDetails;
  }
}));
var VoiceProfileResult_js_1 = __webpack_require__(/*! ./VoiceProfileResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileResult.js");
Object.defineProperty(exports, "VoiceProfileResult", ({
  enumerable: true,
  get: function () {
    return VoiceProfileResult_js_1.VoiceProfileResult;
  }
}));
Object.defineProperty(exports, "VoiceProfileCancellationDetails", ({
  enumerable: true,
  get: function () {
    return VoiceProfileResult_js_1.VoiceProfileCancellationDetails;
  }
}));
var VoiceProfilePhraseResult_js_1 = __webpack_require__(/*! ./VoiceProfilePhraseResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfilePhraseResult.js");
Object.defineProperty(exports, "VoiceProfilePhraseResult", ({
  enumerable: true,
  get: function () {
    return VoiceProfilePhraseResult_js_1.VoiceProfilePhraseResult;
  }
}));
var VoiceProfileClient_js_1 = __webpack_require__(/*! ./VoiceProfileClient.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileClient.js");
Object.defineProperty(exports, "VoiceProfileClient", ({
  enumerable: true,
  get: function () {
    return VoiceProfileClient_js_1.VoiceProfileClient;
  }
}));
var SpeakerRecognizer_js_1 = __webpack_require__(/*! ./SpeakerRecognizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerRecognizer.js");
Object.defineProperty(exports, "SpeakerRecognizer", ({
  enumerable: true,
  get: function () {
    return SpeakerRecognizer_js_1.SpeakerRecognizer;
  }
}));
var SpeakerIdentificationModel_js_1 = __webpack_require__(/*! ./SpeakerIdentificationModel.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerIdentificationModel.js");
Object.defineProperty(exports, "SpeakerIdentificationModel", ({
  enumerable: true,
  get: function () {
    return SpeakerIdentificationModel_js_1.SpeakerIdentificationModel;
  }
}));
var SpeakerVerificationModel_js_1 = __webpack_require__(/*! ./SpeakerVerificationModel.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerVerificationModel.js");
Object.defineProperty(exports, "SpeakerVerificationModel", ({
  enumerable: true,
  get: function () {
    return SpeakerVerificationModel_js_1.SpeakerVerificationModel;
  }
}));
var AutoDetectSourceLanguageConfig_js_1 = __webpack_require__(/*! ./AutoDetectSourceLanguageConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AutoDetectSourceLanguageConfig.js");
Object.defineProperty(exports, "AutoDetectSourceLanguageConfig", ({
  enumerable: true,
  get: function () {
    return AutoDetectSourceLanguageConfig_js_1.AutoDetectSourceLanguageConfig;
  }
}));
var AutoDetectSourceLanguageResult_js_1 = __webpack_require__(/*! ./AutoDetectSourceLanguageResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AutoDetectSourceLanguageResult.js");
Object.defineProperty(exports, "AutoDetectSourceLanguageResult", ({
  enumerable: true,
  get: function () {
    return AutoDetectSourceLanguageResult_js_1.AutoDetectSourceLanguageResult;
  }
}));
var SourceLanguageConfig_js_1 = __webpack_require__(/*! ./SourceLanguageConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SourceLanguageConfig.js");
Object.defineProperty(exports, "SourceLanguageConfig", ({
  enumerable: true,
  get: function () {
    return SourceLanguageConfig_js_1.SourceLanguageConfig;
  }
}));
var SpeakerRecognitionResult_js_1 = __webpack_require__(/*! ./SpeakerRecognitionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerRecognitionResult.js");
Object.defineProperty(exports, "SpeakerRecognitionResult", ({
  enumerable: true,
  get: function () {
    return SpeakerRecognitionResult_js_1.SpeakerRecognitionResult;
  }
}));
Object.defineProperty(exports, "SpeakerRecognitionResultType", ({
  enumerable: true,
  get: function () {
    return SpeakerRecognitionResult_js_1.SpeakerRecognitionResultType;
  }
}));
Object.defineProperty(exports, "SpeakerRecognitionCancellationDetails", ({
  enumerable: true,
  get: function () {
    return SpeakerRecognitionResult_js_1.SpeakerRecognitionCancellationDetails;
  }
}));
var Exports_js_1 = __webpack_require__(/*! ./Transcription/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Exports.js");
Object.defineProperty(exports, "Conversation", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.Conversation;
  }
}));
Object.defineProperty(exports, "ConversationExpirationEventArgs", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationExpirationEventArgs;
  }
}));
Object.defineProperty(exports, "ConversationParticipantsChangedEventArgs", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationParticipantsChangedEventArgs;
  }
}));
Object.defineProperty(exports, "ConversationTranslationCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationTranslationCanceledEventArgs;
  }
}));
Object.defineProperty(exports, "ConversationTranslationEventArgs", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationTranslationEventArgs;
  }
}));
Object.defineProperty(exports, "ConversationTranslationResult", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationTranslationResult;
  }
}));
Object.defineProperty(exports, "ConversationTranslator", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationTranslator;
  }
}));
Object.defineProperty(exports, "ConversationTranscriber", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationTranscriber;
  }
}));
Object.defineProperty(exports, "ConversationTranscriptionResult", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ConversationTranscriptionResult;
  }
}));
Object.defineProperty(exports, "Meeting", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.Meeting;
  }
}));
Object.defineProperty(exports, "MeetingTranscriber", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.MeetingTranscriber;
  }
}));
Object.defineProperty(exports, "Participant", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.Participant;
  }
}));
Object.defineProperty(exports, "ParticipantChangedReason", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.ParticipantChangedReason;
  }
}));
Object.defineProperty(exports, "User", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.User;
  }
}));
var Synthesizer_js_1 = __webpack_require__(/*! ./Synthesizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Synthesizer.js");
Object.defineProperty(exports, "Synthesizer", ({
  enumerable: true,
  get: function () {
    return Synthesizer_js_1.Synthesizer;
  }
}));
var SpeechSynthesisOutputFormat_js_1 = __webpack_require__(/*! ./SpeechSynthesisOutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisOutputFormat.js");
Object.defineProperty(exports, "SpeechSynthesisOutputFormat", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisOutputFormat_js_1.SpeechSynthesisOutputFormat;
  }
}));
var SpeechSynthesizer_js_1 = __webpack_require__(/*! ./SpeechSynthesizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesizer.js");
Object.defineProperty(exports, "SpeechSynthesizer", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesizer_js_1.SpeechSynthesizer;
  }
}));
var SynthesisResult_js_1 = __webpack_require__(/*! ./SynthesisResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SynthesisResult.js");
Object.defineProperty(exports, "SynthesisResult", ({
  enumerable: true,
  get: function () {
    return SynthesisResult_js_1.SynthesisResult;
  }
}));
var SpeechSynthesisResult_js_1 = __webpack_require__(/*! ./SpeechSynthesisResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisResult.js");
Object.defineProperty(exports, "SpeechSynthesisResult", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisResult_js_1.SpeechSynthesisResult;
  }
}));
var SpeechSynthesisEventArgs_js_1 = __webpack_require__(/*! ./SpeechSynthesisEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisEventArgs.js");
Object.defineProperty(exports, "SpeechSynthesisEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisEventArgs_js_1.SpeechSynthesisEventArgs;
  }
}));
var SpeechSynthesisWordBoundaryEventArgs_js_1 = __webpack_require__(/*! ./SpeechSynthesisWordBoundaryEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisWordBoundaryEventArgs.js");
Object.defineProperty(exports, "SpeechSynthesisWordBoundaryEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisWordBoundaryEventArgs_js_1.SpeechSynthesisWordBoundaryEventArgs;
  }
}));
var SpeechSynthesisBookmarkEventArgs_js_1 = __webpack_require__(/*! ./SpeechSynthesisBookmarkEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisBookmarkEventArgs.js");
Object.defineProperty(exports, "SpeechSynthesisBookmarkEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisBookmarkEventArgs_js_1.SpeechSynthesisBookmarkEventArgs;
  }
}));
var SpeechSynthesisVisemeEventArgs_js_1 = __webpack_require__(/*! ./SpeechSynthesisVisemeEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisVisemeEventArgs.js");
Object.defineProperty(exports, "SpeechSynthesisVisemeEventArgs", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisVisemeEventArgs_js_1.SpeechSynthesisVisemeEventArgs;
  }
}));
var SpeechSynthesisBoundaryType_js_1 = __webpack_require__(/*! ./SpeechSynthesisBoundaryType.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisBoundaryType.js");
Object.defineProperty(exports, "SpeechSynthesisBoundaryType", ({
  enumerable: true,
  get: function () {
    return SpeechSynthesisBoundaryType_js_1.SpeechSynthesisBoundaryType;
  }
}));
var SynthesisVoicesResult_js_1 = __webpack_require__(/*! ./SynthesisVoicesResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SynthesisVoicesResult.js");
Object.defineProperty(exports, "SynthesisVoicesResult", ({
  enumerable: true,
  get: function () {
    return SynthesisVoicesResult_js_1.SynthesisVoicesResult;
  }
}));
var VoiceInfo_js_1 = __webpack_require__(/*! ./VoiceInfo.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceInfo.js");
Object.defineProperty(exports, "SynthesisVoiceGender", ({
  enumerable: true,
  get: function () {
    return VoiceInfo_js_1.SynthesisVoiceGender;
  }
}));
Object.defineProperty(exports, "SynthesisVoiceType", ({
  enumerable: true,
  get: function () {
    return VoiceInfo_js_1.SynthesisVoiceType;
  }
}));
Object.defineProperty(exports, "VoiceInfo", ({
  enumerable: true,
  get: function () {
    return VoiceInfo_js_1.VoiceInfo;
  }
}));
var SpeakerAudioDestination_js_1 = __webpack_require__(/*! ./Audio/SpeakerAudioDestination.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/SpeakerAudioDestination.js");
Object.defineProperty(exports, "SpeakerAudioDestination", ({
  enumerable: true,
  get: function () {
    return SpeakerAudioDestination_js_1.SpeakerAudioDestination;
  }
}));
var ConversationTranscriptionCanceledEventArgs_js_1 = __webpack_require__(/*! ./ConversationTranscriptionCanceledEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ConversationTranscriptionCanceledEventArgs.js");
Object.defineProperty(exports, "ConversationTranscriptionCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranscriptionCanceledEventArgs_js_1.ConversationTranscriptionCanceledEventArgs;
  }
}));
var MeetingTranscriptionCanceledEventArgs_js_1 = __webpack_require__(/*! ./MeetingTranscriptionCanceledEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/MeetingTranscriptionCanceledEventArgs.js");
Object.defineProperty(exports, "MeetingTranscriptionCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return MeetingTranscriptionCanceledEventArgs_js_1.MeetingTranscriptionCanceledEventArgs;
  }
}));
var PronunciationAssessmentGradingSystem_js_1 = __webpack_require__(/*! ./PronunciationAssessmentGradingSystem.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentGradingSystem.js");
Object.defineProperty(exports, "PronunciationAssessmentGradingSystem", ({
  enumerable: true,
  get: function () {
    return PronunciationAssessmentGradingSystem_js_1.PronunciationAssessmentGradingSystem;
  }
}));
var PronunciationAssessmentGranularity_js_1 = __webpack_require__(/*! ./PronunciationAssessmentGranularity.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentGranularity.js");
Object.defineProperty(exports, "PronunciationAssessmentGranularity", ({
  enumerable: true,
  get: function () {
    return PronunciationAssessmentGranularity_js_1.PronunciationAssessmentGranularity;
  }
}));
var PronunciationAssessmentConfig_js_1 = __webpack_require__(/*! ./PronunciationAssessmentConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentConfig.js");
Object.defineProperty(exports, "PronunciationAssessmentConfig", ({
  enumerable: true,
  get: function () {
    return PronunciationAssessmentConfig_js_1.PronunciationAssessmentConfig;
  }
}));
var PronunciationAssessmentResult_js_1 = __webpack_require__(/*! ./PronunciationAssessmentResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentResult.js");
Object.defineProperty(exports, "PronunciationAssessmentResult", ({
  enumerable: true,
  get: function () {
    return PronunciationAssessmentResult_js_1.PronunciationAssessmentResult;
  }
}));
var LanguageIdMode_js_1 = __webpack_require__(/*! ./LanguageIdMode.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LanguageIdMode.js");
Object.defineProperty(exports, "LanguageIdMode", ({
  enumerable: true,
  get: function () {
    return LanguageIdMode_js_1.LanguageIdMode;
  }
}));
var AvatarConfig_js_1 = __webpack_require__(/*! ./AvatarConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarConfig.js");
Object.defineProperty(exports, "AvatarConfig", ({
  enumerable: true,
  get: function () {
    return AvatarConfig_js_1.AvatarConfig;
  }
}));
var AvatarEventArgs_js_1 = __webpack_require__(/*! ./AvatarEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarEventArgs.js");
Object.defineProperty(exports, "AvatarEventArgs", ({
  enumerable: true,
  get: function () {
    return AvatarEventArgs_js_1.AvatarEventArgs;
  }
}));
var AvatarSynthesizer_js_1 = __webpack_require__(/*! ./AvatarSynthesizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarSynthesizer.js");
Object.defineProperty(exports, "AvatarSynthesizer", ({
  enumerable: true,
  get: function () {
    return AvatarSynthesizer_js_1.AvatarSynthesizer;
  }
}));
var AvatarVideoFormat_js_1 = __webpack_require__(/*! ./AvatarVideoFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarVideoFormat.js");
Object.defineProperty(exports, "AvatarVideoFormat", ({
  enumerable: true,
  get: function () {
    return AvatarVideoFormat_js_1.AvatarVideoFormat;
  }
}));
Object.defineProperty(exports, "Coordinate", ({
  enumerable: true,
  get: function () {
    return AvatarVideoFormat_js_1.Coordinate;
  }
}));
var AvatarWebRTCConnectionResult_js_1 = __webpack_require__(/*! ./AvatarWebRTCConnectionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/AvatarWebRTCConnectionResult.js");
Object.defineProperty(exports, "AvatarWebRTCConnectionResult", ({
  enumerable: true,
  get: function () {
    return AvatarWebRTCConnectionResult_js_1.AvatarWebRTCConnectionResult;
  }
}));
var Diagnostics_js_1 = __webpack_require__(/*! ./Diagnostics.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Diagnostics.js");
Object.defineProperty(exports, "Diagnostics", ({
  enumerable: true,
  get: function () {
    return Diagnostics_js_1.Diagnostics;
  }
}));
var LogLevel_js_1 = __webpack_require__(/*! ./LogLevel.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LogLevel.js");
Object.defineProperty(exports, "LogLevel", ({
  enumerable: true,
  get: function () {
    return LogLevel_js_1.LogLevel;
  }
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionCanceledEventArgs.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionCanceledEventArgs.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IntentRecognitionCanceledEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Define payload of intent recognition canceled result events.
 * @class IntentRecognitionCanceledEventArgs
 */
class IntentRecognitionCanceledEventArgs extends Exports_js_1.IntentRecognitionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {CancellationReason} result - The result of the intent recognition.
   * @param {string} offset - The offset.
   * @param {IntentRecognitionResult} sessionId - The session id.
   */
  constructor(reason, errorDetails, errorCode, result, offset, sessionId) {
    super(result, offset, sessionId);
    this.privReason = reason;
    this.privErrorDetails = errorDetails;
    this.privErrorCode = errorCode;
  }
  /**
   * The reason the recognition was canceled.
   * @member IntentRecognitionCanceledEventArgs.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get errorCode() {
    return this.privErrorCode;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
}
exports.IntentRecognitionCanceledEventArgs = IntentRecognitionCanceledEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionEventArgs.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionEventArgs.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IntentRecognitionEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Intent recognition result event arguments.
 * @class
 */
class IntentRecognitionEventArgs extends Exports_js_1.RecognitionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param result - The result of the intent recognition.
   * @param offset - The offset.
   * @param sessionId - The session id.
   */
  constructor(result, offset, sessionId) {
    super(offset, sessionId);
    this.privResult = result;
  }
  /**
   * Represents the intent recognition result.
   * @member IntentRecognitionEventArgs.prototype.result
   * @function
   * @public
   * @returns {IntentRecognitionResult} Represents the intent recognition result.
   */
  get result() {
    return this.privResult;
  }
}
exports.IntentRecognitionEventArgs = IntentRecognitionEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionResult.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognitionResult.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IntentRecognitionResult = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Intent recognition result.
 * @class
 */
class IntentRecognitionResult extends Exports_js_1.SpeechRecognitionResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param intentId - The intent id.
   * @param resultId - The result id.
   * @param reason - The reason.
   * @param text - The recognized text.
   * @param duration - The duration.
   * @param offset - The offset into the stream.
   * @param language - Primary Language detected, if provided.
   * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param errorDetails - Error details, if provided.
   * @param json - Additional Json, if provided.
   * @param properties - Additional properties, if provided.
   */
  constructor(intentId, resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
    super(resultId, reason, text, duration, offset, language, languageDetectionConfidence, undefined, errorDetails, json, properties);
    this.privIntentId = intentId;
  }
  /**
   * A String that represents the intent identifier being recognized.
   * @member IntentRecognitionResult.prototype.intentId
   * @function
   * @public
   * @returns {string} A String that represents the intent identifier being recognized.
   */
  get intentId() {
    return this.privIntentId;
  }
}
exports.IntentRecognitionResult = IntentRecognitionResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognizer.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/IntentRecognizer.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IntentRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Intent recognizer.
 * @class
 */
class IntentRecognizer extends Exports_js_3.Recognizer {
  /**
   * Initializes an instance of the IntentRecognizer.
   * @constructor
   * @param {SpeechConfig} speechConfig - The set of configuration properties.
   * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
   */
  constructor(speechConfig, audioConfig) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
    const configImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(configImpl, "speechConfig");
    super(audioConfig, configImpl.properties, new Exports_js_1.IntentConnectionFactory());
    this.privAddedIntents = [];
    this.privAddedLmIntents = {};
    this.privDisposedIntentRecognizer = false;
    this.privProperties = configImpl.properties;
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
  }
  /**
   * Gets the spoken language of recognition.
   * @member IntentRecognizer.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @returns {string} the spoken language of recognition.
   */
  get speechRecognitionLanguage() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member IntentRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
   * @member IntentRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @param {string} value - Authorization token.
   */
  set authorizationToken(value) {
    this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, value);
  }
  /**
   * The collection of properties and their values defined for this IntentRecognizer.
   * @member IntentRecognizer.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their
   * values defined for this IntentRecognizer.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Starts intent recognition, and stops after the first utterance is recognized.
   * The task returns the recognition text and intent as result.
   * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
   * so it is suitable only for single shot recognition like command or query.
   * For long-running recognition, use StartContinuousRecognitionAsync() instead.
   * @member IntentRecognizer.prototype.recognizeOnceAsync
   * @function
   * @public
   * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
   * @param err - Callback invoked in case of an error.
   */
  recognizeOnceAsync(cb, err) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
    if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {
      const context = this.buildSpeechContext();
      this.privReco.speechContext.setSection("intent", context.Intent);
      this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);
      const intentReco = this.privReco;
      intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
    }
    Exports_js_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_js_1.RecognitionMode.Interactive), cb, err);
  }
  /**
   * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
   * User must subscribe to events to receive recognition results.
   * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
   * @function
   * @public
   * @param cb - Callback invoked once the recognition has started.
   * @param err - Callback invoked in case of an error.
   */
  startContinuousRecognitionAsync(cb, err) {
    if (Object.keys(this.privAddedLmIntents).length !== 0 || undefined !== this.privUmbrellaIntent) {
      const context = this.buildSpeechContext();
      this.privReco.speechContext.setSection("intent", context.Intent);
      this.privReco.dynamicGrammar.addReferenceGrammar(context.ReferenceGrammars);
      const intentReco = this.privReco;
      intentReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
    }
    Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_1.RecognitionMode.Conversation), cb, err);
  }
  /**
   * Stops continuous intent recognition.
   * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
   * @function
   * @public
   * @param cb - Callback invoked once the recognition has stopped.
   * @param err - Callback invoked in case of an error.
   */
  stopContinuousRecognitionAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
  }
  /**
   * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
   * User must subscribe to events to receive recognition results.
   * Note: Key word spotting functionality is only available on the Speech Devices SDK.
   * This functionality is currently not included in the SDK itself.
   * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
   * @function
   * @public
   * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
   * @param cb - Callback invoked once the recognition has started.
   * @param err - Callback invoked in case of an error.
   */
  startKeywordRecognitionAsync(model, cb, err) {
    Contracts_js_1.Contracts.throwIfNull(model, "model");
    if (!!err) {
      err("Not yet implemented.");
    }
  }
  /**
   * Stops continuous speech recognition.
   * Note: Key word spotting functionality is only available on the Speech Devices SDK.
   * This functionality is currently not included in the SDK itself.
   * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
   * @function
   * @public
   * @param cb - Callback invoked once the recognition has stopped.
   * @param err - Callback invoked in case of an error.
   */
  stopKeywordRecognitionAsync(cb, err) {
    if (!!cb) {
      try {
        cb();
      } catch (e) {
        if (!!err) {
          err(e);
        }
      }
    }
  }
  /**
   * Adds a phrase that should be recognized as intent.
   * @member IntentRecognizer.prototype.addIntent
   * @function
   * @public
   * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
   * @param {string} phrase - A String that specifies the phrase representing the intent.
   */
  addIntent(simplePhrase, intentId) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(intentId, "intentId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(simplePhrase, "simplePhrase");
    this.privAddedIntents.push([intentId, simplePhrase]);
  }
  /**
   * Adds an intent from Language Understanding service for recognition.
   * @member IntentRecognizer.prototype.addIntentWithLanguageModel
   * @function
   * @public
   * @param {string} intentId - A String that represents the identifier of the intent
   * to be recognized. Ignored if intentName is empty.
   * @param {string} model - The intent model from Language Understanding service.
   * @param {string} intentName - The intent name defined in the intent model. If it
   * is empty, all intent names defined in the model will be added.
   */
  addIntentWithLanguageModel(intentId, model, intentName) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(intentId, "intentId");
    Contracts_js_1.Contracts.throwIfNull(model, "model");
    const modelImpl = model;
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(modelImpl.appId, "model.appId");
    this.privAddedLmIntents[intentId] = new Exports_js_1.AddedLmIntent(modelImpl, intentName);
  }
  /**
   * @summary Adds all intents from the specified Language Understanding Model.
   * @member IntentRecognizer.prototype.addAllIntents
   * @function
   * @public
   * @function
   * @public
   * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
   * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
   */
  addAllIntents(model, intentId) {
    Contracts_js_1.Contracts.throwIfNull(model, "model");
    const modelImpl = model;
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(modelImpl.appId, "model.appId");
    this.privUmbrellaIntent = new Exports_js_1.AddedLmIntent(modelImpl, intentId);
  }
  /**
   * closes all external resources held by an instance of this class.
   * @member IntentRecognizer.prototype.close
   * @function
   * @public
   */
  close(cb, errorCb) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const audioImpl = audioConfig;
    return new Exports_js_1.IntentServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
  }
  async dispose(disposing) {
    if (this.privDisposedIntentRecognizer) {
      return;
    }
    if (disposing) {
      this.privDisposedIntentRecognizer = true;
      await super.dispose(disposing);
    }
  }
  buildSpeechContext() {
    let appId;
    let region;
    let subscriptionKey;
    const refGrammers = [];
    if (undefined !== this.privUmbrellaIntent) {
      appId = this.privUmbrellaIntent.modelImpl.appId;
      region = this.privUmbrellaIntent.modelImpl.region;
      subscriptionKey = this.privUmbrellaIntent.modelImpl.subscriptionKey;
    }
    // Build the reference grammer array.
    for (const intentId of Object.keys(this.privAddedLmIntents)) {
      const addedLmIntent = this.privAddedLmIntents[intentId];
      // validate all the same model, region, and key...
      if (appId === undefined) {
        appId = addedLmIntent.modelImpl.appId;
      } else {
        if (appId !== addedLmIntent.modelImpl.appId) {
          throw new Error("Intents must all be from the same LUIS model");
        }
      }
      if (region === undefined) {
        region = addedLmIntent.modelImpl.region;
      } else {
        if (region !== addedLmIntent.modelImpl.region) {
          throw new Error("Intents must all be from the same LUIS model in a single region");
        }
      }
      if (subscriptionKey === undefined) {
        subscriptionKey = addedLmIntent.modelImpl.subscriptionKey;
      } else {
        if (subscriptionKey !== addedLmIntent.modelImpl.subscriptionKey) {
          throw new Error("Intents must all use the same subscription key");
        }
      }
      const grammer = "luis/" + appId + "-PRODUCTION#" + intentId;
      refGrammers.push(grammer);
    }
    return {
      Intent: {
        id: appId,
        key: subscriptionKey === undefined ? this.privProperties.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key]) : subscriptionKey,
        provider: "LUIS"
      },
      ReferenceGrammars: undefined === this.privUmbrellaIntent ? refGrammers : ["luis/" + appId + "-PRODUCTION"]
    };
  }
}
exports.IntentRecognizer = IntentRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/KeywordRecognitionModel.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/KeywordRecognitionModel.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KeywordRecognitionModel = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
/**
 * Represents a keyword recognition model for recognizing when
 * the user says a keyword to initiate further speech recognition.
 * @class KeywordRecognitionModel
 */
class KeywordRecognitionModel {
  /**
   * Create and initializes a new instance.
   * @constructor
   */
  constructor() {
    this.privDisposed = false;
    return;
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromFile
   * @function
   * @public
   * @param {string} fileName - A string that represents file name for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model
   * will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromFile(fileName) {
    Contracts_js_1.Contracts.throwIfFileDoesNotExist(fileName, "fileName");
    throw new Error("Not yet implemented.");
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromStream
   * @function
   * @public
   * @param {string} file - A File that represents file for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromStream(file) {
    Contracts_js_1.Contracts.throwIfNull(file, "file");
    throw new Error("Not yet implemented.");
  }
  /**
   * Dispose of associated resources.
   * @member KeywordRecognitionModel.prototype.close
   * @function
   * @public
   */
  close() {
    if (this.privDisposed) {
      return;
    }
    this.privDisposed = true;
  }
}
exports.KeywordRecognitionModel = KeywordRecognitionModel;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LanguageIdMode.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LanguageIdMode.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LanguageIdMode = void 0;
/**
 * Language Identification mode
 * @class LanguageIdMode
 */
var LanguageIdMode;
(function (LanguageIdMode) {
  /**
   * Detect language at audio start
   * @member LanguageIdMode.AtStart
   */
  LanguageIdMode[LanguageIdMode["AtStart"] = 0] = "AtStart";
  /**
   * Continuously detect language
   * @member LanguageIdMode.Continuous
   */
  LanguageIdMode[LanguageIdMode["Continuous"] = 1] = "Continuous";
})(LanguageIdMode = exports.LanguageIdMode || (exports.LanguageIdMode = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LanguageUnderstandingModel.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LanguageUnderstandingModel.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LanguageUnderstandingModelImpl = exports.LanguageUnderstandingModel = void 0;
// eslint-disable-next-line max-classes-per-file
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
/**
 * Language understanding model
 * @class LanguageUnderstandingModel
 */
class LanguageUnderstandingModel {
  /**
   * Creates and initializes a new instance
   * @constructor
   */
  constructor() {
    return;
  }
  /**
   * Creates an language understanding model using the specified endpoint.
   * @member LanguageUnderstandingModel.fromEndpoint
   * @function
   * @public
   * @param {URL} uri - A String that represents the endpoint of the language understanding model.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromEndpoint(uri) {
    Contracts_js_1.Contracts.throwIfNull(uri, "uri");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(uri.hostname, "uri");
    const langModelImp = new LanguageUnderstandingModelImpl();
    // Need to extract the app ID from the URL.
    // URL is in the format: https://<region>.api.cognitive.microsoft.com/luis/v2.0/apps/<Guid>?subscription-key=<key>&timezoneOffset=-360
    // Start tearing the string apart.
    // region can be extracted from the host name.
    const firstDot = uri.host.indexOf(".");
    if (-1 === firstDot) {
      throw new Error("Could not determine region from endpoint");
    }
    langModelImp.region = uri.host.substr(0, firstDot);
    // Now the app ID.
    const lastSegment = uri.pathname.lastIndexOf("/") + 1;
    if (-1 === lastSegment) {
      throw new Error("Could not determine appId from endpoint");
    }
    langModelImp.appId = uri.pathname.substr(lastSegment);
    // And finally the key.
    langModelImp.subscriptionKey = uri.searchParams.get("subscription-key");
    if (undefined === langModelImp.subscriptionKey) {
      throw new Error("Could not determine subscription key from endpoint");
    }
    return langModelImp;
  }
  /**
   * Creates an language understanding model using the application id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromAppId
   * @function
   * @public
   * @param {string} appId - A String that represents the application id of Language Understanding service.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromAppId(appId) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(appId, "appId");
    const langModelImp = new LanguageUnderstandingModelImpl();
    langModelImp.appId = appId;
    return langModelImp;
  }
  /**
   * Creates a language understanding model using hostname, subscription key and application
   * id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromSubscription
   * @function
   * @public
   * @param {string} subscriptionKey - A String that represents the subscription key of
   * Language Understanding service.
   * @param {string} appId - A String that represents the application id of Language
   * Understanding service.
   * @param {LanguageUnderstandingModel} region - A String that represents the region
   * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromSubscription(subscriptionKey, appId, region) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(appId, "appId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const langModelImp = new LanguageUnderstandingModelImpl();
    langModelImp.appId = appId;
    langModelImp.region = region;
    langModelImp.subscriptionKey = subscriptionKey;
    return langModelImp;
  }
}
exports.LanguageUnderstandingModel = LanguageUnderstandingModel;
/**
 * @private
 * @class LanguageUnderstandingModelImpl
 */
class LanguageUnderstandingModelImpl extends LanguageUnderstandingModel {}
exports.LanguageUnderstandingModelImpl = LanguageUnderstandingModelImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LogLevel.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/LogLevel.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LogLevel = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
Object.defineProperty(exports, "LogLevel", ({
  enumerable: true,
  get: function () {
    return Exports_js_1.EventType;
  }
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/MeetingTranscriptionCanceledEventArgs.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/MeetingTranscriptionCanceledEventArgs.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MeetingTranscriptionCanceledEventArgs = void 0;
const CancellationEventArgsBase_js_1 = __webpack_require__(/*! ./CancellationEventArgsBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationEventArgsBase.js");
/**
 * Defines content of a MeetingTranscriptionCanceledEvent.
 * @class MeetingTranscriptionCanceledEventArgs
 */
class MeetingTranscriptionCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {}
exports.MeetingTranscriptionCanceledEventArgs = MeetingTranscriptionCanceledEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/NoMatchDetails.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/NoMatchDetails.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NoMatchDetails = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../src/common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Contains detailed information for NoMatch recognition results.
 * @class NoMatchDetails
 */
class NoMatchDetails {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {NoMatchReason} reason - The no-match reason.
   */
  constructor(reason) {
    this.privReason = reason;
  }
  /**
   * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
   * @member NoMatchDetails.fromResult
   * @function
   * @public
   * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
   * result - The recognition result that was not recognized.
   * @returns {NoMatchDetails} The no match details object being created.
   */
  static fromResult(result) {
    const simpleSpeech = Exports_js_1.SimpleSpeechPhrase.fromJSON(result.json, 0); // Offset fixups are already done.
    let reason = Exports_js_2.NoMatchReason.NotRecognized;
    switch (simpleSpeech.RecognitionStatus) {
      case Exports_js_1.RecognitionStatus.BabbleTimeout:
        reason = Exports_js_2.NoMatchReason.InitialBabbleTimeout;
        break;
      case Exports_js_1.RecognitionStatus.InitialSilenceTimeout:
        reason = Exports_js_2.NoMatchReason.InitialSilenceTimeout;
        break;
      default:
        reason = Exports_js_2.NoMatchReason.NotRecognized;
        break;
    }
    return new NoMatchDetails(reason);
  }
  /**
   * The reason the recognition was canceled.
   * @member NoMatchDetails.prototype.reason
   * @function
   * @public
   * @returns {NoMatchReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privReason;
  }
}
exports.NoMatchDetails = NoMatchDetails;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/NoMatchReason.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/NoMatchReason.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NoMatchReason = void 0;
/**
 * Defines the possible reasons a recognition result might not be recognized.
 * @class NoMatchReason
 */
var NoMatchReason;
(function (NoMatchReason) {
  /**
   * Indicates that speech was detected, but not recognized.
   * @member NoMatchReason.NotRecognized
   */
  NoMatchReason[NoMatchReason["NotRecognized"] = 0] = "NotRecognized";
  /**
   * Indicates that the start of the audio stream contained only silence,
   * and the service timed out waiting for speech.
   * @member NoMatchReason.InitialSilenceTimeout
   */
  NoMatchReason[NoMatchReason["InitialSilenceTimeout"] = 1] = "InitialSilenceTimeout";
  /**
   * Indicates that the start of the audio stream contained only noise,
   * and the service timed out waiting for speech.
   * @member NoMatchReason.InitialBabbleTimeout
   */
  NoMatchReason[NoMatchReason["InitialBabbleTimeout"] = 2] = "InitialBabbleTimeout";
})(NoMatchReason = exports.NoMatchReason || (exports.NoMatchReason = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/OutputFormat.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/OutputFormat.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OutputFormat = void 0;
/**
 * Define Speech Recognizer output formats.
 * @class OutputFormat
 */
var OutputFormat;
(function (OutputFormat) {
  /**
   * @member OutputFormat.Simple
   */
  OutputFormat[OutputFormat["Simple"] = 0] = "Simple";
  /**
   * @member OutputFormat.Detailed
   */
  OutputFormat[OutputFormat["Detailed"] = 1] = "Detailed";
})(OutputFormat = exports.OutputFormat || (exports.OutputFormat = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PhraseListGrammar.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PhraseListGrammar.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PhraseListGrammar = void 0;
/**
 * Allows additions of new phrases to improve speech recognition.
 *
 * Phrases added to the recognizer are effective at the start of the next recognition, or the next time the SpeechSDK must reconnect
 * to the speech service.
 */
class PhraseListGrammar {
  constructor(recogBase) {
    this.privGrammerBuilder = recogBase.dynamicGrammar;
  }
  /**
   * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
   * @param recognizer The recognizer to add phrase lists to.
   */
  static fromRecognizer(recognizer) {
    const recoBase = recognizer.internalData;
    return new PhraseListGrammar(recoBase);
  }
  /**
   * Adds a single phrase to the current recognizer.
   * @param phrase Phrase to add.
   */
  addPhrase(phrase) {
    this.privGrammerBuilder.addPhrase(phrase);
  }
  /**
   * Adds multiple phrases to the current recognizer.
   * @param phrases Array of phrases to add.
   */
  addPhrases(phrases) {
    this.privGrammerBuilder.addPhrase(phrases);
  }
  /**
   * Clears all phrases added to the current recognizer.
   */
  clear() {
    this.privGrammerBuilder.clearPhrases();
  }
}
exports.PhraseListGrammar = PhraseListGrammar;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ProfanityOption.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ProfanityOption.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProfanityOption = void 0;
/**
 * Profanity option.
 * Added in version 1.7.0.
 */
var ProfanityOption;
(function (ProfanityOption) {
  ProfanityOption[ProfanityOption["Masked"] = 0] = "Masked";
  ProfanityOption[ProfanityOption["Removed"] = 1] = "Removed";
  ProfanityOption[ProfanityOption["Raw"] = 2] = "Raw";
})(ProfanityOption = exports.ProfanityOption || (exports.ProfanityOption = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentConfig.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentConfig.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PronunciationAssessmentConfig = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Pronunciation assessment configuration.
 * @class PronunciationAssessmentConfig
 * Added in version 1.15.0.
 */
class PronunciationAssessmentConfig {
  /**
   * PronunciationAssessmentConfig constructor.
   * @constructor
   * @param {string} referenceText
   * @param gradingSystem
   * @param granularity
   * @param enableMiscue
   */
  constructor(referenceText, gradingSystem = Exports_js_1.PronunciationAssessmentGradingSystem.FivePoint, granularity = Exports_js_1.PronunciationAssessmentGranularity.Phoneme, enableMiscue = false) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(referenceText, "referenceText");
    this.privProperties = new Exports_js_1.PropertyCollection();
    this.privProperties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_ReferenceText, referenceText);
    this.privProperties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_GradingSystem, Exports_js_1.PronunciationAssessmentGradingSystem[gradingSystem]);
    this.privProperties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_Granularity, Exports_js_1.PronunciationAssessmentGranularity[granularity]);
    this.privProperties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_EnableMiscue, String(enableMiscue));
  }
  /**
   * @member PronunciationAssessmentConfig.fromJSON
   * @function
   * @public
   * @param {string} json The json string containing the pronunciation assessment parameters.
   * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
   * @summary Creates an instance of the PronunciationAssessmentConfig from json.
   * This method is designed to support the pronunciation assessment parameters still in preview.
   * Under normal circumstances, use the constructor instead.
   */
  static fromJSON(json) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(json, "json");
    const config = new PronunciationAssessmentConfig("");
    config.privProperties = new Exports_js_1.PropertyCollection();
    config.properties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_Json, json);
    return config;
  }
  toJSON() {
    this.updateJson();
    return this.privProperties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_Params);
  }
  applyTo(recognizer) {
    this.updateJson();
    const recoBase = recognizer.internalData;
    recoBase.expectContentAssessmentResponse = !!this.privContentAssessmentTopic;
    recoBase.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, recoBase.isSpeakerDiarizationEnabled);
  }
  /**
   * Gets the reference text.
   * @member PronunciationAssessmentConfig.prototype.referenceText
   * @function
   * @public
   * @returns {string} Reference text.
   */
  get referenceText() {
    return this.properties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_ReferenceText);
  }
  /**
   * Gets/Sets the reference text.
   * @member PronunciationAssessmentConfig.prototype.referenceText
   * @function
   * @public
   * @param {string} referenceText - Reference text.
   */
  set referenceText(referenceText) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(referenceText, "referenceText");
    this.properties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_ReferenceText, referenceText);
  }
  /**
   * Sets the phoneme alphabet.
   * The valid values are "SAPI" (default) and "IPA".
   * Added in version 1.20.0
   * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
   * @function
   * @public
   * @param {string} phonemeAlphabet - Phoneme alphabet.
   */
  set phonemeAlphabet(phonemeAlphabet) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(phonemeAlphabet, "phonemeAlphabet");
    this.privPhonemeAlphabet = phonemeAlphabet;
  }
  /**
   * Sets the boolean enableMiscue property.
   * Added in version 1.26.0
   * @member PronunciationAssessmentConfig.prototype.enableMiscue
   * @function
   * @public
   * @param {boolean} enableMiscue - enable miscue.
   */
  set enableMiscue(enableMiscue) {
    const enableMiscueString = enableMiscue ? "true" : "false";
    this.properties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_EnableMiscue, enableMiscueString);
  }
  /**
   * Gets the boolean enableMiscue property.
   * Added in version 1.26.0
   * @member PronunciationAssessmentConfig.prototype.enableMiscue
   * @function
   * @public
   * @return {boolean} enableMiscue - enable miscue.
   */
  get enableMiscue() {
    const enableMiscueString = this.properties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_EnableMiscue, "false");
    return enableMiscueString.toLowerCase() === "true";
  }
  /**
   * Sets the nbest phoneme count
   * Added in version 1.20.0
   * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
   * @function
   * @public
   * @param {number} nbestPhonemeCount - NBest phoneme count.
   */
  set nbestPhonemeCount(nbestPhonemeCount) {
    this.privNBestPhonemeCount = nbestPhonemeCount;
  }
  /**
   * Enables the prosody assessment.
   * Added in version 1.34.0
   * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
   * @function
   * @public
   * @param {boolean} enableProsodyAssessment - enable prosody assessment.
   */
  set enableProsodyAssessment(enableProsodyAssessment) {
    this.privEnableProsodyAssessment = enableProsodyAssessment;
  }
  /**
   * Enables content assessment and sets the topic.
   * Added in version 1.34.0
   * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
   * @function
   * @public
   * @param {string} topic - Topic for content assessment.
   */
  enableContentAssessmentWithTopic(topic) {
    this.privContentAssessmentTopic = topic;
  }
  /**
   * @member PronunciationAssessmentConfig.prototype.properties
   * @function
   * @public
   * @return {PropertyCollection} Properties of the config.
   * @summary Gets a pronunciation assessment config properties
   */
  get properties() {
    return this.privProperties;
  }
  updateJson() {
    const jsonString = this.privProperties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_Json, "{}");
    const paramsJson = JSON.parse(jsonString);
    const referenceText = this.privProperties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_ReferenceText);
    if (referenceText) {
      paramsJson.referenceText = referenceText;
    }
    const gradingSystem = this.privProperties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_GradingSystem);
    if (gradingSystem) {
      paramsJson.gradingSystem = gradingSystem;
    }
    const granularity = this.privProperties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_Granularity);
    if (granularity) {
      paramsJson.granularity = granularity;
    }
    if (this.privPhonemeAlphabet) {
      paramsJson.phonemeAlphabet = this.privPhonemeAlphabet;
    }
    if (this.privNBestPhonemeCount) {
      paramsJson.nbestPhonemeCount = this.privNBestPhonemeCount;
    }
    paramsJson.enableProsodyAssessment = this.privEnableProsodyAssessment;
    // always set dimension to Comprehensive
    paramsJson.dimension = "Comprehensive";
    const enableMiscueString = this.privProperties.getProperty(Exports_js_1.PropertyId.PronunciationAssessment_EnableMiscue);
    if (enableMiscueString) {
      paramsJson.enableMiscue = this.enableMiscue;
    }
    this.privProperties.setProperty(Exports_js_1.PropertyId.PronunciationAssessment_Params, JSON.stringify(paramsJson));
  }
}
exports.PronunciationAssessmentConfig = PronunciationAssessmentConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentGradingSystem.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentGradingSystem.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PronunciationAssessmentGradingSystem = void 0;
/**
 * Defines the point system for pronunciation score calibration; default value is FivePoint.
 * Added in version 1.15.0
 * @class PronunciationAssessmentGradingSystem
 */
var PronunciationAssessmentGradingSystem;
(function (PronunciationAssessmentGradingSystem) {
  /**
   * Five point calibration
   * @member PronunciationAssessmentGradingSystem.FivePoint
   */
  PronunciationAssessmentGradingSystem[PronunciationAssessmentGradingSystem["FivePoint"] = 1] = "FivePoint";
  /**
   * Hundred mark
   * @member PronunciationAssessmentGradingSystem.HundredMark
   */
  PronunciationAssessmentGradingSystem[PronunciationAssessmentGradingSystem["HundredMark"] = 2] = "HundredMark";
})(PronunciationAssessmentGradingSystem = exports.PronunciationAssessmentGradingSystem || (exports.PronunciationAssessmentGradingSystem = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentGranularity.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentGranularity.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PronunciationAssessmentGranularity = void 0;
/**
 * Defines the pronunciation evaluation granularity; default value is Phoneme.
 * Added in version 1.15.0
 * @class PronunciationAssessmentGranularity
 */
var PronunciationAssessmentGranularity;
(function (PronunciationAssessmentGranularity) {
  /**
   * Shows the score on the full text, word and phoneme level
   * @member PronunciationAssessmentGranularity.Phoneme
   */
  PronunciationAssessmentGranularity[PronunciationAssessmentGranularity["Phoneme"] = 1] = "Phoneme";
  /**
   * Shows the score on the full text and word level
   * @member PronunciationAssessmentGranularity.Word
   */
  PronunciationAssessmentGranularity[PronunciationAssessmentGranularity["Word"] = 2] = "Word";
  /**
   * Shows the score on the full text level only
   * @member PronunciationAssessmentGranularity.FullText
   */
  PronunciationAssessmentGranularity[PronunciationAssessmentGranularity["FullText"] = 3] = "FullText";
})(PronunciationAssessmentGranularity = exports.PronunciationAssessmentGranularity || (exports.PronunciationAssessmentGranularity = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentResult.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PronunciationAssessmentResult.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PronunciationAssessmentResult = exports.ContentAssessmentResult = void 0;
/* eslint-disable max-classes-per-file */
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class ContentAssessmentResult {
  /**
   * @Internal
   * Do not use externally.
   */
  constructor(detailResult) {
    this.privPronJson = detailResult;
  }
  /**
   * Correctness in using grammar and variety of sentence patterns.
   * Grammatical errors are jointly evaluated by lexical accuracy,
   * grammatical accuracy and diversity of sentence structures.
   * @member ContentAssessmentResult.prototype.grammarScore
   * @function
   * @public
   * @returns {number} Grammar score.
   */
  get grammarScore() {
    return this.privPronJson.ContentAssessment.GrammarScore;
  }
  /**
   * Proficiency in lexical usage. It evaluates the speaker's effective usage
   * of words and their appropriateness within the given context to express
   * ideas accurately, as well as level of lexical complexity.
   * @member ContentAssessmentResult.prototype.vocabularyScore
   * @function
   * @public
   * @returns {number} Vocabulary score.
   */
  get vocabularyScore() {
    return this.privPronJson.ContentAssessment.VocabularyScore;
  }
  /**
   * Level of understanding and engagement with the topic, which provides
   * insights into the speaker’s ability to express their thoughts and ideas
   * effectively and the ability to engage with the topic.
   * @member ContentAssessmentResult.prototype.topicScore
   * @function
   * @public
   * @returns {number} Topic score.
   */
  get topicScore() {
    return this.privPronJson.ContentAssessment.TopicScore;
  }
}
exports.ContentAssessmentResult = ContentAssessmentResult;
/**
 * Pronunciation assessment results.
 * @class PronunciationAssessmentResult
 * Added in version 1.15.0.
 */
class PronunciationAssessmentResult {
  constructor(jsonString) {
    const j = JSON.parse(jsonString);
    Contracts_js_1.Contracts.throwIfNullOrUndefined(j.NBest[0], "NBest");
    this.privPronJson = j.NBest[0];
  }
  /**
   * @member PronunciationAssessmentResult.fromResult
   * @function
   * @public
   * @param {RecognitionResult} result The recognition result.
   * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
   * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
   */
  static fromResult(result) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(result, "result");
    const json = result.properties.getProperty(Exports_js_1.PropertyId.SpeechServiceResponse_JsonResult);
    Contracts_js_1.Contracts.throwIfNullOrUndefined(json, "json");
    return new PronunciationAssessmentResult(json);
  }
  /**
   * Gets the detail result of pronunciation assessment.
   * @member PronunciationAssessmentConfig.prototype.detailResult
   * @function
   * @public
   * @returns {DetailResult} detail result.
   */
  get detailResult() {
    return this.privPronJson;
  }
  /**
   * The score indicating the pronunciation accuracy of the given speech, which indicates
   * how closely the phonemes match a native speaker's pronunciation.
   * @member PronunciationAssessmentResult.prototype.accuracyScore
   * @function
   * @public
   * @returns {number} Accuracy score.
   */
  get accuracyScore() {
    return this.detailResult.PronunciationAssessment?.AccuracyScore;
  }
  /**
   * The overall score indicating the pronunciation quality of the given speech.
   * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
   * @member PronunciationAssessmentResult.prototype.pronunciationScore
   * @function
   * @public
   * @returns {number} Pronunciation score.
   */
  get pronunciationScore() {
    return this.detailResult.PronunciationAssessment?.PronScore;
  }
  /**
   * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
   * @member PronunciationAssessmentResult.prototype.completenessScore
   * @function
   * @public
   * @returns {number} Completeness score.
   */
  get completenessScore() {
    return this.detailResult.PronunciationAssessment?.CompletenessScore;
  }
  /**
   * The score indicating the fluency of the given speech.
   * @member PronunciationAssessmentResult.prototype.fluencyScore
   * @function
   * @public
   * @returns {number} Fluency score.
   */
  get fluencyScore() {
    return this.detailResult.PronunciationAssessment?.FluencyScore;
  }
  /**
   * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
   * @member PronunciationAssessmentResult.prototype.prosodyScore
   * @function
   * @public
   * @returns {number} Prosody score.
   */
  get prosodyScore() {
    return this.detailResult.PronunciationAssessment?.ProsodyScore;
  }
  /**
   * The concent assessment result.
   * Only available when content assessment is enabled.
   * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
   * @function
   * @public
   * @returns {ContentAssessmentResult} Content assessment result.
   */
  get contentAssessmentResult() {
    if (this.detailResult.ContentAssessment === undefined) {
      return undefined;
    }
    return new ContentAssessmentResult(this.detailResult);
  }
}
exports.PronunciationAssessmentResult = PronunciationAssessmentResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyCollection.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyCollection.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PropertyCollection = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Represents collection of properties and their values.
 * @class PropertyCollection
 */
class PropertyCollection {
  constructor() {
    this.privKeys = [];
    this.privValues = [];
  }
  /**
   * Returns the property value in type String.
   * Currently only String, int and bool are allowed.
   * If the name is not available, the specified defaultValue is returned.
   * @member PropertyCollection.prototype.getProperty
   * @function
   * @public
   * @param {string} key - The parameter name.
   * @param {string | number | boolean} def - The default value which is returned if the parameter
   * is not available in the collection.
   * @returns {string} value of the parameter.
   */
  getProperty(key, def) {
    let keyToUse;
    if (typeof key === "string") {
      keyToUse = key;
    } else {
      keyToUse = Exports_js_1.PropertyId[key];
    }
    for (let n = 0; n < this.privKeys.length; n++) {
      if (this.privKeys[n] === keyToUse) {
        return this.privValues[n];
      }
    }
    if (def === undefined) {
      return undefined;
    }
    return String(def);
  }
  /**
   * Sets the String value of the parameter specified by name.
   * @member PropertyCollection.prototype.setProperty
   * @function
   * @public
   * @param {string} key - The parameter name.
   * @param {string} value - The value of the parameter.
   */
  setProperty(key, value) {
    let keyToUse;
    if (typeof key === "string") {
      keyToUse = key;
    } else {
      keyToUse = Exports_js_1.PropertyId[key];
    }
    for (let n = 0; n < this.privKeys.length; n++) {
      if (this.privKeys[n] === keyToUse) {
        this.privValues[n] = value;
        return;
      }
    }
    this.privKeys.push(keyToUse);
    this.privValues.push(value);
  }
  /**
   * Clones the collection.
   * @member PropertyCollection.prototype.clone
   * @function
   * @public
   * @returns {PropertyCollection} A copy of the collection.
   */
  clone() {
    const clonedMap = new PropertyCollection();
    for (let n = 0; n < this.privKeys.length; n++) {
      clonedMap.privKeys.push(this.privKeys[n]);
      clonedMap.privValues.push(this.privValues[n]);
    }
    return clonedMap;
  }
  /**
   * Merges this set of properties into another, no overwrites.
   * @member PropertyCollection.prototype.mergeTo
   * @function
   * @public
   * @param {PropertyCollection}  destinationCollection - The collection to merge into.
   */
  mergeTo(destinationCollection) {
    this.privKeys.forEach(key => {
      if (destinationCollection.getProperty(key, undefined) === undefined) {
        const value = this.getProperty(key);
        destinationCollection.setProperty(key, value);
      }
    });
  }
  /**
   * Get the keys in Property Collection.
   * @member PropertyCollection.prototype.keys
   * @function
   * @public
   * @returns {string []} Keys in the collection.
   */
  get keys() {
    return this.privKeys;
  }
}
exports.PropertyCollection = PropertyCollection;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyId.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/PropertyId.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PropertyId = void 0;
/**
 * Defines speech property ids.
 * @class PropertyId
 */
var PropertyId;
(function (PropertyId) {
  /**
   * The Cognitive Services Speech Service subscription Key. If you are using an intent recognizer, you need to
   * specify the LUIS endpoint key for your particular LUIS app. Under normal circumstances, you shouldn't
   * have to use this property directly.
   * Instead, use [[SpeechConfig.fromSubscription]].
   * @member PropertyId.SpeechServiceConnection_Key
   */
  PropertyId[PropertyId["SpeechServiceConnection_Key"] = 0] = "SpeechServiceConnection_Key";
  /**
   * The Cognitive Services Speech Service endpoint (url). Under normal circumstances, you shouldn't
   * have to use this property directly.
   * Instead, use [[SpeechConfig.fromEndpoint]].
   * NOTE: This endpoint is not the same as the endpoint used to obtain an access token.
   * @member PropertyId.SpeechServiceConnection_Endpoint
   */
  PropertyId[PropertyId["SpeechServiceConnection_Endpoint"] = 1] = "SpeechServiceConnection_Endpoint";
  /**
   * The Cognitive Services Speech Service region. Under normal circumstances, you shouldn't have to
   * use this property directly.
   * Instead, use [[SpeechConfig.fromSubscription]], [[SpeechConfig.fromEndpoint]], [[SpeechConfig.fromAuthorizationToken]].
   * @member PropertyId.SpeechServiceConnection_Region
   */
  PropertyId[PropertyId["SpeechServiceConnection_Region"] = 2] = "SpeechServiceConnection_Region";
  /**
   * The Cognitive Services Speech Service authorization token (aka access token). Under normal circumstances,
   * you shouldn't have to use this property directly.
   * Instead, use [[SpeechConfig.fromAuthorizationToken]], [[SpeechRecognizer.authorizationToken]],
   * [[IntentRecognizer.authorizationToken]], [[TranslationRecognizer.authorizationToken]], [[SpeakerRecognizer.authorizationToken]].
   * @member PropertyId.SpeechServiceAuthorization_Token
   */
  PropertyId[PropertyId["SpeechServiceAuthorization_Token"] = 3] = "SpeechServiceAuthorization_Token";
  /**
   * The Cognitive Services Speech Service authorization type. Currently unused.
   * @member PropertyId.SpeechServiceAuthorization_Type
   */
  PropertyId[PropertyId["SpeechServiceAuthorization_Type"] = 4] = "SpeechServiceAuthorization_Type";
  /**
   * The Cognitive Services Speech Service endpoint id. Under normal circumstances, you shouldn't
   * have to use this property directly.
   * Instead, use [[SpeechConfig.endpointId]].
   * NOTE: The endpoint id is available in the Speech Portal, listed under Endpoint Details.
   * @member PropertyId.SpeechServiceConnection_EndpointId
   */
  PropertyId[PropertyId["SpeechServiceConnection_EndpointId"] = 5] = "SpeechServiceConnection_EndpointId";
  /**
   * The list of comma separated languages (BCP-47 format) used as target translation languages. Under normal circumstances,
   * you shouldn't have to use this property directly.
   * Instead use [[SpeechTranslationConfig.addTargetLanguage]],
   * [[SpeechTranslationConfig.targetLanguages]], [[TranslationRecognizer.targetLanguages]].
   * @member PropertyId.SpeechServiceConnection_TranslationToLanguages
   */
  PropertyId[PropertyId["SpeechServiceConnection_TranslationToLanguages"] = 6] = "SpeechServiceConnection_TranslationToLanguages";
  /**
   * The name of the Cognitive Service Text to Speech Service Voice. Under normal circumstances, you shouldn't have to use this
   * property directly.
   * Instead, use [[SpeechTranslationConfig.voiceName]].
   * NOTE: Valid voice names can be found <a href="https://aka.ms/csspeech/voicenames">here</a>.
   * @member PropertyId.SpeechServiceConnection_TranslationVoice
   */
  PropertyId[PropertyId["SpeechServiceConnection_TranslationVoice"] = 7] = "SpeechServiceConnection_TranslationVoice";
  /**
   * Translation features.
   * @member PropertyId.SpeechServiceConnection_TranslationFeatures
   */
  PropertyId[PropertyId["SpeechServiceConnection_TranslationFeatures"] = 8] = "SpeechServiceConnection_TranslationFeatures";
  /**
   * The Language Understanding Service Region. Under normal circumstances, you shouldn't have to use this property directly.
   * Instead, use [[LanguageUnderstandingModel]].
   * @member PropertyId.SpeechServiceConnection_IntentRegion
   */
  PropertyId[PropertyId["SpeechServiceConnection_IntentRegion"] = 9] = "SpeechServiceConnection_IntentRegion";
  /**
   * The host name of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
   * You shouldn't have to use this property directly.
   * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
   * Added in version 1.4.0.
   */
  PropertyId[PropertyId["SpeechServiceConnection_ProxyHostName"] = 10] = "SpeechServiceConnection_ProxyHostName";
  /**
   * The port of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
   * You shouldn't have to use this property directly.
   * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
   * Added in version 1.4.0.
   */
  PropertyId[PropertyId["SpeechServiceConnection_ProxyPort"] = 11] = "SpeechServiceConnection_ProxyPort";
  /**
   * The user name of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
   * You shouldn't have to use this property directly.
   * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
   * Added in version 1.4.0.
   */
  PropertyId[PropertyId["SpeechServiceConnection_ProxyUserName"] = 12] = "SpeechServiceConnection_ProxyUserName";
  /**
   * The password of the proxy server used to connect to the Cognitive Services Speech Service. Only relevant in Node.js environments.
   * You shouldn't have to use this property directly.
   * Instead use <see cref="SpeechConfig.SetProxy(string,int,string,string)"/>.
   * Added in version 1.4.0.
   */
  PropertyId[PropertyId["SpeechServiceConnection_ProxyPassword"] = 13] = "SpeechServiceConnection_ProxyPassword";
  /**
   * The Cognitive Services Speech Service recognition Mode. Can be "INTERACTIVE", "CONVERSATION", "DICTATION".
   * This property is intended to be read-only. The SDK is using it internally.
   * @member PropertyId.SpeechServiceConnection_RecoMode
   */
  PropertyId[PropertyId["SpeechServiceConnection_RecoMode"] = 14] = "SpeechServiceConnection_RecoMode";
  /**
   * The spoken language to be recognized (in BCP-47 format). Under normal circumstances, you shouldn't have to use this property
   * directly.
   * Instead, use [[SpeechConfig.speechRecognitionLanguage]].
   * @member PropertyId.SpeechServiceConnection_RecoLanguage
   */
  PropertyId[PropertyId["SpeechServiceConnection_RecoLanguage"] = 15] = "SpeechServiceConnection_RecoLanguage";
  /**
   * The session id. This id is a universally unique identifier (aka UUID) representing a specific binding of an audio input stream
   * and the underlying speech recognition instance to which it is bound. Under normal circumstances, you shouldn't have to use this
   * property directly.
   * Instead use [[SessionEventArgs.sessionId]].
   * @member PropertyId.Speech_SessionId
   */
  PropertyId[PropertyId["Speech_SessionId"] = 16] = "Speech_SessionId";
  /**
   * The spoken language to be synthesized (e.g. en-US)
   * @member PropertyId.SpeechServiceConnection_SynthLanguage
   */
  PropertyId[PropertyId["SpeechServiceConnection_SynthLanguage"] = 17] = "SpeechServiceConnection_SynthLanguage";
  /**
   * The name of the TTS voice to be used for speech synthesis
   * @member PropertyId.SpeechServiceConnection_SynthVoice
   */
  PropertyId[PropertyId["SpeechServiceConnection_SynthVoice"] = 18] = "SpeechServiceConnection_SynthVoice";
  /**
   * The string to specify TTS output audio format
   * @member PropertyId.SpeechServiceConnection_SynthOutputFormat
   */
  PropertyId[PropertyId["SpeechServiceConnection_SynthOutputFormat"] = 19] = "SpeechServiceConnection_SynthOutputFormat";
  /**
   * The list of comma separated languages used as possible source languages
   * Added in version 1.13.0
   * @member PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages
   */
  PropertyId[PropertyId["SpeechServiceConnection_AutoDetectSourceLanguages"] = 20] = "SpeechServiceConnection_AutoDetectSourceLanguages";
  /**
   * The requested Cognitive Services Speech Service response output format (simple or detailed). Under normal circumstances, you shouldn't have
   * to use this property directly.
   * Instead use [[SpeechConfig.outputFormat]].
   * @member PropertyId.SpeechServiceResponse_RequestDetailedResultTrueFalse
   */
  PropertyId[PropertyId["SpeechServiceResponse_RequestDetailedResultTrueFalse"] = 21] = "SpeechServiceResponse_RequestDetailedResultTrueFalse";
  /**
   * The requested Cognitive Services Speech Service response output profanity level. Currently unused.
   * @member PropertyId.SpeechServiceResponse_RequestProfanityFilterTrueFalse
   */
  PropertyId[PropertyId["SpeechServiceResponse_RequestProfanityFilterTrueFalse"] = 22] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse";
  /**
   * The Cognitive Services Speech Service response output (in JSON format). This property is available on recognition result objects only.
   * @member PropertyId.SpeechServiceResponse_JsonResult
   */
  PropertyId[PropertyId["SpeechServiceResponse_JsonResult"] = 23] = "SpeechServiceResponse_JsonResult";
  /**
   * The Cognitive Services Speech Service error details (in JSON format). Under normal circumstances, you shouldn't have to
   * use this property directly. Instead use [[CancellationDetails.errorDetails]].
   * @member PropertyId.SpeechServiceResponse_JsonErrorDetails
   */
  PropertyId[PropertyId["SpeechServiceResponse_JsonErrorDetails"] = 24] = "SpeechServiceResponse_JsonErrorDetails";
  /**
   * The cancellation reason. Currently unused.
   * @member PropertyId.CancellationDetails_Reason
   */
  PropertyId[PropertyId["CancellationDetails_Reason"] = 25] = "CancellationDetails_Reason";
  /**
   * The cancellation text. Currently unused.
   * @member PropertyId.CancellationDetails_ReasonText
   */
  PropertyId[PropertyId["CancellationDetails_ReasonText"] = 26] = "CancellationDetails_ReasonText";
  /**
   * The Cancellation detailed text. Currently unused.
   * @member PropertyId.CancellationDetails_ReasonDetailedText
   */
  PropertyId[PropertyId["CancellationDetails_ReasonDetailedText"] = 27] = "CancellationDetails_ReasonDetailedText";
  /**
   * The Language Understanding Service response output (in JSON format). Available via [[IntentRecognitionResult]]
   * @member PropertyId.LanguageUnderstandingServiceResponse_JsonResult
   */
  PropertyId[PropertyId["LanguageUnderstandingServiceResponse_JsonResult"] = 28] = "LanguageUnderstandingServiceResponse_JsonResult";
  /**
   * The URL string built from speech configuration.
   * This property is intended to be read-only. The SDK is using it internally.
   * NOTE: Added in version 1.7.0.
   */
  PropertyId[PropertyId["SpeechServiceConnection_Url"] = 29] = "SpeechServiceConnection_Url";
  /**
   * The initial silence timeout value (in milliseconds) used by the service.
   * Added in version 1.7.0
   */
  PropertyId[PropertyId["SpeechServiceConnection_InitialSilenceTimeoutMs"] = 30] = "SpeechServiceConnection_InitialSilenceTimeoutMs";
  /**
   * The end silence timeout value (in milliseconds) used by the service.
   * Added in version 1.7.0
   */
  PropertyId[PropertyId["SpeechServiceConnection_EndSilenceTimeoutMs"] = 31] = "SpeechServiceConnection_EndSilenceTimeoutMs";
  /**
   * A duration of detected silence, measured in milliseconds, after which speech-to-text will determine a spoken
   * phrase has ended and generate a final Recognized result. Configuring this timeout may be helpful in situations
   * where spoken input is significantly faster or slower than usual and default segmentation behavior consistently
   * yields results that are too long or too short. Segmentation timeout values that are inappropriately high or low
   * can negatively affect speech-to-text accuracy; this property should be carefully configured and the resulting
   * behavior should be thoroughly validated as intended.
   *
   * For more information about timeout configuration that includes discussion of default behaviors, please visit
   * https://aka.ms/csspeech/timeouts.
   *
   * Added in version 1.21.0.
   */
  PropertyId[PropertyId["Speech_SegmentationSilenceTimeoutMs"] = 32] = "Speech_SegmentationSilenceTimeoutMs";
  /**
   * SegmentationMaximumTimeMs represents the maximum length of a spoken phrase when using the Time segmentation strategy.
   * As the length of a spoken phrase approaches this value, the @member Speech_SegmentationSilenceTimeoutMs will be reduced until either
   * the phrase silence timeout is reached or the phrase reaches the maximum length.
   *
   * Added in version 1.42.0.
   */
  PropertyId[PropertyId["Speech_SegmentationMaximumTimeMs"] = 33] = "Speech_SegmentationMaximumTimeMs";
  /**
   * SegmentationStrategy defines the strategy used to determine when a spoken phrase has ended and a final Recognized result should be generated.
   * Allowed values are "Default", "Time", and "Semantic".
   *
   * Valid values:
   * - "Default": Uses the default strategy and settings as determined by the Speech Service. Suitable for most situations.
   * - "Time": Uses a time-based strategy where the amount of silence between speech determines when to generate a final result.
   * - "Semantic": Uses an AI model to determine the end of a spoken phrase based on the phrase's content.
   *
   * Additional Notes:
   * - When using the Time strategy, @member Speech_SegmentationSilenceTimeoutMs can be adjusted to modify the required silence duration for ending a phrase,
   * and @member Speech_SegmentationMaximumTimeMs can be adjusted to set the maximum length of a spoken phrase.
   * - The Semantic strategy does not have any adjustable properties.
   *
   * Added in version 1.42.0.
   */
  PropertyId[PropertyId["Speech_SegmentationStrategy"] = 34] = "Speech_SegmentationStrategy";
  /**
   * A boolean value specifying whether audio logging is enabled in the service or not.
   * Audio and content logs are stored either in Microsoft-owned storage, or in your own storage account linked
   * to your Cognitive Services subscription (Bring Your Own Storage (BYOS) enabled Speech resource).
   * The logs will be removed after 30 days.
   * Added in version 1.7.0
   */
  PropertyId[PropertyId["SpeechServiceConnection_EnableAudioLogging"] = 35] = "SpeechServiceConnection_EnableAudioLogging";
  /**
   * The speech service connection language identifier mode.
   * Can be "AtStart" (the default), or "Continuous". See Language
   * Identification document https://aka.ms/speech/lid?pivots=programming-language-javascript
   * for more details.
   * Added in 1.25.0
   **/
  PropertyId[PropertyId["SpeechServiceConnection_LanguageIdMode"] = 36] = "SpeechServiceConnection_LanguageIdMode";
  /**
   * A string value representing the desired endpoint version to target for Speech Recognition.
   * Added in version 1.21.0
   */
  PropertyId[PropertyId["SpeechServiceConnection_RecognitionEndpointVersion"] = 37] = "SpeechServiceConnection_RecognitionEndpointVersion";
  /**
  /**
   * A string value the current speaker recognition scenario/mode (TextIndependentIdentification, etc.).
   * Added in version 1.23.0
   */
  PropertyId[PropertyId["SpeechServiceConnection_SpeakerIdMode"] = 38] = "SpeechServiceConnection_SpeakerIdMode";
  /**
   * The requested Cognitive Services Speech Service response output profanity setting.
   * Allowed values are "masked", "removed", and "raw".
   * Added in version 1.7.0.
   */
  PropertyId[PropertyId["SpeechServiceResponse_ProfanityOption"] = 39] = "SpeechServiceResponse_ProfanityOption";
  /**
   * A string value specifying which post processing option should be used by service.
   * Allowed values are "TrueText".
   * Added in version 1.7.0
   */
  PropertyId[PropertyId["SpeechServiceResponse_PostProcessingOption"] = 40] = "SpeechServiceResponse_PostProcessingOption";
  /**
   * A boolean value specifying whether to include word-level timestamps in the response result.
   * Added in version 1.7.0
   */
  PropertyId[PropertyId["SpeechServiceResponse_RequestWordLevelTimestamps"] = 41] = "SpeechServiceResponse_RequestWordLevelTimestamps";
  /**
   * The number of times a word has to be in partial results to be returned.
   * Added in version 1.7.0
   */
  PropertyId[PropertyId["SpeechServiceResponse_StablePartialResultThreshold"] = 42] = "SpeechServiceResponse_StablePartialResultThreshold";
  /**
   * A string value specifying the output format option in the response result. Internal use only.
   * Added in version 1.7.0.
   */
  PropertyId[PropertyId["SpeechServiceResponse_OutputFormatOption"] = 43] = "SpeechServiceResponse_OutputFormatOption";
  /**
   * A boolean value to request for stabilizing translation partial results by omitting words in the end.
   * Added in version 1.7.0.
   */
  PropertyId[PropertyId["SpeechServiceResponse_TranslationRequestStablePartialResult"] = 44] = "SpeechServiceResponse_TranslationRequestStablePartialResult";
  /**
   * A boolean value specifying whether to request WordBoundary events.
   * @member PropertyId.SpeechServiceResponse_RequestWordBoundary
   * Added in version 1.21.0.
   */
  PropertyId[PropertyId["SpeechServiceResponse_RequestWordBoundary"] = 45] = "SpeechServiceResponse_RequestWordBoundary";
  /**
   * A boolean value specifying whether to request punctuation boundary in WordBoundary Events. Default is true.
   * @member PropertyId.SpeechServiceResponse_RequestPunctuationBoundary
   * Added in version 1.21.0.
   */
  PropertyId[PropertyId["SpeechServiceResponse_RequestPunctuationBoundary"] = 46] = "SpeechServiceResponse_RequestPunctuationBoundary";
  /**
   * A boolean value specifying whether to request sentence boundary in WordBoundary Events. Default is false.
   * @member PropertyId.SpeechServiceResponse_RequestSentenceBoundary
   * Added in version 1.21.0.
   */
  PropertyId[PropertyId["SpeechServiceResponse_RequestSentenceBoundary"] = 47] = "SpeechServiceResponse_RequestSentenceBoundary";
  /**
   * Determines if intermediate results contain speaker identification.
   * Allowed values are "true" or "false". If set to "true", the intermediate results will contain speaker identification.
   * The default value if unset or set to an invalid value is "false".
   * This is currently only supported for scenarios using the ConversationTranscriber".
   * @member PropertyId.SpeechServiceResponse_DiarizeIntermediateResults
   * Adding in version 1.41.
   */
  PropertyId[PropertyId["SpeechServiceResponse_DiarizeIntermediateResults"] = 48] = "SpeechServiceResponse_DiarizeIntermediateResults";
  /**
   * Identifier used to connect to the backend service.
   * @member PropertyId.Conversation_ApplicationId
   */
  PropertyId[PropertyId["Conversation_ApplicationId"] = 49] = "Conversation_ApplicationId";
  /**
   * Type of dialog backend to connect to.
   * @member PropertyId.Conversation_DialogType
   */
  PropertyId[PropertyId["Conversation_DialogType"] = 50] = "Conversation_DialogType";
  /**
   * Silence timeout for listening
   * @member PropertyId.Conversation_Initial_Silence_Timeout
   */
  PropertyId[PropertyId["Conversation_Initial_Silence_Timeout"] = 51] = "Conversation_Initial_Silence_Timeout";
  /**
   * From Id to add to speech recognition activities.
   * @member PropertyId.Conversation_From_Id
   */
  PropertyId[PropertyId["Conversation_From_Id"] = 52] = "Conversation_From_Id";
  /**
   * ConversationId for the session.
   * @member PropertyId.Conversation_Conversation_Id
   */
  PropertyId[PropertyId["Conversation_Conversation_Id"] = 53] = "Conversation_Conversation_Id";
  /**
   * Comma separated list of custom voice deployment ids.
   * @member PropertyId.Conversation_Custom_Voice_Deployment_Ids
   */
  PropertyId[PropertyId["Conversation_Custom_Voice_Deployment_Ids"] = 54] = "Conversation_Custom_Voice_Deployment_Ids";
  /**
   * Speech activity template, stamp properties from the template on the activity generated by the service for speech.
   * @member PropertyId.Conversation_Speech_Activity_Template
   * Added in version 1.10.0.
   */
  PropertyId[PropertyId["Conversation_Speech_Activity_Template"] = 55] = "Conversation_Speech_Activity_Template";
  /**
   * Enables or disables the receipt of turn status messages as obtained on the turnStatusReceived event.
   * @member PropertyId.Conversation_Request_Bot_Status_Messages
   * Added in version 1.15.0.
   */
  PropertyId[PropertyId["Conversation_Request_Bot_Status_Messages"] = 56] = "Conversation_Request_Bot_Status_Messages";
  /**
   * Specifies the connection ID to be provided in the Agent configuration message, e.g. a Direct Line token for
   * channel authentication.
   * Added in version 1.15.1.
   */
  PropertyId[PropertyId["Conversation_Agent_Connection_Id"] = 57] = "Conversation_Agent_Connection_Id";
  /**
   * The Cognitive Services Speech Service host (url). Under normal circumstances, you shouldn't have to use this property directly.
   * Instead, use [[SpeechConfig.fromHost]].
   */
  PropertyId[PropertyId["SpeechServiceConnection_Host"] = 58] = "SpeechServiceConnection_Host";
  /**
   * Set the host for service calls to the Conversation Translator REST management and websocket calls.
   */
  PropertyId[PropertyId["ConversationTranslator_Host"] = 59] = "ConversationTranslator_Host";
  /**
   * Optionally set the the host's display name.
   * Used when joining a conversation.
   */
  PropertyId[PropertyId["ConversationTranslator_Name"] = 60] = "ConversationTranslator_Name";
  /**
   * Optionally set a value for the X-CorrelationId request header.
   * Used for troubleshooting errors in the server logs. It should be a valid guid.
   */
  PropertyId[PropertyId["ConversationTranslator_CorrelationId"] = 61] = "ConversationTranslator_CorrelationId";
  /**
   * Set the conversation token to be sent to the speech service. This enables the
   * service to service call from the speech service to the Conversation Translator service for relaying
   * recognitions. For internal use.
   */
  PropertyId[PropertyId["ConversationTranslator_Token"] = 62] = "ConversationTranslator_Token";
  /**
   * The reference text of the audio for pronunciation evaluation.
   * For this and the following pronunciation assessment parameters, see
   * https://docs.microsoft.com/azure/cognitive-services/speech-service/rest-speech-to-text#pronunciation-assessment-parameters for details.
   * Under normal circumstances, you shouldn't have to use this property directly.
   * Added in version 1.15.0
   */
  PropertyId[PropertyId["PronunciationAssessment_ReferenceText"] = 63] = "PronunciationAssessment_ReferenceText";
  /**
   * The point system for pronunciation score calibration (FivePoint or HundredMark).
   * Under normal circumstances, you shouldn't have to use this property directly.
   * Added in version 1.15.0
   */
  PropertyId[PropertyId["PronunciationAssessment_GradingSystem"] = 64] = "PronunciationAssessment_GradingSystem";
  /**
   * The pronunciation evaluation granularity (Phoneme, Word, or FullText).
   * Under normal circumstances, you shouldn't have to use this property directly.
   * Added in version 1.15.0
   */
  PropertyId[PropertyId["PronunciationAssessment_Granularity"] = 65] = "PronunciationAssessment_Granularity";
  /**
   * Defines if enable miscue calculation.
   * With this enabled, the pronounced words will be compared to the reference text,
   * and will be marked with omission/insertion based on the comparison. The default setting is False.
   * Under normal circumstances, you shouldn't have to use this property directly.
   * Added in version 1.15.0
   */
  PropertyId[PropertyId["PronunciationAssessment_EnableMiscue"] = 66] = "PronunciationAssessment_EnableMiscue";
  /**
   * The json string of pronunciation assessment parameters
   * Under normal circumstances, you shouldn't have to use this property directly.
   * Added in version 1.15.0
   */
  PropertyId[PropertyId["PronunciationAssessment_Json"] = 67] = "PronunciationAssessment_Json";
  /**
   * Pronunciation assessment parameters.
   * This property is intended to be read-only. The SDK is using it internally.
   * Added in version 1.15.0
   */
  PropertyId[PropertyId["PronunciationAssessment_Params"] = 68] = "PronunciationAssessment_Params";
  /**
   * Version of Speaker Recognition API to use.
   * Added in version 1.18.0
   */
  PropertyId[PropertyId["SpeakerRecognition_Api_Version"] = 69] = "SpeakerRecognition_Api_Version";
  /**
   * Specifies whether to allow load of data URL for web worker
   * Allowed values are "off" and "on". Default is "on".
   * Added in version 1.32.0
   */
  PropertyId[PropertyId["WebWorkerLoadType"] = 70] = "WebWorkerLoadType";
  /**
   * Talking avatar service WebRTC session description protocol.
   * This property is intended to be read-only. The SDK is using it internally.
   * Added in version 1.33.0
   */
  PropertyId[PropertyId["TalkingAvatarService_WebRTC_SDP"] = 71] = "TalkingAvatarService_WebRTC_SDP";
})(PropertyId = exports.PropertyId || (exports.PropertyId = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/RecognitionEventArgs.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/RecognitionEventArgs.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RecognitionEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines payload for session events like Speech Start/End Detected
 * @class
 */
class RecognitionEventArgs extends Exports_js_1.SessionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} offset - The offset.
   * @param {string} sessionId - The session id.
   */
  constructor(offset, sessionId) {
    super(sessionId);
    this.privOffset = offset;
  }
  /**
   * Represents the message offset
   * @member RecognitionEventArgs.prototype.offset
   * @function
   * @public
   */
  get offset() {
    return this.privOffset;
  }
}
exports.RecognitionEventArgs = RecognitionEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/RecognitionResult.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/RecognitionResult.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RecognitionResult = void 0;
/**
 * Defines result of speech recognition.
 * @class RecognitionResult
 */
class RecognitionResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} text - The recognized text.
   * @param {number} duration - The duration.
   * @param {number} offset - The offset into the stream.
   * @param {string} language - Primary Language detected, if provided.
   * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param {string} errorDetails - Error details, if provided.
   * @param {string} json - Additional Json, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
    this.privResultId = resultId;
    this.privReason = reason;
    this.privText = text;
    this.privDuration = duration;
    this.privOffset = offset;
    this.privLanguage = language;
    this.privLanguageDetectionConfidence = languageDetectionConfidence;
    this.privErrorDetails = errorDetails;
    this.privJson = json;
    this.privProperties = properties;
  }
  /**
   * Specifies the result identifier.
   * @member RecognitionResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member RecognitionResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * Presents the recognized text in the result.
   * @member RecognitionResult.prototype.text
   * @function
   * @public
   * @returns {string} Presents the recognized text in the result.
   */
  get text() {
    return this.privText;
  }
  /**
   * Duration of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.duration
   * @function
   * @public
   * @returns {number} Duration of recognized speech in 100 nano second increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Offset of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.offset
   * @function
   * @public
   * @returns {number} Offset of recognized speech in 100 nano second increments.
   */
  get offset() {
    return this.privOffset;
  }
  /**
   * Primary Language detected.
   * @member RecognitionResult.prototype.language
   * @function
   * @public
   * @returns {string} language detected.
   */
  get language() {
    return this.privLanguage;
  }
  /**
   * Primary Language detection confidence (Unknown, Low, Medium, High).
   * @member RecognitionResult.prototype.languageDetectionConfidence
   * @function
   * @public
   * @returns {string} detection confidence strength.
   */
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member RecognitionResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * A string containing Json serialized recognition result as it was received from the service.
   * @member RecognitionResult.prototype.json
   * @function
   * @private
   * @returns {string} Json serialized representation of the result.
   */
  get json() {
    return this.privJson;
  }
  /**
   * The set of properties exposed in the result.
   * @member RecognitionResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
exports.RecognitionResult = RecognitionResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Recognizer.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Recognizer.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Recognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines the base class Recognizer which mainly contains common event handlers.
 * @class Recognizer
 */
class Recognizer {
  /**
   * Creates and initializes an instance of a Recognizer
   * @constructor
   * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
   * @param {PropertyCollection} properties - A set of properties to set on the recognizer
   * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
   */
  constructor(audioConfig, properties, connectionFactory) {
    this.audioConfig = audioConfig !== undefined ? audioConfig : Exports_js_3.AudioConfig.fromDefaultMicrophoneInput();
    this.privDisposed = false;
    this.privProperties = properties.clone();
    this.privConnectionFactory = connectionFactory;
    this.implCommonRecognizerSetup();
  }
  /**
   * Dispose of associated resources.
   * @member Recognizer.prototype.close
   * @function
   * @public
   */
  close(cb, errorCb) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
  }
  /**
   * @Internal
   * Internal data member to support fromRecognizer* pattern methods on other classes.
   * Do not use externally, object returned will change without warning or notice.
   */
  get internalData() {
    return this.privReco;
  }
  /**
   * This method performs cleanup of resources.
   * The Boolean parameter disposing indicates whether the method is called
   * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
   * Derived classes should override this method to dispose resource if needed.
   * @member Recognizer.prototype.dispose
   * @function
   * @public
   * @param {boolean} disposing - Flag to request disposal.
   */
  async dispose(disposing) {
    if (this.privDisposed) {
      return;
    }
    this.privDisposed = true;
    if (disposing) {
      if (this.privReco) {
        await this.privReco.audioSource.turnOff();
        await this.privReco.dispose();
      }
    }
  }
  /**
   * This method returns the current state of the telemetry setting.
   * @member Recognizer.prototype.telemetryEnabled
   * @function
   * @public
   * @returns true if the telemetry is enabled, false otherwise.
   */
  static get telemetryEnabled() {
    return Exports_js_1.ServiceRecognizerBase.telemetryDataEnabled;
  }
  /**
   * This method globally enables or disables telemetry.
   * @member Recognizer.prototype.enableTelemetry
   * @function
   * @public
   * @param enabled - Global setting for telemetry collection.
   * If set to true, telemetry information like microphone errors,
   * recognition errors are collected and sent to Microsoft.
   * If set to false, no telemetry is sent to Microsoft.
   */
  static enableTelemetry(enabled) {
    Exports_js_1.ServiceRecognizerBase.telemetryDataEnabled = enabled;
  }
  // Does the generic recognizer setup that is common across all recognizer types.
  implCommonRecognizerSetup() {
    let osPlatform = typeof window !== "undefined" ? "Browser" : "Node";
    let osName = "unknown";
    let osVersion = "unknown";
    if (typeof navigator !== "undefined") {
      osPlatform = osPlatform + "/" + navigator.platform;
      osName = navigator.userAgent;
      osVersion = navigator.appVersion;
    }
    const recognizerConfig = this.createRecognizerConfig(new Exports_js_1.SpeechServiceConfig(new Exports_js_1.Context(new Exports_js_1.OS(osPlatform, osName, osVersion))));
    this.privReco = this.createServiceRecognizer(Recognizer.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, recognizerConfig);
  }
  async recognizeOnceAsyncImpl(recognitionMode) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);
    const ret = new Exports_js_2.Deferred();
    await this.implRecognizerStop();
    await this.privReco.recognize(recognitionMode, ret.resolve, ret.reject);
    const result = await ret.promise;
    await this.implRecognizerStop();
    return result;
  }
  async startContinuousRecognitionAsyncImpl(recognitionMode) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);
    await this.implRecognizerStop();
    await this.privReco.recognize(recognitionMode, undefined, undefined);
  }
  async stopContinuousRecognitionAsyncImpl() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);
    await this.implRecognizerStop();
  }
  async implRecognizerStop() {
    if (this.privReco) {
      await this.privReco.stopRecognizing();
    }
    return;
  }
  static getAuthFromProperties(properties) {
    const subscriptionKey = properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Key, undefined);
    const authentication = subscriptionKey && subscriptionKey !== "" ? new Exports_js_1.CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new Exports_js_1.CognitiveTokenAuthentication(() => {
      const authorizationToken = properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
      return Promise.resolve(authorizationToken);
    }, () => {
      const authorizationToken = properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
      return Promise.resolve(authorizationToken);
    });
    return authentication;
  }
}
exports.Recognizer = Recognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ResultReason.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ResultReason.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ResultReason = void 0;
/**
 * Defines the possible reasons a recognition result might be generated.
 * @class ResultReason
 */
var ResultReason;
(function (ResultReason) {
  /**
   * Indicates speech could not be recognized. More details
   * can be found in the NoMatchDetails object.
   * @member ResultReason.NoMatch
   */
  ResultReason[ResultReason["NoMatch"] = 0] = "NoMatch";
  /**
   * Indicates that the recognition was canceled. More details
   * can be found using the CancellationDetails object.
   * @member ResultReason.Canceled
   */
  ResultReason[ResultReason["Canceled"] = 1] = "Canceled";
  /**
   * Indicates the speech result contains hypothesis text.
   * @member ResultReason.RecognizedSpeech
   */
  ResultReason[ResultReason["RecognizingSpeech"] = 2] = "RecognizingSpeech";
  /**
   * Indicates the speech result contains final text that has been recognized.
   * Speech Recognition is now complete for this phrase.
   * @member ResultReason.RecognizedSpeech
   */
  ResultReason[ResultReason["RecognizedSpeech"] = 3] = "RecognizedSpeech";
  /**
   * Indicates the speech result contains a finalized acceptance of a provided keyword.
   * Speech recognition will continue unless otherwise configured.
   * @member ResultReason.RecognizedKeyword
   */
  ResultReason[ResultReason["RecognizedKeyword"] = 4] = "RecognizedKeyword";
  /**
   * Indicates the intent result contains hypothesis text and intent.
   * @member ResultReason.RecognizingIntent
   */
  ResultReason[ResultReason["RecognizingIntent"] = 5] = "RecognizingIntent";
  /**
   * Indicates the intent result contains final text and intent.
   * Speech Recognition and Intent determination are now complete for this phrase.
   * @member ResultReason.RecognizedIntent
   */
  ResultReason[ResultReason["RecognizedIntent"] = 6] = "RecognizedIntent";
  /**
   * Indicates the translation result contains hypothesis text and its translation(s).
   * @member ResultReason.TranslatingSpeech
   */
  ResultReason[ResultReason["TranslatingSpeech"] = 7] = "TranslatingSpeech";
  /**
   * Indicates the translation result contains final text and corresponding translation(s).
   * Speech Recognition and Translation are now complete for this phrase.
   * @member ResultReason.TranslatedSpeech
   */
  ResultReason[ResultReason["TranslatedSpeech"] = 8] = "TranslatedSpeech";
  /**
   * Indicates the synthesized audio result contains a non-zero amount of audio data
   * @member ResultReason.SynthesizingAudio
   */
  ResultReason[ResultReason["SynthesizingAudio"] = 9] = "SynthesizingAudio";
  /**
   * Indicates the synthesized audio is now complete for this phrase.
   * @member ResultReason.SynthesizingAudioCompleted
   */
  ResultReason[ResultReason["SynthesizingAudioCompleted"] = 10] = "SynthesizingAudioCompleted";
  /**
   * Indicates the speech synthesis is now started
   * @member ResultReason.SynthesizingAudioStarted
   */
  ResultReason[ResultReason["SynthesizingAudioStarted"] = 11] = "SynthesizingAudioStarted";
  /**
   * Indicates the voice profile is being enrolled and customers need to send more audio to create a voice profile.
   * @member ResultReason.EnrollingVoiceProfile
   */
  ResultReason[ResultReason["EnrollingVoiceProfile"] = 12] = "EnrollingVoiceProfile";
  /**
   * Indicates the voice profile has been enrolled.
   * @member ResultReason.EnrolledVoiceProfile
   */
  ResultReason[ResultReason["EnrolledVoiceProfile"] = 13] = "EnrolledVoiceProfile";
  /**
   * Indicates successful identification of some speakers.
   * @member ResultReason.RecognizedSpeakers
   */
  ResultReason[ResultReason["RecognizedSpeakers"] = 14] = "RecognizedSpeakers";
  /**
   * Indicates successfully verified one speaker.
   * @member ResultReason.RecognizedSpeaker
   */
  ResultReason[ResultReason["RecognizedSpeaker"] = 15] = "RecognizedSpeaker";
  /**
   * Indicates a voice profile has been reset successfully.
   * @member ResultReason.ResetVoiceProfile
   */
  ResultReason[ResultReason["ResetVoiceProfile"] = 16] = "ResetVoiceProfile";
  /**
   * Indicates a voice profile has been deleted successfully.
   * @member ResultReason.DeletedVoiceProfile
   */
  ResultReason[ResultReason["DeletedVoiceProfile"] = 17] = "DeletedVoiceProfile";
  /**
   * Indicates synthesis voices list has been successfully retrieved.
   * @member ResultReason.VoicesListRetrieved
   */
  ResultReason[ResultReason["VoicesListRetrieved"] = 18] = "VoicesListRetrieved";
  /**
   * Indicates the transcription result contains hypothesis text and its translation(s) for
   * other participants in the conversation.
   * @member ResultReason.TranslatingParticipantSpeech
   */
  ResultReason[ResultReason["TranslatingParticipantSpeech"] = 19] = "TranslatingParticipantSpeech";
  /**
   * Indicates the transcription result contains final text and corresponding translation(s)
   * for other participants in the conversation. Speech Recognition and Translation are now
   * complete for this phrase.
   * @member ResultReason.TranslatedParticipantSpeech
   */
  ResultReason[ResultReason["TranslatedParticipantSpeech"] = 20] = "TranslatedParticipantSpeech";
  /**
   * <summary>
   * Indicates the transcription result contains the instant message and corresponding
   * translation(s).
   * @member ResultReason.TranslatedInstantMessage
   */
  ResultReason[ResultReason["TranslatedInstantMessage"] = 21] = "TranslatedInstantMessage";
  /**
   * Indicates the transcription result contains the instant message for other participants
   * in the conversation and corresponding translation(s).
   * @member ResultReason.TranslatedParticipantInstantMessage
   */
  ResultReason[ResultReason["TranslatedParticipantInstantMessage"] = 22] = "TranslatedParticipantInstantMessage";
})(ResultReason = exports.ResultReason || (exports.ResultReason = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ServiceEventArgs.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ServiceEventArgs.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


//
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.
//
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServiceEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines payload for any Service message event
 * Added in version 1.9.0
 */
class ServiceEventArgs extends Exports_js_1.SessionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} json - json payload of the USP message.
   */
  constructor(json, name, sessionId) {
    super(sessionId);
    this.privJsonResult = json;
    this.privEventName = name;
  }
  get jsonString() {
    return this.privJsonResult;
  }
  get eventName() {
    return this.privEventName;
  }
}
exports.ServiceEventArgs = ServiceEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ServicePropertyChannel.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/ServicePropertyChannel.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ServicePropertyChannel = void 0;
/**
 * Defines channels used to pass property settings to service.
 * Added in version 1.7.0.
 */
var ServicePropertyChannel;
(function (ServicePropertyChannel) {
  /**
   * Uses URI query parameter to pass property settings to service.
   */
  ServicePropertyChannel[ServicePropertyChannel["UriQueryParameter"] = 0] = "UriQueryParameter";
})(ServicePropertyChannel = exports.ServicePropertyChannel || (exports.ServicePropertyChannel = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SessionEventArgs.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SessionEventArgs.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SessionEventArgs = void 0;
/**
 * Defines content for session events like SessionStarted/Stopped, SoundStarted/Stopped.
 * @class SessionEventArgs
 */
class SessionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionId - The session id.
   */
  constructor(sessionId) {
    this.privSessionId = sessionId;
  }
  /**
   * Represents the session identifier.
   * @member SessionEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} Represents the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
}
exports.SessionEventArgs = SessionEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SourceLanguageConfig.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SourceLanguageConfig.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SourceLanguageConfig = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
/**
 * Source Language configuration.
 * @class SourceLanguageConfig
 */
class SourceLanguageConfig {
  constructor(language, endpointId) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(language, "language");
    this.privLanguage = language;
    this.privEndpointId = endpointId;
  }
  /**
   * @member SourceLanguageConfig.fromLanguage
   * @function
   * @public
   * @param {string} language language (eg. "en-US") value of config.
   * @param {string?} endpointId endpointId of model bound to given language of config.
   * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
   * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
   * Added in version 1.13.0.
   */
  static fromLanguage(language, endpointId) {
    return new SourceLanguageConfig(language, endpointId);
  }
  get language() {
    return this.privLanguage;
  }
  get endpointId() {
    return this.privEndpointId;
  }
}
exports.SourceLanguageConfig = SourceLanguageConfig;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerIdentificationModel.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerIdentificationModel.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeakerIdentificationModel = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines SpeakerIdentificationModel class for Speaker Recognition
 * Model contains a set of profiles against which to identify speaker(s)
 * @class SpeakerIdentificationModel
 */
class SpeakerIdentificationModel {
  constructor(profiles) {
    this.privVoiceProfiles = [];
    this.privProfileIds = [];
    Contracts_js_1.Contracts.throwIfNullOrUndefined(profiles, "VoiceProfiles");
    if (profiles.length === 0) {
      throw new Error("Empty Voice Profiles array");
    }
    for (const profile of profiles) {
      if (profile.profileType !== Exports_js_1.VoiceProfileType.TextIndependentIdentification) {
        throw new Error("Identification model can only be created from Identification profile: " + profile.profileId);
      }
      this.privVoiceProfiles.push(profile);
      this.privProfileIds.push(profile.profileId);
    }
  }
  static fromProfiles(profiles) {
    return new SpeakerIdentificationModel(profiles);
  }
  get voiceProfileIds() {
    return this.privProfileIds.join(",");
  }
  get profileIds() {
    return this.privProfileIds;
  }
  get scenario() {
    return "TextIndependentIdentification";
  }
}
exports.SpeakerIdentificationModel = SpeakerIdentificationModel;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerRecognitionResult.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerRecognitionResult.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeakerRecognitionCancellationDetails = exports.SpeakerRecognitionResult = exports.SpeakerRecognitionResultType = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
var SpeakerRecognitionResultType;
(function (SpeakerRecognitionResultType) {
  SpeakerRecognitionResultType[SpeakerRecognitionResultType["Verify"] = 0] = "Verify";
  SpeakerRecognitionResultType[SpeakerRecognitionResultType["Identify"] = 1] = "Identify";
})(SpeakerRecognitionResultType = exports.SpeakerRecognitionResultType || (exports.SpeakerRecognitionResultType = {}));
/**
 * Output format
 * @class SpeakerRecognitionResult
 */
class SpeakerRecognitionResult {
  constructor(response, resultReason = Exports_js_2.ResultReason.RecognizedSpeaker, cancellationErrorCode = Exports_js_2.CancellationErrorCode.NoError, errorDetails = "") {
    this.privProperties = new Exports_js_2.PropertyCollection();
    const resultType = response.scenario === "TextIndependentIdentification" ? SpeakerRecognitionResultType.Identify : SpeakerRecognitionResultType.Verify;
    this.privReason = resultReason;
    if (this.privReason !== Exports_js_2.ResultReason.Canceled) {
      if (resultType === SpeakerRecognitionResultType.Identify) {
        this.privProfileId = response.identificationResult.identifiedProfile.profileId;
        this.privScore = response.identificationResult.identifiedProfile.score;
        this.privReason = Exports_js_2.ResultReason.RecognizedSpeakers;
      } else {
        this.privScore = response.verificationResult.score;
        if (response.verificationResult.recognitionResult.toLowerCase() !== "accept") {
          this.privReason = Exports_js_2.ResultReason.NoMatch;
        }
        if (response.verificationResult.profileId !== undefined && response.verificationResult.profileId !== "") {
          this.privProfileId = response.verificationResult.profileId;
        }
      }
    } else {
      this.privErrorDetails = errorDetails;
      this.privProperties.setProperty(Exports_js_1.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[cancellationErrorCode]);
    }
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(response));
  }
  get properties() {
    return this.privProperties;
  }
  get reason() {
    return this.privReason;
  }
  get profileId() {
    return this.privProfileId;
  }
  get errorDetails() {
    return this.privErrorDetails;
  }
  get score() {
    return this.privScore;
  }
}
exports.SpeakerRecognitionResult = SpeakerRecognitionResult;
/**
 * @class SpeakerRecognitionCancellationDetails
 */
class SpeakerRecognitionCancellationDetails extends Exports_js_2.CancellationDetailsBase {
  constructor(reason, errorDetails, errorCode) {
    super(reason, errorDetails, errorCode);
  }
  /**
   * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
   * @member SpeakerRecognitionCancellationDetails.fromResult
   * @function
   * @public
   * @param {SpeakerRecognitionResult} result - The result that was canceled.
   * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
   */
  static fromResult(result) {
    const reason = Exports_js_2.CancellationReason.Error;
    let errorCode = Exports_js_2.CancellationErrorCode.NoError;
    if (!!result.properties) {
      errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_1.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])];
    }
    return new SpeakerRecognitionCancellationDetails(reason, result.errorDetails, errorCode);
  }
}
exports.SpeakerRecognitionCancellationDetails = SpeakerRecognitionCancellationDetails;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerRecognizer.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerRecognizer.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeakerRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines SpeakerRecognizer class for Speaker Recognition
 * Handles operations from user for Voice Profile operations (e.g. createProfile, deleteProfile)
 * @class SpeakerRecognizer
 */
class SpeakerRecognizer extends Exports_js_2.Recognizer {
  /**
   * Initializes an instance of the SpeakerRecognizer.
   * @constructor
   * @param {SpeechConfig} speechConfig - The set of configuration properties.
   * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
   */
  constructor(speechConfig, audioConfig) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
    const configImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(configImpl, "speechConfig");
    super(audioConfig, configImpl.properties, new Exports_js_1.SpeakerRecognitionConnectionFactory());
    this.privAudioConfigImpl = audioConfig;
    Contracts_js_1.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig");
    this.privDisposedSpeakerRecognizer = false;
    this.privProperties = configImpl.properties;
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member SpeakerRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * @member SpeakerRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @param {string} token - Authorization token.
   */
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  /**
   * The collection of properties and their values defined for this SpeakerRecognizer.
   * @member SpeakerRecognizer.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Get recognition result for model using given audio
   * @member SpeakerRecognizer.prototype.recognizeOnceAsync
   * @function
   * @public
   * @async
   * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
   * @param cb - Callback invoked once result is returned.
   * @param err - Callback invoked in case of an error.
   */
  async recognizeOnceAsync(model) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
    return this.recognizeSpeakerOnceAsyncImpl(model);
  }
  /**
   * Included for compatibility
   * @member SpeakerRecognizer.prototype.close
   * @function
   * @public
   * @async
   */
  async close() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
    await this.dispose(true);
  }
  async recognizeSpeakerOnceAsyncImpl(model) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer);
    await this.implRecognizerStop();
    const result = await this.privReco.recognizeSpeaker(model);
    await this.implRecognizerStop();
    return result;
  }
  async implRecognizerStop() {
    if (this.privReco) {
      await this.privReco.stopRecognizing();
    }
    return;
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const audioImpl = audioConfig;
    return new Exports_js_1.SpeakerServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
  }
  async dispose(disposing) {
    if (this.privDisposedSpeakerRecognizer) {
      return;
    }
    if (disposing) {
      this.privDisposedSpeakerRecognizer = true;
      await super.dispose(disposing);
    }
  }
}
exports.SpeakerRecognizer = SpeakerRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerVerificationModel.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeakerVerificationModel.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeakerVerificationModel = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines SpeakerVerificationModel class for Speaker Recognition
 * Model contains a profile against which to verify a speaker
 * @class SpeakerVerificationModel
 */
class SpeakerVerificationModel {
  constructor(profile) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(profile, "VoiceProfile");
    if (profile.profileType === Exports_js_1.VoiceProfileType.TextIndependentIdentification) {
      throw new Error("Verification model cannot be created from Identification profile");
    }
    this.privVoiceProfile = profile;
  }
  static fromProfile(profile) {
    return new SpeakerVerificationModel(profile);
  }
  get voiceProfile() {
    return this.privVoiceProfile;
  }
  get profileIds() {
    return [this.voiceProfile.profileId];
  }
  get scenario() {
    if (this.voiceProfile.profileType === Exports_js_1.VoiceProfileType.TextDependentVerification) {
      return "TextDependentVerification";
    } else {
      return "TextIndependentVerification";
    }
  }
}
exports.SpeakerVerificationModel = SpeakerVerificationModel;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechConfig.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechConfig.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
/* eslint-disable max-classes-per-file */
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechConfigImpl = exports.SpeechConfig = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Speech configuration.
 * @class SpeechConfig
 */
class SpeechConfig {
  /**
   * Creates and initializes an instance.
   * @constructor
   */
  constructor() {
    return;
  }
  /**
   * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
   * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
   * @member SpeechConfig.fromSubscription
   * @function
   * @public
   * @param {string} subscriptionKey - The subscription key.
   * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {SpeechConfig} The speech factory
   */
  static fromSubscription(subscriptionKey, region) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const speechImpl = new SpeechConfigImpl();
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_IntentRegion, region);
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    return speechImpl;
  }
  /**
   * Creates an instance of the speech config with specified endpoint and subscription key.
   * This method is intended only for users who use a non-standard service endpoint or parameters.
   * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
   * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
   * For example, if language is defined in the uri as query parameter "language=de-DE", and also set by
   * SpeechConfig.speechRecognitionLanguage = "en-US", the language setting in uri takes precedence,
   * and the effective language is "de-DE". Only the parameters that are not specified in the
   * endpoint URL can be set by other APIs.
   * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
   * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
   * use the authorization token.
   * @member SpeechConfig.fromEndpoint
   * @function
   * @public
   * @param {URL} endpoint - The service endpoint to connect to.
   * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
   * @returns {SpeechConfig} A speech factory instance.
   */
  static fromEndpoint(endpoint, subscriptionKey) {
    Contracts_js_1.Contracts.throwIfNull(endpoint, "endpoint");
    const speechImpl = new SpeechConfigImpl();
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);
    if (undefined !== subscriptionKey) {
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    }
    return speechImpl;
  }
  /**
   * Creates an instance of the speech config with specified host and subscription key.
   * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
   * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
   * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
   * Note: To use an authorization token with fromHost, use fromHost(URL),
   * and then set the AuthorizationToken property on the created SpeechConfig instance.
   * Note: Added in version 1.9.0.
   * @member SpeechConfig.fromHost
   * @function
   * @public
   * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
   * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
   * @returns {SpeechConfig} A speech factory instance.
   */
  static fromHost(hostName, subscriptionKey) {
    Contracts_js_1.Contracts.throwIfNull(hostName, "hostName");
    const speechImpl = new SpeechConfigImpl();
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, hostName.protocol + "//" + hostName.hostname + (hostName.port === "" ? "" : ":" + hostName.port));
    if (undefined !== subscriptionKey) {
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    }
    return speechImpl;
  }
  /**
   * Creates an instance of the speech factory with specified initial authorization token and region.
   * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
   * expires, the caller needs to refresh it by calling this setter with a new valid token.
   * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
   * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
   * the new token value will not apply to recognizers that have already been created. For recognizers
   * that have been created before, you need to set authorization token of the corresponding recognizer
   * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
   * @member SpeechConfig.fromAuthorizationToken
   * @function
   * @public
   * @param {string} authorizationToken - The initial authorization token.
   * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {SpeechConfig} A speech factory instance.
   */
  static fromAuthorizationToken(authorizationToken, region) {
    Contracts_js_1.Contracts.throwIfNull(authorizationToken, "authorizationToken");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const speechImpl = new SpeechConfigImpl();
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_IntentRegion, region);
    speechImpl.authorizationToken = authorizationToken;
    return speechImpl;
  }
  /**
   * Closes the configuration.
   * @member SpeechConfig.prototype.close
   * @function
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  close() {}
}
exports.SpeechConfig = SpeechConfig;
/**
 * @public
 * @class SpeechConfigImpl
 */
class SpeechConfigImpl extends SpeechConfig {
  constructor() {
    super();
    this.privProperties = new Exports_js_2.PropertyCollection();
    this.speechRecognitionLanguage = "en-US"; // Should we have a default?
    this.outputFormat = Exports_js_2.OutputFormat.Simple;
  }
  get properties() {
    return this.privProperties;
  }
  get endPoint() {
    return new URL(this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint));
  }
  get subscriptionKey() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key);
  }
  get region() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
  }
  get authorizationToken() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
  }
  set authorizationToken(value) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, value);
  }
  get speechRecognitionLanguage() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage);
  }
  set speechRecognitionLanguage(value) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, value);
  }
  get autoDetectSourceLanguages() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
  }
  set autoDetectSourceLanguages(value) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, value);
  }
  get outputFormat() {
    return Exports_js_2.OutputFormat[this.privProperties.getProperty(Exports_js_1.OutputFormatPropertyName, undefined)];
  }
  set outputFormat(value) {
    this.privProperties.setProperty(Exports_js_1.OutputFormatPropertyName, Exports_js_2.OutputFormat[value]);
  }
  get endpointId() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId);
  }
  set endpointId(value) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, value);
  }
  setProperty(name, value) {
    Contracts_js_1.Contracts.throwIfNull(value, "value");
    this.privProperties.setProperty(name, value);
  }
  getProperty(name, def) {
    return this.privProperties.getProperty(name, def);
  }
  setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);
  }
  setServiceProperty(name, value) {
    const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_1.ServicePropertiesPropertyName, "{}"));
    currentProperties[name] = value;
    this.privProperties.setProperty(Exports_js_1.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
  }
  setProfanity(profanity) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, Exports_js_2.ProfanityOption[profanity]);
  }
  enableAudioLogging() {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
  }
  requestWordLevelTimestamps() {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    this.privProperties.setProperty(Exports_js_1.OutputFormatPropertyName, Exports_js_2.OutputFormat[Exports_js_2.OutputFormat.Detailed]);
  }
  enableDictation() {
    this.privProperties.setProperty(Exports_js_1.ForceDictationPropertyName, "true");
  }
  clone() {
    const ret = new SpeechConfigImpl();
    ret.privProperties = this.privProperties.clone();
    return ret;
  }
  get speechSynthesisLanguage() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage);
  }
  set speechSynthesisLanguage(language) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage, language);
  }
  get speechSynthesisVoiceName() {
    return this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice);
  }
  set speechSynthesisVoiceName(voice) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice, voice);
  }
  get speechSynthesisOutputFormat() {
    return Exports_js_2.SpeechSynthesisOutputFormat[this.privProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)];
  }
  set speechSynthesisOutputFormat(format) {
    this.privProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, Exports_js_2.SpeechSynthesisOutputFormat[format]);
  }
}
exports.SpeechConfigImpl = SpeechConfigImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionCanceledEventArgs.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionCanceledEventArgs.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechRecognitionCanceledEventArgs = void 0;
const CancellationEventArgsBase_js_1 = __webpack_require__(/*! ./CancellationEventArgsBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationEventArgsBase.js");
class SpeechRecognitionCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {}
exports.SpeechRecognitionCanceledEventArgs = SpeechRecognitionCanceledEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionEventArgs.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionEventArgs.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MeetingTranscriptionEventArgs = exports.ConversationTranscriptionEventArgs = exports.SpeechRecognitionEventArgs = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines contents of speech recognizing/recognized event.
 * @class SpeechRecognitionEventArgs
 */
class SpeechRecognitionEventArgs extends Exports_js_1.RecognitionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {SpeechRecognitionResult} result - The speech recognition result.
   * @param {number} offset - The offset.
   * @param {string} sessionId - The session id.
   */
  constructor(result, offset, sessionId) {
    super(offset, sessionId);
    this.privResult = result;
  }
  /**
   * Specifies the recognition result.
   * @member SpeechRecognitionEventArgs.prototype.result
   * @function
   * @public
   * @returns {SpeechRecognitionResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
}
exports.SpeechRecognitionEventArgs = SpeechRecognitionEventArgs;
/**
 * Defines contents of conversation transcribed/transcribing event.
 * @class ConversationTranscriptionEventArgs
 */
class ConversationTranscriptionEventArgs extends Exports_js_1.RecognitionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {ConversationTranscriptionResult} result - The conversation transcription result.
   * @param {number} offset - The offset.
   * @param {string} sessionId - The session id.
   */
  constructor(result, offset, sessionId) {
    super(offset, sessionId);
    this.privResult = result;
  }
  /**
   * Specifies the transcription result.
   * @member ConversationTranscription1EventArgs.prototype.result
   * @function
   * @public
   * @returns {ConversationTranscriptionResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
}
exports.ConversationTranscriptionEventArgs = ConversationTranscriptionEventArgs;
/**
 * Defines contents of meeting transcribed/transcribing event.
 * @class MeetingTranscriptionEventArgs
 */
class MeetingTranscriptionEventArgs extends SpeechRecognitionEventArgs {}
exports.MeetingTranscriptionEventArgs = MeetingTranscriptionEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionResult.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognitionResult.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechRecognitionResult = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines result of speech recognition.
 * @class SpeechRecognitionResult
 */
class SpeechRecognitionResult extends Exports_js_1.RecognitionResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @public
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} text - The recognized text.
   * @param {number} duration - The duration.
   * @param {number} offset - The offset into the stream.
   * @param {string} language - Primary Language detected, if provided.
   * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param {string} speakerId - speaker id for conversation transcription, if provided.
   * @param {string} errorDetails - Error details, if provided.
   * @param {string} json - Additional Json, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(resultId, reason, text, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {
    super(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties);
    this.privSpeakerId = speakerId;
  }
  /**
   * speaker id from conversation transcription/id scenarios
   * @member SpeechRecognitionResult.prototype.speakerId
   * @function
   * @public
   * @returns {string} id of speaker in given result
   */
  get speakerId() {
    return this.privSpeakerId;
  }
}
exports.SpeechRecognitionResult = SpeechRecognitionResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognizer.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechRecognizer.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Performs speech recognition from microphone, file, or other audio input streams, and gets transcribed text as result.
 * @class SpeechRecognizer
 */
class SpeechRecognizer extends Exports_js_3.Recognizer {
  /**
   * SpeechRecognizer constructor.
   * @constructor
   * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
   */
  constructor(speechConfig, audioConfig) {
    const speechConfigImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    super(audioConfig, speechConfigImpl.properties, new Exports_js_1.SpeechConnectionFactory());
    this.privDisposedRecognizer = false;
  }
  /**
   * SpeechRecognizer constructor.
   * @constructor
   * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
   * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
   */
  static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
    const speechConfigImpl = speechConfig;
    autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
    const recognizer = new SpeechRecognizer(speechConfig, audioConfig);
    return recognizer;
  }
  /**
   * Gets the endpoint id of a customized speech model that is used for speech recognition.
   * @member SpeechRecognizer.prototype.endpointId
   * @function
   * @public
   * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
   */
  get endpointId() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member SpeechRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * @member SpeechRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @param {string} token - Authorization token.
   */
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  /**
   * Gets the spoken language of recognition.
   * @member SpeechRecognizer.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @returns {string} The spoken language of recognition.
   */
  get speechRecognitionLanguage() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
  }
  /**
   * Gets the output format of recognition.
   * @member SpeechRecognizer.prototype.outputFormat
   * @function
   * @public
   * @returns {OutputFormat} The output format of recognition.
   */
  get outputFormat() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    if (this.properties.getProperty(Exports_js_1.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) === Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) {
      return Exports_js_3.OutputFormat.Simple;
    } else {
      return Exports_js_3.OutputFormat.Detailed;
    }
  }
  /**
   * The collection of properties and their values defined for this SpeechRecognizer.
   * @member SpeechRecognizer.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Starts speech recognition, and stops after the first utterance is recognized.
   * The task returns the recognition text as result.
   * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
   * so it is suitable only for single shot recognition
   * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
   * @member SpeechRecognizer.prototype.recognizeOnceAsync
   * @function
   * @public
   * @param cb - Callback that received the SpeechRecognitionResult.
   * @param err - Callback invoked in case of an error.
   */
  recognizeOnceAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_js_1.RecognitionMode.Interactive), cb, err);
  }
  /**
   * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
   * User must subscribe to events to receive recognition results.
   * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
   * @function
   * @public
   * @param cb - Callback invoked once the recognition has started.
   * @param err - Callback invoked in case of an error.
   */
  startContinuousRecognitionAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_1.RecognitionMode.Conversation), cb, err);
  }
  /**
   * Stops continuous speech recognition.
   * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
   * @function
   * @public
   * @param cb - Callback invoked once the recognition has stopped.
   * @param err - Callback invoked in case of an error.
   */
  stopContinuousRecognitionAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
  }
  /**
   * Starts speech recognition with keyword spotting, until
   * stopKeywordRecognitionAsync() is called.
   * User must subscribe to events to receive recognition results.
   * Note: Key word spotting functionality is only available on the
   * Speech Devices SDK. This functionality is currently not included in the SDK itself.
   * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
   * @function
   * @public
   * @param {KeywordRecognitionModel} model The keyword recognition model that
   * specifies the keyword to be recognized.
   * @param cb - Callback invoked once the recognition has started.
   * @param err - Callback invoked in case of an error.
   */
  startKeywordRecognitionAsync(model, cb, err) {
    Contracts_js_1.Contracts.throwIfNull(model, "model");
    if (!!err) {
      err("Not yet implemented.");
    }
  }
  /**
   * Stops continuous speech recognition.
   * Note: Key word spotting functionality is only available on the
   * Speech Devices SDK. This functionality is currently not included in the SDK itself.
   * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
   * @function
   * @public
   * @param cb - Callback invoked once the recognition has stopped.
   * @param err - Callback invoked in case of an error.
   */
  stopKeywordRecognitionAsync(cb) {
    if (!!cb) {
      cb();
    }
  }
  /**
   * closes all external resources held by an instance of this class.
   * @member SpeechRecognizer.prototype.close
   * @function
   * @public
   */
  close(cb, errorCb) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
  }
  /**
   * Disposes any resources held by the object.
   * @member SpeechRecognizer.prototype.dispose
   * @function
   * @public
   * @param {boolean} disposing - true if disposing the object.
   */
  async dispose(disposing) {
    if (this.privDisposedRecognizer) {
      return;
    }
    if (disposing) {
      this.privDisposedRecognizer = true;
      await this.implRecognizerStop();
    }
    await super.dispose(disposing);
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const configImpl = audioConfig;
    return new Exports_js_1.SpeechServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
  }
}
exports.SpeechRecognizer = SpeechRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisBookmarkEventArgs.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisBookmarkEventArgs.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisBookmarkEventArgs = void 0;
/**
 * Defines contents of speech synthesis bookmark event.
 * @class SpeechSynthesisBookmarkEventArgs
 * Added in version 1.16.0
 */
class SpeechSynthesisBookmarkEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {string} text - The bookmark text.
   */
  constructor(audioOffset, text) {
    this.privAudioOffset = audioOffset;
    this.privText = text;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the bookmark.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the bookmark text.
   */
  get text() {
    return this.privText;
  }
}
exports.SpeechSynthesisBookmarkEventArgs = SpeechSynthesisBookmarkEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisBoundaryType.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisBoundaryType.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisBoundaryType = void 0;
/**
 * Defines the boundary type of speech synthesis boundary event.
 * @class SpeechSynthesisBoundaryType
 * Added in version 1.21.0
 */
var SpeechSynthesisBoundaryType;
(function (SpeechSynthesisBoundaryType) {
  /**
   * Indicates the boundary text is a word.
   * @member SpeechSynthesisBoundaryType.Word
   */
  SpeechSynthesisBoundaryType["Word"] = "WordBoundary";
  /**
   * Indicates the boundary text is a punctuation.
   * @member SpeechSynthesisBoundaryType.Punctuation
   */
  SpeechSynthesisBoundaryType["Punctuation"] = "PunctuationBoundary";
  /**
   * Indicates the boundary text is a sentence.
   * @member SpeechSynthesisBoundaryType.Sentence
   */
  SpeechSynthesisBoundaryType["Sentence"] = "SentenceBoundary";
})(SpeechSynthesisBoundaryType = exports.SpeechSynthesisBoundaryType || (exports.SpeechSynthesisBoundaryType = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisEventArgs.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisEventArgs.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisEventArgs = void 0;
/**
 * Defines contents of speech synthesis events.
 * @class SpeechSynthesisEventArgs
 * Added in version 1.11.0
 */
class SpeechSynthesisEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {SpeechSynthesisResult} result - The speech synthesis result.
   */
  constructor(result) {
    this.privResult = result;
  }
  /**
   * Specifies the synthesis result.
   * @member SpeechSynthesisEventArgs.prototype.result
   * @function
   * @public
   * @returns {SpeechSynthesisResult} the synthesis result.
   */
  get result() {
    return this.privResult;
  }
}
exports.SpeechSynthesisEventArgs = SpeechSynthesisEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisOutputFormat.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisOutputFormat.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisOutputFormat = void 0;
/**
 * Define speech synthesis audio output formats.
 * @enum SpeechSynthesisOutputFormat
 * Updated in version 1.17.0
 */
var SpeechSynthesisOutputFormat;
(function (SpeechSynthesisOutputFormat) {
  /**
   * raw-8khz-8bit-mono-mulaw
   * @member SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw,
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw8Khz8BitMonoMULaw"] = 0] = "Raw8Khz8BitMonoMULaw";
  /**
   * riff-16khz-16kbps-mono-siren
   * @note Unsupported by the service. Do not use this value.
   * @member SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff16Khz16KbpsMonoSiren"] = 1] = "Riff16Khz16KbpsMonoSiren";
  /**
   * audio-16khz-16kbps-mono-siren
   * @note Unsupported by the service. Do not use this value.
   * @member SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz16KbpsMonoSiren"] = 2] = "Audio16Khz16KbpsMonoSiren";
  /**
   * audio-16khz-32kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz32KBitRateMonoMp3"] = 3] = "Audio16Khz32KBitRateMonoMp3";
  /**
   * audio-16khz-128kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz128KBitRateMonoMp3"] = 4] = "Audio16Khz128KBitRateMonoMp3";
  /**
   * audio-16khz-64kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz64KBitRateMonoMp3"] = 5] = "Audio16Khz64KBitRateMonoMp3";
  /**
   * audio-24khz-48kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz48KBitRateMonoMp3"] = 6] = "Audio24Khz48KBitRateMonoMp3";
  /**
   * audio-24khz-96kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz96KBitRateMonoMp3"] = 7] = "Audio24Khz96KBitRateMonoMp3";
  /**
   * audio-24khz-160kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz160KBitRateMonoMp3"] = 8] = "Audio24Khz160KBitRateMonoMp3";
  /**
   * raw-16khz-16bit-mono-truesilk
   * @member SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw16Khz16BitMonoTrueSilk"] = 9] = "Raw16Khz16BitMonoTrueSilk";
  /**
   * riff-16khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff16Khz16BitMonoPcm"] = 10] = "Riff16Khz16BitMonoPcm";
  /**
   * riff-8khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff8Khz16BitMonoPcm"] = 11] = "Riff8Khz16BitMonoPcm";
  /**
   * riff-24khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff24Khz16BitMonoPcm"] = 12] = "Riff24Khz16BitMonoPcm";
  /**
   * riff-8khz-8bit-mono-mulaw
   * @member SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff8Khz8BitMonoMULaw"] = 13] = "Riff8Khz8BitMonoMULaw";
  /**
   * raw-16khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw16Khz16BitMonoPcm"] = 14] = "Raw16Khz16BitMonoPcm";
  /**
   * raw-24khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw24Khz16BitMonoPcm"] = 15] = "Raw24Khz16BitMonoPcm";
  /**
   * raw-8khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw8Khz16BitMonoPcm"] = 16] = "Raw8Khz16BitMonoPcm";
  /**
   * ogg-16khz-16bit-mono-opus
   * @member SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Ogg16Khz16BitMonoOpus"] = 17] = "Ogg16Khz16BitMonoOpus";
  /**
   * ogg-24khz-16bit-mono-opus
   * @member SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Ogg24Khz16BitMonoOpus"] = 18] = "Ogg24Khz16BitMonoOpus";
  /**
   * raw-48khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw48Khz16BitMonoPcm"] = 19] = "Raw48Khz16BitMonoPcm";
  /**
   * riff-48khz-16bit-mono-pcm
   * @member SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff48Khz16BitMonoPcm"] = 20] = "Riff48Khz16BitMonoPcm";
  /**
   * audio-48khz-96kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio48Khz96KBitRateMonoMp3"] = 21] = "Audio48Khz96KBitRateMonoMp3";
  /**
   * audio-48khz-192kbitrate-mono-mp3
   * @member SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio48Khz192KBitRateMonoMp3"] = 22] = "Audio48Khz192KBitRateMonoMp3";
  /**
   * ogg-48khz-16bit-mono-opus
   * Added in version 1.16.0
   * @member SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Ogg48Khz16BitMonoOpus"] = 23] = "Ogg48Khz16BitMonoOpus";
  /**
   * webm-16khz-16bit-mono-opus
   * Added in version 1.16.0
   * @member SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Webm16Khz16BitMonoOpus"] = 24] = "Webm16Khz16BitMonoOpus";
  /**
   * webm-24khz-16bit-mono-opus
   * Added in version 1.16.0
   * @member SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Webm24Khz16BitMonoOpus"] = 25] = "Webm24Khz16BitMonoOpus";
  /**
   * raw-24khz-16bit-mono-truesilk
   * Added in version 1.17.0
   * @member SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw24Khz16BitMonoTrueSilk"] = 26] = "Raw24Khz16BitMonoTrueSilk";
  /**
   * raw-8khz-8bit-mono-alaw
   * Added in version 1.17.0
   * @member SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw8Khz8BitMonoALaw"] = 27] = "Raw8Khz8BitMonoALaw";
  /**
   * riff-8khz-8bit-mono-alaw
   * Added in version 1.17.0
   * @member SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff8Khz8BitMonoALaw"] = 28] = "Riff8Khz8BitMonoALaw";
  /**
   * webm-24khz-16bit-24kbps-mono-opus
   * Audio compressed by OPUS codec in a webm container, with bitrate of 24kbps, optimized for IoT scenario.
   * Added in version 1.19.0
   * @member SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Webm24Khz16Bit24KbpsMonoOpus"] = 29] = "Webm24Khz16Bit24KbpsMonoOpus";
  /**
   * audio-16khz-16bit-32kbps-mono-opus
   * Audio compressed by OPUS codec without container, with bitrate of 32kbps.
   * Added in version 1.20.0
   * @member SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio16Khz16Bit32KbpsMonoOpus"] = 30] = "Audio16Khz16Bit32KbpsMonoOpus";
  /**
   * audio-24khz-16bit-48kbps-mono-opus
   * Audio compressed by OPUS codec without container, with bitrate of 48kbps.
   * Added in version 1.20.0
   * @member SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz16Bit48KbpsMonoOpus"] = 31] = "Audio24Khz16Bit48KbpsMonoOpus";
  /**
   * audio-24khz-16bit-24kbps-mono-opus
   * Audio compressed by OPUS codec without container, with bitrate of 24kbps.
   * Added in version 1.20.0
   * @member SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Audio24Khz16Bit24KbpsMonoOpus"] = 32] = "Audio24Khz16Bit24KbpsMonoOpus";
  /**
   * raw-22050hz-16bit-mono-pcm
   * Raw PCM audio at 22050Hz sampling rate and 16-bit depth.
   * Added in version 1.22.0
   * @member SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw22050Hz16BitMonoPcm"] = 33] = "Raw22050Hz16BitMonoPcm";
  /**
   * riff-22050hz-16bit-mono-pcm
   * PCM audio at 22050Hz sampling rate and 16-bit depth, with RIFF header.
   * Added in version 1.22.0
   * @member SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff22050Hz16BitMonoPcm"] = 34] = "Riff22050Hz16BitMonoPcm";
  /**
   * raw-44100hz-16bit-mono-pcm
   * Raw PCM audio at 44100Hz sampling rate and 16-bit depth.
   * Added in version 1.22.0
   * @member SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Raw44100Hz16BitMonoPcm"] = 35] = "Raw44100Hz16BitMonoPcm";
  /**
   * riff-44100hz-16bit-mono-pcm
   * PCM audio at 44100Hz sampling rate and 16-bit depth, with RIFF header.
   * Added in version 1.22.0
   * @member SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["Riff44100Hz16BitMonoPcm"] = 36] = "Riff44100Hz16BitMonoPcm";
  /**
   * amr-wb-16000hz
   * AMR-WB audio at 16kHz sampling rate.
   * Added in version 1.38.0
   * @member SpeechSynthesisOutputFormat.AmrWb16000Hz
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["AmrWb16000Hz"] = 37] = "AmrWb16000Hz";
  /**
   * g722-16khz-64kbps
   * G.722 audio at 16kHz sampling rate and 64kbps bitrate.
   * Added in version 1.38.0
   */
  SpeechSynthesisOutputFormat[SpeechSynthesisOutputFormat["G72216Khz64Kbps"] = 38] = "G72216Khz64Kbps";
})(SpeechSynthesisOutputFormat = exports.SpeechSynthesisOutputFormat || (exports.SpeechSynthesisOutputFormat = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisResult.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisResult.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisResult = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines result of speech synthesis.
 * @class SpeechSynthesisResult
 * Added in version 1.11.0
 */
class SpeechSynthesisResult extends Exports_js_1.SynthesisResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {ArrayBuffer} audioData - The synthesized audio binary.
   * @param {string} errorDetails - Error details, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   * @param {number} audioDuration - The audio duration.
   */
  constructor(resultId, reason, audioData, errorDetails, properties, audioDuration) {
    super(resultId, reason, errorDetails, properties);
    this.privAudioData = audioData;
    this.privAudioDuration = audioDuration;
  }
  /**
   * The synthesized audio data
   * @member SpeechSynthesisResult.prototype.audioData
   * @function
   * @public
   * @returns {ArrayBuffer} The synthesized audio data.
   */
  get audioData() {
    return this.privAudioData;
  }
  /**
   * The time duration of synthesized audio, in ticks (100 nanoseconds).
   * @member SpeechSynthesisResult.prototype.audioDuration
   * @function
   * @public
   * @returns {number} The time duration of synthesized audio.
   */
  get audioDuration() {
    return this.privAudioDuration;
  }
}
exports.SpeechSynthesisResult = SpeechSynthesisResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisVisemeEventArgs.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisVisemeEventArgs.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisVisemeEventArgs = void 0;
/**
 * Defines contents of speech synthesis viseme event.
 * @class SpeechSynthesisVisemeEventArgs
 * Added in version 1.16.0
 */
class SpeechSynthesisVisemeEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} visemeId - The viseme ID.
   * @param {string} animation - The animation, could be in svg or other format.
   */
  constructor(audioOffset, visemeId, animation) {
    this.privAudioOffset = audioOffset;
    this.privVisemeId = visemeId;
    this.privAnimation = animation;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the viseme ID.
   * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
   * @function
   * @public
   * @returns {number} the viseme ID.
   */
  get visemeId() {
    return this.privVisemeId;
  }
  /**
   * Specifies the animation.
   * @member SpeechSynthesisVisemeEventArgs.prototype.animation
   * @function
   * @public
   * @returns {string} the animation, could be in svg or other format.
   */
  get animation() {
    return this.privAnimation;
  }
}
exports.SpeechSynthesisVisemeEventArgs = SpeechSynthesisVisemeEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisWordBoundaryEventArgs.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesisWordBoundaryEventArgs.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesisWordBoundaryEventArgs = void 0;
/**
 * Defines contents of speech synthesis word boundary event.
 * @class SpeechSynthesisWordBoundaryEventArgs
 * Added in version 1.11.0
 */
class SpeechSynthesisWordBoundaryEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} duration - The audio duration.
   * @param {string} text - The text.
   * @param {number} wordLength - The length of the word.
   * @param {number} textOffset - The text offset.
   * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
   */
  constructor(audioOffset, duration, text, wordLength, textOffset, boundaryType) {
    this.privAudioOffset = audioOffset;
    this.privDuration = duration;
    this.privText = text;
    this.privWordLength = wordLength;
    this.privTextOffset = textOffset;
    this.privBoundaryType = boundaryType;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the duration, in ticks (100 nanoseconds).
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
   * @function
   * @public
   * @returns {number} Duration in 100 nanosecond increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Specifies the text of the word boundary event.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the text.
   */
  get text() {
    return this.privText;
  }
  /**
   * Specifies the word length
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
   * @function
   * @public
   * @returns {number} the word length
   */
  get wordLength() {
    return this.privWordLength;
  }
  /**
   * Specifies the text offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
   * @function
   * @public
   * @returns {number} the text offset.
   */
  get textOffset() {
    return this.privTextOffset;
  }
  /**
   * Specifies the boundary type.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
   * @function
   * @public
   * @returns {SpeechSynthesisBoundaryType} the boundary type.
   */
  get boundaryType() {
    return this.privBoundaryType;
  }
}
exports.SpeechSynthesisWordBoundaryEventArgs = SpeechSynthesisWordBoundaryEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesizer.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechSynthesizer.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechSynthesizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const AudioFileWriter_js_1 = __webpack_require__(/*! ./Audio/AudioFileWriter.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioFileWriter.js");
const AudioOutputFormat_js_1 = __webpack_require__(/*! ./Audio/AudioOutputFormat.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputFormat.js");
const AudioOutputStream_js_1 = __webpack_require__(/*! ./Audio/AudioOutputStream.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioOutputStream.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Synthesizer_js_1 = __webpack_require__(/*! ./Synthesizer.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Synthesizer.js");
/**
 * Defines the class SpeechSynthesizer for text to speech.
 * Updated in version 1.16.0
 * @class SpeechSynthesizer
 */
class SpeechSynthesizer extends Exports_js_3.Synthesizer {
  /**
   * SpeechSynthesizer constructor.
   * @constructor
   * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
   */
  constructor(speechConfig, audioConfig) {
    super(speechConfig);
    if (audioConfig !== null) {
      if (audioConfig === undefined) {
        this.audioConfig = typeof window === "undefined" ? undefined : Exports_js_3.AudioConfig.fromDefaultSpeakerOutput();
      } else {
        this.audioConfig = audioConfig;
      }
    }
    this.privConnectionFactory = new Exports_js_1.SpeechSynthesisConnectionFactory();
    this.implCommonSynthesizeSetup();
  }
  /**
   * SpeechSynthesizer constructor.
   * @constructor
   * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
   * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
   */
  static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
    const speechConfigImpl = speechConfig;
    autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
    return new SpeechSynthesizer(speechConfig, audioConfig);
  }
  /**
   * Executes speech synthesis on plain text.
   * The task returns the synthesis result.
   * @member SpeechSynthesizer.prototype.speakTextAsync
   * @function
   * @public
   * @param text - Text to be synthesized.
   * @param cb - Callback that received the SpeechSynthesisResult.
   * @param err - Callback invoked in case of an error.
   * @param stream - AudioOutputStream to receive the synthesized audio.
   */
  speakTextAsync(text, cb, err, stream) {
    this.speakImpl(text, false, cb, err, stream);
  }
  /**
   * Executes speech synthesis on SSML.
   * The task returns the synthesis result.
   * @member SpeechSynthesizer.prototype.speakSsmlAsync
   * @function
   * @public
   * @param ssml - SSML to be synthesized.
   * @param cb - Callback that received the SpeechSynthesisResult.
   * @param err - Callback invoked in case of an error.
   * @param stream - AudioOutputStream to receive the synthesized audio.
   */
  speakSsmlAsync(ssml, cb, err, stream) {
    this.speakImpl(ssml, true, cb, err, stream);
  }
  /**
   * Get list of synthesis voices available.
   * The task returns the synthesis voice result.
   * @member SpeechSynthesizer.prototype.getVoicesAsync
   * @function
   * @async
   * @public
   * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
   * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
   */
  async getVoicesAsync(locale = "") {
    return this.getVoices(locale);
  }
  /**
   * Dispose of associated resources.
   * @member SpeechSynthesizer.prototype.close
   * @function
   * @public
   */
  close(cb, err) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, err);
  }
  /**
   * @Internal
   * Do not use externally, object returned will change without warning or notice.
   */
  get internalData() {
    return this.privAdapter;
  }
  //
  // ################################################################################################################
  // IMPLEMENTATION.
  // ################################################################################################################
  //
  // Creates the synthesis adapter
  createSynthesisAdapter(authentication, connectionFactory, synthesizerConfig) {
    return new Exports_js_1.SpeechSynthesisAdapter(authentication, connectionFactory, synthesizerConfig, this, this.audioConfig);
  }
  createRestSynthesisAdapter(authentication, synthesizerConfig) {
    return new Exports_js_1.SynthesisRestAdapter(synthesizerConfig, authentication);
  }
  implCommonSynthesizeSetup() {
    super.implCommonSynthesizeSetup();
    this.privAdapter.audioOutputFormat = AudioOutputFormat_js_1.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(Exports_js_3.SpeechSynthesisOutputFormat[this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)]);
  }
  speakImpl(text, IsSsml, cb, err, dataStream) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privDisposed);
      const requestId = Exports_js_2.createNoDashGuid();
      let audioDestination;
      if (dataStream instanceof Exports_js_3.PushAudioOutputStreamCallback) {
        audioDestination = new AudioOutputStream_js_1.PushAudioOutputStreamImpl(dataStream);
      } else if (dataStream instanceof Exports_js_3.PullAudioOutputStream) {
        audioDestination = dataStream;
      } else if (dataStream !== undefined) {
        audioDestination = new AudioFileWriter_js_1.AudioFileWriter(dataStream);
      } else {
        audioDestination = undefined;
      }
      this.synthesisRequestQueue.enqueue(new Synthesizer_js_1.SynthesisRequest(requestId, text, IsSsml, e => {
        this.privSynthesizing = false;
        if (!!cb) {
          try {
            cb(e);
          } catch (e) {
            if (!!err) {
              err(e);
            }
          }
        }
        cb = undefined;
        /* eslint-disable no-empty */
        this.adapterSpeak().catch(() => {});
      }, e => {
        if (!!err) {
          err(e);
        }
      }, audioDestination));
      /* eslint-disable no-empty-function */
      this.adapterSpeak().catch(() => {});
    } catch (error) {
      if (!!err) {
        if (error instanceof Error) {
          const typedError = error;
          err(typedError.name + ": " + typedError.message);
        } else {
          err(error);
        }
      }
      // Destroy the synthesizer.
      /* eslint-disable no-empty */
      this.dispose(true).catch(() => {});
    }
  }
  async getVoices(locale) {
    const requestId = Exports_js_2.createNoDashGuid();
    const response = await this.privRestAdapter.getVoicesList(requestId);
    if (response.ok && Array.isArray(response.json)) {
      let json = response.json;
      if (!!locale && locale.length > 0) {
        json = json.filter(item => !!item.Locale && item.Locale.toLowerCase() === locale.toLowerCase());
      }
      return new Exports_js_3.SynthesisVoicesResult(requestId, json, undefined);
    } else {
      return new Exports_js_3.SynthesisVoicesResult(requestId, undefined, `Error: ${response.status}: ${response.statusText}`);
    }
  }
}
exports.SpeechSynthesizer = SpeechSynthesizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechTranslationConfig.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SpeechTranslationConfig.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SpeechTranslationConfigImpl = exports.SpeechTranslationConfig = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Speech translation configuration.
 * @class SpeechTranslationConfig
 */
class SpeechTranslationConfig extends Exports_js_2.SpeechConfig {
  /**
   * Creates an instance of recognizer config.
   */
  constructor() {
    super();
  }
  /**
   * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
   * @member SpeechTranslationConfig.fromSubscription
   * @function
   * @public
   * @param {string} subscriptionKey - The subscription key.
   * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {SpeechTranslationConfig} The speech translation config.
   */
  static fromSubscription(subscriptionKey, region) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(subscriptionKey, "subscriptionKey");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const ret = new SpeechTranslationConfigImpl();
    ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
    return ret;
  }
  /**
   * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
   * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
   * expires, the caller needs to refresh it by setting the property authorizationToken with a new
   * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
   * will encounter errors during recognition.
   * As configuration values are copied when creating a new recognizer, the new token value will not apply
   * to recognizers that have already been created.
   * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
   * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
   * @member SpeechTranslationConfig.fromAuthorizationToken
   * @function
   * @public
   * @param {string} authorizationToken - The authorization token.
   * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {SpeechTranslationConfig} The speech translation config.
   */
  static fromAuthorizationToken(authorizationToken, region) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(authorizationToken, "authorizationToken");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(region, "region");
    const ret = new SpeechTranslationConfigImpl();
    ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, authorizationToken);
    ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region, region);
    return ret;
  }
  /**
   * Creates an instance of the speech config with specified host and subscription key.
   * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
   * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
   * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
   * Note: To use an authorization token with fromHost, use fromHost(URL),
   * and then set the AuthorizationToken property on the created SpeechConfig instance.
   * Note: Added in version 1.9.0.
   * @member SpeechConfig.fromHost
   * @function
   * @public
   * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
   * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
   * @returns {SpeechConfig} A speech factory instance.
   */
  static fromHost(hostName, subscriptionKey) {
    Contracts_js_1.Contracts.throwIfNull(hostName, "hostName");
    const speechImpl = new SpeechTranslationConfigImpl();
    speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Host, hostName.protocol + "//" + hostName.hostname + (hostName.port === "" ? "" : ":" + hostName.port));
    if (undefined !== subscriptionKey) {
      speechImpl.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    }
    return speechImpl;
  }
  /**
   * Creates an instance of the speech translation config with specified endpoint and subscription key.
   * This method is intended only for users who use a non-standard service endpoint or paramters.
   * Note: The query properties specified in the endpoint URL are not changed, even if they are
   * set by any other APIs. For example, if language is defined in the uri as query parameter
   * "language=de-DE", and also set by the speechRecognitionLanguage property, the language
   * setting in uri takes precedence, and the effective language is "de-DE".
   * Only the properties that are not specified in the endpoint URL can be set by other APIs.
   * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
   * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
   * use the authorization token.
   * @member SpeechTranslationConfig.fromEndpoint
   * @function
   * @public
   * @param {URL} endpoint - The service endpoint to connect to.
   * @param {string} subscriptionKey - The subscription key.
   * @returns {SpeechTranslationConfig} A speech config instance.
   */
  static fromEndpoint(endpoint, subscriptionKey) {
    Contracts_js_1.Contracts.throwIfNull(endpoint, "endpoint");
    Contracts_js_1.Contracts.throwIfNull(subscriptionKey, "subscriptionKey");
    const ret = new SpeechTranslationConfigImpl();
    ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Endpoint, endpoint.href);
    ret.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Key, subscriptionKey);
    return ret;
  }
}
exports.SpeechTranslationConfig = SpeechTranslationConfig;
/**
 * @private
 * @class SpeechTranslationConfigImpl
 */
class SpeechTranslationConfigImpl extends SpeechTranslationConfig {
  constructor() {
    super();
    this.privSpeechProperties = new Exports_js_2.PropertyCollection();
    this.outputFormat = Exports_js_2.OutputFormat.Simple;
  }
  /**
   * Gets/Sets the authorization token.
   * If this is set, subscription key is ignored.
   * User needs to make sure the provided authorization token is valid and not expired.
   * @member SpeechTranslationConfigImpl.prototype.authorizationToken
   * @function
   * @public
   * @param {string} value - The authorization token.
   */
  set authorizationToken(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "value");
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, value);
  }
  /**
   * Sets the speech recognition language.
   * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @param {string} value - The authorization token.
   */
  set speechRecognitionLanguage(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "value");
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage, value);
  }
  /**
   * Gets the speech recognition language.
   * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @return {string} The speechRecognitionLanguage.
   */
  get speechRecognitionLanguage() {
    return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_RecoLanguage]);
  }
  /**
   * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
   * @function
   * @public
   */
  get subscriptionKey() {
    return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_Key]);
  }
  /**
   * Gets the output format
   * @member SpeechTranslationConfigImpl.prototype.outputFormat
   * @function
   * @public
   */
  get outputFormat() {
    // eslint-disable-next-line
    return Exports_js_2.OutputFormat[this.privSpeechProperties.getProperty(Exports_js_1.OutputFormatPropertyName, undefined)];
  }
  /**
   * Gets/Sets the output format
   * @member SpeechTranslationConfigImpl.prototype.outputFormat
   * @function
   * @public
   */
  set outputFormat(value) {
    this.privSpeechProperties.setProperty(Exports_js_1.OutputFormatPropertyName, Exports_js_2.OutputFormat[value]);
  }
  /**
   * Gets the endpoint id.
   * @member SpeechTranslationConfigImpl.prototype.endpointId
   * @function
   * @public
   */
  get endpointId() {
    return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId);
  }
  /**
   * Gets/Sets the endpoint id.
   * @member SpeechTranslationConfigImpl.prototype.endpointId
   * @function
   * @public
   */
  set endpointId(value) {
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EndpointId, value);
  }
  /**
   * Add a (text) target language to translate into.
   * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
   * @function
   * @public
   * @param {string} value - The language such as de-DE
   */
  addTargetLanguage(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "value");
    const languages = this.targetLanguages;
    if (!languages.includes(value)) {
      languages.push(value);
      this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
    }
  }
  /**
   * Gets the (text) target language to translate into.
   * @member SpeechTranslationConfigImpl.prototype.targetLanguages
   * @function
   * @public
   * @param {string} value - The language such as de-DE
   */
  get targetLanguages() {
    if (this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {
      return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    } else {
      return [];
    }
  }
  /**
   * Gets the voice name.
   * @member SpeechTranslationConfigImpl.prototype.voiceName
   * @function
   * @public
   */
  get voiceName() {
    return this.getProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_TranslationVoice]);
  }
  /**
   * Gets/Sets the voice of the translated language, enable voice synthesis output.
   * @member SpeechTranslationConfigImpl.prototype.voiceName
   * @function
   * @public
   * @param {string} value - The name of the voice.
   */
  set voiceName(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "value");
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_TranslationVoice, value);
  }
  /**
   * Provides the region.
   * @member SpeechTranslationConfigImpl.prototype.region
   * @function
   * @public
   * @returns {string} The region.
   */
  get region() {
    return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_Region);
  }
  setProxy(proxyHostName, proxyPort, proxyUserName, proxyPassword) {
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyHostName], proxyHostName);
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPort], proxyPort);
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyUserName], proxyUserName);
    this.setProperty(Exports_js_2.PropertyId[Exports_js_2.PropertyId.SpeechServiceConnection_ProxyPassword], proxyPassword);
  }
  /**
   * Gets an arbitrary property value.
   * @member SpeechTranslationConfigImpl.prototype.getProperty
   * @function
   * @public
   * @param {string} name - The name of the property.
   * @param {string} def - The default value of the property in case it is not set.
   * @returns {string} The value of the property.
   */
  getProperty(name, def) {
    return this.privSpeechProperties.getProperty(name, def);
  }
  /**
   * Gets/Sets an arbitrary property value.
   * @member SpeechTranslationConfigImpl.prototype.setProperty
   * @function
   * @public
   * @param {string | PropertyId} name - The name of the property to set.
   * @param {string} value - The value of the property.
   */
  setProperty(name, value) {
    this.privSpeechProperties.setProperty(name, value);
  }
  /**
   * Provides access to custom properties.
   * @member SpeechTranslationConfigImpl.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The properties.
   */
  get properties() {
    return this.privSpeechProperties;
  }
  /**
   * Dispose of associated resources.
   * @member SpeechTranslationConfigImpl.prototype.close
   * @function
   * @public
   */
  close() {
    return;
  }
  setServiceProperty(name, value) {
    const currentProperties = JSON.parse(this.privSpeechProperties.getProperty(Exports_js_1.ServicePropertiesPropertyName, "{}"));
    currentProperties[name] = value;
    this.privSpeechProperties.setProperty(Exports_js_1.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
  }
  setProfanity(profanity) {
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_ProfanityOption, Exports_js_2.ProfanityOption[profanity]);
  }
  enableAudioLogging() {
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
  }
  requestWordLevelTimestamps() {
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
  }
  enableDictation() {
    this.privSpeechProperties.setProperty(Exports_js_1.ForceDictationPropertyName, "true");
  }
  get speechSynthesisLanguage() {
    return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage);
  }
  set speechSynthesisLanguage(language) {
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthLanguage, language);
  }
  get speechSynthesisVoiceName() {
    return this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice);
  }
  set speechSynthesisVoiceName(voice) {
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthVoice, voice);
  }
  get speechSynthesisOutputFormat() {
    // eslint-disable-next-line
    return Exports_js_2.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)];
  }
  set speechSynthesisOutputFormat(format) {
    this.privSpeechProperties.setProperty(Exports_js_2.PropertyId.SpeechServiceConnection_SynthOutputFormat, Exports_js_2.SpeechSynthesisOutputFormat[format]);
  }
}
exports.SpeechTranslationConfigImpl = SpeechTranslationConfigImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SynthesisResult.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SynthesisResult.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisResult = void 0;
/**
 * Base class for synthesis results
 * @class SynthesisResult
 * Added in version 1.20.0
 */
class SynthesisResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(resultId, reason, errorDetails, properties) {
    this.privResultId = resultId;
    this.privReason = reason;
    this.privErrorDetails = errorDetails;
    this.privProperties = properties;
  }
  /**
   * Specifies the result identifier.
   * @member SynthesisResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member SynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful synthesis, provides details of the occurred error.
   * @member SynthesisResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The set of properties exposed in the result.
   * @member SynthesisResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
exports.SynthesisResult = SynthesisResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SynthesisVoicesResult.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/SynthesisVoicesResult.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisVoicesResult = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines result of speech synthesis.
 * @class SynthesisVoicesResult
 * Added in version 1.20.0
 */
class SynthesisVoicesResult extends Exports_js_1.SynthesisResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param requestId - result id for request.
   * @param json - json payload from endpoint.
   */
  constructor(requestId, json, errorDetails) {
    if (Array.isArray(json)) {
      super(requestId, Exports_js_1.ResultReason.VoicesListRetrieved, undefined, new Exports_js_1.PropertyCollection());
      this.privVoices = [];
      for (const item of json) {
        this.privVoices.push(new Exports_js_1.VoiceInfo(item));
      }
    } else {
      super(requestId, Exports_js_1.ResultReason.Canceled, errorDetails ? errorDetails : "Error information unavailable", new Exports_js_1.PropertyCollection());
    }
  }
  /**
   * The list of voices
   * @member SynthesisVoicesResult.prototype.voices
   * @function
   * @public
   * @returns {VoiceInfo[]} List of synthesized voices.
   */
  get voices() {
    return this.privVoices;
  }
}
exports.SynthesisVoicesResult = SynthesisVoicesResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Synthesizer.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Synthesizer.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SynthesisRequest = exports.Synthesizer = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class Synthesizer {
  /**
   * Creates and initializes an instance of a Recognizer
   * @constructor
   * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
   */
  constructor(speechConfig) {
    const speechConfigImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
    this.privProperties = speechConfigImpl.properties.clone();
    this.privDisposed = false;
    this.privSynthesizing = false;
    this.synthesisRequestQueue = new Exports_js_2.Queue();
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member Synthesizer.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * @member Synthesizer.prototype.authorizationToken
   * @function
   * @public
   * @param {string} token - Authorization token.
   */
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  /**
   * The collection of properties and their values defined for this Synthesizer.
   * @member Synthesizer.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Indicates if auto detect source language is enabled
   * @member Synthesizer.prototype.autoDetectSourceLanguage
   * @function
   * @public
   * @returns {boolean} if auto detect source language is enabled
   */
  get autoDetectSourceLanguage() {
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === Exports_js_1.AutoDetectSourceLanguagesOpenRangeOptionName;
  }
  buildSsml(text) {
    const languageToDefaultVoice = {
      ["af-ZA"]: "af-ZA-AdriNeural",
      ["am-ET"]: "am-ET-AmehaNeural",
      ["ar-AE"]: "ar-AE-FatimaNeural",
      ["ar-BH"]: "ar-BH-AliNeural",
      ["ar-DZ"]: "ar-DZ-AminaNeural",
      ["ar-EG"]: "ar-EG-SalmaNeural",
      ["ar-IQ"]: "ar-IQ-BasselNeural",
      ["ar-JO"]: "ar-JO-SanaNeural",
      ["ar-KW"]: "ar-KW-FahedNeural",
      ["ar-LY"]: "ar-LY-ImanNeural",
      ["ar-MA"]: "ar-MA-JamalNeural",
      ["ar-QA"]: "ar-QA-AmalNeural",
      ["ar-SA"]: "ar-SA-HamedNeural",
      ["ar-SY"]: "ar-SY-AmanyNeural",
      ["ar-TN"]: "ar-TN-HediNeural",
      ["ar-YE"]: "ar-YE-MaryamNeural",
      ["bg-BG"]: "bg-BG-BorislavNeural",
      ["bn-BD"]: "bn-BD-NabanitaNeural",
      ["bn-IN"]: "bn-IN-BashkarNeural",
      ["ca-ES"]: "ca-ES-JoanaNeural",
      ["cs-CZ"]: "cs-CZ-AntoninNeural",
      ["cy-GB"]: "cy-GB-AledNeural",
      ["da-DK"]: "da-DK-ChristelNeural",
      ["de-AT"]: "de-AT-IngridNeural",
      ["de-CH"]: "de-CH-JanNeural",
      ["de-DE"]: "de-DE-KatjaNeural",
      ["el-GR"]: "el-GR-AthinaNeural",
      ["en-AU"]: "en-AU-NatashaNeural",
      ["en-CA"]: "en-CA-ClaraNeural",
      ["en-GB"]: "en-GB-LibbyNeural",
      ["en-HK"]: "en-HK-SamNeural",
      ["en-IE"]: "en-IE-ConnorNeural",
      ["en-IN"]: "en-IN-NeerjaNeural",
      ["en-KE"]: "en-KE-AsiliaNeural",
      ["en-NG"]: "en-NG-AbeoNeural",
      ["en-NZ"]: "en-NZ-MitchellNeural",
      ["en-PH"]: "en-PH-JamesNeural",
      ["en-SG"]: "en-SG-LunaNeural",
      ["en-TZ"]: "en-TZ-ElimuNeural",
      ["en-US"]: "en-US-AvaMultilingualNeural",
      ["en-ZA"]: "en-ZA-LeahNeural",
      ["es-AR"]: "es-AR-ElenaNeural",
      ["es-BO"]: "es-BO-MarceloNeural",
      ["es-CL"]: "es-CL-CatalinaNeural",
      ["es-CO"]: "es-CO-GonzaloNeural",
      ["es-CR"]: "es-CR-JuanNeural",
      ["es-CU"]: "es-CU-BelkysNeural",
      ["es-DO"]: "es-DO-EmilioNeural",
      ["es-EC"]: "es-EC-AndreaNeural",
      ["es-ES"]: "es-ES-AlvaroNeural",
      ["es-GQ"]: "es-GQ-JavierNeural",
      ["es-GT"]: "es-GT-AndresNeural",
      ["es-HN"]: "es-HN-CarlosNeural",
      ["es-MX"]: "es-MX-DaliaNeural",
      ["es-NI"]: "es-NI-FedericoNeural",
      ["es-PA"]: "es-PA-MargaritaNeural",
      ["es-PE"]: "es-PE-AlexNeural",
      ["es-PR"]: "es-PR-KarinaNeural",
      ["es-PY"]: "es-PY-MarioNeural",
      ["es-SV"]: "es-SV-LorenaNeural",
      ["es-US"]: "es-US-AlonsoNeural",
      ["es-UY"]: "es-UY-MateoNeural",
      ["es-VE"]: "es-VE-PaolaNeural",
      ["et-EE"]: "et-EE-AnuNeural",
      ["fa-IR"]: "fa-IR-DilaraNeural",
      ["fi-FI"]: "fi-FI-SelmaNeural",
      ["fil-PH"]: "fil-PH-AngeloNeural",
      ["fr-BE"]: "fr-BE-CharlineNeural",
      ["fr-CA"]: "fr-CA-SylvieNeural",
      ["fr-CH"]: "fr-CH-ArianeNeural",
      ["fr-FR"]: "fr-FR-DeniseNeural",
      ["ga-IE"]: "ga-IE-ColmNeural",
      ["gl-ES"]: "gl-ES-RoiNeural",
      ["gu-IN"]: "gu-IN-DhwaniNeural",
      ["he-IL"]: "he-IL-AvriNeural",
      ["hi-IN"]: "hi-IN-MadhurNeural",
      ["hr-HR"]: "hr-HR-GabrijelaNeural",
      ["hu-HU"]: "hu-HU-NoemiNeural",
      ["id-ID"]: "id-ID-ArdiNeural",
      ["is-IS"]: "is-IS-GudrunNeural",
      ["it-IT"]: "it-IT-IsabellaNeural",
      ["ja-JP"]: "ja-JP-NanamiNeural",
      ["jv-ID"]: "jv-ID-DimasNeural",
      ["kk-KZ"]: "kk-KZ-AigulNeural",
      ["km-KH"]: "km-KH-PisethNeural",
      ["kn-IN"]: "kn-IN-GaganNeural",
      ["ko-KR"]: "ko-KR-SunHiNeural",
      ["lo-LA"]: "lo-LA-ChanthavongNeural",
      ["lt-LT"]: "lt-LT-LeonasNeural",
      ["lv-LV"]: "lv-LV-EveritaNeural",
      ["mk-MK"]: "mk-MK-AleksandarNeural",
      ["ml-IN"]: "ml-IN-MidhunNeural",
      ["mr-IN"]: "mr-IN-AarohiNeural",
      ["ms-MY"]: "ms-MY-OsmanNeural",
      ["mt-MT"]: "mt-MT-GraceNeural",
      ["my-MM"]: "my-MM-NilarNeural",
      ["nb-NO"]: "nb-NO-PernilleNeural",
      ["nl-BE"]: "nl-BE-ArnaudNeural",
      ["nl-NL"]: "nl-NL-ColetteNeural",
      ["pl-PL"]: "pl-PL-AgnieszkaNeural",
      ["ps-AF"]: "ps-AF-GulNawazNeural",
      ["pt-BR"]: "pt-BR-FranciscaNeural",
      ["pt-PT"]: "pt-PT-DuarteNeural",
      ["ro-RO"]: "ro-RO-AlinaNeural",
      ["ru-RU"]: "ru-RU-SvetlanaNeural",
      ["si-LK"]: "si-LK-SameeraNeural",
      ["sk-SK"]: "sk-SK-LukasNeural",
      ["sl-SI"]: "sl-SI-PetraNeural",
      ["so-SO"]: "so-SO-MuuseNeural",
      ["sr-RS"]: "sr-RS-NicholasNeural",
      ["su-ID"]: "su-ID-JajangNeural",
      ["sv-SE"]: "sv-SE-SofieNeural",
      ["sw-KE"]: "sw-KE-RafikiNeural",
      ["sw-TZ"]: "sw-TZ-DaudiNeural",
      ["ta-IN"]: "ta-IN-PallaviNeural",
      ["ta-LK"]: "ta-LK-KumarNeural",
      ["ta-SG"]: "ta-SG-AnbuNeural",
      ["te-IN"]: "te-IN-MohanNeural",
      ["th-TH"]: "th-TH-PremwadeeNeural",
      ["tr-TR"]: "tr-TR-AhmetNeural",
      ["uk-UA"]: "uk-UA-OstapNeural",
      ["ur-IN"]: "ur-IN-GulNeural",
      ["ur-PK"]: "ur-PK-AsadNeural",
      ["uz-UZ"]: "uz-UZ-MadinaNeural",
      ["vi-VN"]: "vi-VN-HoaiMyNeural",
      ["zh-CN"]: "zh-CN-XiaoxiaoNeural",
      ["zh-HK"]: "zh-HK-HiuMaanNeural",
      ["zh-TW"]: "zh-TW-HsiaoChenNeural",
      ["zu-ZA"]: "zu-ZA-ThandoNeural"
    };
    let language = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US");
    let voice = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_SynthVoice, "");
    let ssml = Synthesizer.XMLEncode(text);
    if (this.autoDetectSourceLanguage) {
      language = "en-US";
    } else {
      voice = voice || languageToDefaultVoice[language];
    }
    if (voice) {
      ssml = `<voice name='${voice}'>${ssml}</voice>`;
    }
    ssml = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${language}'>${ssml}</speak>`;
    return ssml;
  }
  /**
   * This method performs cleanup of resources.
   * The Boolean parameter disposing indicates whether the method is called
   * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
   * Derived classes should override this method to dispose resource if needed.
   * @member Synthesizer.prototype.dispose
   * @function
   * @public
   * @param {boolean} disposing - Flag to request disposal.
   */
  async dispose(disposing) {
    if (this.privDisposed) {
      return;
    }
    if (disposing) {
      if (this.privAdapter) {
        await this.privAdapter.dispose();
      }
    }
    this.privDisposed = true;
  }
  async adapterSpeak() {
    if (!this.privDisposed && !this.privSynthesizing) {
      this.privSynthesizing = true;
      const request = await this.synthesisRequestQueue.dequeue();
      return this.privAdapter.Speak(request.text, request.isSSML, request.requestId, request.cb, request.err, request.dataStream);
    }
  }
  createSynthesizerConfig(speechConfig) {
    return new Exports_js_1.SynthesizerConfig(speechConfig, this.privProperties);
  }
  // Does the generic synthesizer setup that is common across all synthesizer types.
  implCommonSynthesizeSetup() {
    let osPlatform = typeof window !== "undefined" ? "Browser" : "Node";
    let osName = "unknown";
    let osVersion = "unknown";
    if (typeof navigator !== "undefined") {
      osPlatform = osPlatform + "/" + navigator.platform;
      osName = navigator.userAgent;
      osVersion = navigator.appVersion;
    }
    const synthesizerConfig = this.createSynthesizerConfig(new Exports_js_1.SpeechServiceConfig(new Exports_js_1.Context(new Exports_js_1.OS(osPlatform, osName, osVersion))));
    const subscriptionKey = this.privProperties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_Key, undefined);
    const authentication = subscriptionKey && subscriptionKey !== "" ? new Exports_js_1.CognitiveSubscriptionKeyAuthentication(subscriptionKey) : new Exports_js_1.CognitiveTokenAuthentication(() => {
      const authorizationToken = this.privProperties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
      return Promise.resolve(authorizationToken);
    }, () => {
      const authorizationToken = this.privProperties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, undefined);
      return Promise.resolve(authorizationToken);
    });
    this.privAdapter = this.createSynthesisAdapter(authentication, this.privConnectionFactory, synthesizerConfig);
    this.privRestAdapter = this.createRestSynthesisAdapter(authentication, synthesizerConfig);
  }
  static XMLEncode(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
  }
}
exports.Synthesizer = Synthesizer;
class SynthesisRequest {
  constructor(requestId, text, isSSML, cb, err, dataStream) {
    this.requestId = requestId;
    this.text = text;
    this.isSSML = isSSML;
    this.cb = cb;
    this.err = err;
    this.dataStream = dataStream;
  }
}
exports.SynthesisRequest = SynthesisRequest;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Conversation.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Conversation.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationImpl = exports.Conversation = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class Conversation {
  constructor() {
    return;
  }
  /**
   * Create a conversation
   * @param speechConfig
   * @param cb
   * @param err
   */
  static createConversationAsync(speechConfig, arg2, arg3, arg4) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config"));
    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig.region, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region"));
    if (!speechConfig.subscriptionKey && !speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceAuthorization_Token])) {
      Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
    }
    let conversationImpl;
    let cb;
    let err;
    if (typeof arg2 === "string") {
      conversationImpl = new ConversationImpl(speechConfig, arg2);
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      Exports_js_2.marshalPromiseToCallbacks((async () => {})(), arg3, arg4);
    } else {
      conversationImpl = new ConversationImpl(speechConfig);
      cb = arg2;
      err = arg3;
      conversationImpl.createConversationAsync(() => {
        if (!!cb) {
          cb();
        }
      }, error => {
        if (!!err) {
          err(error);
        }
      });
    }
    return conversationImpl;
  }
}
exports.Conversation = Conversation;
class ConversationImpl extends Conversation {
  /**
   * Create a conversation impl
   * @param speechConfig
   * @param {string} id - optional conversationId
   */
  constructor(speechConfig, id) {
    super();
    this.privErrors = Exports_js_1.ConversationConnectionConfig.restErrors;
    /** websocket callbacks */
    /* eslint-disable @typescript-eslint/typedef */
    this.onConnected = e => {
      this.privIsConnected = true;
      try {
        if (!!this.privConversationTranslator?.sessionStarted) {
          this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      }
    };
    this.onDisconnected = e => {
      try {
        if (!!this.privConversationTranslator?.sessionStopped) {
          this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      } finally {
        void this.close(false);
      }
    };
    this.onCanceled = (r, e) => {
      try {
        if (!!this.privConversationTranslator?.canceled) {
          this.privConversationTranslator.canceled(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantUpdateCommandReceived = (r, e) => {
      try {
        const updatedParticipant = this.privParticipants.getParticipant(e.id);
        if (updatedParticipant !== undefined) {
          switch (e.key) {
            case Exports_js_1.ConversationTranslatorCommandTypes.changeNickname:
              updatedParticipant.displayName = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setUseTTS:
              updatedParticipant.isUsingTts = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setProfanityFiltering:
              updatedParticipant.profanity = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setMute:
              updatedParticipant.isMuted = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages:
              updatedParticipant.translateToLanguages = e.value;
              break;
          }
          this.privParticipants.addOrUpdateParticipant(updatedParticipant);
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));
          }
        }
      } catch (e) {
        //
      }
    };
    this.onLockRoomCommandReceived = () => {
      // TODO
    };
    this.onMuteAllCommandReceived = (r, e) => {
      try {
        this.privParticipants.participants.forEach(p => p.isMuted = p.isHost ? false : e.isMuted);
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantJoinCommandReceived = (r, e) => {
      try {
        const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);
        if (newParticipant !== undefined) {
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));
          }
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantLeaveCommandReceived = (r, e) => {
      try {
        const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);
        if (ejectedParticipant !== undefined) {
          // remove the participant from the internal participants list
          this.privParticipants.deleteParticipant(e.participant.id);
          if (!!this.privConversationTranslator) {
            // notify subscribers that the participant has left the conversation
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));
          }
        }
      } catch (e) {
        //
      }
    };
    this.onTranslationReceived = (r, e) => {
      try {
        switch (e.command) {
          case Exports_js_1.ConversationTranslatorMessageTypes.final:
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.transcribed(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
            }
            break;
          case Exports_js_1.ConversationTranslatorMessageTypes.partial:
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.transcribing(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
            }
            break;
          case Exports_js_1.ConversationTranslatorMessageTypes.instantMessage:
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
            }
            break;
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantsListReceived = (r, e) => {
      try {
        // check if the session token needs to be updated
        if (e.sessionToken !== undefined && e.sessionToken !== null) {
          this.privRoom.token = e.sessionToken;
        }
        // save the participants
        this.privParticipants.participants = [...e.participants];
        // enable the conversation
        if (this.privParticipants.me !== undefined) {
          this.privIsReady = true;
        }
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));
        }
        // if this is the host, update the nickname if needed
        if (this.me.isHost) {
          const nickname = this.privConversationTranslator?.properties.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Name);
          if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {
            // issue a change nickname request
            this.changeNicknameAsync(nickname);
          }
        }
      } catch (e) {
        //
      }
    };
    this.onConversationExpiration = (r, e) => {
      try {
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      }
    };
    this.privIsConnected = false;
    this.privIsDisposed = false;
    this.privConversationId = "";
    this.privProperties = new Exports_js_3.PropertyCollection();
    this.privManager = new Exports_js_1.ConversationManager();
    // check the speech language
    const language = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    if (!language) {
      speechConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], Exports_js_1.ConversationConnectionConfig.defaultLanguageCode);
    }
    this.privLanguage = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    if (!id) {
      // check the target language(s)
      if (speechConfig.targetLanguages.length === 0) {
        speechConfig.addTargetLanguage(this.privLanguage);
      }
      // check the profanity setting: speech and conversationTranslator should be in sync
      const profanity = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceResponse_ProfanityOption]);
      if (!profanity) {
        speechConfig.setProfanity(Exports_js_3.ProfanityOption.Masked);
      }
      // check the nickname: it should pass this regex: ^\w+([\s-][\w\(\)]+)*$"
      // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error
      // TODO: check what the max length is and if a truncation is required or if the service handles it without an error
      let hostNickname = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.ConversationTranslator_Name]);
      if (hostNickname === undefined || hostNickname === null) {
        hostNickname = "Host";
      }
      Contracts_js_1.Contracts.throwIfNullOrTooLong(hostNickname, "nickname", 50);
      Contracts_js_1.Contracts.throwIfNullOrTooShort(hostNickname, "nickname", 2);
      speechConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.ConversationTranslator_Name], hostNickname);
    } else {
      this.privConversationId = id;
    }
    // save the speech config for future usage
    this.privConfig = speechConfig;
    // save the config properties
    const configImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(configImpl, "speechConfig");
    this.privProperties = configImpl.properties.clone();
    this.privIsConnected = false;
    this.privParticipants = new Exports_js_1.InternalParticipants();
    this.privIsReady = false;
    this.privTextMessageMaxLength = 1000;
  }
  // get the internal data about a conversation
  get room() {
    return this.privRoom;
  }
  // get the wrapper for connecting to the websockets
  get connection() {
    return this.privConversationRecognizer; // this.privConnection;
  }
  // get the config
  get config() {
    return this.privConfig;
  }
  // get the conversation Id
  get conversationId() {
    return this.privRoom ? this.privRoom.roomId : this.privConversationId;
  }
  // get the properties
  get properties() {
    return this.privProperties;
  }
  // get the speech language
  get speechRecognitionLanguage() {
    return this.privLanguage;
  }
  get isMutedByHost() {
    return this.privParticipants.me?.isHost ? false : this.privParticipants.me?.isMuted;
  }
  get isConnected() {
    return this.privIsConnected && this.privIsReady;
  }
  get participants() {
    return this.toParticipants(true);
  }
  get me() {
    return this.toParticipant(this.privParticipants.me);
  }
  get host() {
    return this.toParticipant(this.privParticipants.host);
  }
  get transcriberRecognizer() {
    return this.privTranscriberRecognizer;
  }
  get conversationInfo() {
    const convId = this.conversationId;
    const p = this.participants.map(part => ({
      id: part.id,
      preferredLanguage: part.preferredLanguage,
      voice: part.voice
    }));
    const props = {};
    for (const key of Exports_js_1.ConversationConnectionConfig.transcriptionEventKeys) {
      const val = this.properties.getProperty(key, "");
      if (val !== "") {
        props[key] = val;
      }
    }
    const info = {
      id: convId,
      participants: p,
      conversationProperties: props
    };
    return info;
  }
  get canSend() {
    return this.privIsConnected && !this.privParticipants.me?.isMuted;
  }
  get canSendAsHost() {
    return this.privIsConnected && this.privParticipants.me?.isHost;
  }
  // get / set the speech auth token
  // eslint-disable-next-line @typescript-eslint/member-ordering
  get authorizationToken() {
    return this.privToken;
  }
  set authorizationToken(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "authorizationToken");
    this.privToken = value;
  }
  set conversationTranslator(conversationTranslator) {
    this.privConversationTranslator = conversationTranslator;
  }
  onToken(token) {
    this.privConversationTranslator.onToken(token);
  }
  /**
   * Create a new conversation as Host
   * @param cb
   * @param err
   */
  createConversationAsync(cb, err) {
    try {
      if (!!this.privConversationRecognizer) {
        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
      }
      this.privManager.createOrJoin(this.privProperties, undefined, room => {
        if (!room) {
          this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);
        }
        this.privRoom = room;
        this.handleCallback(cb, err);
      }, error => {
        this.handleError(error, err);
      });
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Starts a new conversation as host.
   * @param cb
   * @param err
   */
  startConversationAsync(cb, err) {
    try {
      // check if there is already a recognizer
      if (!!this.privConversationRecognizer) {
        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
      }
      // check if there is conversation data available
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);
      // connect to the conversation websocket
      this.privParticipants.meId = this.privRoom.participantId;
      this.privConversationRecognizer = Exports_js_1.ConversationRecognizerFactory.fromConfig(this, this.privConfig);
      // Because ConversationTranslator manually sets up and manages the connection, Conversation
      // has to forward serviceRecognizer connection events that usually get passed automatically
      this.privConversationRecognizer.connected = this.onConnected;
      this.privConversationRecognizer.disconnected = this.onDisconnected;
      this.privConversationRecognizer.canceled = this.onCanceled;
      this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;
      this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;
      this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;
      this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;
      this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;
      this.privConversationRecognizer.translationReceived = this.onTranslationReceived;
      this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;
      this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;
      this.privConversationRecognizer.connect(this.privRoom.token, () => {
        this.handleCallback(cb, err);
      }, error => {
        this.handleError(error, err);
      });
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Join a conversation as a participant.
   * @param { IParticipant } participant - participant to add
   * @param cb
   * @param err
   */
  addParticipantAsync(participant, cb, err) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(participant, "Participant");
    Exports_js_2.marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);
  }
  /**
   * Join a conversation as a participant.
   * @param conversation
   * @param nickname
   * @param lang
   * @param cb
   * @param err
   */
  joinConversationAsync(conversationId, nickname, lang, cb, err) {
    try {
      // TODO
      // if (!!this.privConversationRecognizer) {
      //     throw new Error(this.privErrors.permissionDeniedStart);
      // }
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace("{arg}", "conversationId"));
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace("{arg}", "language"));
      // join the conversation
      this.privManager.createOrJoin(this.privProperties, conversationId, room => {
        Contracts_js_1.Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);
        this.privRoom = room;
        this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;
        // join callback
        if (!!cb) {
          cb(room.cognitiveSpeechAuthToken);
        }
      }, error => {
        this.handleError(error, err);
      });
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Deletes a conversation
   * @param cb
   * @param err
   */
  deleteConversationAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb, err);
  }
  async deleteConversationImplAsync() {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);
    await this.privManager.leave(this.privProperties, this.privRoom.token);
    this.dispose();
  }
  /**
   * Issues a request to close the client websockets
   * @param cb
   * @param err
   */
  endConversationAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.endConversationImplAsync(), cb, err);
  }
  endConversationImplAsync() {
    return this.close(true);
  }
  /**
   * Issues a request to lock the conversation
   * @param cb
   * @param err
   */
  lockConversationAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getLockCommand(true), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to mute the conversation
   * @param cb
   * @param err
   */
  muteAllParticipantsAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      // check the user's permissions
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to mute a participant in the conversation
   * @param userId
   * @param cb
   * @param err
   */
  muteParticipantAsync(userId, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      // check the connection is open (host + participant can perform the mute command)
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      // if not host, check the participant is not muting another participant
      if (!this.me.isHost && this.me.id !== userId) {
        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
      }
      // check the user exists
      const exists = this.privParticipants.getParticipantIndex(userId);
      if (exists === -1) {
        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to remove a participant from the conversation
   * @param userId
   * @param cb
   * @param err
   */
  removeParticipantAsync(userId, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      if (!!this.privTranscriberRecognizer && userId.hasOwnProperty("id")) {
        // Assume this is a transcription participant
        Exports_js_2.marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);
      } else {
        Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), err);
        }
        let participantId = "";
        if (typeof userId === "string") {
          participantId = userId;
        } else if (userId.hasOwnProperty("id")) {
          const participant = userId;
          participantId = participant.id;
        } else if (userId.hasOwnProperty("userId")) {
          const user = userId;
          participantId = user.userId;
        }
        Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
        // check the participant exists
        const index = this.participants.findIndex(p => p.id === participantId);
        if (index === -1) {
          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId), () => {
            this.handleCallback(cb, err);
          }, error => {
            this.handleError(error, err);
          });
        }
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to unlock the conversation
   * @param cb
   * @param err
   */
  unlockConversationAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getLockCommand(false), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to unmute all participants in the conversation
   * @param cb
   * @param err
   */
  unmuteAllParticipantsAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to unmute a participant in the conversation
   * @param userId
   * @param cb
   * @param err
   */
  unmuteParticipantAsync(userId, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      // check the connection is open (host + participant can perform the mute command)
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      // if not host, check the participant is not muting another participant
      if (!this.me.isHost && this.me.id !== userId) {
        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
      }
      // check the user exists
      const exists = this.privParticipants.getParticipantIndex(userId);
      if (exists === -1) {
        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Send a text message
   * @param message
   * @param cb
   * @param err
   */
  sendTextMessageAsync(message, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", "message"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      // TODO: is a max length check required?
      if (message.length > this.privTextMessageMaxLength) {
        this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Set translated to languages
   * @param {string[]} languages - languages to translate to
   * @param cb
   * @param err
   */
  setTranslatedLanguagesAsync(languages, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace("{arg}", "languages"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Change nickname
   * @param {string} nickname - new nickname for the room
   * @param cb
   * @param err
   */
  changeNicknameAsync(nickname, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.privIsDisposed = true;
    if (!!this.config) {
      this.config.close();
    }
    this.privConfig = undefined;
    this.privLanguage = undefined;
    this.privProperties = undefined;
    this.privRoom = undefined;
    this.privToken = undefined;
    this.privManager = undefined;
    this.privIsConnected = false;
    this.privIsReady = false;
    this.privParticipants = undefined;
  }
  async connectTranscriberRecognizer(recognizer) {
    if (!!this.privTranscriberRecognizer) {
      await this.privTranscriberRecognizer.close();
    }
    await recognizer.enforceAudioGating();
    this.privTranscriberRecognizer = recognizer;
    this.privTranscriberRecognizer.conversation = this;
  }
  getKeepAlive() {
    const nickname = !!this.me ? this.me.displayName : "default_nickname";
    return JSON.stringify({
      id: "0",
      nickname,
      participantId: this.privRoom.participantId,
      roomId: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.keepAlive
    });
  }
  /* eslint-enable @typescript-eslint/typedef */
  addParticipantImplAsync(participant) {
    const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);
    if (newParticipant !== undefined) {
      if (!!this.privTranscriberRecognizer) {
        const conversationInfo = this.conversationInfo;
        conversationInfo.participants = [participant];
        return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, "join");
      }
    }
  }
  removeParticipantImplAsync(participant) {
    this.privParticipants.deleteParticipant(participant.id);
    const conversationInfo = this.conversationInfo;
    conversationInfo.participants = [participant];
    return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, "leave");
  }
  async close(dispose) {
    try {
      this.privIsConnected = false;
      await this.privConversationRecognizer?.close();
      this.privConversationRecognizer = undefined;
      if (!!this.privConversationTranslator) {
        this.privConversationTranslator.dispose();
      }
    } catch (e) {
      // ignore error
      throw e;
    }
    if (dispose) {
      this.dispose();
    }
  }
  /** Helpers */
  handleCallback(cb, err) {
    if (!!cb) {
      try {
        cb();
      } catch (e) {
        if (!!err) {
          err(e);
        }
      }
      cb = undefined;
    }
  }
  handleError(error, err) {
    if (!!err) {
      if (error instanceof Error) {
        const typedError = error;
        err(typedError.name + ": " + typedError.message);
      } else {
        err(error);
      }
    }
  }
  /** Participant Helpers */
  toParticipants(includeHost) {
    const participants = this.privParticipants.participants.map(p => this.toParticipant(p));
    if (!includeHost) {
      return participants.filter(p => p.isHost === false);
    } else {
      return participants;
    }
  }
  toParticipant(p) {
    return new Exports_js_3.Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);
  }
  getMuteAllCommand(isMuted) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setMuteAll,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: isMuted
    });
  }
  getMuteCommand(participantId, isMuted) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setMute,
      // eslint-disable-next-line object-shorthand
      participantId: participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: isMuted
    });
  }
  getLockCommand(isLocked) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setLockState,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: isLocked
    });
  }
  getEjectCommand(participantId) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.ejectParticipant,
      // eslint-disable-next-line object-shorthand
      participantId: participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand
    });
  }
  getSetTranslateToLanguagesCommand(languages) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: languages
    });
  }
  getChangeNicknameCommand(nickname) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.changeNickname,
      nickname,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: nickname
    });
  }
  getMessageCommand(message) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, "message");
    return JSON.stringify({
      participantId: this.privRoom.participantId,
      roomId: this.privRoom.roomId,
      text: message,
      type: Exports_js_1.ConversationTranslatorMessageTypes.instantMessage
    });
  }
}
exports.ConversationImpl = ConversationImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationCommon.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationCommon.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationCommon = void 0;
class ConversationCommon {
  constructor(audioConfig) {
    this.privAudioConfig = audioConfig;
  }
  handleCallback(cb, err) {
    if (!!cb) {
      try {
        cb();
      } catch (e) {
        if (!!err) {
          err(e);
        }
      }
      cb = undefined;
    }
  }
  handleError(error, err) {
    if (!!err) {
      if (error instanceof Error) {
        const typedError = error;
        err(typedError.name + ": " + typedError.message);
      } else {
        err(error);
      }
    }
  }
}
exports.ConversationCommon = ConversationCommon;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationExpirationEventArgs.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationExpirationEventArgs.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationExpirationEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class ConversationExpirationEventArgs extends Exports_js_1.SessionEventArgs {
  constructor(expirationTime, sessionId) {
    super(sessionId);
    this.privExpirationTime = expirationTime;
  }
  /** How much longer until the conversation expires (in minutes). */
  get expirationTime() {
    return this.privExpirationTime;
  }
}
exports.ConversationExpirationEventArgs = ConversationExpirationEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationParticipantsChangedEventArgs.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationParticipantsChangedEventArgs.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationParticipantsChangedEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class ConversationParticipantsChangedEventArgs extends Exports_js_1.SessionEventArgs {
  constructor(reason, participants, sessionId) {
    super(sessionId);
    this.privReason = reason;
    this.privParticipant = participants;
  }
  get reason() {
    return this.privReason;
  }
  get participants() {
    return this.privParticipant;
  }
}
exports.ConversationParticipantsChangedEventArgs = ConversationParticipantsChangedEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranscriber.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranscriber.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranscriber = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Performs speech recognition with speaker separation from microphone, file, or other audio input streams, and gets transcribed text as result.
 * @class ConversationTranscriber
 */
class ConversationTranscriber extends Exports_js_3.Recognizer {
  /**
   * ConversationTranscriber constructor.
   * @constructor
   * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
   */
  constructor(speechConfig, audioConfig) {
    const speechConfigImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(speechConfigImpl.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    super(audioConfig, speechConfigImpl.properties, new Exports_js_1.ConversationTranscriberConnectionFactory());
    this.privProperties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
    this.privDisposedRecognizer = false;
  }
  /**
   * ConversationTranscriber constructor.
   * @constructor
   * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
   * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
   */
  static FromConfig(speechConfig, autoDetectSourceLanguageConfig, audioConfig) {
    const speechConfigImpl = speechConfig;
    autoDetectSourceLanguageConfig.properties.mergeTo(speechConfigImpl.properties);
    const recognizer = new ConversationTranscriber(speechConfig, audioConfig);
    return recognizer;
  }
  /**
   * Gets the endpoint id of a customized speech model that is used for transcription.
   * @member ConversationTranscriber.prototype.endpointId
   * @function
   * @public
   * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
   */
  get endpointId() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member ConversationTranscriber.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * @member ConversationTranscriber.prototype.authorizationToken
   * @function
   * @public
   * @param {string} token - Authorization token.
   */
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  /**
   * Gets the spoken language of transcription.
   * @member ConversationTranscriber.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @returns {string} The spoken language of transcription.
   */
  get speechRecognitionLanguage() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
  }
  /**
   * Gets the output format of transcription.
   * @member ConversationTranscriber.prototype.outputFormat
   * @function
   * @public
   * @returns {OutputFormat} The output format of transcription.
   */
  get outputFormat() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    if (this.properties.getProperty(Exports_js_1.OutputFormatPropertyName, Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) === Exports_js_3.OutputFormat[Exports_js_3.OutputFormat.Simple]) {
      return Exports_js_3.OutputFormat.Simple;
    } else {
      return Exports_js_3.OutputFormat.Detailed;
    }
  }
  /**
   * The collection of properties and their values defined for this conversation transcriber.
   * @member ConversationTranscriber.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Starts conversation transcription, until stopTranscribingAsync() is called.
   * User must subscribe to events to receive transcription results.
   * @member ConversationTranscriber.prototype.startTranscribingAsync
   * @function
   * @public
   * @param cb - Callback invoked once the transcription has started.
   * @param err - Callback invoked in case of an error.
   */
  startTranscribingAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_1.RecognitionMode.Conversation), cb, err);
  }
  /**
   * Stops conversation transcription.
   * @member ConversationTranscriber.prototype.stopTranscribingAsync
   * @function
   * @public
   * @param cb - Callback invoked once the transcription has stopped.
   * @param err - Callback invoked in case of an error.
   */
  stopTranscribingAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
  }
  /**
   * closes all external resources held by an instance of this class.
   * @member ConversationTranscriber.prototype.close
   * @function
   * @public
   */
  close(cb, errorCb) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
  }
  /**
   * Disposes any resources held by the object.
   * @member SpeechRecognizer.prototype.dispose
   * @function
   * @public
   * @param {boolean} disposing - true if disposing the object.
   */
  async dispose(disposing) {
    if (this.privDisposedRecognizer) {
      return;
    }
    if (disposing) {
      this.privDisposedRecognizer = true;
      await this.implRecognizerStop();
    }
    await super.dispose(disposing);
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const configImpl = audioConfig;
    recognizerConfig.isSpeakerDiarizationEnabled = true;
    return new Exports_js_1.ConversationTranscriptionServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
  }
}
exports.ConversationTranscriber = ConversationTranscriber;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranscriptionResult.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranscriptionResult.js ***!
  \**********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranscriptionResult = void 0;
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines result of conversation transcription.
 * @class ConversationTranscriptionResult
 */
class ConversationTranscriptionResult extends Exports_js_1.RecognitionResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @public
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} text - The recognized text.
   * @param {number} duration - The duration.
   * @param {number} offset - The offset into the stream.
   * @param {string} language - Primary Language detected, if provided.
   * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param {string} speakerId - speaker id for conversation transcription.
   * @param {string} errorDetails - Error details, if provided.
   * @param {string} json - Additional Json, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(resultId, reason, text, duration, offset, language, languageDetectionConfidence, speakerId, errorDetails, json, properties) {
    super(resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties);
    this.privSpeakerId = speakerId;
  }
  /**
   * speaker id
   * @member ConversationTranscriptionResult.prototype.speakerId
   * @function
   * @public
   * @returns {string} id of speaker in given result
   */
  get speakerId() {
    return this.privSpeakerId;
  }
}
exports.ConversationTranscriptionResult = ConversationTranscriptionResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationCanceledEventArgs.js":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationCanceledEventArgs.js ***!
  \*******************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranslationCanceledEventArgs = void 0;
const CancellationEventArgsBase_js_1 = __webpack_require__(/*! ../CancellationEventArgsBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationEventArgsBase.js");
class ConversationTranslationCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {}
exports.ConversationTranslationCanceledEventArgs = ConversationTranslationCanceledEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationEventArgs.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationEventArgs.js ***!
  \***********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranslationEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class ConversationTranslationEventArgs extends Exports_js_1.RecognitionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {ConversationTranslationResult} result - The translation recognition result.
   * @param {number} offset - The offset.
   * @param {string} sessionId - The session id.
   */
  constructor(result, offset, sessionId) {
    super(offset, sessionId);
    this.privResult = result;
  }
  /**
   * Specifies the recognition result.
   * @returns {ConversationTranslationResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
}
exports.ConversationTranslationEventArgs = ConversationTranslationEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationResult.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationResult.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranslationResult = void 0;
const TranslationRecognitionResult_js_1 = __webpack_require__(/*! ../TranslationRecognitionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionResult.js");
class ConversationTranslationResult extends TranslationRecognitionResult_js_1.TranslationRecognitionResult {
  constructor(participantId, translations, originalLanguage, resultId, reason, text, duration, offset, errorDetails, json, properties) {
    super(translations, resultId, reason, text, duration, offset, undefined, undefined, errorDetails, json, properties);
    this.privId = participantId;
    this.privOrigLang = originalLanguage;
  }
  /**
   * The unique identifier for the participant this result is for.
   */
  get participantId() {
    return this.privId;
  }
  /**
   * The original language this result was in.
   */
  get originalLang() {
    return this.privOrigLang;
  }
}
exports.ConversationTranslationResult = ConversationTranslationResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslator.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslator.js ***!
  \*************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConversationTranslator = exports.SpeechState = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const ConversationTranslatorConnectionFactory_js_1 = __webpack_require__(/*! ../../common.speech/Transcription/ConversationTranslatorConnectionFactory.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Transcription/ConversationTranslatorConnectionFactory.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Conversation_js_1 = __webpack_require__(/*! ./Conversation.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Conversation.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Exports.js");
var SpeechState;
(function (SpeechState) {
  SpeechState[SpeechState["Inactive"] = 0] = "Inactive";
  SpeechState[SpeechState["Connecting"] = 1] = "Connecting";
  SpeechState[SpeechState["Connected"] = 2] = "Connected";
})(SpeechState = exports.SpeechState || (exports.SpeechState = {}));
// child class of TranslationRecognizer meant only for use with ConversationTranslator
class ConversationTranslationRecognizer extends Exports_js_3.TranslationRecognizer {
  constructor(speechConfig, audioConfig, translator, convGetter) {
    super(speechConfig, audioConfig, new ConversationTranslatorConnectionFactory_js_1.ConversationTranslatorConnectionFactory(convGetter));
    this.privSpeechState = SpeechState.Inactive;
    if (!!translator) {
      this.privTranslator = translator;
      this.sessionStarted = () => {
        this.privSpeechState = SpeechState.Connected;
      };
      this.sessionStopped = () => {
        this.privSpeechState = SpeechState.Inactive;
      };
      this.recognizing = (tr, e) => {
        if (!!this.privTranslator.recognizing) {
          this.privTranslator.recognizing(this.privTranslator, e);
        }
      };
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      this.recognized = async (tr, e) => {
        // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.
        if (e.result?.errorDetails) {
          await this.cancelSpeech();
          // TODO: format the error message contained in 'errorDetails'
          this.fireCancelEvent(e.result.errorDetails);
        } else {
          if (!!this.privTranslator.recognized) {
            this.privTranslator.recognized(this.privTranslator, e);
          }
        }
        return;
      };
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      this.canceled = async () => {
        if (this.privSpeechState !== SpeechState.Inactive) {
          try {
            await this.cancelSpeech();
          } catch (error) {
            this.privSpeechState = SpeechState.Inactive;
          }
        }
      };
    }
  }
  get state() {
    return this.privSpeechState;
  }
  set state(newState) {
    this.privSpeechState = newState;
  }
  set authentication(token) {
    this.privReco.authentication = token;
  }
  onConnection() {
    this.privSpeechState = SpeechState.Connected;
  }
  async onCancelSpeech() {
    this.privSpeechState = SpeechState.Inactive;
    await this.cancelSpeech();
  }
  /**
   * Fire a cancel event
   * @param error
   */
  fireCancelEvent(error) {
    try {
      if (!!this.privTranslator.canceled) {
        const cancelEvent = new Exports_js_4.ConversationTranslationCanceledEventArgs(Exports_js_3.CancellationReason.Error, error, Exports_js_3.CancellationErrorCode.RuntimeError);
        this.privTranslator.canceled(this.privTranslator, cancelEvent);
      }
    } catch (e) {
      //
    }
  }
  async cancelSpeech() {
    try {
      this.stopContinuousRecognitionAsync();
      await this.privReco?.disconnect();
      this.privSpeechState = SpeechState.Inactive;
    } catch (e) {
      // ignore the error
    }
  }
}
/**
 * Join, leave or connect to a conversation.
 */
class ConversationTranslator extends Exports_js_4.ConversationCommon {
  constructor(audioConfig) {
    super(audioConfig);
    this.privErrors = Exports_js_1.ConversationConnectionConfig.restErrors;
    this.privIsDisposed = false;
    this.privIsSpeaking = false;
    this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345";
    this.privPlaceholderRegion = "westus";
    this.privProperties = new Exports_js_3.PropertyCollection();
  }
  get properties() {
    return this.privProperties;
  }
  get speechRecognitionLanguage() {
    return this.privSpeechRecognitionLanguage;
  }
  get participants() {
    return this.privConversation?.participants;
  }
  get canSpeak() {
    // is there a Conversation websocket available and has the Recognizer been set up
    if (!this.privConversation.isConnected || !this.privCTRecognizer) {
      return false;
    }
    // is the user already speaking
    if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {
      return false;
    }
    // is the user muted
    if (this.privConversation.isMutedByHost) {
      return false;
    }
    return true;
  }
  onToken(token) {
    this.privCTRecognizer.authentication = token;
  }
  setServiceProperty(name, value) {
    const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_1.ServicePropertiesPropertyName, "{}"));
    currentProperties[name] = value;
    this.privProperties.setProperty(Exports_js_1.ServicePropertiesPropertyName, JSON.stringify(currentProperties));
  }
  joinConversationAsync(conversation, nickname, param1, param2, param3) {
    try {
      if (typeof conversation === "string") {
        Contracts_js_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace("{arg}", "conversation id"));
        Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
        if (!!this.privConversation) {
          this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);
        }
        let lang = param1;
        if (lang === undefined || lang === null || lang === "") {
          lang = Exports_js_1.ConversationConnectionConfig.defaultLanguageCode;
        }
        // create a placeholder config
        this.privSpeechTranslationConfig = Exports_js_3.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);
        this.privSpeechTranslationConfig.setProfanity(Exports_js_3.ProfanityOption.Masked);
        this.privSpeechTranslationConfig.addTargetLanguage(lang);
        this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], lang);
        this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.ConversationTranslator_Name], nickname);
        const propertyIdsToCopy = [Exports_js_3.PropertyId.SpeechServiceConnection_Host, Exports_js_3.PropertyId.ConversationTranslator_Host, Exports_js_3.PropertyId.SpeechServiceConnection_Endpoint, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyHostName, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyPassword, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyPort, Exports_js_3.PropertyId.SpeechServiceConnection_ProxyUserName, "ConversationTranslator_MultiChannelAudio", "ConversationTranslator_Region"];
        for (const prop of propertyIdsToCopy) {
          const value = this.privProperties.getProperty(prop);
          if (value) {
            const key = typeof prop === "string" ? prop : Exports_js_3.PropertyId[prop];
            this.privSpeechTranslationConfig.setProperty(key, value);
          }
        }
        const currentProperties = JSON.parse(this.privProperties.getProperty(Exports_js_1.ServicePropertiesPropertyName, "{}"));
        for (const prop of Object.keys(currentProperties)) {
          this.privSpeechTranslationConfig.setServiceProperty(prop, currentProperties[prop], Exports_js_3.ServicePropertyChannel.UriQueryParameter);
        }
        // join the conversation
        this.privConversation = new Conversation_js_1.ConversationImpl(this.privSpeechTranslationConfig);
        this.privConversation.conversationTranslator = this;
        this.privConversation.joinConversationAsync(conversation, nickname, lang, result => {
          if (!result) {
            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);
          }
          this.privSpeechTranslationConfig.authorizationToken = result;
          this.privConversation.room.isHost = false;
          // connect to the ws
          this.privConversation.startConversationAsync(() => {
            this.handleCallback(param2, param3);
          }, error => {
            this.handleError(error, param3);
          });
        }, error => {
          this.handleError(error, param3);
        });
      } else if (typeof conversation === "object") {
        Contracts_js_1.Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace("{arg}", "conversation id"));
        Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
        // save the nickname
        this.privProperties.setProperty(Exports_js_3.PropertyId.ConversationTranslator_Name, nickname);
        // ref the conversation object
        this.privConversation = conversation;
        // ref the conversation translator object
        this.privConversation.conversationTranslator = this;
        this.privConversation.room.isHost = true;
        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);
        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);
        this.privSpeechTranslationConfig = conversation.config;
        this.handleCallback(param1, param2);
      } else {
        this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), param2);
      }
    } catch (error) {
      this.handleError(error, typeof param1 === "string" ? param3 : param2);
    }
  }
  /**
   * Leave the conversation
   * @param cb
   * @param err
   */
  leaveConversationAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks((async () => {
      // stop the speech websocket
      await this.cancelSpeech();
      // stop the websocket
      await this.privConversation.endConversationImplAsync();
      // https delete request
      await this.privConversation.deleteConversationImplAsync();
      this.dispose();
    })(), cb, err);
  }
  /**
   * Send a text message
   * @param message
   * @param cb
   * @param err
   */
  sendTextMessageAsync(message, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", message));
      this.privConversation.sendTextMessageAsync(message, cb, err);
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Start speaking
   * @param cb
   * @param err
   */
  startTranscribingAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks((async () => {
      try {
        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);
        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);
        if (this.privCTRecognizer === undefined) {
          await this.connectTranslatorRecognizer();
        }
        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);
        if (!this.canSpeak) {
          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
        }
        await this.startContinuousRecognition();
        this.privIsSpeaking = true;
      } catch (error) {
        this.privIsSpeaking = false;
        await this.cancelSpeech();
        throw error;
      }
    })(), cb, err);
  }
  /**
   * Stop speaking
   * @param cb
   * @param err
   */
  stopTranscribingAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks((async () => {
      try {
        if (!this.privIsSpeaking) {
          // stop speech
          await this.cancelSpeech();
          return;
        }
        // stop the recognition but leave the websocket open
        this.privIsSpeaking = false;
        await new Promise((resolve, reject) => {
          this.privCTRecognizer.stopContinuousRecognitionAsync(resolve, reject);
        });
      } catch (error) {
        await this.cancelSpeech();
      }
    })(), cb, err);
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  dispose(reason, success, err) {
    Exports_js_2.marshalPromiseToCallbacks((async () => {
      if (this.isDisposed && !this.privIsSpeaking) {
        return;
      }
      await this.cancelSpeech();
      this.privIsDisposed = true;
      this.privSpeechTranslationConfig.close();
      this.privSpeechRecognitionLanguage = undefined;
      this.privProperties = undefined;
      this.privAudioConfig = undefined;
      this.privSpeechTranslationConfig = undefined;
      this.privConversation.dispose();
      this.privConversation = undefined;
    })(), success, err);
  }
  /**
   * Cancel the speech websocket
   */
  async cancelSpeech() {
    try {
      this.privIsSpeaking = false;
      await this.privCTRecognizer?.onCancelSpeech();
      this.privCTRecognizer = undefined;
    } catch (e) {
      // ignore the error
    }
  }
  /**
   * Connect to the speech translation recognizer.
   * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
   * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
   * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
   */
  async connectTranslatorRecognizer() {
    try {
      if (this.privAudioConfig === undefined) {
        this.privAudioConfig = Exports_js_3.AudioConfig.fromDefaultMicrophoneInput();
      }
      // clear the temp subscription key if it's a participant joining
      if (this.privSpeechTranslationConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {
        this.privSpeechTranslationConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_Key], "");
      }
      const convGetter = () => this.privConversation;
      this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this, convGetter);
    } catch (error) {
      await this.cancelSpeech();
      throw error;
    }
  }
  /**
   * Handle the start speaking request
   */
  startContinuousRecognition() {
    return new Promise((resolve, reject) => {
      this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);
    });
  }
}
exports.ConversationTranslator = ConversationTranslator;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Exports.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Exports.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var Conversation_js_1 = __webpack_require__(/*! ./Conversation.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Conversation.js");
Object.defineProperty(exports, "Conversation", ({
  enumerable: true,
  get: function () {
    return Conversation_js_1.Conversation;
  }
}));
Object.defineProperty(exports, "ConversationImpl", ({
  enumerable: true,
  get: function () {
    return Conversation_js_1.ConversationImpl;
  }
}));
var ConversationCommon_js_1 = __webpack_require__(/*! ./ConversationCommon.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationCommon.js");
Object.defineProperty(exports, "ConversationCommon", ({
  enumerable: true,
  get: function () {
    return ConversationCommon_js_1.ConversationCommon;
  }
}));
var ConversationExpirationEventArgs_js_1 = __webpack_require__(/*! ./ConversationExpirationEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationExpirationEventArgs.js");
Object.defineProperty(exports, "ConversationExpirationEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationExpirationEventArgs_js_1.ConversationExpirationEventArgs;
  }
}));
var ConversationParticipantsChangedEventArgs_js_1 = __webpack_require__(/*! ./ConversationParticipantsChangedEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationParticipantsChangedEventArgs.js");
Object.defineProperty(exports, "ConversationParticipantsChangedEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationParticipantsChangedEventArgs_js_1.ConversationParticipantsChangedEventArgs;
  }
}));
var ConversationTranslationCanceledEventArgs_js_1 = __webpack_require__(/*! ./ConversationTranslationCanceledEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationCanceledEventArgs.js");
Object.defineProperty(exports, "ConversationTranslationCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslationCanceledEventArgs_js_1.ConversationTranslationCanceledEventArgs;
  }
}));
var ConversationTranslationEventArgs_js_1 = __webpack_require__(/*! ./ConversationTranslationEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationEventArgs.js");
Object.defineProperty(exports, "ConversationTranslationEventArgs", ({
  enumerable: true,
  get: function () {
    return ConversationTranslationEventArgs_js_1.ConversationTranslationEventArgs;
  }
}));
var ConversationTranslationResult_js_1 = __webpack_require__(/*! ./ConversationTranslationResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslationResult.js");
Object.defineProperty(exports, "ConversationTranslationResult", ({
  enumerable: true,
  get: function () {
    return ConversationTranslationResult_js_1.ConversationTranslationResult;
  }
}));
var ConversationTranslator_js_1 = __webpack_require__(/*! ./ConversationTranslator.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranslator.js");
Object.defineProperty(exports, "ConversationTranslator", ({
  enumerable: true,
  get: function () {
    return ConversationTranslator_js_1.ConversationTranslator;
  }
}));
var ConversationTranscriber_js_1 = __webpack_require__(/*! ./ConversationTranscriber.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranscriber.js");
Object.defineProperty(exports, "ConversationTranscriber", ({
  enumerable: true,
  get: function () {
    return ConversationTranscriber_js_1.ConversationTranscriber;
  }
}));
var IParticipant_js_1 = __webpack_require__(/*! ./IParticipant.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/IParticipant.js");
Object.defineProperty(exports, "Participant", ({
  enumerable: true,
  get: function () {
    return IParticipant_js_1.Participant;
  }
}));
Object.defineProperty(exports, "User", ({
  enumerable: true,
  get: function () {
    return IParticipant_js_1.User;
  }
}));
var ParticipantChangedReason_js_1 = __webpack_require__(/*! ./ParticipantChangedReason.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ParticipantChangedReason.js");
Object.defineProperty(exports, "ParticipantChangedReason", ({
  enumerable: true,
  get: function () {
    return ParticipantChangedReason_js_1.ParticipantChangedReason;
  }
}));
var Meeting_js_1 = __webpack_require__(/*! ./Meeting.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Meeting.js");
Object.defineProperty(exports, "Meeting", ({
  enumerable: true,
  get: function () {
    return Meeting_js_1.Meeting;
  }
}));
Object.defineProperty(exports, "MeetingImpl", ({
  enumerable: true,
  get: function () {
    return Meeting_js_1.MeetingImpl;
  }
}));
var MeetingTranscriptionCanceledEventArgs_js_1 = __webpack_require__(/*! ./MeetingTranscriptionCanceledEventArgs.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/MeetingTranscriptionCanceledEventArgs.js");
Object.defineProperty(exports, "MeetingTranscriptionCanceledEventArgs", ({
  enumerable: true,
  get: function () {
    return MeetingTranscriptionCanceledEventArgs_js_1.MeetingTranscriptionCanceledEventArgs;
  }
}));
var MeetingTranscriber_js_1 = __webpack_require__(/*! ./MeetingTranscriber.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/MeetingTranscriber.js");
Object.defineProperty(exports, "MeetingTranscriber", ({
  enumerable: true,
  get: function () {
    return MeetingTranscriber_js_1.MeetingTranscriber;
  }
}));
var ConversationTranscriptionResult_js_1 = __webpack_require__(/*! ./ConversationTranscriptionResult.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ConversationTranscriptionResult.js");
Object.defineProperty(exports, "ConversationTranscriptionResult", ({
  enumerable: true,
  get: function () {
    return ConversationTranscriptionResult_js_1.ConversationTranscriptionResult;
  }
}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/IParticipant.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/IParticipant.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Participant = exports.User = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class User {
  constructor(userId) {
    this.privUserId = userId;
  }
  get userId() {
    return this.privUserId;
  }
}
exports.User = User;
class Participant {
  constructor(id, avatar, displayName, isHost, isMuted, isUsingTts, preferredLanguage, voice) {
    this.privId = id;
    this.privAvatar = avatar;
    this.privDisplayName = displayName;
    this.privIsHost = isHost;
    this.privIsMuted = isMuted;
    this.privIsUsingTts = isUsingTts;
    this.privPreferredLanguage = preferredLanguage;
    this.privVoice = voice;
    this.privProperties = new Exports_js_1.PropertyCollection();
  }
  get avatar() {
    return this.privAvatar;
  }
  get displayName() {
    return this.privDisplayName;
  }
  get id() {
    return this.privId;
  }
  get preferredLanguage() {
    return this.privPreferredLanguage;
  }
  get isHost() {
    return this.privIsHost;
  }
  get isMuted() {
    return this.privIsMuted;
  }
  get isUsingTts() {
    return this.privIsUsingTts;
  }
  get voice() {
    return this.privVoice;
  }
  get properties() {
    return this.privProperties;
  }
  static From(id, language, voice) {
    return new Participant(id, "", id, false, false, false, language, voice);
  }
}
exports.Participant = Participant;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Meeting.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Meeting.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MeetingImpl = exports.Meeting = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
class Meeting {
  constructor() {
    return;
  }
  /**
   * Create a meeting
   * @param speechConfig
   * @param meetingId
   * @param cb
   * @param err
   */
  static createMeetingAsync(speechConfig, meetingId, arg3, arg4) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config"));
    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig.region, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region"));
    Contracts_js_1.Contracts.throwIfNull(meetingId, "meetingId");
    if (meetingId.length === 0) {
      throw new Error("meetingId cannot be empty");
    }
    if (!speechConfig.subscriptionKey && !speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceAuthorization_Token])) {
      Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, Exports_js_1.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
    }
    const meetingImpl = new MeetingImpl(speechConfig, meetingId);
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    Exports_js_2.marshalPromiseToCallbacks((async () => {})(), arg3, arg4);
    return meetingImpl;
  }
}
exports.Meeting = Meeting;
class MeetingImpl extends Meeting {
  /**
   * Create a Meeting impl
   * @param speechConfig
   * @param {string} id - optional conversationId
   */
  constructor(speechConfig, id) {
    super();
    this.privErrors = Exports_js_1.ConversationConnectionConfig.restErrors;
    /** websocket callbacks */
    /* eslint-disable @typescript-eslint/typedef */
    this.onConnected = e => {
      this.privIsConnected = true;
      try {
        if (!!this.privConversationTranslator?.sessionStarted) {
          this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      }
    };
    this.onDisconnected = e => {
      try {
        if (!!this.privConversationTranslator?.sessionStopped) {
          this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      } finally {
        void this.close(false);
      }
    };
    this.onCanceled = (r, e) => {
      try {
        if (!!this.privConversationTranslator?.canceled) {
          this.privConversationTranslator.canceled(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantUpdateCommandReceived = (r, e) => {
      try {
        const updatedParticipant = this.privParticipants.getParticipant(e.id);
        if (updatedParticipant !== undefined) {
          switch (e.key) {
            case Exports_js_1.ConversationTranslatorCommandTypes.changeNickname:
              updatedParticipant.displayName = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setUseTTS:
              updatedParticipant.isUsingTts = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setProfanityFiltering:
              updatedParticipant.profanity = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setMute:
              updatedParticipant.isMuted = e.value;
              break;
            case Exports_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages:
              updatedParticipant.translateToLanguages = e.value;
              break;
          }
          this.privParticipants.addOrUpdateParticipant(updatedParticipant);
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));
          }
        }
      } catch (e) {
        //
      }
    };
    this.onLockRoomCommandReceived = () => {
      // TODO
    };
    this.onMuteAllCommandReceived = (r, e) => {
      try {
        this.privParticipants.participants.forEach(p => p.isMuted = p.isHost ? false : e.isMuted);
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantJoinCommandReceived = (r, e) => {
      try {
        const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);
        if (newParticipant !== undefined) {
          if (!!this.privConversationTranslator) {
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));
          }
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantLeaveCommandReceived = (r, e) => {
      try {
        const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);
        if (ejectedParticipant !== undefined) {
          // remove the participant from the internal participants list
          this.privParticipants.deleteParticipant(e.participant.id);
          if (!!this.privConversationTranslator) {
            // notify subscribers that the participant has left the conversation
            this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));
          }
        }
      } catch (e) {
        //
      }
    };
    this.onTranslationReceived = (r, e) => {
      try {
        switch (e.command) {
          case Exports_js_1.ConversationTranslatorMessageTypes.final:
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.transcribed(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
            }
            break;
          case Exports_js_1.ConversationTranslatorMessageTypes.partial:
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.transcribing(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
            }
            break;
          case Exports_js_1.ConversationTranslatorMessageTypes.instantMessage:
            if (!!this.privConversationTranslator) {
              this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new Exports_js_3.ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));
            }
            break;
        }
      } catch (e) {
        //
      }
    };
    this.onParticipantsListReceived = (r, e) => {
      try {
        // check if the session token needs to be updated
        if (e.sessionToken !== undefined && e.sessionToken !== null) {
          this.privRoom.token = e.sessionToken;
        }
        // save the participants
        this.privParticipants.participants = [...e.participants];
        // enable the conversation
        if (this.privParticipants.me !== undefined) {
          this.privIsReady = true;
        }
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new Exports_js_3.ConversationParticipantsChangedEventArgs(Exports_js_3.ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));
        }
        // if this is the host, update the nickname if needed
        if (this.me.isHost) {
          const nickname = this.privConversationTranslator?.properties.getProperty(Exports_js_3.PropertyId.ConversationTranslator_Name);
          if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {
            // issue a change nickname request
            this.changeNicknameAsync(nickname);
          }
        }
      } catch (e) {
        //
      }
    };
    this.onConversationExpiration = (r, e) => {
      try {
        if (!!this.privConversationTranslator) {
          this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, e);
        }
      } catch (e) {
        //
      }
    };
    this.privIsConnected = false;
    this.privIsDisposed = false;
    this.privConversationId = "";
    this.privProperties = new Exports_js_3.PropertyCollection();
    this.privManager = new Exports_js_1.ConversationManager();
    // check the speech language
    const language = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    if (!language) {
      speechConfig.setProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage], Exports_js_1.ConversationConnectionConfig.defaultLanguageCode);
    }
    this.privLanguage = speechConfig.getProperty(Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
    this.privConversationId = id;
    // save the speech config for future usage
    this.privConfig = speechConfig;
    // save the config properties
    const configImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(configImpl, "speechConfig");
    this.privProperties = configImpl.properties.clone();
    this.privIsConnected = false;
    this.privParticipants = new Exports_js_1.InternalParticipants();
    this.privIsReady = false;
    this.privTextMessageMaxLength = 1000;
  }
  // get the internal data about a conversation
  get room() {
    return this.privRoom;
  }
  // get the wrapper for connecting to the websockets
  get connection() {
    return this.privConversationRecognizer; // this.privConnection;
  }
  // get the config
  get config() {
    return this.privConfig;
  }
  // get the meeting Id
  get meetingId() {
    return this.privRoom ? this.privRoom.roomId : this.privConversationId;
  }
  // get the properties
  get properties() {
    return this.privProperties;
  }
  // get the speech language
  get speechRecognitionLanguage() {
    return this.privLanguage;
  }
  get isMutedByHost() {
    return this.privParticipants.me?.isHost ? false : this.privParticipants.me?.isMuted;
  }
  get isConnected() {
    return this.privIsConnected && this.privIsReady;
  }
  get participants() {
    return this.toParticipants(true);
  }
  get me() {
    return this.toParticipant(this.privParticipants.me);
  }
  get host() {
    return this.toParticipant(this.privParticipants.host);
  }
  get transcriberRecognizer() {
    return this.privTranscriberRecognizer;
  }
  get meetingInfo() {
    const convId = this.meetingId;
    const p = this.participants.map(part => ({
      id: part.id,
      preferredLanguage: part.preferredLanguage,
      voice: part.voice
    }));
    const props = {};
    for (const key of Exports_js_1.ConversationConnectionConfig.transcriptionEventKeys) {
      const val = this.properties.getProperty(key, "");
      if (val !== "") {
        props[key] = val;
      }
    }
    const info = {
      id: convId,
      participants: p,
      meetingProperties: props
    };
    return info;
  }
  get canSend() {
    return this.privIsConnected && !this.privParticipants.me?.isMuted;
  }
  get canSendAsHost() {
    return this.privIsConnected && this.privParticipants.me?.isHost;
  }
  // get / set the speech auth token
  // eslint-disable-next-line @typescript-eslint/member-ordering
  get authorizationToken() {
    return this.privToken;
  }
  set authorizationToken(value) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(value, "authorizationToken");
    this.privToken = value;
  }
  /**
   * Create a new meeting as Host
   * @param cb
   * @param err
   */
  createMeetingAsync(cb, err) {
    try {
      if (!!this.privConversationRecognizer) {
        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
      }
      this.privManager.createOrJoin(this.privProperties, undefined, room => {
        if (!room) {
          this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);
        }
        this.privRoom = room;
        this.handleCallback(cb, err);
      }, error => {
        this.handleError(error, err);
      });
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Starts a new meeting as host.
   * @param cb
   * @param err
   */
  startMeetingAsync(cb, err) {
    try {
      // check if there is already a recognizer
      if (!!this.privConversationRecognizer) {
        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);
      }
      // check if there is conversation data available
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);
      // connect to the conversation websocket
      this.privParticipants.meId = this.privRoom.participantId;
      // Because ConversationTranslator manually sets up and manages the connection, Conversation
      // has to forward serviceRecognizer connection events that usually get passed automatically
      this.privConversationRecognizer.connected = this.onConnected;
      this.privConversationRecognizer.disconnected = this.onDisconnected;
      this.privConversationRecognizer.canceled = this.onCanceled;
      this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;
      this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;
      this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;
      this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;
      this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;
      this.privConversationRecognizer.translationReceived = this.onTranslationReceived;
      this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;
      this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;
      this.privConversationRecognizer.connect(this.privRoom.token, () => {
        this.handleCallback(cb, err);
      }, error => {
        this.handleError(error, err);
      });
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Join a meeting as a participant.
   * @param { IParticipant } participant - participant to add
   * @param cb
   * @param err
   */
  addParticipantAsync(participant, cb, err) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(participant, "Participant");
    Exports_js_2.marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);
  }
  /**
   * Join a meeting as a participant.
   * @param meeting
   * @param nickname
   * @param lang
   * @param cb
   * @param err
   */
  joinMeetingAsync(meetingId, nickname, lang, cb, err) {
    try {
      // TODO
      // if (!!this.privConversationRecognizer) {
      //     throw new Error(this.privErrors.permissionDeniedStart);
      // }
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(meetingId, this.privErrors.invalidArgs.replace("{arg}", "conversationId"));
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace("{arg}", "language"));
      // join the conversation
      this.privManager.createOrJoin(this.privProperties, meetingId, room => {
        Contracts_js_1.Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);
        this.privRoom = room;
        this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;
        // join callback
        if (!!cb) {
          cb(room.cognitiveSpeechAuthToken);
        }
      }, error => {
        this.handleError(error, err);
      });
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Deletes a meeting
   * @param cb
   * @param err
   */
  deleteMeetingAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.deleteMeetingImplAsync(), cb, err);
  }
  async deleteMeetingImplAsync() {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);
    await this.privManager.leave(this.privProperties, this.privRoom.token);
    this.dispose();
  }
  /**
   * Issues a request to close the client websockets
   * @param cb
   * @param err
   */
  endMeetingAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.endMeetingImplAsync(), cb, err);
  }
  endMeetingImplAsync() {
    return this.close(true);
  }
  /**
   * Issues a request to lock the conversation
   * @param cb
   * @param err
   */
  lockMeetingAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getLockCommand(true), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to mute the meeting
   * @param cb
   * @param err
   */
  muteAllParticipantsAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      // check the user's permissions
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(true), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to mute a participant in the meeting
   * @param userId
   * @param cb
   * @param err
   */
  muteParticipantAsync(userId, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      // check the connection is open (host + participant can perform the mute command)
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      // if not host, check the participant is not muting another participant
      if (!this.me.isHost && this.me.id !== userId) {
        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
      }
      // check the user exists
      const exists = this.privParticipants.getParticipantIndex(userId);
      if (exists === -1) {
        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, true), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to remove a participant from the conversation
   * @param userId
   * @param cb
   * @param err
   */
  removeParticipantAsync(userId, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      if (!!this.privTranscriberRecognizer && userId.hasOwnProperty("id")) {
        // Assume this is a transcription participant
        Exports_js_2.marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);
      } else {
        Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
        Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
        if (!this.canSendAsHost) {
          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), err);
        }
        let participantId = "";
        if (typeof userId === "string") {
          participantId = userId;
        } else if (userId.hasOwnProperty("id")) {
          const participant = userId;
          participantId = participant.id;
        } else if (userId.hasOwnProperty("userId")) {
          const user = userId;
          participantId = user.userId;
        }
        Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
        // check the participant exists
        const index = this.participants.findIndex(p => p.id === participantId);
        if (index === -1) {
          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
        }
        if (!!this.privConversationRecognizer) {
          this.privConversationRecognizer.sendRequest(this.getEjectCommand(participantId), () => {
            this.handleCallback(cb, err);
          }, error => {
            this.handleError(error, err);
          });
        }
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to unlock the meeting
   * @param cb
   * @param err
   */
  unlockMeetingAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getLockCommand(false), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to unmute all participants in the meeting
   * @param cb
   * @param err
   */
  unmuteAllParticipantsAsync(cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSendAsHost) {
        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(false), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Issues a request to unmute a participant in the meeting
   * @param userId
   * @param cb
   * @param err
   */
  unmuteParticipantAsync(userId, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace("{arg}", "userId"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      // check the connection is open (host + participant can perform the mute command)
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      // if not host, check the participant is not muting another participant
      if (!this.me.isHost && this.me.id !== userId) {
        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), err);
      }
      // check the user exists
      const exists = this.privParticipants.getParticipantIndex(userId);
      if (exists === -1) {
        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMuteCommand(userId, false), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Send a text message
   * @param message
   * @param cb
   * @param err
   */
  sendTextMessageAsync(message, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace("{arg}", "message"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      // TODO: is a max length check required?
      if (message.length > this.privTextMessageMaxLength) {
        this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getMessageCommand(message), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Set translated to languages
   * @param {string[]} languages - languages to translate to
   * @param cb
   * @param err
   */
  setTranslatedLanguagesAsync(languages, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfArrayEmptyOrWhitespace(languages, this.privErrors.invalidArgs.replace("{arg}", "languages"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(languages), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  /**
   * Change nickname
   * @param {string} nickname - new nickname for the room
   * @param cb
   * @param err
   */
  changeNicknameAsync(nickname, cb, err) {
    try {
      Contracts_js_1.Contracts.throwIfDisposed(this.privIsDisposed);
      Contracts_js_1.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace("{arg}", "nickname"));
      Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);
      if (!this.canSend) {
        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);
      }
      if (!!this.privConversationRecognizer) {
        this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(nickname), () => {
          this.handleCallback(cb, err);
        }, error => {
          this.handleError(error, err);
        });
      }
    } catch (error) {
      this.handleError(error, err);
    }
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.privIsDisposed = true;
    if (!!this.config) {
      this.config.close();
    }
    this.privConfig = undefined;
    this.privLanguage = undefined;
    this.privProperties = undefined;
    this.privRoom = undefined;
    this.privToken = undefined;
    this.privManager = undefined;
    this.privIsConnected = false;
    this.privIsReady = false;
    this.privParticipants = undefined;
  }
  async connectTranscriberRecognizer(recognizer) {
    if (!!this.privTranscriberRecognizer) {
      await this.privTranscriberRecognizer.close();
    }
    await recognizer.enforceAudioGating();
    this.privTranscriberRecognizer = recognizer;
    this.privTranscriberRecognizer.meeting = this;
  }
  getKeepAlive() {
    const nickname = !!this.me ? this.me.displayName : "default_nickname";
    return JSON.stringify({
      id: "0",
      nickname,
      participantId: this.privRoom.participantId,
      roomId: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.keepAlive
    });
  }
  /* eslint-enable @typescript-eslint/typedef */
  addParticipantImplAsync(participant) {
    const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);
    if (newParticipant !== undefined) {
      if (!!this.privTranscriberRecognizer) {
        const meetingInfo = this.meetingInfo;
        meetingInfo.participants = [participant];
        return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, "join");
      }
    }
  }
  removeParticipantImplAsync(participant) {
    this.privParticipants.deleteParticipant(participant.id);
    const meetingInfo = this.meetingInfo;
    meetingInfo.participants = [participant];
    return this.privTranscriberRecognizer.pushMeetingEvent(meetingInfo, "leave");
  }
  async close(dispose) {
    try {
      this.privIsConnected = false;
      await this.privConversationRecognizer?.close();
      this.privConversationRecognizer = undefined;
      if (!!this.privConversationTranslator) {
        this.privConversationTranslator.dispose();
      }
    } catch (e) {
      // ignore error
      throw e;
    }
    if (dispose) {
      this.dispose();
    }
  }
  /** Helpers */
  handleCallback(cb, err) {
    if (!!cb) {
      try {
        cb();
      } catch (e) {
        if (!!err) {
          err(e);
        }
      }
      cb = undefined;
    }
  }
  handleError(error, err) {
    if (!!err) {
      if (error instanceof Error) {
        const typedError = error;
        err(typedError.name + ": " + typedError.message);
      } else {
        err(error);
      }
    }
  }
  /** Participant Helpers */
  toParticipants(includeHost) {
    const participants = this.privParticipants.participants.map(p => this.toParticipant(p));
    if (!includeHost) {
      return participants.filter(p => p.isHost === false);
    } else {
      return participants;
    }
  }
  toParticipant(p) {
    return new Exports_js_3.Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);
  }
  getMuteAllCommand(isMuted) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setMuteAll,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: isMuted
    });
  }
  getMuteCommand(participantId, isMuted) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setMute,
      // eslint-disable-next-line object-shorthand
      participantId: participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: isMuted
    });
  }
  getLockCommand(isLocked) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setLockState,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: isLocked
    });
  }
  getEjectCommand(participantId) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.ejectParticipant,
      // eslint-disable-next-line object-shorthand
      participantId: participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand
    });
  }
  getSetTranslateToLanguagesCommand(languages) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.setTranslateToLanguages,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: languages
    });
  }
  getChangeNicknameCommand(nickname) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(nickname, "nickname");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    return JSON.stringify({
      command: Exports_js_1.ConversationTranslatorCommandTypes.changeNickname,
      nickname,
      participantId: this.privRoom.participantId,
      roomid: this.privRoom.roomId,
      type: Exports_js_1.ConversationTranslatorMessageTypes.participantCommand,
      value: nickname
    });
  }
  getMessageCommand(message) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId");
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(message, "message");
    return JSON.stringify({
      participantId: this.privRoom.participantId,
      roomId: this.privRoom.roomId,
      text: message,
      type: Exports_js_1.ConversationTranslatorMessageTypes.instantMessage
    });
  }
}
exports.MeetingImpl = MeetingImpl;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/MeetingTranscriber.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/MeetingTranscriber.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MeetingTranscriber = void 0;
const Exports_js_1 = __webpack_require__(/*! ../../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ../Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ../Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
const Exports_js_4 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/Exports.js");
class MeetingTranscriber {
  /**
   * MeetingTranscriber constructor.
   * @constructor
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
   */
  constructor(audioConfig) {
    this.privAudioConfig = audioConfig;
    this.privProperties = new Exports_js_3.PropertyCollection();
    this.privRecognizer = undefined;
    this.privDisposedRecognizer = false;
  }
  /**
   * Gets the spoken language of recognition.
   * @member MeetingTranscriber.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @returns {string} The spoken language of recognition.
   */
  get speechRecognitionLanguage() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
  }
  /**
   * The collection of properties and their values defined for this MeetingTranscriber.
   * @member MeetingTranscriber.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * @Internal
   * Internal data member to support fromRecognizer* pattern methods on other classes.
   * Do not use externally, object returned will change without warning or notice.
   */
  get internalData() {
    return this.privRecognizer.internalData;
  }
  /**
   * @Deprecated
   * @Obsolete
   * Please use the Connection.fromRecognizer pattern to obtain a connection object
   */
  get connection() {
    return Exports_js_3.Connection.fromRecognizer(this.privRecognizer);
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member MeetingTranscriber.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * @member MeetingTranscriber.prototype.authorizationToken
   * @function
   * @public
   * @param {string} token - Authorization token.
   */
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  /**
   * @param {Meeting} meeting - meeting to be recognized
   */
  joinMeetingAsync(meeting, cb, err) {
    /* eslint-disable no-console */
    // console.log(">> MeetingTranscriber::joinMeetingAsync");
    /* eslint-enable no-console */
    const meetingImpl = meeting;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(Exports_js_4.MeetingImpl, "Meeting");
    // ref the meeting object
    // create recognizer and subscribe to recognizer events
    this.privRecognizer = new Exports_js_1.TranscriberRecognizer(meeting.config, this.privAudioConfig);
    Contracts_js_1.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer");
    this.privRecognizer.connectMeetingCallbacks(this);
    Exports_js_2.marshalPromiseToCallbacks(meetingImpl.connectTranscriberRecognizer(this.privRecognizer), cb, err);
  }
  /**
   * Starts meeting transcription, until stopTranscribingAsync() is called.
   * User must subscribe to events to receive transcription results.
   * @member MeetingTranscriber.prototype.startTranscribingAsync
   * @function
   * @public
   * @param cb - Callback invoked once the transcription has started.
   * @param err - Callback invoked in case of an error.
   */
  startTranscribingAsync(cb, err) {
    this.privRecognizer.startContinuousRecognitionAsync(cb, err);
  }
  /**
   * Starts meeting transcription, until stopTranscribingAsync() is called.
   * User must subscribe to events to receive transcription results.
   * @member MeetingTranscriber.prototype.stopTranscribingAsync
   * @function
   * @public
   * @param cb - Callback invoked once the transcription has started.
   * @param err - Callback invoked in case of an error.
   */
  stopTranscribingAsync(cb, err) {
    this.privRecognizer.stopContinuousRecognitionAsync(cb, err);
  }
  /**
   * Leave the current meeting. After this is called, you will no longer receive any events.
   */
  leaveMeetingAsync(cb, err) {
    this.privRecognizer.disconnectCallbacks();
    // eslint-disable-next-line
    Exports_js_2.marshalPromiseToCallbacks((async () => {
      return;
    })(), cb, err);
  }
  /**
   * closes all external resources held by an instance of this class.
   * @member MeetingTranscriber.prototype.close
   * @function
   * @public
   */
  close(cb, errorCb) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedRecognizer);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
  }
  /**
   * Disposes any resources held by the object.
   * @member MeetingTranscriber.prototype.dispose
   * @function
   * @public
   * @param {boolean} disposing - true if disposing the object.
   */
  async dispose(disposing) {
    if (this.privDisposedRecognizer) {
      return;
    }
    if (!!this.privRecognizer) {
      await this.privRecognizer.close();
      this.privRecognizer = undefined;
    }
    if (disposing) {
      this.privDisposedRecognizer = true;
    }
  }
}
exports.MeetingTranscriber = MeetingTranscriber;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/MeetingTranscriptionCanceledEventArgs.js":
/*!****************************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/MeetingTranscriptionCanceledEventArgs.js ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MeetingTranscriptionCanceledEventArgs = void 0;
const CancellationEventArgsBase_js_1 = __webpack_require__(/*! ../CancellationEventArgsBase.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/CancellationEventArgsBase.js");
class MeetingTranscriptionCanceledEventArgs extends CancellationEventArgsBase_js_1.CancellationEventArgsBase {}
exports.MeetingTranscriptionCanceledEventArgs = MeetingTranscriptionCanceledEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ParticipantChangedReason.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Transcription/ParticipantChangedReason.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
// Multi-device Conversation is a Preview feature.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ParticipantChangedReason = void 0;
var ParticipantChangedReason;
(function (ParticipantChangedReason) {
  /** Participant has joined the conversation. */
  ParticipantChangedReason[ParticipantChangedReason["JoinedConversation"] = 0] = "JoinedConversation";
  /** Participant has left the conversation. This could be voluntary, or involuntary
   * (e.g. they are experiencing networking issues).
   */
  ParticipantChangedReason[ParticipantChangedReason["LeftConversation"] = 1] = "LeftConversation";
  /** The participants' state has changed (e.g. they became muted, changed their nickname). */
  ParticipantChangedReason[ParticipantChangedReason["Updated"] = 2] = "Updated";
})(ParticipantChangedReason = exports.ParticipantChangedReason || (exports.ParticipantChangedReason = {}));

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionCanceledEventArgs.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionCanceledEventArgs.js ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationRecognitionCanceledEventArgs = void 0;
/**
 * Define payload of speech recognition canceled result events.
 * @class TranslationRecognitionCanceledEventArgs
 */
class TranslationRecognitionCanceledEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionid - The session id.
   * @param {CancellationReason} cancellationReason - The cancellation reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {TranslationRecognitionResult} result - The result.
   */
  constructor(sessionid, cancellationReason, errorDetails, errorCode, result) {
    this.privCancelReason = cancellationReason;
    this.privErrorDetails = errorDetails;
    this.privResult = result;
    this.privSessionId = sessionid;
    this.privErrorCode = errorCode;
  }
  /**
   * Specifies the recognition result.
   * @member TranslationRecognitionCanceledEventArgs.prototype.result
   * @function
   * @public
   * @returns {TranslationRecognitionResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
  /**
   * Specifies the session identifier.
   * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
  /**
   * The reason the recognition was canceled.
   * @member TranslationRecognitionCanceledEventArgs.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privCancelReason;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get errorCode() {
    return this.privErrorCode;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
}
exports.TranslationRecognitionCanceledEventArgs = TranslationRecognitionCanceledEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionEventArgs.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionEventArgs.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationRecognitionEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Translation text result event arguments.
 * @class TranslationRecognitionEventArgs
 */
class TranslationRecognitionEventArgs extends Exports_js_1.RecognitionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {TranslationRecognitionResult} result - The translation recognition result.
   * @param {number} offset - The offset.
   * @param {string} sessionId - The session id.
   */
  constructor(result, offset, sessionId) {
    super(offset, sessionId);
    this.privResult = result;
  }
  /**
   * Specifies the recognition result.
   * @member TranslationRecognitionEventArgs.prototype.result
   * @function
   * @public
   * @returns {TranslationRecognitionResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
}
exports.TranslationRecognitionEventArgs = TranslationRecognitionEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionResult.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognitionResult.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationRecognitionResult = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Translation text result.
 * @class TranslationRecognitionResult
 */
class TranslationRecognitionResult extends Exports_js_1.SpeechRecognitionResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {Translations} translations - The translations.
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} text - The recognized text.
   * @param {number} duration - The duration.
   * @param {number} offset - The offset into the stream.
   * @param {string} language - Primary Language detected, if provided.
   * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param {string} errorDetails - Error details, if provided.
   * @param {string} json - Additional Json, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(translations, resultId, reason, text, duration, offset, language, languageDetectionConfidence, errorDetails, json, properties) {
    super(resultId, reason, text, duration, offset, language, languageDetectionConfidence, undefined, errorDetails, json, properties);
    this.privTranslations = translations;
  }
  static fromSpeechRecognitionResult(result) {
    return new TranslationRecognitionResult(undefined, result.resultId, result.reason, result.text, result.duration, result.offset, result.language, result.languageDetectionConfidence, result.errorDetails, result.json, result.properties);
  }
  /**
   * Presents the translation results. Each item in the dictionary represents
   * a translation result in one of target languages, where the key is the name
   * of the target language, in BCP-47 format, and the value is the translation
   * text in the specified language.
   * @member TranslationRecognitionResult.prototype.translations
   * @function
   * @public
   * @returns {Translations} the current translation map that holds all translations requested.
   */
  get translations() {
    return this.privTranslations;
  }
}
exports.TranslationRecognitionResult = TranslationRecognitionResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognizer.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationRecognizer.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationRecognizer = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ../common/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common/Exports.js");
const Connection_js_1 = __webpack_require__(/*! ./Connection.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Connection.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_3 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Translation recognizer
 * @class TranslationRecognizer
 */
class TranslationRecognizer extends Exports_js_3.Recognizer {
  /**
   * Initializes an instance of the TranslationRecognizer.
   * @constructor
   * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
   * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
   * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
   */
  constructor(speechConfig, audioConfig, connectionFactory) {
    const configImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(configImpl, "speechConfig");
    super(audioConfig, configImpl.properties, connectionFactory || new Exports_js_1.TranslationConnectionFactory());
    this.privDisposedTranslationRecognizer = false;
    if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, undefined) !== undefined) {
      Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages]);
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage), Exports_js_3.PropertyId[Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage]);
  }
  /**
   * TranslationRecognizer constructor.
   * @constructor
   * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
   * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
   * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
   */
  static FromConfig(speechTranslationConfig, autoDetectSourceLanguageConfig, audioConfig) {
    const speechTranslationConfigImpl = speechTranslationConfig;
    autoDetectSourceLanguageConfig.properties.mergeTo(speechTranslationConfigImpl.properties);
    return new TranslationRecognizer(speechTranslationConfig, audioConfig);
  }
  /**
   * Gets the language name that was set when the recognizer was created.
   * @member TranslationRecognizer.prototype.speechRecognitionLanguage
   * @function
   * @public
   * @returns {string} Gets the language name that was set when the recognizer was created.
   */
  get speechRecognitionLanguage() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_RecoLanguage);
  }
  /**
   * Gets target languages for translation that were set when the recognizer was created.
   * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
   * @member TranslationRecognizer.prototype.targetLanguages
   * @function
   * @public
   * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
   */
  get targetLanguages() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
  }
  /**
   * Gets the name of output voice.
   * @member TranslationRecognizer.prototype.voiceName
   * @function
   * @public
   * @returns {string} the name of output voice.
   */
  get voiceName() {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationVoice, undefined);
  }
  /**
   * The collection of properties and their values defined for this TranslationRecognizer.
   * @member TranslationRecognizer.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member TranslationRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * @member TranslationRecognizer.prototype.authorizationToken
   * @function
   * @public
   * @param {string} value - Authorization token.
   */
  set authorizationToken(value) {
    this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceAuthorization_Token, value);
  }
  /**
   * Starts recognition and translation, and stops after the first utterance is recognized.
   * The task returns the translation text as result.
   * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
   * for single shot recognition like command or query. For long-running recognition,
   * use startContinuousRecognitionAsync() instead.
   * @member TranslationRecognizer.prototype.recognizeOnceAsync
   * @function
   * @public
   * @param cb - Callback that received the result when the translation has completed.
   * @param err - Callback invoked in case of an error.
   */
  recognizeOnceAsync(cb, err) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
    Exports_js_2.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(Exports_js_1.RecognitionMode.Interactive), cb, err);
  }
  /**
   * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
   * User must subscribe to events to receive translation results.
   * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
   * @function
   * @public
   * @param cb - Callback that received the translation has started.
   * @param err - Callback invoked in case of an error.
   */
  startContinuousRecognitionAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(Exports_js_1.RecognitionMode.Conversation), cb, err);
  }
  /**
   * Stops continuous recognition and translation.
   * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
   * @function
   * @public
   * @param cb - Callback that received the translation has stopped.
   * @param err - Callback invoked in case of an error.
   */
  stopContinuousRecognitionAsync(cb, err) {
    Exports_js_2.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), cb, err);
  }
  /**
   * dynamically remove a language from list of target language
   * (can be used while recognition is ongoing)
   * @member TranslationRecognizer.prototype.removeTargetLanguage
   * @function
   * @param lang - language to be removed
   * @public
   */
  removeTargetLanguage(lang) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(lang, "language to be removed");
    if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {
      const languages = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
      const index = languages.indexOf(lang);
      if (index > -1) {
        languages.splice(index, 1);
        this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
        this.updateLanguages(languages);
      }
    }
  }
  /**
   * dynamically add a language to list of target language
   * (can be used while recognition is ongoing)
   * @member TranslationRecognizer.prototype.addTargetLanguage
   * @function
   * @param lang - language to be added
   * @public
   */
  addTargetLanguage(lang) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(lang, "language to be added");
    let languages = [];
    if (this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, undefined) !== undefined) {
      languages = this.properties.getProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
      if (!languages.includes(lang)) {
        languages.push(lang);
        this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, languages.join(","));
      }
    } else {
      this.properties.setProperty(Exports_js_3.PropertyId.SpeechServiceConnection_TranslationToLanguages, lang);
      languages = [lang];
    }
    this.updateLanguages(languages);
  }
  /**
   * closes all external resources held by an instance of this class.
   * @member TranslationRecognizer.prototype.close
   * @function
   * @public
   */
  close(cb, errorCb) {
    Contracts_js_1.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer);
    Exports_js_2.marshalPromiseToCallbacks(this.dispose(true), cb, errorCb);
  }
  /**
   * handles ConnectionEstablishedEvent for conversation translation scenarios.
   * @member TranslationRecognizer.prototype.onConnection
   * @function
   * @public
   */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onConnection() {}
  async dispose(disposing) {
    if (this.privDisposedTranslationRecognizer) {
      return;
    }
    this.privDisposedTranslationRecognizer = true;
    if (disposing) {
      await this.implRecognizerStop();
      await super.dispose(disposing);
    }
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.privProperties);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const configImpl = audioConfig;
    return new Exports_js_1.TranslationServiceRecognizer(authentication, connectionFactory, configImpl, recognizerConfig, this);
  }
  updateLanguages(languages) {
    const conn = Connection_js_1.Connection.fromRecognizer(this);
    if (!!conn) {
      conn.setMessageProperty("speech.context", "translationcontext", {
        to: languages
      });
      conn.sendMessageAsync("event", JSON.stringify({
        id: "translation",
        name: "updateLanguage",
        to: languages
      }));
    }
  }
}
exports.TranslationRecognizer = TranslationRecognizer;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationSynthesisEventArgs.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationSynthesisEventArgs.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationSynthesisEventArgs = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Translation Synthesis event arguments
 * @class TranslationSynthesisEventArgs
 */
class TranslationSynthesisEventArgs extends Exports_js_1.SessionEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {TranslationSynthesisResult} result - The translation synthesis result.
   * @param {string} sessionId - The session id.
   */
  constructor(result, sessionId) {
    super(sessionId);
    this.privResult = result;
  }
  /**
   * Specifies the translation synthesis result.
   * @member TranslationSynthesisEventArgs.prototype.result
   * @function
   * @public
   * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
   */
  get result() {
    return this.privResult;
  }
}
exports.TranslationSynthesisEventArgs = TranslationSynthesisEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationSynthesisResult.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TranslationSynthesisResult.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TranslationSynthesisResult = void 0;
/**
 * Defines translation synthesis result, i.e. the voice output of the translated
 * text in the target language.
 * @class TranslationSynthesisResult
 */
class TranslationSynthesisResult {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {ResultReason} reason - The synthesis reason.
   * @param {ArrayBuffer} audio - The audio data.
   */
  constructor(reason, audio) {
    this.privReason = reason;
    this.privAudio = audio;
  }
  /**
   * Translated text in the target language.
   * @member TranslationSynthesisResult.prototype.audio
   * @function
   * @public
   * @returns {ArrayBuffer} Translated audio in the target language.
   */
  get audio() {
    return this.privAudio;
  }
  /**
   * The synthesis status.
   * @member TranslationSynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} The synthesis status.
   */
  get reason() {
    return this.privReason;
  }
}
exports.TranslationSynthesisResult = TranslationSynthesisResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Translations.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Translations.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Translations = void 0;
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Represents collection of parameters and their values.
 * @class Translations
 */
class Translations {
  constructor() {
    // Use an PropertyCollection internally, just wrapping it to hide the | enum syntax it has.
    this.privMap = new Exports_js_1.PropertyCollection();
  }
  /**
   * Get the languages in the object in a String array.
   * @member Translations.prototype.languages
   * @function
   * @public
   * @returns {string[]} languages in translations object.
   */
  get languages() {
    return this.privMap.keys;
  }
  /**
   * Returns the parameter value in type String. The parameter must have the same type as String.
   * Currently only String, int and bool are allowed.
   * If the name is not available, the specified defaultValue is returned.
   * @member Translations.prototype.get
   * @function
   * @public
   * @param {string} key - The parameter name.
   * @param {string} def - The default value which is returned if the parameter is not available in the collection.
   * @returns {string} value of the parameter.
   */
  get(key, def) {
    return this.privMap.getProperty(key, def);
  }
  /**
   * Sets the String value of the parameter specified by name.
   * @member Translations.prototype.set
   * @function
   * @public
   * @param {string} key - The parameter name.
   * @param {string} value - The value of the parameter.
   */
  set(key, value) {
    this.privMap.setProperty(key, value);
  }
}
exports.Translations = Translations;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TurnStatusReceivedEventArgs.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/TurnStatusReceivedEventArgs.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TurnStatusReceivedEventArgs = void 0;
const TurnStatusPayload_js_1 = __webpack_require__(/*! ../common.speech/ServiceMessages/TurnStatusPayload.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/ServiceMessages/TurnStatusPayload.js");
/**
 * Defines contents of received message/events.
 * @class TurnStatusReceivedEventArgs
 */
class TurnStatusReceivedEventArgs {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} turnStatus - The JSON-encoded turn status message.
   */
  constructor(turnStatus) {
    this.privTurnStatus = TurnStatusPayload_js_1.TurnStatusResponsePayload.fromJSON(turnStatus);
  }
  /**
   * Gets the interaction identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.interactionId
   * @function
   * @public
   * @returns {any} the received interaction id.
   */
  get interactionId() {
    return this.privTurnStatus.interactionId;
  }
  /**
   * Gets the conversation identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.conversationId
   * @function
   * @public
   * @returns {any} the received conversation id.
   */
  get conversationId() {
    return this.privTurnStatus.conversationId;
  }
  /**
   * Gets the received turn status code.
   * @member TurnStatusReceivedEventArgs.prototype.statusCode
   * @function
   * @public
   * @returns {number} the received turn status.
   */
  get statusCode() {
    return this.privTurnStatus.statusCode; // eslint-disable-line @typescript-eslint/no-unsafe-return
  }
}
exports.TurnStatusReceivedEventArgs = TurnStatusReceivedEventArgs;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceInfo.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceInfo.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceInfo = exports.SynthesisVoiceType = exports.SynthesisVoiceGender = void 0;
/**
 * Defines the gender of synthesis voices.
 * Added in version 1.20.0.
 */
var SynthesisVoiceGender;
(function (SynthesisVoiceGender) {
  /** Gender unknown */
  SynthesisVoiceGender[SynthesisVoiceGender["Unknown"] = 0] = "Unknown";
  /** Female voice */
  SynthesisVoiceGender[SynthesisVoiceGender["Female"] = 1] = "Female";
  /** Male voice */
  SynthesisVoiceGender[SynthesisVoiceGender["Male"] = 2] = "Male";
  /** Neutral voice */
  SynthesisVoiceGender[SynthesisVoiceGender["Neutral"] = 3] = "Neutral";
})(SynthesisVoiceGender = exports.SynthesisVoiceGender || (exports.SynthesisVoiceGender = {}));
var SynthesisVoiceType;
(function (SynthesisVoiceType) {
  /**
   * Voice type is not known.
   */
  SynthesisVoiceType[SynthesisVoiceType["Unknown"] = 0] = "Unknown";
  /**
   * Online neural voices.
   */
  SynthesisVoiceType[SynthesisVoiceType["OnlineNeural"] = 1] = "OnlineNeural";
  /**
   * Online standard voices. These voices are deprecated.
   */
  SynthesisVoiceType[SynthesisVoiceType["OnlineStandard"] = 2] = "OnlineStandard";
  /**
   * Offline neural voices.
   */
  SynthesisVoiceType[SynthesisVoiceType["OfflineNeural"] = 3] = "OfflineNeural";
  /**
   * Offline standard voices.
   */
  SynthesisVoiceType[SynthesisVoiceType["OfflineStandard"] = 4] = "OfflineStandard";
  /**
   * High definition (HD) voices. Refer to https://learn.microsoft.com/azure/ai-services/speech-service/high-definition-voices
   */
  SynthesisVoiceType[SynthesisVoiceType["OnlineNeuralHD"] = 5] = "OnlineNeuralHD";
})(SynthesisVoiceType = exports.SynthesisVoiceType || (exports.SynthesisVoiceType = {}));
const GENDER_LOOKUP = {
  [SynthesisVoiceGender[SynthesisVoiceGender.Neutral]]: SynthesisVoiceGender.Neutral,
  [SynthesisVoiceGender[SynthesisVoiceGender.Male]]: SynthesisVoiceGender.Male,
  [SynthesisVoiceGender[SynthesisVoiceGender.Female]]: SynthesisVoiceGender.Female
};
const VOICE_TYPE_LOOKUP = {
  Neural: SynthesisVoiceType.OnlineNeural,
  NeuralHD: SynthesisVoiceType.OnlineNeuralHD
};
/**
 * Information about Speech Synthesis voice
 * Added in version 1.20.0.
 * @class VoiceInfo
 */
class VoiceInfo {
  constructor(json) {
    this.privStyleList = [];
    if (!!json) {
      this.privName = json.Name;
      this.privLocale = json.Locale;
      this.privShortName = json.ShortName;
      this.privLocaleName = json.LocaleName;
      this.privDisplayName = json.DisplayName;
      this.privLocalName = json.LocalName;
      this.privVoiceType = VOICE_TYPE_LOOKUP[json.VoiceType] || SynthesisVoiceType.Unknown;
      this.privGender = GENDER_LOOKUP[json.Gender] || SynthesisVoiceGender.Unknown;
      if (!!json.StyleList && Array.isArray(json.StyleList)) {
        for (const style of json.StyleList) {
          this.privStyleList.push(style);
        }
      }
      this.privSampleRateHertz = json.SampleRateHertz;
      this.privStatus = json.Status;
      if (json.ExtendedPropertyMap) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        this.privExtendedPropertyMap = json.ExtendedPropertyMap;
      }
      this.privWordsPerMinute = json.WordsPerMinute;
      if (Array.isArray(json.SecondaryLocaleList)) {
        this.privSecondaryLocaleList = [...json.SecondaryLocaleList];
      }
      if (Array.isArray(json.RolePlayList)) {
        this.privRolePlayList = [...json.RolePlayList];
      }
      if (json.VoiceTag) {
        this.privVoiceTag = json.VoiceTag;
      }
    }
  }
  get name() {
    return this.privName;
  }
  get locale() {
    return this.privLocale;
  }
  get shortName() {
    return this.privShortName;
  }
  get displayName() {
    return this.privDisplayName;
  }
  get localName() {
    return this.privLocalName;
  }
  get localeName() {
    return this.privLocaleName;
  }
  get gender() {
    return this.privGender;
  }
  get voiceType() {
    return this.privVoiceType;
  }
  get styleList() {
    return this.privStyleList;
  }
  get sampleRateHertz() {
    return this.privSampleRateHertz;
  }
  get status() {
    return this.privStatus;
  }
  get extendedPropertyMap() {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return this.privExtendedPropertyMap;
  }
  get wordsPerMinute() {
    return this.privWordsPerMinute;
  }
  get secondaryLocaleList() {
    return this.privSecondaryLocaleList;
  }
  get rolePlayList() {
    return this.privRolePlayList;
  }
  get voiceTag() {
    return this.privVoiceTag;
  }
}
exports.VoiceInfo = VoiceInfo;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfile.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfile.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceProfile = void 0;
/**
 * Defines Voice Profile class for Speaker Recognition
 * @class VoiceProfile
 */
class VoiceProfile {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} profileId - profileId of this Voice Profile.
   * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
   */
  constructor(profileId, profileType) {
    this.privId = profileId;
    this.privProfileType = profileType;
  }
  /**
   * profileId of this Voice Profile instance
   * @member VoiceProfile.prototype.profileId
   * @function
   * @public
   * @returns {string} profileId of this Voice Profile instance.
   */
  get profileId() {
    return this.privId;
  }
  /**
   * profileType of this Voice Profile instance
   * @member VoiceProfile.prototype.profileType
   * @function
   * @public
   * @returns {VoiceProfileType} profile type of this Voice Profile instance.
   */
  get profileType() {
    return this.privProfileType;
  }
}
exports.VoiceProfile = VoiceProfile;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileClient.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileClient.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceProfileClient = void 0;
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const AudioConfig_js_1 = __webpack_require__(/*! ./Audio/AudioConfig.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Audio/AudioConfig.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Defines VoiceProfileClient class for Speaker Recognition
 * Handles operations from user for Voice Profile operations (e.g. createProfile, deleteProfile)
 * @class VoiceProfileClient
 */
class VoiceProfileClient extends Exports_js_2.Recognizer {
  /**
   * VoiceProfileClient constructor.
   * @constructor
   * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
   */
  constructor(speechConfig) {
    Contracts_js_1.Contracts.throwIfNullOrUndefined(speechConfig, "speechConfig");
    const speechConfigImpl = speechConfig;
    Contracts_js_1.Contracts.throwIfNull(speechConfigImpl, "speechConfig");
    super(AudioConfig_js_1.AudioConfig.fromStreamInput(Exports_js_2.AudioInputStream.createPushStream()), speechConfigImpl.properties, new Exports_js_1.VoiceProfileConnectionFactory());
    this.privProperties = speechConfigImpl.properties.clone();
    this.privVoiceAdapter = this.privReco;
    this.privDisposedVoiceAdapter = false;
  }
  /**
   * The collection of properties and their values defined for this VoiceProfileClient.
   * @member VoiceProfileClient.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
   */
  get properties() {
    return this.privProperties;
  }
  /**
   * Gets the authorization token used to communicate with the service.
   * @member VoiceProfileClient.prototype.authorizationToken
   * @function
   * @public
   * @returns {string} Authorization token.
   */
  get authorizationToken() {
    return this.properties.getProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token);
  }
  /**
   * Gets/Sets the authorization token used to communicate with the service.
   * @member VoiceProfileClient.prototype.authorizationToken
   * @function
   * @public
   * @param {string} token - Authorization token.
   */
  set authorizationToken(token) {
    Contracts_js_1.Contracts.throwIfNullOrWhitespace(token, "token");
    this.properties.setProperty(Exports_js_2.PropertyId.SpeechServiceAuthorization_Token, token);
  }
  /**
   * Create a speaker recognition voice profile
   * @member VoiceProfileClient.prototype.createProfileAsync
   * @function
   * @public
   * @async
   * @param {VoiceProfileType} profileType Type of Voice Profile to be created
   * @param {string} lang Language string (locale) for Voice Profile
   * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
   */
  async createProfileAsync(profileType, lang) {
    const profileIds = await this.privVoiceAdapter.createProfile(profileType, lang);
    return new Exports_js_2.VoiceProfile(profileIds[0], profileType);
  }
  /**
   * Get current information of a voice profile
   * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
   * @function
   * @public
   * @async
   * @param {VoiceProfile} profile Voice Profile to retrieve info for
   * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
   */
  async retrieveEnrollmentResultAsync(profile) {
    return this.privVoiceAdapter.retrieveEnrollmentResult(profile);
  }
  /**
   * Get all voice profiles on account with given voice profile type
   * @member VoiceProfileClient.prototype.getAllProfilesAsync
   * @function
   * @public
   * @async
   * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
   * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
   */
  async getAllProfilesAsync(profileType) {
    return this.privVoiceAdapter.getAllProfiles(profileType);
    /*
    const result: { json: { value: EnrollmentResultJSON[] } } = await this.privAdapter.getProfiles(profileType);
    if (profileType === VoiceProfileType.TextIndependentIdentification) {
        return VoiceProfileEnrollmentResult.FromIdentificationProfileList(result.json);
    }
    return VoiceProfileEnrollmentResult.FromVerificationProfileList(result.json);
    */
  }
  /**
   * Get valid authorization phrases for voice profile enrollment
   * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
   * @function
   * @public
   * @async
   * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
   * @param {string} lang Language string (locale) for Voice Profile
   */
  async getActivationPhrasesAsync(profileType, lang) {
    return this.privVoiceAdapter.getActivationPhrases(profileType, lang);
  }
  /**
   * Create a speaker recognition voice profile
   * @member VoiceProfileClient.prototype.enrollProfileAsync
   * @function
   * @public
   * @async
   * @param {VoiceProfile} profile Voice Profile to create enrollment for
   * @param {AudioConfig} audioConfig source info from which to create enrollment
   * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
   */
  async enrollProfileAsync(profile, audioConfig) {
    const configImpl = audioConfig;
    Contracts_js_1.Contracts.throwIfNullOrUndefined(configImpl, "audioConfig");
    this.audioConfig = audioConfig;
    this.privVoiceAdapter.SpeakerAudioSource = configImpl;
    return this.privVoiceAdapter.enrollProfile(profile);
  }
  /**
   * Delete a speaker recognition voice profile
   * @member VoiceProfileClient.prototype.deleteProfileAsync
   * @function
   * @public
   * @async
   * @param {VoiceProfile} profile Voice Profile to be deleted
   * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
   */
  async deleteProfileAsync(profile) {
    return this.privVoiceAdapter.deleteProfile(profile);
  }
  /**
   * Remove all enrollments for a speaker recognition voice profile
   * @member VoiceProfileClient.prototype.resetProfileAsync
   * @function
   * @public
   * @async
   * @param {VoiceProfile} profile Voice Profile to be reset
   * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
   */
  async resetProfileAsync(profile) {
    return this.privVoiceAdapter.resetProfile(profile);
  }
  /**
   * Clean up object and close underlying connection
   * @member VoiceProfileClient.prototype.close
   * @function
   * @async
   * @public
   */
  async close() {
    await this.dispose(true);
  }
  createServiceRecognizer(authentication, connectionFactory, audioConfig, recognizerConfig) {
    const audioImpl = audioConfig;
    return new Exports_js_1.VoiceServiceRecognizer(authentication, connectionFactory, audioImpl, recognizerConfig, this);
  }
  async dispose(disposing) {
    if (this.privDisposedVoiceAdapter) {
      return;
    }
    this.privDisposedVoiceAdapter = true;
    if (disposing) {
      await super.dispose(disposing);
    }
  }
  createRecognizerConfig(speechConfig) {
    return new Exports_js_1.RecognizerConfig(speechConfig, this.properties);
  }
  getResult(result, successReason) {
    const response = new Exports_js_2.VoiceProfileResult(result.ok ? successReason : Exports_js_2.ResultReason.Canceled, result.statusText);
    return response;
  }
}
exports.VoiceProfileClient = VoiceProfileClient;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileEnrollmentResult.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileEnrollmentResult.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceProfileEnrollmentCancellationDetails = exports.VoiceProfileEnrollmentResult = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Output format
 * @class VoiceProfileEnrollmentResult
 */
class VoiceProfileEnrollmentResult {
  constructor(reason, json, statusText) {
    this.privReason = reason;
    this.privProperties = new Exports_js_2.PropertyCollection();
    if (this.privReason !== Exports_js_2.ResultReason.Canceled) {
      if (!!json) {
        this.privDetails = JSON.parse(json);
        if (this.privDetails.enrollmentStatus.toLowerCase() === "enrolling") {
          this.privReason = Exports_js_2.ResultReason.EnrollingVoiceProfile;
        }
      }
    } else {
      this.privErrorDetails = statusText;
      this.privProperties.setProperty(Exports_js_1.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.ServiceError]);
    }
  }
  get reason() {
    return this.privReason;
  }
  get enrollmentsCount() {
    return this.privDetails.enrollmentsCount;
  }
  get enrollmentsLength() {
    return this.privDetails.enrollmentsLength;
  }
  get properties() {
    return this.privProperties;
  }
  get enrollmentResultDetails() {
    return this.privDetails;
  }
  get errorDetails() {
    return this.privErrorDetails;
  }
  static FromIdentificationProfileList(json) {
    const results = [];
    for (const item of json.value) {
      const reason = item.enrollmentStatus.toLowerCase() === "enrolling" ? Exports_js_2.ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === "enrolled" ? Exports_js_2.ResultReason.EnrolledVoiceProfile : Exports_js_2.ResultReason.Canceled;
      const result = new VoiceProfileEnrollmentResult(reason, null, null);
      result.privDetails = this.getIdentificationDetails(item);
      results.push(result);
    }
    return results;
  }
  static FromVerificationProfileList(json) {
    const results = [];
    for (const item of json.value) {
      const reason = item.enrollmentStatus.toLowerCase() === "enrolling" ? Exports_js_2.ResultReason.EnrollingVoiceProfile : item.enrollmentStatus.toLowerCase() === "enrolled" ? Exports_js_2.ResultReason.EnrolledVoiceProfile : Exports_js_2.ResultReason.Canceled;
      const result = new VoiceProfileEnrollmentResult(reason, null, null);
      result.privDetails = this.getVerificationDetails(item);
      results.push(result);
    }
    return results;
  }
  static getIdentificationDetails(json) {
    return {
      audioLength: json.audioLength ? parseFloat(json.audioLength) : 0,
      audioSpeechLength: json.audioSpeechLength ? parseFloat(json.audioSpeechLength) : 0,
      enrollmentStatus: json.enrollmentStatus,
      enrollmentsCount: json.enrollmentsCount || 0,
      enrollmentsLength: json.enrollmentsLength ? parseFloat(json.enrollmentsLength) : 0,
      enrollmentsSpeechLength: json.enrollmentsSpeechLength ? parseFloat(json.enrollmentsSpeechLength) : 0,
      profileId: json.profileId || json.identificationProfileId,
      remainingEnrollmentsSpeechLength: json.remainingEnrollmentsSpeechLength ? parseFloat(json.remainingEnrollmentsSpeechLength) : 0
    };
  }
  static getVerificationDetails(json) {
    return {
      audioLength: json.audioLength ? parseFloat(json.audioLength) : 0,
      audioSpeechLength: json.audioSpeechLength ? parseFloat(json.audioSpeechLength) : 0,
      enrollmentStatus: json.enrollmentStatus,
      enrollmentsCount: json.enrollmentsCount,
      enrollmentsLength: json.enrollmentsLength ? parseFloat(json.enrollmentsLength) : 0,
      enrollmentsSpeechLength: json.enrollmentsSpeechLength ? parseFloat(json.enrollmentsSpeechLength) : 0,
      profileId: json.profileId || json.verificationProfileId,
      remainingEnrollmentsCount: json.remainingEnrollments || json.remainingEnrollmentsCount,
      remainingEnrollmentsSpeechLength: json.remainingEnrollmentsSpeechLength ? parseFloat(json.remainingEnrollmentsSpeechLength) : 0
    };
  }
}
exports.VoiceProfileEnrollmentResult = VoiceProfileEnrollmentResult;
/**
 * @class VoiceProfileEnrollmentCancellationDetails
 */
class VoiceProfileEnrollmentCancellationDetails extends Exports_js_2.CancellationDetailsBase {
  constructor(reason, errorDetails, errorCode) {
    super(reason, errorDetails, errorCode);
  }
  /**
   * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
   * @member VoiceProfileEnrollmentCancellationDetails.fromResult
   * @function
   * @public
   * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
   * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
   */
  static fromResult(result) {
    const reason = Exports_js_2.CancellationReason.Error;
    let errorCode = Exports_js_2.CancellationErrorCode.NoError;
    if (!!result.properties) {
      errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_1.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])]; //eslint-disable-line
    }
    return new VoiceProfileEnrollmentCancellationDetails(reason, result.errorDetails, errorCode);
  }
}
exports.VoiceProfileEnrollmentCancellationDetails = VoiceProfileEnrollmentCancellationDetails;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfilePhraseResult.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfilePhraseResult.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceProfilePhraseResult = void 0;
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_1 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Output format
 * @class VoiceProfilePhraseResult
 */
class VoiceProfilePhraseResult extends Exports_js_1.VoiceProfileResult {
  constructor(reason, statusText, type, phraseArray) {
    super(reason, statusText);
    this.privPhrases = [];
    Contracts_js_1.Contracts.throwIfNullOrUndefined(phraseArray, "phrase array");
    this.privType = type;
    if (!!phraseArray && !!phraseArray[0]) {
      this.privPhrases = phraseArray;
    }
  }
  get phrases() {
    return this.privPhrases;
  }
  get type() {
    return this.privType;
  }
}
exports.VoiceProfilePhraseResult = VoiceProfilePhraseResult;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileResult.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileResult.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceProfileCancellationDetails = exports.VoiceProfileResult = void 0;
/* eslint-disable max-classes-per-file */
const Exports_js_1 = __webpack_require__(/*! ../common.speech/Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/Exports.js");
const Contracts_js_1 = __webpack_require__(/*! ./Contracts.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Contracts.js");
const Exports_js_2 = __webpack_require__(/*! ./Exports.js */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/Exports.js");
/**
 * Output format
 * @class VoiceProfileResult
 */
class VoiceProfileResult {
  constructor(reason, statusText) {
    this.privReason = reason;
    this.privProperties = new Exports_js_2.PropertyCollection();
    if (reason === Exports_js_2.ResultReason.Canceled) {
      Contracts_js_1.Contracts.throwIfNullOrUndefined(statusText, "statusText");
      this.privErrorDetails = statusText;
      this.privProperties.setProperty(Exports_js_1.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.ServiceError]);
    }
  }
  get reason() {
    return this.privReason;
  }
  get properties() {
    return this.privProperties;
  }
  get errorDetails() {
    return this.privErrorDetails;
  }
}
exports.VoiceProfileResult = VoiceProfileResult;
/**
 * @class VoiceProfileCancellationDetails
 */
class VoiceProfileCancellationDetails extends Exports_js_2.CancellationDetailsBase {
  constructor(reason, errorDetails, errorCode) {
    super(reason, errorDetails, errorCode);
  }
  /**
   * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
   * @member VoiceProfileCancellationDetails.fromResult
   * @function
   * @public
   * @param {VoiceProfileResult} result - The result that was canceled.
   * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
   */
  static fromResult(result) {
    const reason = Exports_js_2.CancellationReason.Error;
    let errorCode = Exports_js_2.CancellationErrorCode.NoError;
    if (!!result.properties) {
      errorCode = Exports_js_2.CancellationErrorCode[result.properties.getProperty(Exports_js_1.CancellationErrorCodePropertyName, Exports_js_2.CancellationErrorCode[Exports_js_2.CancellationErrorCode.NoError])]; //eslint-disable-line
    }
    return new VoiceProfileCancellationDetails(reason, result.errorDetails, errorCode);
  }
}
exports.VoiceProfileCancellationDetails = VoiceProfileCancellationDetails;

/***/ }),

/***/ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileType.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/src/sdk/VoiceProfileType.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VoiceProfileType = void 0;
/**
 * Output format
 * @class VoiceProfileType
 */
var VoiceProfileType;
(function (VoiceProfileType) {
  /**
   * Text independent speaker identification
   * @member VoiceProfileType.TextIndependentIdentification
   */
  VoiceProfileType[VoiceProfileType["TextIndependentIdentification"] = 0] = "TextIndependentIdentification";
  /**
   * Text dependent speaker verification
   * @member VoiceProfileType.TextDependentVerification
   */
  VoiceProfileType[VoiceProfileType["TextDependentVerification"] = 1] = "TextDependentVerification";
  /**
   * Text independent speaker verification
   * @member VoiceProfileType.TextIndependentVerification
   */
  VoiceProfileType[VoiceProfileType["TextIndependentVerification"] = 2] = "TextIndependentVerification";
})(VoiceProfileType = exports.VoiceProfileType || (exports.VoiceProfileType = {}));

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom-client.development.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom-client.development.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom-client.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


 true && function () {
  function findHook(fiber, id) {
    for (fiber = fiber.memoizedState; null !== fiber && 0 < id;) fiber = fiber.next, id--;
    return fiber;
  }
  function copyWithSetImpl(obj, path, index, value) {
    if (index >= path.length) return value;
    var key = path[index],
      updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
    return updated;
  }
  function copyWithRename(obj, oldPath, newPath) {
    if (oldPath.length !== newPath.length) console.warn("copyWithRename() expects paths of the same length");else {
      for (var i = 0; i < newPath.length - 1; i++) if (oldPath[i] !== newPath[i]) {
        console.warn("copyWithRename() expects paths to be the same except for the deepest key");
        return;
      }
      return copyWithRenameImpl(obj, oldPath, newPath, 0);
    }
  }
  function copyWithRenameImpl(obj, oldPath, newPath, index) {
    var oldKey = oldPath[index],
      updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
    index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);
    return updated;
  }
  function copyWithDeleteImpl(obj, path, index) {
    var key = path[index],
      updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
    if (index + 1 === path.length) return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
    return updated;
  }
  function shouldSuspendImpl() {
    return !1;
  }
  function shouldErrorImpl() {
    return null;
  }
  function createFiber(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }
  function warnInvalidHookAccess() {
    console.error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks");
  }
  function warnInvalidContextAccess() {
    console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
  }
  function noop$2() {}
  function warnForMissingKey() {}
  function setToSortedString(set) {
    var array = [];
    set.forEach(function (value) {
      array.push(value);
    });
    return array.sort().join(", ");
  }
  function scheduleRoot(root, element) {
    root.context === emptyContextObject && (updateContainerSync(element, root, null, null), flushSyncWork$1());
  }
  function scheduleRefresh(root, update) {
    if (null !== resolveFamily) {
      var staleFamilies = update.staleFamilies;
      update = update.updatedFamilies;
      flushPassiveEffects();
      scheduleFibersWithFamiliesRecursively(root.current, update, staleFamilies);
      flushSyncWork$1();
    }
  }
  function setRefreshHandler(handler) {
    resolveFamily = handler;
  }
  function isValidContainer(node) {
    return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
  }
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
    }
    if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
    return null;
  }
  function getComponentNameFromOwner(owner) {
    return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
  }
  function getComponentNameFromFiber(fiber) {
    var type = fiber.type;
    switch (fiber.tag) {
      case 24:
        return "Cache";
      case 9:
        return (type._context.displayName || "Context") + ".Consumer";
      case 10:
        return (type.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 26:
      case 27:
      case 5:
        return type;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return getComponentNameFromType(type);
      case 8:
        return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 14:
      case 15:
        if ("function" === typeof type) return type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        break;
      case 29:
        type = fiber._debugInfo;
        if (null != type) for (var i = type.length - 1; 0 <= i; i--) if ("string" === typeof type[i].name) return type[i].name;
        if (null !== fiber.return) return getComponentNameFromFiber(fiber.return);
    }
    return null;
  }
  function disabledLog() {}
  function disableLogs() {
    if (0 === disabledDepth) {
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd;
      var props = {
        configurable: !0,
        enumerable: !0,
        value: disabledLog,
        writable: !0
      };
      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
    }
    disabledDepth++;
  }
  function reenableLogs() {
    disabledDepth--;
    if (0 === disabledDepth) {
      var props = {
        configurable: !0,
        enumerable: !0,
        writable: !0
      };
      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
    }
    0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
  }
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix) try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + prefix + name + suffix;
  }
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    var frame = componentFrameCache.get(fn);
    if (void 0 !== frame) return frame;
    reentry = !0;
    frame = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    var previousDispatcher = null;
    previousDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = null;
    disableLogs();
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: function () {
          try {
            if (construct) {
              var Fake = function () {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function () {
                  throw Error();
                }
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  var control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$0) {
                  control = x$0;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$1) {
                control = x$1;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
          }
          return [null, null];
        }
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
        value: "DetermineComponentFrameRoot"
      });
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
        sampleStack = _RunInRootFrame$Deter[0],
        controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"),
          controlLines = controlStack.split("\n");
        for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
        for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
        if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
        for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
          if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
            do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
              fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
              "function" === typeof fn && componentFrameCache.set(fn, _frame);
              return _frame;
            } while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
          }
          break;
        }
      }
    } finally {
      reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
    }
    sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
    "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
    return sampleLines;
  }
  function describeFiber(fiber) {
    switch (fiber.tag) {
      case 26:
      case 27:
      case 5:
        return describeBuiltInComponentFrame(fiber.type);
      case 16:
        return describeBuiltInComponentFrame("Lazy");
      case 13:
        return describeBuiltInComponentFrame("Suspense");
      case 19:
        return describeBuiltInComponentFrame("SuspenseList");
      case 0:
      case 15:
        return fiber = describeNativeComponentFrame(fiber.type, !1), fiber;
      case 11:
        return fiber = describeNativeComponentFrame(fiber.type.render, !1), fiber;
      case 1:
        return fiber = describeNativeComponentFrame(fiber.type, !0), fiber;
      default:
        return "";
    }
  }
  function getStackByFiberInDevAndProd(workInProgress) {
    try {
      var info = "";
      do {
        info += describeFiber(workInProgress);
        var debugInfo = workInProgress._debugInfo;
        if (debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) {
          var entry = debugInfo[i];
          if ("string" === typeof entry.name) {
            var JSCompiler_temp_const = info,
              env = entry.env;
            var JSCompiler_inline_result = describeBuiltInComponentFrame(entry.name + (env ? " [" + env + "]" : ""));
            info = JSCompiler_temp_const + JSCompiler_inline_result;
          }
        }
        workInProgress = workInProgress.return;
      } while (workInProgress);
      return info;
    } catch (x) {
      return "\nError generating stack: " + x.message + "\n" + x.stack;
    }
  }
  function getCurrentFiberOwnerNameInDevOrNull() {
    if (null === current) return null;
    var owner = current._debugOwner;
    return null != owner ? getComponentNameFromOwner(owner) : null;
  }
  function getCurrentFiberStackInDev() {
    return null === current ? "" : getStackByFiberInDevAndProd(current);
  }
  function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
    var previousFiber = current;
    ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
    isRendering = !1;
    current = fiber;
    try {
      return callback(arg0, arg1, arg2, arg3, arg4);
    } finally {
      current = previousFiber;
    }
    throw Error("runWithFiberInDEV should never be called in production. This is a bug in React.");
  }
  function getNearestMountedFiber(fiber) {
    var node = fiber,
      nearestMounted = fiber;
    if (fiber.alternate) for (; node.return;) node = node.return;else {
      fiber = node;
      do node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return; while (fiber);
    }
    return 3 === node.tag ? nearestMounted : null;
  }
  function getSuspenseInstanceFromFiber(fiber) {
    if (13 === fiber.tag) {
      var suspenseState = fiber.memoizedState;
      null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
      if (null !== suspenseState) return suspenseState.dehydrated;
    }
    return null;
  }
  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber) throw Error("Unable to find node on an unmounted component.");
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      alternate = getNearestMountedFiber(fiber);
      if (null === alternate) throw Error("Unable to find node on an unmounted component.");
      return alternate !== fiber ? null : fiber;
    }
    for (var a = fiber, b = alternate;;) {
      var parentA = a.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;
      if (null === parentB) {
        b = parentA.return;
        if (null !== b) {
          a = b;
          continue;
        }
        break;
      }
      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB;) {
          if (parentB === a) return assertIsMounted(parentA), fiber;
          if (parentB === b) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }
        throw Error("Unable to find node on an unmounted component.");
      }
      if (a.return !== b.return) a = parentA, b = parentB;else {
        for (var didFindChild = !1, _child = parentA.child; _child;) {
          if (_child === a) {
            didFindChild = !0;
            a = parentA;
            b = parentB;
            break;
          }
          if (_child === b) {
            didFindChild = !0;
            b = parentA;
            a = parentB;
            break;
          }
          _child = _child.sibling;
        }
        if (!didFindChild) {
          for (_child = parentB.child; _child;) {
            if (_child === a) {
              didFindChild = !0;
              a = parentB;
              b = parentA;
              break;
            }
            if (_child === b) {
              didFindChild = !0;
              b = parentB;
              a = parentA;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
        }
      }
      if (a.alternate !== b) throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
    }
    if (3 !== a.tag) throw Error("Unable to find node on an unmounted component.");
    return a.stateNode.current === a ? fiber : alternate;
  }
  function findCurrentHostFiberImpl(node) {
    var tag = node.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
    for (node = node.child; null !== node;) {
      tag = findCurrentHostFiberImpl(node);
      if (null !== tag) return tag;
      node = node.sibling;
    }
    return null;
  }
  function createCursor(defaultValue) {
    return {
      current: defaultValue
    };
  }
  function pop(cursor, fiber) {
    0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
  }
  function push(cursor, value, fiber) {
    index$jscomp$0++;
    valueStack[index$jscomp$0] = cursor.current;
    fiberStack[index$jscomp$0] = fiber;
    cursor.current = value;
  }
  function requiredContext(c) {
    null === c && console.error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
    return c;
  }
  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance, fiber);
    push(contextFiberStackCursor, fiber, fiber);
    push(contextStackCursor, null, fiber);
    var nextRootContext = nextRootInstance.nodeType;
    switch (nextRootContext) {
      case 9:
      case 11:
        nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
        nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
        break;
      default:
        if (nextRootInstance = 8 === nextRootContext ? nextRootInstance.parentNode : nextRootInstance, nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI) nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(nextRootInstance, nextRootContext);else switch (nextRootContext) {
          case "svg":
            nextRootInstance = HostContextNamespaceSvg;
            break;
          case "math":
            nextRootInstance = HostContextNamespaceMath;
            break;
          default:
            nextRootInstance = HostContextNamespaceNone;
        }
    }
    nextRootContext = nextRootContext.toLowerCase();
    nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
    nextRootContext = {
      context: nextRootInstance,
      ancestorInfo: nextRootContext
    };
    pop(contextStackCursor, fiber);
    push(contextStackCursor, nextRootContext, fiber);
  }
  function popHostContainer(fiber) {
    pop(contextStackCursor, fiber);
    pop(contextFiberStackCursor, fiber);
    pop(rootInstanceStackCursor, fiber);
  }
  function getHostContext() {
    return requiredContext(contextStackCursor.current);
  }
  function pushHostContext(fiber) {
    null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
    var context = requiredContext(contextStackCursor.current);
    var type = fiber.type;
    var nextContext = getChildHostContextProd(context.context, type);
    type = updatedAncestorInfoDev(context.ancestorInfo, type);
    nextContext = {
      context: nextContext,
      ancestorInfo: type
    };
    context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
  }
  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
    hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
  }
  function typeName(value) {
    return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
  }
  function willCoercionThrow(value) {
    try {
      return testStringCoercion(value), !1;
    } catch (e) {
      return !0;
    }
  }
  function testStringCoercion(value) {
    return "" + value;
  }
  function checkAttributeStringCoercion(value, attributeName) {
    if (willCoercionThrow(value)) return console.error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.", attributeName, typeName(value)), testStringCoercion(value);
  }
  function checkCSSPropertyStringCoercion(value, propName) {
    if (willCoercionThrow(value)) return console.error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.", propName, typeName(value)), testStringCoercion(value);
  }
  function checkFormFieldValueStringCoercion(value) {
    if (willCoercionThrow(value)) return console.error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.", typeName(value)), testStringCoercion(value);
  }
  function injectInternals(internals) {
    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook.isDisabled) return !0;
    if (!hook.supportsFiber) return console.error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"), !0;
    try {
      rendererID = hook.inject(internals), injectedHook = hook;
    } catch (err) {
      console.error("React instrumentation encountered an error: %s.", err);
    }
    return hook.checkDCE ? !0 : !1;
  }
  function onCommitRoot$1(root, eventPriority) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot) try {
      var didError = 128 === (root.current.flags & 128);
      switch (eventPriority) {
        case DiscreteEventPriority:
          var schedulerPriority = ImmediatePriority;
          break;
        case ContinuousEventPriority:
          schedulerPriority = UserBlockingPriority;
          break;
        case DefaultEventPriority:
          schedulerPriority = NormalPriority$1;
          break;
        case IdleEventPriority:
          schedulerPriority = IdlePriority;
          break;
        default:
          schedulerPriority = NormalPriority$1;
      }
      injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);
    } catch (err) {
      hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
    }
  }
  function setIsStrictModeForDevtools(newIsStrictMode) {
    "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
    if (injectedHook && "function" === typeof injectedHook.setStrictMode) try {
      injectedHook.setStrictMode(rendererID, newIsStrictMode);
    } catch (err) {
      hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
    }
  }
  function injectProfilingHooks(profilingHooks) {
    injectedProfilingHooks = profilingHooks;
  }
  function markCommitStopped() {
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
  }
  function markComponentRenderStarted(fiber) {
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
  }
  function markComponentRenderStopped() {
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
  }
  function markRenderStarted(lanes) {
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
  }
  function markRenderStopped() {
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
  }
  function markStateUpdateScheduled(fiber, lane) {
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
  }
  function clz32Fallback(x) {
    x >>>= 0;
    return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
  }
  function getLabelForLane(lane) {
    if (lane & 1) return "SyncHydrationLane";
    if (lane & 2) return "Sync";
    if (lane & 4) return "InputContinuousHydration";
    if (lane & 8) return "InputContinuous";
    if (lane & 16) return "DefaultHydration";
    if (lane & 32) return "Default";
    if (lane & 64) return "TransitionHydration";
    if (lane & 4194176) return "Transition";
    if (lane & 62914560) return "Retry";
    if (lane & 67108864) return "SelectiveHydration";
    if (lane & 134217728) return "IdleHydration";
    if (lane & 268435456) return "Idle";
    if (lane & 536870912) return "Offscreen";
    if (lane & 1073741824) return "Deferred";
  }
  function getHighestPriorityLanes(lanes) {
    var pendingSyncLanes = lanes & 42;
    if (0 !== pendingSyncLanes) return pendingSyncLanes;
    switch (lanes & -lanes) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return lanes & 4194176;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return lanes & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return console.error("Should have found matching lanes. This is a bug in React."), lanes;
    }
  }
  function getNextLanes(root, wipLanes) {
    var pendingLanes = root.pendingLanes;
    if (0 === pendingLanes) return 0;
    var nextLanes = 0,
      suspendedLanes = root.suspendedLanes,
      pingedLanes = root.pingedLanes,
      warmLanes = root.warmLanes;
    root = 0 !== root.finishedLanes;
    var nonIdlePendingLanes = pendingLanes & 134217727;
    0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = nonIdlePendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : root || (warmLanes = pendingLanes & ~warmLanes, 0 !== warmLanes && (nextLanes = getHighestPriorityLanes(warmLanes))));
    return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, warmLanes = wipLanes & -wipLanes, suspendedLanes >= warmLanes || 32 === suspendedLanes && 0 !== (warmLanes & 4194176)) ? wipLanes : nextLanes;
  }
  function checkIfRootIsPrerendering(root, renderLanes) {
    return 0 === (root.pendingLanes & ~(root.suspendedLanes & ~root.pingedLanes) & renderLanes);
  }
  function computeExpirationTime(lane, currentTime) {
    switch (lane) {
      case 1:
      case 2:
      case 4:
      case 8:
        return currentTime + 250;
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return currentTime + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return console.error("Should have found matching lanes. This is a bug in React."), -1;
    }
  }
  function claimNextTransitionLane() {
    var lane = nextTransitionLane;
    nextTransitionLane <<= 1;
    0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);
    return lane;
  }
  function claimNextRetryLane() {
    var lane = nextRetryLane;
    nextRetryLane <<= 1;
    0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
    return lane;
  }
  function createLaneMap(initial) {
    for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
    return laneMap;
  }
  function markRootUpdated$1(root, updateLane) {
    root.pendingLanes |= updateLane;
    268435456 !== updateLane && (root.suspendedLanes = 0, root.pingedLanes = 0, root.warmLanes = 0);
  }
  function markRootFinished(root, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
    var previouslyPendingLanes = root.pendingLanes;
    root.pendingLanes = remainingLanes;
    root.suspendedLanes = 0;
    root.pingedLanes = 0;
    root.warmLanes = 0;
    root.expiredLanes &= remainingLanes;
    root.entangledLanes &= remainingLanes;
    root.errorRecoveryDisabledLanes &= remainingLanes;
    root.shellSuspendCounter = 0;
    var entanglements = root.entanglements,
      expirationTimes = root.expirationTimes,
      hiddenUpdates = root.hiddenUpdates;
    for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes;) {
      var index = 31 - clz32(remainingLanes),
        lane = 1 << index;
      entanglements[index] = 0;
      expirationTimes[index] = -1;
      var hiddenUpdatesForLane = hiddenUpdates[index];
      if (null !== hiddenUpdatesForLane) for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
        var update = hiddenUpdatesForLane[index];
        null !== update && (update.lane &= -536870913);
      }
      remainingLanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);
    0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root.tag && (root.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
  }
  function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {
    root.pendingLanes |= spawnedLane;
    root.suspendedLanes &= ~spawnedLane;
    var spawnedLaneIndex = 31 - clz32(spawnedLane);
    root.entangledLanes |= spawnedLane;
    root.entanglements[spawnedLaneIndex] = root.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194218;
  }
  function markRootEntangled(root, entangledLanes) {
    var rootEntangledLanes = root.entangledLanes |= entangledLanes;
    for (root = root.entanglements; rootEntangledLanes;) {
      var index = 31 - clz32(rootEntangledLanes),
        lane = 1 << index;
      lane & entangledLanes | root[index] & entangledLanes && (root[index] |= entangledLanes);
      rootEntangledLanes &= ~lane;
    }
  }
  function addFiberToLanesMap(root, fiber, lanes) {
    if (isDevToolsPresent) for (root = root.pendingUpdatersLaneMap; 0 < lanes;) {
      var index = 31 - clz32(lanes),
        lane = 1 << index;
      root[index].add(fiber);
      lanes &= ~lane;
    }
  }
  function movePendingFibersToMemoized(root, lanes) {
    if (isDevToolsPresent) for (var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap, memoizedUpdaters = root.memoizedUpdaters; 0 < lanes;) {
      var index = 31 - clz32(lanes);
      root = 1 << index;
      index = pendingUpdatersLaneMap[index];
      0 < index.size && (index.forEach(function (fiber) {
        var alternate = fiber.alternate;
        null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
      }), index.clear());
      lanes &= ~root;
    }
  }
  function lanesToEventPriority(lanes) {
    lanes &= -lanes;
    return 0 !== DiscreteEventPriority && DiscreteEventPriority < lanes ? 0 !== ContinuousEventPriority && ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
  }
  function resolveUpdatePriority() {
    var updatePriority = ReactDOMSharedInternals.p;
    if (0 !== updatePriority) return updatePriority;
    updatePriority = window.event;
    return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
  }
  function runWithPriority(priority, fn) {
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      return ReactDOMSharedInternals.p = priority, fn();
    } finally {
      ReactDOMSharedInternals.p = previousPriority;
    }
  }
  function detachDeletedInstance(node) {
    delete node[internalInstanceKey];
    delete node[internalPropsKey];
    delete node[internalEventHandlersKey];
    delete node[internalEventHandlerListenersKey];
    delete node[internalEventHandlesSetKey];
  }
  function getClosestInstanceFromNode(targetNode) {
    var targetInst = targetNode[internalInstanceKey];
    if (targetInst) return targetInst;
    for (var parentNode = targetNode.parentNode; parentNode;) {
      if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
        parentNode = targetInst.alternate;
        if (null !== targetInst.child || null !== parentNode && null !== parentNode.child) for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode;) {
          if (parentNode = targetNode[internalInstanceKey]) return parentNode;
          targetNode = getParentSuspenseInstance(targetNode);
        }
        return targetInst;
      }
      targetNode = parentNode;
      parentNode = targetNode.parentNode;
    }
    return null;
  }
  function getInstanceFromNode(node) {
    if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
      var tag = node.tag;
      if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag) return node;
    }
    return null;
  }
  function getNodeFromInstance(inst) {
    var tag = inst.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
    throw Error("getNodeFromInstance: Invalid argument.");
  }
  function getResourcesFromRoot(root) {
    var resources = root[internalRootNodeResourcesKey];
    resources || (resources = root[internalRootNodeResourcesKey] = {
      hoistableStyles: new Map(),
      hoistableScripts: new Map()
    });
    return resources;
  }
  function markNodeAsHoistable(node) {
    node[internalHoistableMarker] = !0;
  }
  function registerTwoPhaseEvent(registrationName, dependencies) {
    registerDirectEvent(registrationName, dependencies);
    registerDirectEvent(registrationName + "Capture", dependencies);
  }
  function registerDirectEvent(registrationName, dependencies) {
    registrationNameDependencies[registrationName] && console.error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
    registrationNameDependencies[registrationName] = dependencies;
    var lowerCasedName = registrationName.toLowerCase();
    possibleRegistrationNames[lowerCasedName] = registrationName;
    "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
    for (registrationName = 0; registrationName < dependencies.length; registrationName++) allNativeEvents.add(dependencies[registrationName]);
  }
  function checkControlledValueProps(tagName, props) {
    hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`.") : console.error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."));
    props.onChange || props.readOnly || props.disabled || null == props.checked || console.error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
  }
  function isAttributeNameSafe(attributeName) {
    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) return !0;
    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) return validatedAttributeNameCache[attributeName] = !0;
    illegalAttributeNameCache[attributeName] = !0;
    console.error("Invalid attribute name: `%s`", attributeName);
    return !1;
  }
  function getValueForAttributeOnCustomComponent(node, name, expected) {
    if (isAttributeNameSafe(name)) {
      if (!node.hasAttribute(name)) {
        switch (typeof expected) {
          case "symbol":
          case "object":
            return expected;
          case "function":
            return expected;
          case "boolean":
            if (!1 === expected) return expected;
        }
        return void 0 === expected ? void 0 : null;
      }
      node = node.getAttribute(name);
      if ("" === node && !0 === expected) return !0;
      checkAttributeStringCoercion(expected, name);
      return node === "" + expected ? expected : node;
    }
  }
  function setValueForAttribute(node, name, value) {
    if (isAttributeNameSafe(name)) if (null === value) node.removeAttribute(name);else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
          node.removeAttribute(name);
          return;
        case "boolean":
          var prefix = name.toLowerCase().slice(0, 5);
          if ("data-" !== prefix && "aria-" !== prefix) {
            node.removeAttribute(name);
            return;
          }
      }
      checkAttributeStringCoercion(value, name);
      node.setAttribute(name, "" + value);
    }
  }
  function setValueForKnownAttribute(node, name, value) {
    if (null === value) node.removeAttribute(name);else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      checkAttributeStringCoercion(value, name);
      node.setAttribute(name, "" + value);
    }
  }
  function setValueForNamespacedAttribute(node, namespace, name, value) {
    if (null === value) node.removeAttribute(name);else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      checkAttributeStringCoercion(value, name);
      node.setAttributeNS(namespace, name, "" + value);
    }
  }
  function getToStringValue(value) {
    switch (typeof value) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return value;
      case "object":
        return checkFormFieldValueStringCoercion(value), value;
      default:
        return "";
    }
  }
  function isCheckable(elem) {
    var type = elem.type;
    return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
  }
  function trackValueOnNode(node) {
    var valueField = isCheckable(node) ? "checked" : "value",
      descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
    checkFormFieldValueStringCoercion(node[valueField]);
    var currentValue = "" + node[valueField];
    if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
      var get = descriptor.get,
        set = descriptor.set;
      Object.defineProperty(node, valueField, {
        configurable: !0,
        get: function () {
          return get.call(this);
        },
        set: function (value) {
          checkFormFieldValueStringCoercion(value);
          currentValue = "" + value;
          set.call(this, value);
        }
      });
      Object.defineProperty(node, valueField, {
        enumerable: descriptor.enumerable
      });
      return {
        getValue: function () {
          return currentValue;
        },
        setValue: function (value) {
          checkFormFieldValueStringCoercion(value);
          currentValue = "" + value;
        },
        stopTracking: function () {
          node._valueTracker = null;
          delete node[valueField];
        }
      };
    }
  }
  function track(node) {
    node._valueTracker || (node._valueTracker = trackValueOnNode(node));
  }
  function updateValueIfChanged(node) {
    if (!node) return !1;
    var tracker = node._valueTracker;
    if (!tracker) return !0;
    var lastValue = tracker.getValue();
    var value = "";
    node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
    node = value;
    return node !== lastValue ? (tracker.setValue(node), !0) : !1;
  }
  function getActiveElement(doc) {
    doc = doc || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof doc) return null;
    try {
      return doc.activeElement || doc.body;
    } catch (e) {
      return doc.body;
    }
  }
  function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
    return value.replace(escapeSelectorAttributeValueInsideDoubleQuotesRegex, function (ch) {
      return "\\" + ch.charCodeAt(0).toString(16) + " ";
    });
  }
  function validateInputProps(element, props) {
    void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnCheckedDefaultChecked = !0);
    void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnValueDefaultValue$1 = !0);
  }
  function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
    element.name = "";
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
    if (null != value) {
      if ("number" === type) {
        if (0 === value && "" === element.value || element.value != value) element.value = "" + getToStringValue(value);
      } else element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
    } else "submit" !== type && "reset" !== type || element.removeAttribute("value");
    null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
    null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
    null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
  }
  function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating) {
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
    if (null != value || null != defaultValue) {
      if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) return;
      defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      value = null != value ? "" + getToStringValue(value) : defaultValue;
      isHydrating || value === element.value || (element.value = value);
      element.defaultValue = value;
    }
    checked = null != checked ? checked : defaultChecked;
    checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
    element.checked = isHydrating ? element.checked : !!checked;
    element.defaultChecked = !!checked;
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
  }
  function setDefaultValue(node, type, value) {
    "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
  }
  function validateOptionProps(element, props) {
    null == props.value && ("object" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function (child) {
      null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = !0, console.error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."));
    }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = !0, console.error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")));
    null == props.selected || didWarnSelectedSetOnOption || (console.error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
  }
  function getDeclarationErrorAddendum() {
    var ownerName = getCurrentFiberOwnerNameInDevOrNull();
    return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
  }
  function updateOptions(node, multiple, propValue, setDefaultSelected) {
    node = node.options;
    if (multiple) {
      multiple = {};
      for (var i = 0; i < propValue.length; i++) multiple["$" + propValue[i]] = !0;
      for (propValue = 0; propValue < node.length; propValue++) i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = !0);
    } else {
      propValue = "" + getToStringValue(propValue);
      multiple = null;
      for (i = 0; i < node.length; i++) {
        if (node[i].value === propValue) {
          node[i].selected = !0;
          setDefaultSelected && (node[i].defaultSelected = !0);
          return;
        }
        null !== multiple || node[i].disabled || (multiple = node[i]);
      }
      null !== multiple && (multiple.selected = !0);
    }
  }
  function validateSelectProps(element, props) {
    for (element = 0; element < valuePropNames.length; element++) {
      var propName = valuePropNames[element];
      if (null != props[propName]) {
        var propNameIsArray = isArrayImpl(props[propName]);
        props.multiple && !propNameIsArray ? console.error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !props.multiple && propNameIsArray && console.error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
      }
    }
    void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"), didWarnValueDefaultValue = !0);
  }
  function validateTextareaProps(element, props) {
    void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component"), didWarnValDefaultVal = !0);
    null != props.children && null == props.value && console.error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
  }
  function updateTextarea(element, value, defaultValue) {
    if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
      element.defaultValue !== value && (element.defaultValue = value);
      return;
    }
    element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
  }
  function initTextarea(element, value, defaultValue, children) {
    if (null == value) {
      if (null != children) {
        if (null != defaultValue) throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
        if (isArrayImpl(children)) {
          if (1 < children.length) throw Error("<textarea> can only have at most one child.");
          children = children[0];
        }
        defaultValue = children;
      }
      null == defaultValue && (defaultValue = "");
      value = defaultValue;
    }
    defaultValue = getToStringValue(value);
    element.defaultValue = defaultValue;
    children = element.textContent;
    children === defaultValue && "" !== children && null !== children && (element.value = children);
  }
  function findNotableNode(node, indent) {
    return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
  }
  function indentation(indent) {
    return "  " + "  ".repeat(indent);
  }
  function added(indent) {
    return "+ " + "  ".repeat(indent);
  }
  function removed(indent) {
    return "- " + "  ".repeat(indent);
  }
  function describeFiberType(fiber) {
    switch (fiber.tag) {
      case 26:
      case 27:
      case 5:
        return fiber.type;
      case 16:
        return "Lazy";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 0:
      case 15:
        return fiber = fiber.type, fiber.displayName || fiber.name || null;
      case 11:
        return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
      case 1:
        return fiber = fiber.type, fiber.displayName || fiber.name || null;
      default:
        return null;
    }
  }
  function describeTextNode(content, maxLength) {
    return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
  }
  function describeTextDiff(clientText, serverProps, indent) {
    var maxLength = 120 - 2 * indent;
    if (null === serverProps) return added(indent) + describeTextNode(clientText, maxLength) + "\n";
    if ("string" === typeof serverProps) {
      for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++);
      firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
      return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
    }
    return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
  }
  function objectName(object) {
    return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function (m, p0) {
      return p0;
    });
  }
  function describeValue(value, maxLength) {
    switch (typeof value) {
      case "string":
        return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
      case "object":
        if (null === value) return "null";
        if (isArrayImpl(value)) return "[...]";
        if (value.$$typeof === REACT_ELEMENT_TYPE) return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
        var name = objectName(value);
        if ("Object" === name) {
          name = "";
          maxLength -= 2;
          for (var propName in value) if (value.hasOwnProperty(propName)) {
            var jsonPropName = JSON.stringify(propName);
            jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
            maxLength -= propName.length - 2;
            jsonPropName = describeValue(value[propName], 15 > maxLength ? maxLength : 15);
            maxLength -= jsonPropName.length;
            if (0 > maxLength) {
              name += "" === name ? "..." : ", ...";
              break;
            }
            name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
          }
          return "{" + name + "}";
        }
        return name;
      case "function":
        return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
      default:
        return String(value);
    }
  }
  function describePropValue(value, maxLength) {
    return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
  }
  function describeExpandedElement(type, props, rowPrefix) {
    var remainingRowLength = 120 - rowPrefix.length - type.length,
      properties = [],
      propName;
    for (propName in props) if (props.hasOwnProperty(propName) && "children" !== propName) {
      var propValue = describePropValue(props[propName], 120 - rowPrefix.length - propName.length - 1);
      remainingRowLength -= propName.length + propValue.length + 2;
      properties.push(propName + "=" + propValue);
    }
    return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
  }
  function describePropertiesDiff(clientObject, serverObject, indent) {
    var properties = "",
      remainingServerProperties = assign({}, serverObject),
      propName;
    for (propName in clientObject) if (clientObject.hasOwnProperty(propName)) {
      delete remainingServerProperties[propName];
      var maxLength = 120 - 2 * indent - propName.length - 2,
        clientPropValue = describeValue(clientObject[propName], maxLength);
      serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
    }
    for (var _propName in remainingServerProperties) remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(remainingServerProperties[_propName], 120 - 2 * indent - _propName.length - 2), properties += removed(indent) + _propName + ": " + clientObject + "\n");
    return properties;
  }
  function describeElementDiff(type, clientProps, serverProps, indent) {
    var content = "",
      serverPropNames = new Map();
    for (propName$jscomp$0 in serverProps) serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(propName$jscomp$0.toLowerCase(), propName$jscomp$0);
    if (1 === serverPropNames.size && serverPropNames.has("children")) content += describeExpandedElement(type, clientProps, indentation(indent));else {
      for (var _propName2 in clientProps) if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
        var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1,
          serverPropName = serverPropNames.get(_propName2.toLowerCase());
        if (void 0 !== serverPropName) {
          serverPropNames.delete(_propName2.toLowerCase());
          var propName$jscomp$0 = clientProps[_propName2];
          serverPropName = serverProps[serverPropName];
          var clientPropValue = describePropValue(propName$jscomp$0, maxLength$jscomp$0);
          maxLength$jscomp$0 = describePropValue(serverPropName, maxLength$jscomp$0);
          "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(propName$jscomp$0, serverPropName, indent + 2) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
        } else content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
      }
      serverPropNames.forEach(function (propName) {
        if ("children" !== propName) {
          var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
          content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
        }
      });
      content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
    }
    type = serverProps.children;
    clientProps = clientProps.children;
    if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
      serverPropNames = "";
      if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) serverPropNames = "" + clientProps;
      content += describeTextDiff(serverPropNames, "" + type, indent + 1);
    } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps) content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
    return content;
  }
  function describeSiblingFiber(fiber, indent) {
    var type = describeFiberType(fiber);
    if (null === type) {
      type = "";
      for (fiber = fiber.child; fiber;) type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
      return type;
    }
    return indentation(indent) + "<" + type + ">\n";
  }
  function describeNode(node, indent) {
    var skipToNode = findNotableNode(node, indent);
    if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode)) return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
    skipToNode = "";
    var debugInfo = node.fiber._debugInfo;
    if (debugInfo) for (var i = 0; i < debugInfo.length; i++) {
      var serverComponentName = debugInfo[i].name;
      "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
    }
    debugInfo = "";
    i = node.fiber.pendingProps;
    if (6 === node.fiber.tag) debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName) if (void 0 === node.serverProps) {
      debugInfo = indent;
      var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2,
        content = "";
      for (propName in i) if (i.hasOwnProperty(propName) && "children" !== propName) {
        var propValue = describePropValue(i[propName], 15);
        maxLength -= propName.length + propValue.length + 2;
        if (0 > maxLength) {
          content += " ...";
          break;
        }
        content += " " + propName + "=" + propValue;
      }
      debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
      indent++;
    } else null === node.serverProps ? (debugInfo = describeExpandedElement(serverComponentName, i, added(indent)), indent++) : "string" === typeof node.serverProps ? console.error("Should not have matched a non HostText fiber to a Text node. This is a bug in React.") : (debugInfo = describeElementDiff(serverComponentName, i, node.serverProps, indent), indent++);
    var propName = "";
    i = node.fiber.child;
    for (serverComponentName = 0; i && serverComponentName < node.children.length;) maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
    i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
    i = node.serverTail;
    null === node.serverProps && indent--;
    for (node = 0; node < i.length; node++) serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(serverComponentName.type, serverComponentName.props, removed(indent));
    return skipToNode + debugInfo + propName;
  }
  function describeDiff(rootNode) {
    try {
      return "\n\n" + describeNode(rootNode, 0);
    } catch (x) {
      return "";
    }
  }
  function describeAncestors(ancestor, child, props) {
    for (var fiber = child, node = null, distanceFromLeaf = 0; fiber;) fiber === ancestor && (distanceFromLeaf = 0), node = {
      fiber: fiber,
      children: null !== node ? [node] : [],
      serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
      serverTail: [],
      distanceFromLeaf: distanceFromLeaf
    }, distanceFromLeaf++, fiber = fiber.return;
    return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
  }
  function updatedAncestorInfoDev(oldInfo, tag) {
    oldInfo = assign({}, oldInfo || emptyAncestorInfoDev);
    var info = {
      tag: tag
    };
    -1 !== inScopeTags.indexOf(tag) && (oldInfo.aTagInScope = null, oldInfo.buttonTagInScope = null, oldInfo.nobrTagInScope = null);
    -1 !== buttonScopeTags.indexOf(tag) && (oldInfo.pTagInButtonScope = null);
    -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (oldInfo.listItemTagAutoclosing = null, oldInfo.dlItemTagAutoclosing = null);
    oldInfo.current = info;
    "form" === tag && (oldInfo.formTag = info);
    "a" === tag && (oldInfo.aTagInScope = info);
    "button" === tag && (oldInfo.buttonTagInScope = info);
    "nobr" === tag && (oldInfo.nobrTagInScope = info);
    "p" === tag && (oldInfo.pTagInButtonScope = info);
    "li" === tag && (oldInfo.listItemTagAutoclosing = info);
    if ("dd" === tag || "dt" === tag) oldInfo.dlItemTagAutoclosing = info;
    "#document" === tag || "html" === tag ? oldInfo.containerTagInScope = null : oldInfo.containerTagInScope || (oldInfo.containerTagInScope = info);
    return oldInfo;
  }
  function isTagValidWithParent(tag, parentTag) {
    switch (parentTag) {
      case "select":
        return "hr" === tag || "option" === tag || "optgroup" === tag || "#text" === tag;
      case "optgroup":
        return "option" === tag || "#text" === tag;
      case "option":
        return "#text" === tag;
      case "tr":
        return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
      case "tbody":
      case "thead":
      case "tfoot":
        return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
      case "colgroup":
        return "col" === tag || "template" === tag;
      case "table":
        return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
      case "head":
        return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
      case "html":
        return "head" === tag || "body" === tag || "frameset" === tag;
      case "frameset":
        return "frame" === tag;
      case "#document":
        return "html" === tag;
    }
    switch (tag) {
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
      case "rp":
      case "rt":
        return -1 === impliedEndTags.indexOf(parentTag);
      case "body":
      case "caption":
      case "col":
      case "colgroup":
      case "frameset":
      case "frame":
      case "head":
      case "html":
      case "tbody":
      case "td":
      case "tfoot":
      case "th":
      case "thead":
      case "tr":
        return null == parentTag;
    }
    return !0;
  }
  function findInvalidAncestorForTag(tag, ancestorInfo) {
    switch (tag) {
      case "address":
      case "article":
      case "aside":
      case "blockquote":
      case "center":
      case "details":
      case "dialog":
      case "dir":
      case "div":
      case "dl":
      case "fieldset":
      case "figcaption":
      case "figure":
      case "footer":
      case "header":
      case "hgroup":
      case "main":
      case "menu":
      case "nav":
      case "ol":
      case "p":
      case "section":
      case "summary":
      case "ul":
      case "pre":
      case "listing":
      case "table":
      case "hr":
      case "xmp":
      case "h1":
      case "h2":
      case "h3":
      case "h4":
      case "h5":
      case "h6":
        return ancestorInfo.pTagInButtonScope;
      case "form":
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
      case "li":
        return ancestorInfo.listItemTagAutoclosing;
      case "dd":
      case "dt":
        return ancestorInfo.dlItemTagAutoclosing;
      case "button":
        return ancestorInfo.buttonTagInScope;
      case "a":
        return ancestorInfo.aTagInScope;
      case "nobr":
        return ancestorInfo.nobrTagInScope;
    }
    return null;
  }
  function findAncestor(parent, tagName) {
    for (; parent;) {
      switch (parent.tag) {
        case 5:
        case 26:
        case 27:
          if (parent.type === tagName) return parent;
      }
      parent = parent.return;
    }
    return null;
  }
  function validateDOMNesting(childTag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
    var parentInfo = ancestorInfo.current;
    ancestorInfo = (parentInfo = isTagValidWithParent(childTag, parentInfo && parentInfo.tag) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    ancestorInfo = parentInfo || ancestorInfo;
    if (!ancestorInfo) return !0;
    ancestorInfo = ancestorInfo.tag;
    var warnKey = String(!!parentInfo) + "|" + childTag + "|" + ancestorInfo;
    if (didWarn[warnKey]) return !1;
    didWarn[warnKey] = !0;
    var ancestor = (warnKey = current) ? findAncestor(warnKey.return, ancestorInfo) : null;
    warnKey = null !== warnKey && null !== ancestor ? describeAncestors(ancestor, warnKey, null) : "";
    ancestor = "<" + childTag + ">";
    parentInfo ? (parentInfo = "", "table" === ancestorInfo && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error("In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s", ancestor, ancestorInfo, parentInfo, warnKey)) : console.error("In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s", ancestor, ancestorInfo, warnKey);
    return !1;
  }
  function validateTextNesting(childText, parentTag) {
    if (isTagValidWithParent("#text", parentTag)) return !0;
    var warnKey = "#text|" + parentTag;
    if (didWarn[warnKey]) return !1;
    didWarn[warnKey] = !0;
    var ancestor = (warnKey = current) ? findAncestor(warnKey, parentTag) : null;
    warnKey = null !== warnKey && null !== ancestor ? describeAncestors(ancestor, warnKey, 6 !== warnKey.tag ? {
      children: null
    } : null) : "";
    /\S/.test(childText) ? console.error("In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s", parentTag, warnKey) : console.error("In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s", parentTag, warnKey);
    return !1;
  }
  function setTextContent(node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  }
  function camelize(string) {
    return string.replace(hyphenPattern, function (_, character) {
      return character.toUpperCase();
    });
  }
  function setValueForStyle(style, styleName, value) {
    var isCustomProperty = 0 === styleName.indexOf("--");
    isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported style property %s. Did you mean %s?", styleName, camelize(styleName.replace(msPattern, "ms-")))) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = !0, console.error("Unsupported vendor-prefixed style property %s. Did you mean %s?", styleName, styleName.charAt(0).toUpperCase() + styleName.slice(1))) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, console.error('Style property values shouldn\'t contain a semicolon. Try "%s: %s" instead.', styleName, value.replace(badStyleValueWithSemicolonPattern, ""))), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = !0, console.error("`NaN` is an invalid value for the `%s` css style property.", styleName)) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = !0, console.error("`Infinity` is an invalid value for the `%s` css style property.", styleName))));
    null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style.setProperty(styleName, "") : "float" === styleName ? style.cssFloat = "" : style[styleName] = "" : isCustomProperty ? style.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style[styleName] = ("" + value).trim()) : style[styleName] = value + "px";
  }
  function setValueForStyles(node, styles, prevStyles) {
    if (null != styles && "object" !== typeof styles) throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
    styles && Object.freeze(styles);
    node = node.style;
    if (null != prevStyles) {
      if (styles) {
        var expandedUpdates = {};
        if (prevStyles) for (var key in prevStyles) if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key)) for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++) expandedUpdates[longhands[i]] = key;
        for (var _key in styles) if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key])) for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++) expandedUpdates[key[longhands]] = _key;
        _key = {};
        for (var key$jscomp$0 in styles) for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++) _key[key[longhands]] = key$jscomp$0;
        key$jscomp$0 = {};
        for (var _key2 in expandedUpdates) if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
          key$jscomp$0[i] = !0;
          i = console;
          var value = styles[key];
          i.error.call(i, "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating", key, longhands);
        }
      }
      for (var styleName in prevStyles) !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
      for (var _styleName in styles) _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
    } else for (expandedUpdates in styles) styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
  }
  function isCustomElement(tagName) {
    if (-1 === tagName.indexOf("-")) return !1;
    switch (tagName) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  function getAttributeAlias(name) {
    return aliases.get(name) || name;
  }
  function validateProperty$1(tagName, name) {
    if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) return !0;
    if (rARIACamel$1.test(name)) {
      tagName = "aria-" + name.slice(4).toLowerCase();
      tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
      if (null == tagName) return console.error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name), warnedProperties$1[name] = !0;
      if (name !== tagName) return console.error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0;
    }
    if (rARIA$1.test(name)) {
      tagName = name.toLowerCase();
      tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
      if (null == tagName) return warnedProperties$1[name] = !0, !1;
      name !== tagName && (console.error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, tagName), warnedProperties$1[name] = !0);
    }
    return !0;
  }
  function validateProperties$2(type, props) {
    var invalidProps = [],
      key;
    for (key in props) validateProperty$1(type, key) || invalidProps.push(key);
    props = invalidProps.map(function (prop) {
      return "`" + prop + "`";
    }).join(", ");
    1 === invalidProps.length ? console.error("Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type) : 1 < invalidProps.length && console.error("Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props", props, type);
  }
  function validateProperty(tagName, name, value, eventRegistry) {
    if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) return !0;
    var lowerCasedName = name.toLowerCase();
    if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName) return console.error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties[name] = !0;
    if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name)) return !0;
    if (null != eventRegistry) {
      tagName = eventRegistry.possibleRegistrationNames;
      if (eventRegistry.registrationNameDependencies.hasOwnProperty(name)) return !0;
      eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
      if (null != eventRegistry) return console.error("Invalid event handler property `%s`. Did you mean `%s`?", name, eventRegistry), warnedProperties[name] = !0;
      if (EVENT_NAME_REGEX.test(name)) return console.error("Unknown event handler property `%s`. It will be ignored.", name), warnedProperties[name] = !0;
    } else if (EVENT_NAME_REGEX.test(name)) return INVALID_EVENT_NAME_REGEX.test(name) && console.error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name), warnedProperties[name] = !0;
    if (rARIA.test(name) || rARIACamel.test(name)) return !0;
    if ("innerhtml" === lowerCasedName) return console.error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties[name] = !0;
    if ("aria" === lowerCasedName) return console.error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties[name] = !0;
    if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value) return console.error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties[name] = !0;
    if ("number" === typeof value && isNaN(value)) return console.error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name), warnedProperties[name] = !0;
    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
      if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name) return console.error("Invalid DOM property `%s`. Did you mean `%s`?", name, lowerCasedName), warnedProperties[name] = !0;
    } else if (name !== lowerCasedName) return console.error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName), warnedProperties[name] = !0;
    switch (name) {
      case "dangerouslySetInnerHTML":
      case "children":
      case "style":
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        return !0;
      case "innerText":
      case "textContent":
        return !0;
    }
    switch (typeof value) {
      case "boolean":
        switch (name) {
          case "autoFocus":
          case "checked":
          case "multiple":
          case "muted":
          case "selected":
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
          case "capture":
          case "download":
          case "inert":
            return !0;
          default:
            lowerCasedName = name.toLowerCase().slice(0, 5);
            if ("data-" === lowerCasedName || "aria-" === lowerCasedName) return !0;
            value ? console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name) : console.error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
            return warnedProperties[name] = !0;
        }
      case "function":
      case "symbol":
        return warnedProperties[name] = !0, !1;
      case "string":
        if ("false" === value || "true" === value) {
          switch (name) {
            case "checked":
            case "selected":
            case "multiple":
            case "muted":
            case "allowFullScreen":
            case "async":
            case "autoPlay":
            case "controls":
            case "default":
            case "defer":
            case "disabled":
            case "disablePictureInPicture":
            case "disableRemotePlayback":
            case "formNoValidate":
            case "hidden":
            case "loop":
            case "noModule":
            case "noValidate":
            case "open":
            case "playsInline":
            case "readOnly":
            case "required":
            case "reversed":
            case "scoped":
            case "seamless":
            case "itemScope":
            case "inert":
              break;
            default:
              return !0;
          }
          console.error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
          warnedProperties[name] = !0;
        }
    }
    return !0;
  }
  function warnUnknownProperties(type, props, eventRegistry) {
    var unknownProps = [],
      key;
    for (key in props) validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
    props = unknownProps.map(function (prop) {
      return "`" + prop + "`";
    }).join(", ");
    1 === unknownProps.length ? console.error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type) : 1 < unknownProps.length && console.error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ", props, type);
  }
  function sanitizeURL(url) {
    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
  }
  function getEventTarget(nativeEvent) {
    nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
    nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
    return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
  }
  function restoreStateOfTarget(target) {
    var internalInstance = getInstanceFromNode(target);
    if (internalInstance && (target = internalInstance.stateNode)) {
      var props = target[internalPropsKey] || null;
      a: switch (target = internalInstance.stateNode, internalInstance.type) {
        case "input":
          updateInput(target, props.value, props.defaultValue, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name);
          internalInstance = props.name;
          if ("radio" === props.type && null != internalInstance) {
            for (props = target; props.parentNode;) props = props.parentNode;
            checkAttributeStringCoercion(internalInstance, "name");
            props = props.querySelectorAll('input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes("" + internalInstance) + '"][type="radio"]');
            for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
              var otherNode = props[internalInstance];
              if (otherNode !== target && otherNode.form === target.form) {
                var otherProps = otherNode[internalPropsKey] || null;
                if (!otherProps) throw Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                updateInput(otherNode, otherProps.value, otherProps.defaultValue, otherProps.defaultValue, otherProps.checked, otherProps.defaultChecked, otherProps.type, otherProps.name);
              }
            }
            for (internalInstance = 0; internalInstance < props.length; internalInstance++) otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
          }
          break a;
        case "textarea":
          updateTextarea(target, props.value, props.defaultValue);
          break a;
        case "select":
          internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, !1);
      }
    }
  }
  function batchedUpdates$1(fn, a, b) {
    if (isInsideEventHandler) return fn(a, b);
    isInsideEventHandler = !0;
    try {
      var JSCompiler_inline_result = fn(a);
      return JSCompiler_inline_result;
    } finally {
      if (isInsideEventHandler = !1, null !== restoreTarget || null !== restoreQueue) if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn)) for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
    }
  }
  function getListener(inst, registrationName) {
    var stateNode = inst.stateNode;
    if (null === stateNode) return null;
    var props = stateNode[internalPropsKey] || null;
    if (null === props) return null;
    stateNode = props[registrationName];
    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;
      default:
        inst = !1;
    }
    if (inst) return null;
    if (stateNode && "function" !== typeof stateNode) throw Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type.");
    return stateNode;
  }
  function getData() {
    if (fallbackText) return fallbackText;
    var start,
      startValue = startText,
      startLength = startValue.length,
      end,
      endValue = "value" in root ? root.value : root.textContent,
      endLength = endValue.length;
    for (start = 0; start < startLength && startValue[start] === endValue[start]; start++);
    var minEnd = startLength - start;
    for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++);
    return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
  }
  function getEventCharCode(nativeEvent) {
    var keyCode = nativeEvent.keyCode;
    "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
    10 === nativeEvent && (nativeEvent = 13);
    return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
  }
  function functionThatReturnsTrue() {
    return !0;
  }
  function functionThatReturnsFalse() {
    return !1;
  }
  function createSyntheticEvent(Interface) {
    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
      this._reactName = reactName;
      this._targetInst = targetInst;
      this.type = reactEventType;
      this.nativeEvent = nativeEvent;
      this.target = nativeEventTarget;
      this.currentTarget = null;
      for (var propName in Interface) Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
      this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : !1 === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
      this.isPropagationStopped = functionThatReturnsFalse;
      return this;
    }
    assign(SyntheticBaseEvent.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var event = this.nativeEvent;
        event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
      },
      stopPropagation: function () {
        var event = this.nativeEvent;
        event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
      },
      persist: function () {},
      isPersistent: functionThatReturnsTrue
    });
    return SyntheticBaseEvent;
  }
  function modifierStateGetter(keyArg) {
    var nativeEvent = this.nativeEvent;
    return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : !1;
  }
  function getEventModifierState() {
    return modifierStateGetter;
  }
  function isFallbackCompositionEnd(domEventName, nativeEvent) {
    switch (domEventName) {
      case "keyup":
        return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
      case "keydown":
        return nativeEvent.keyCode !== START_KEYCODE;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    nativeEvent = nativeEvent.detail;
    return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
  }
  function getNativeBeforeInputChars(domEventName, nativeEvent) {
    switch (domEventName) {
      case "compositionend":
        return getDataFromCustomEvent(nativeEvent);
      case "keypress":
        if (nativeEvent.which !== SPACEBAR_CODE) return null;
        hasSpaceKeypress = !0;
        return SPACEBAR_CHAR;
      case "textInput":
        return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(domEventName, nativeEvent) {
    if (isComposing) return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = !1, domEventName) : null;
    switch (domEventName) {
      case "paste":
        return null;
      case "keypress":
        if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
          if (nativeEvent.char && 1 < nativeEvent.char.length) return nativeEvent.char;
          if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case "compositionend":
        return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? !0 : !1;
  }
  function isEventSupported(eventNameSuffix) {
    if (!canUseDOM) return !1;
    eventNameSuffix = "on" + eventNameSuffix;
    var isSupported = eventNameSuffix in document;
    isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
    return isSupported;
  }
  function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
    restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
    inst = accumulateTwoPhaseListeners(inst, "onChange");
    0 < inst.length && (nativeEvent = new SyntheticEvent("onChange", "change", null, nativeEvent, target), dispatchQueue.push({
      event: nativeEvent,
      listeners: inst
    }));
  }
  function runEventInBatch(dispatchQueue) {
    processDispatchQueue(dispatchQueue, 0);
  }
  function getInstIfValueChanged(targetInst) {
    var targetNode = getNodeFromInstance(targetInst);
    if (updateValueIfChanged(targetNode)) return targetInst;
  }
  function getTargetInstForChangeEvent(domEventName, targetInst) {
    if ("change" === domEventName) return targetInst;
  }
  function stopWatchingForValueChange() {
    activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
  }
  function handlePropertyChange(nativeEvent) {
    if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
      var dispatchQueue = [];
      createAndAccumulateChangeEvent(dispatchQueue, activeElementInst$1, nativeEvent, getEventTarget(nativeEvent));
      batchedUpdates$1(runEventInBatch, dispatchQueue);
    }
  }
  function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
    "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
  }
  function getTargetInstForInputEventPolyfill(domEventName) {
    if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName) return getInstIfValueChanged(activeElementInst$1);
  }
  function getTargetInstForClickEvent(domEventName, targetInst) {
    if ("click" === domEventName) return getInstIfValueChanged(targetInst);
  }
  function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
    if ("input" === domEventName || "change" === domEventName) return getInstIfValueChanged(targetInst);
  }
  function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
  }
  function shallowEqual(objA, objB) {
    if (objectIs(objA, objB)) return !0;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB) return !1;
    var keysA = Object.keys(objA),
      keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return !1;
    for (keysB = 0; keysB < keysA.length; keysB++) {
      var currentKey = keysA[keysB];
      if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) return !1;
    }
    return !0;
  }
  function getLeafNode(node) {
    for (; node && node.firstChild;) node = node.firstChild;
    return node;
  }
  function getNodeForCharacterOffset(root, offset) {
    var node = getLeafNode(root);
    root = 0;
    for (var nodeEnd; node;) {
      if (3 === node.nodeType) {
        nodeEnd = root + node.textContent.length;
        if (root <= offset && nodeEnd >= offset) return {
          node: node,
          offset: offset - root
        };
        root = nodeEnd;
      }
      a: {
        for (; node;) {
          if (node.nextSibling) {
            node = node.nextSibling;
            break a;
          }
          node = node.parentNode;
        }
        node = void 0;
      }
      node = getLeafNode(node);
    }
  }
  function containsNode(outerNode, innerNode) {
    return outerNode && innerNode ? outerNode === innerNode ? !0 : outerNode && 3 === outerNode.nodeType ? !1 : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1 : !1;
  }
  function getActiveElementDeep(containerInfo) {
    containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
    for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement;) {
      try {
        var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
      } catch (err) {
        JSCompiler_inline_result = !1;
      }
      if (JSCompiler_inline_result) containerInfo = element.contentWindow;else break;
      element = getActiveElement(containerInfo.document);
    }
    return element;
  }
  function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
  }
  function restoreSelection(priorSelectionInformation, containerInfo) {
    var curFocusedElem = getActiveElementDeep(containerInfo);
    containerInfo = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== containerInfo && containerInfo && containerInfo.ownerDocument && containsNode(containerInfo.ownerDocument.documentElement, containerInfo)) {
      if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo)) if (priorSelectionInformation = priorSelectionRange.start, curFocusedElem = priorSelectionRange.end, void 0 === curFocusedElem && (curFocusedElem = priorSelectionInformation), "selectionStart" in containerInfo) containerInfo.selectionStart = priorSelectionInformation, containerInfo.selectionEnd = Math.min(curFocusedElem, containerInfo.value.length);else if (curFocusedElem = (priorSelectionInformation = containerInfo.ownerDocument || document) && priorSelectionInformation.defaultView || window, curFocusedElem.getSelection) {
        curFocusedElem = curFocusedElem.getSelection();
        var length = containerInfo.textContent.length,
          start = Math.min(priorSelectionRange.start, length);
        priorSelectionRange = void 0 === priorSelectionRange.end ? start : Math.min(priorSelectionRange.end, length);
        !curFocusedElem.extend && start > priorSelectionRange && (length = priorSelectionRange, priorSelectionRange = start, start = length);
        length = getNodeForCharacterOffset(containerInfo, start);
        var endMarker = getNodeForCharacterOffset(containerInfo, priorSelectionRange);
        length && endMarker && (1 !== curFocusedElem.rangeCount || curFocusedElem.anchorNode !== length.node || curFocusedElem.anchorOffset !== length.offset || curFocusedElem.focusNode !== endMarker.node || curFocusedElem.focusOffset !== endMarker.offset) && (priorSelectionInformation = priorSelectionInformation.createRange(), priorSelectionInformation.setStart(length.node, length.offset), curFocusedElem.removeAllRanges(), start > priorSelectionRange ? (curFocusedElem.addRange(priorSelectionInformation), curFocusedElem.extend(endMarker.node, endMarker.offset)) : (priorSelectionInformation.setEnd(endMarker.node, endMarker.offset), curFocusedElem.addRange(priorSelectionInformation)));
      }
      priorSelectionInformation = [];
      for (curFocusedElem = containerInfo; curFocusedElem = curFocusedElem.parentNode;) 1 === curFocusedElem.nodeType && priorSelectionInformation.push({
        element: curFocusedElem,
        left: curFocusedElem.scrollLeft,
        top: curFocusedElem.scrollTop
      });
      "function" === typeof containerInfo.focus && containerInfo.focus();
      for (containerInfo = 0; containerInfo < priorSelectionInformation.length; containerInfo++) curFocusedElem = priorSelectionInformation[containerInfo], curFocusedElem.element.scrollLeft = curFocusedElem.left, curFocusedElem.element.scrollTop = curFocusedElem.top;
    }
  }
  function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
    mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = {
      start: doc.selectionStart,
      end: doc.selectionEnd
    } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
      anchorNode: doc.anchorNode,
      anchorOffset: doc.anchorOffset,
      focusNode: doc.focusNode,
      focusOffset: doc.focusOffset
    }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
      event: nativeEvent,
      listeners: doc
    }), nativeEvent.target = activeElement)));
  }
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit" + styleProp] = "webkit" + eventName;
    prefixes["Moz" + styleProp] = "moz" + eventName;
    return prefixes;
  }
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    if (!vendorPrefixes[eventName]) return eventName;
    var prefixMap = vendorPrefixes[eventName],
      styleProp;
    for (styleProp in prefixMap) if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) return prefixedEventNames[eventName] = prefixMap[styleProp];
    return eventName;
  }
  function registerSimpleEvent(domEventName, reactName) {
    topLevelEventsToReactNames.set(domEventName, reactName);
    registerTwoPhaseEvent(reactName, [domEventName]);
  }
  function finishQueueingConcurrentUpdates() {
    for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex;) {
      var fiber = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var queue = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var update = concurrentQueues[i];
      concurrentQueues[i++] = null;
      var lane = concurrentQueues[i];
      concurrentQueues[i++] = null;
      if (null !== queue && null !== update) {
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
    }
  }
  function enqueueUpdate$1(fiber, queue, update, lane) {
    concurrentQueues[concurrentQueuesIndex++] = fiber;
    concurrentQueues[concurrentQueuesIndex++] = queue;
    concurrentQueues[concurrentQueuesIndex++] = update;
    concurrentQueues[concurrentQueuesIndex++] = lane;
    concurrentlyUpdatedLanes |= lane;
    fiber.lanes |= lane;
    fiber = fiber.alternate;
    null !== fiber && (fiber.lanes |= lane);
  }
  function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
    enqueueUpdate$1(fiber, queue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function enqueueConcurrentRenderForLane(fiber, lane) {
    enqueueUpdate$1(fiber, null, null, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
    sourceFiber.lanes |= lane;
    var alternate = sourceFiber.alternate;
    null !== alternate && (alternate.lanes |= lane);
    for (var isHidden = !1, parent = sourceFiber.return; null !== parent;) parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = !0)), sourceFiber = parent, parent = parent.return;
    isHidden && null !== update && 3 === sourceFiber.tag && (parent = sourceFiber.stateNode, isHidden = 31 - clz32(lane), parent = parent.hiddenUpdates, sourceFiber = parent[isHidden], null === sourceFiber ? parent[isHidden] = [update] : sourceFiber.push(update), update.lane = lane | 536870912);
  }
  function getRootForUpdatedFiber(sourceFiber) {
    if (nestedUpdateCount > NESTED_UPDATE_LIMIT) throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
    nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
    for (var node = sourceFiber, parent = node.return; null !== parent;) null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
    return 3 === node.tag ? node.stateNode : null;
  }
  function resolveFunctionForHotReloading(type) {
    if (null === resolveFamily) return type;
    var family = resolveFamily(type);
    return void 0 === family ? type : family.current;
  }
  function resolveForwardRefForHotReloading(type) {
    if (null === resolveFamily) return type;
    var family = resolveFamily(type);
    return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = {
      $$typeof: REACT_FORWARD_REF_TYPE,
      render: family
    }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
  }
  function isCompatibleFamilyForHotReloading(fiber, element) {
    if (null === resolveFamily) return !1;
    var prevType = fiber.elementType;
    element = element.type;
    var needsCompareFamilies = !1,
      $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
    switch (fiber.tag) {
      case 1:
        "function" === typeof element && (needsCompareFamilies = !0);
        break;
      case 0:
        "function" === typeof element ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
        break;
      case 11:
        $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
        break;
      case 14:
      case 15:
        $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = !0 : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = !0);
        break;
      default:
        return !1;
    }
    return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? !0 : !1;
  }
  function markFailedErrorBoundaryForHotReloading(fiber) {
    null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = new WeakSet()), failedBoundaries.add(fiber));
  }
  function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
    var alternate = fiber.alternate,
      child = fiber.child,
      sibling = fiber.sibling,
      tag = fiber.tag,
      type = fiber.type,
      candidateType = null;
    switch (tag) {
      case 0:
      case 15:
      case 1:
        candidateType = type;
        break;
      case 11:
        candidateType = type.render;
    }
    if (null === resolveFamily) throw Error("Expected resolveFamily to be set during hot reload.");
    var needsRender = !1;
    type = !1;
    null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = !0 : updatedFamilies.has(candidateType) && (1 === tag ? type = !0 : needsRender = !0)));
    null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = !0);
    type && (fiber._debugNeedsRemount = !0);
    if (type || needsRender) alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
    null === child || type || scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
    null !== sibling && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
  }
  function pushNestedEffectDurations() {
    var prevEffectDuration = profilerEffectDuration;
    profilerEffectDuration = 0;
    return prevEffectDuration;
  }
  function popNestedEffectDurations(prevEffectDuration) {
    var elapsedTime = profilerEffectDuration;
    profilerEffectDuration = prevEffectDuration;
    return elapsedTime;
  }
  function bubbleNestedEffectDurations(prevEffectDuration) {
    var elapsedTime = profilerEffectDuration;
    profilerEffectDuration += prevEffectDuration;
    return elapsedTime;
  }
  function startProfilerTimer(fiber) {
    profilerStartTime = now();
    0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
  }
  function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
    if (0 <= profilerStartTime) {
      var elapsedTime = now() - profilerStartTime;
      fiber.actualDuration += elapsedTime;
      fiber.selfBaseDuration = elapsedTime;
      profilerStartTime = -1;
    }
  }
  function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
    if (0 <= profilerStartTime) {
      var elapsedTime = now() - profilerStartTime;
      fiber.actualDuration += elapsedTime;
      profilerStartTime = -1;
    }
  }
  function recordEffectDuration() {
    if (0 <= profilerStartTime) {
      var elapsedTime = now() - profilerStartTime;
      profilerStartTime = -1;
      profilerEffectDuration += elapsedTime;
    }
  }
  function startEffectTimer() {
    profilerStartTime = now();
  }
  function transferActualDuration(fiber) {
    for (var child = fiber.child; child;) fiber.actualDuration += child.actualDuration, child = child.sibling;
  }
  function createCapturedValueAtFiber(value, source) {
    if ("object" === typeof value && null !== value) {
      var existing = CapturedStacks.get(value);
      if (void 0 !== existing) return existing;
      source = {
        value: value,
        source: source,
        stack: getStackByFiberInDevAndProd(source)
      };
      CapturedStacks.set(value, source);
      return source;
    }
    return {
      value: value,
      source: source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
  function pushTreeFork(workInProgress, totalChildren) {
    warnIfNotHydrating();
    forkStack[forkStackIndex++] = treeForkCount;
    forkStack[forkStackIndex++] = treeForkProvider;
    treeForkProvider = workInProgress;
    treeForkCount = totalChildren;
  }
  function pushTreeId(workInProgress, totalChildren, index) {
    warnIfNotHydrating();
    idStack[idStackIndex++] = treeContextId;
    idStack[idStackIndex++] = treeContextOverflow;
    idStack[idStackIndex++] = treeContextProvider;
    treeContextProvider = workInProgress;
    var baseIdWithLeadingBit = treeContextId;
    workInProgress = treeContextOverflow;
    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
    baseIdWithLeadingBit &= ~(1 << baseLength);
    index += 1;
    var length = 32 - clz32(totalChildren) + baseLength;
    if (30 < length) {
      var numberOfOverflowBits = baseLength - baseLength % 5;
      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
      baseIdWithLeadingBit >>= numberOfOverflowBits;
      baseLength -= numberOfOverflowBits;
      treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
      treeContextOverflow = length + workInProgress;
    } else treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress;
  }
  function pushMaterializedTreeId(workInProgress) {
    warnIfNotHydrating();
    null !== workInProgress.return && (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));
  }
  function popTreeContext(workInProgress) {
    for (; workInProgress === treeForkProvider;) treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
    for (; workInProgress === treeContextProvider;) treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
  }
  function warnIfNotHydrating() {
    isHydrating || console.error("Expected to be hydrating. This is a bug in React. Please file an issue.");
  }
  function buildHydrationDiffNode(fiber, distanceFromLeaf) {
    if (null === fiber.return) {
      if (null === hydrationDiffRootDEV) hydrationDiffRootDEV = {
        fiber: fiber,
        children: [],
        serverProps: void 0,
        serverTail: [],
        distanceFromLeaf: distanceFromLeaf
      };else {
        if (hydrationDiffRootDEV.fiber !== fiber) throw Error("Saw multiple hydration diff roots in a pass. This is a bug in React.");
        hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
      }
      return hydrationDiffRootDEV;
    }
    var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children;
    if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber) return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
    distanceFromLeaf = {
      fiber: fiber,
      children: [],
      serverProps: void 0,
      serverTail: [],
      distanceFromLeaf: distanceFromLeaf
    };
    siblings.push(distanceFromLeaf);
    return distanceFromLeaf;
  }
  function warnNonHydratedInstance(fiber, rejectedCandidate) {
    didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
  }
  function throwOnHydrationMismatch(fiber) {
    var diff = "",
      diffRoot = hydrationDiffRootDEV;
    null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
    queueHydrationError(createCapturedValueAtFiber(Error("Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff), fiber));
    throw HydrationMismatchException;
  }
  function prepareToHydrateHostInstance(fiber) {
    var didHydrate = fiber.stateNode;
    var type = fiber.type,
      props = fiber.memoizedProps;
    didHydrate[internalInstanceKey] = fiber;
    didHydrate[internalPropsKey] = props;
    validatePropertiesInDevelopment(type, props);
    switch (type) {
      case "dialog":
        listenToNonDelegatedEvent("cancel", didHydrate);
        listenToNonDelegatedEvent("close", didHydrate);
        break;
      case "iframe":
      case "object":
      case "embed":
        listenToNonDelegatedEvent("load", didHydrate);
        break;
      case "video":
      case "audio":
        for (type = 0; type < mediaEventTypes.length; type++) listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
        break;
      case "source":
        listenToNonDelegatedEvent("error", didHydrate);
        break;
      case "img":
      case "image":
      case "link":
        listenToNonDelegatedEvent("error", didHydrate);
        listenToNonDelegatedEvent("load", didHydrate);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", didHydrate);
        break;
      case "input":
        checkControlledValueProps("input", props);
        listenToNonDelegatedEvent("invalid", didHydrate);
        validateInputProps(didHydrate, props);
        initInput(didHydrate, props.value, props.defaultValue, props.checked, props.defaultChecked, props.type, props.name, !0);
        track(didHydrate);
        break;
      case "option":
        validateOptionProps(didHydrate, props);
        break;
      case "select":
        checkControlledValueProps("select", props);
        listenToNonDelegatedEvent("invalid", didHydrate);
        validateSelectProps(didHydrate, props);
        break;
      case "textarea":
        checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(didHydrate, props.value, props.defaultValue, props.children), track(didHydrate);
    }
    type = props.children;
    "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || !0 === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = !0) : didHydrate = !1;
    didHydrate || throwOnHydrationMismatch(fiber);
  }
  function popToNextHostParent(fiber) {
    for (hydrationParentFiber = fiber.return; hydrationParentFiber;) switch (hydrationParentFiber.tag) {
      case 3:
      case 27:
        rootOrSingletonContext = !0;
        return;
      case 5:
      case 13:
        rootOrSingletonContext = !1;
        return;
      default:
        hydrationParentFiber = hydrationParentFiber.return;
    }
  }
  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) return !1;
    if (!isHydrating) return popToNextHostParent(fiber), isHydrating = !0, !1;
    var shouldClear = !1,
      JSCompiler_temp;
    if (JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag) {
      if (JSCompiler_temp = 5 === fiber.tag) JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
      JSCompiler_temp = !JSCompiler_temp;
    }
    JSCompiler_temp && (shouldClear = !0);
    if (shouldClear && nextHydratableInstance) {
      for (shouldClear = nextHydratableInstance; shouldClear;) {
        JSCompiler_temp = buildHydrationDiffNode(fiber, 0);
        var description = describeHydratableInstanceForDevWarnings(shouldClear);
        JSCompiler_temp.serverTail.push(description);
        shouldClear = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(shouldClear) : getNextHydratable(shouldClear.nextSibling);
      }
      throwOnHydrationMismatch(fiber);
    }
    popToNextHostParent(fiber);
    if (13 === fiber.tag) {
      fiber = fiber.memoizedState;
      fiber = null !== fiber ? fiber.dehydrated : null;
      if (!fiber) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
    } else nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
    return !0;
  }
  function resetHydrationState() {
    nextHydratableInstance = hydrationParentFiber = null;
    didSuspendOrErrorDEV = isHydrating = !1;
  }
  function queueHydrationError(error) {
    null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
  }
  function emitPendingHydrationWarnings() {
    var diffRoot = hydrationDiffRootDEV;
    null !== diffRoot && (hydrationDiffRootDEV = null, diffRoot = describeDiff(diffRoot), console.error("A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s", "https://react.dev/link/hydration-mismatch", diffRoot));
  }
  function createThenableState() {
    return {
      didWarnAboutUncachedPromise: !1,
      thenables: []
    };
  }
  function isThenableResolved(thenable) {
    thenable = thenable.status;
    return "fulfilled" === thenable || "rejected" === thenable;
  }
  function noop$3() {}
  function trackUsedThenable(thenableState, thenable, index) {
    null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = !0);
    var trackedThenables = thenableState.thenables;
    index = trackedThenables[index];
    void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState.didWarnAboutUncachedPromise || (thenableState.didWarnAboutUncachedPromise = !0, console.error("A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework.")), thenable.then(noop$3, noop$3), thenable = index);
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
      default:
        if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);else {
          thenableState = workInProgressRoot;
          if (null !== thenableState && 100 < thenableState.shellSuspendCounter) throw Error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
          thenableState = thenable;
          thenableState.status = "pending";
          thenableState.then(function (fulfilledValue) {
            if ("pending" === thenable.status) {
              var fulfilledThenable = thenable;
              fulfilledThenable.status = "fulfilled";
              fulfilledThenable.value = fulfilledValue;
            }
          }, function (error) {
            if ("pending" === thenable.status) {
              var rejectedThenable = thenable;
              rejectedThenable.status = "rejected";
              rejectedThenable.reason = error;
            }
          });
        }
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState), thenableState;
        }
        suspendedThenable = thenable;
        needsToResetSuspendedThenableDEV = !0;
        throw SuspenseException;
    }
  }
  function getSuspendedThenable() {
    if (null === suspendedThenable) throw Error("Expected a suspended thenable. This is a bug in React. Please file an issue.");
    var thenable = suspendedThenable;
    suspendedThenable = null;
    needsToResetSuspendedThenableDEV = !1;
    return thenable;
  }
  function checkIfUseWrappedInAsyncCatch(rejectedReason) {
    if (rejectedReason === SuspenseException) throw Error("Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.");
  }
  function pushDebugInfo(debugInfo) {
    var previousDebugInfo = currentDebugInfo;
    null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
    return previousDebugInfo;
  }
  function validateFragmentProps(element, fiber, returnFiber) {
    for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
      var key = keys[i];
      if ("children" !== key && "key" !== key) {
        null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
        runWithFiberInDEV(fiber, function (erroredKey) {
          console.error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", erroredKey);
        }, key);
        break;
      }
    }
  }
  function unwrapThenable(thenable) {
    var index = thenableIndexCounter$1;
    thenableIndexCounter$1 += 1;
    null === thenableState$1 && (thenableState$1 = createThenableState());
    return trackUsedThenable(thenableState$1, thenable, index);
  }
  function coerceRef(workInProgress, element) {
    element = element.props.ref;
    workInProgress.ref = void 0 !== element ? element : null;
  }
  function throwOnInvalidObjectType(returnFiber, newChild) {
    if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) throw Error('A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.');
    returnFiber = Object.prototype.toString.call(newChild);
    throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead.");
  }
  function warnOnFunctionType(returnFiber, invalidChild) {
    var parentName = getComponentNameFromFiber(returnFiber) || "Component";
    ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = !0, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)", invalidChild, invalidChild, invalidChild) : console.error("Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>", invalidChild, invalidChild, parentName, invalidChild, parentName));
  }
  function warnOnSymbolType(returnFiber, invalidChild) {
    var parentName = getComponentNameFromFiber(returnFiber) || "Component";
    ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = !0, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error("Symbols are not valid as a React child.\n  root.render(%s)", invalidChild) : console.error("Symbols are not valid as a React child.\n  <%s>%s</%s>", parentName, invalidChild, parentName));
  }
  function createChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var deletions = returnFiber.deletions;
        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
      }
    }
    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;
      for (; null !== currentFirstChild;) deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return null;
    }
    function mapRemainingChildren(currentFirstChild) {
      for (var existingChildren = new Map(); null !== currentFirstChild;) null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return existingChildren;
    }
    function useFiber(fiber, pendingProps) {
      fiber = createWorkInProgress(fiber, pendingProps);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }
    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects) return newFiber.flags |= 1048576, lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex) return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 33554434, lastPlacedIndex) : newIndex;
      newFiber.flags |= 33554434;
      return lastPlacedIndex;
    }
    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 33554434);
      return newFiber;
    }
    function updateTextNode(returnFiber, current, textContent, lanes) {
      if (null === current || 6 !== current.tag) return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;
      current = useFiber(current, textContent);
      current.return = returnFiber;
      current._debugInfo = currentDebugInfo;
      return current;
    }
    function updateElement(returnFiber, current, element, lanes) {
      var elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE) return current = updateFragment(returnFiber, current, element.props.children, lanes, element.key), validateFragmentProps(element, current, returnFiber), current;
      if (null !== current && (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current.type)) return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current._debugOwner = element._owner, current._debugInfo = currentDebugInfo, current;
      current = createFiberFromElement(element, returnFiber.mode, lanes);
      coerceRef(current, element);
      current.return = returnFiber;
      current._debugInfo = currentDebugInfo;
      return current;
    }
    function updatePortal(returnFiber, current, portal, lanes) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current._debugInfo = currentDebugInfo, current;
      current = useFiber(current, portal.children || []);
      current.return = returnFiber;
      current._debugInfo = currentDebugInfo;
      return current;
    }
    function updateFragment(returnFiber, current, fragment, lanes, key) {
      if (null === current || 7 !== current.tag) return current = createFiberFromFragment(fragment, returnFiber.mode, lanes, key), current.return = returnFiber, current._debugOwner = returnFiber, current._debugInfo = currentDebugInfo, current;
      current = useFiber(current, fragment);
      current.return = returnFiber;
      current._debugInfo = currentDebugInfo;
      return current;
    }
    function createChild(returnFiber, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return newChild = createFiberFromText("" + newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(newChild, returnFiber.mode, lanes), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
          case REACT_LAZY_TYPE:
            var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            newChild = callLazyInitInDEV(newChild);
            returnFiber = createChild(returnFiber, newChild, lanes);
            currentDebugInfo = _prevDebugInfo;
            return returnFiber;
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return lanes = createFiberFromFragment(newChild, returnFiber.mode, lanes, null), lanes.return = returnFiber, lanes._debugOwner = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
        if ("function" === typeof newChild.then) return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(returnFiber, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo, returnFiber;
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return createChild(returnFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
      return null;
    }
    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber) : null;
          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_LAZY_TYPE:
            return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(returnFiber, oldFiber, newChild, lanes), currentDebugInfo = key, returnFiber;
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
          if (null !== key) return null;
          key = pushDebugInfo(newChild._debugInfo);
          returnFiber = updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          currentDebugInfo = key;
          return returnFiber;
        }
        if ("function" === typeof newChild.then) return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(returnFiber, oldFiber, unwrapThenable(newChild), lanes), currentDebugInfo = key, returnFiber;
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
      return null;
    }
    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newIdx = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(returnFiber, newIdx, newChild, lanes), currentDebugInfo = existingChildren, returnFiber;
          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(null === newChild.key ? newIdx : newChild.key) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
          case REACT_LAZY_TYPE:
            var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
            newChild = callLazyInitInDEV(newChild);
            returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes);
            currentDebugInfo = _prevDebugInfo7;
            return returnFiber;
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild)) return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(returnFiber, newIdx, newChild, lanes, null), currentDebugInfo = existingChildren, returnFiber;
        if ("function" === typeof newChild.then) return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(newChild), lanes), currentDebugInfo = _prevDebugInfo7, returnFiber;
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
      return null;
    }
    function warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys) {
      if ("object" !== typeof child || null === child) return knownKeys;
      switch (child.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          warnForMissingKey(returnFiber, workInProgress, child);
          var key = child.key;
          if ("string" !== typeof key) break;
          if (null === knownKeys) {
            knownKeys = new Set();
            knownKeys.add(key);
            break;
          }
          if (!knownKeys.has(key)) {
            knownKeys.add(key);
            break;
          }
          runWithFiberInDEV(workInProgress, function () {
            console.error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
          });
          break;
        case REACT_LAZY_TYPE:
          child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress, child, knownKeys);
      }
      return knownKeys;
    }
    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
      for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        knownKeys = warnOnInvalidKey(returnFiber, newFiber, newChildren[newIdx], knownKeys);
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (newIdx === newChildren.length) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++) oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, newChildren[newIdx], knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, newChildren[newIdx], lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, newChildren[newIdx], knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
      if (null == newChildren) throw Error("An iterable object provided no iterator.");
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        knownKeys = warnOnInvalidKey(returnFiber, newFiber, step.value, knownKeys);
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (step.done) return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildren.next()) oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(returnFiber, oldFiber, step.value, knownKeys), currentFirstChild = placeChild(oldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next()) nextOldFiber = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(returnFiber, nextOldFiber, step.value, knownKeys), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(null === nextOldFiber.key ? newIdx : nextOldFiber.key), currentFirstChild = placeChild(nextOldFiber, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      shouldTrackSideEffects && oldFiber.forEach(function (child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
      "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
            a: {
              for (var key = newChild.key; null !== currentFirstChild;) {
                if (currentFirstChild.key === key) {
                  key = newChild.type;
                  if (key === REACT_FRAGMENT_TYPE) {
                    if (7 === currentFirstChild.tag) {
                      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                      lanes = useFiber(currentFirstChild, newChild.props.children);
                      lanes.return = returnFiber;
                      lanes._debugOwner = newChild._owner;
                      lanes._debugInfo = currentDebugInfo;
                      validateFragmentProps(newChild, lanes, returnFiber);
                      returnFiber = lanes;
                      break a;
                    }
                  } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(currentFirstChild, newChild) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    lanes = useFiber(currentFirstChild, newChild.props);
                    coerceRef(lanes, newChild);
                    lanes.return = returnFiber;
                    lanes._debugOwner = newChild._owner;
                    lanes._debugInfo = currentDebugInfo;
                    returnFiber = lanes;
                    break a;
                  }
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(newChild.props.children, returnFiber.mode, lanes, newChild.key), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(newChild, returnFiber.mode, lanes), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
            }
            returnFiber = placeSingleChild(returnFiber);
            currentDebugInfo = prevDebugInfo;
            return returnFiber;
          case REACT_PORTAL_TYPE:
            a: {
              prevDebugInfo = newChild;
              for (newChild = prevDebugInfo.key; null !== currentFirstChild;) {
                if (currentFirstChild.key === newChild) {
                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                    lanes = useFiber(currentFirstChild, prevDebugInfo.children || []);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              lanes = createFiberFromPortal(prevDebugInfo, returnFiber.mode, lanes);
              lanes.return = returnFiber;
              returnFiber = lanes;
            }
            return placeSingleChild(returnFiber);
          case REACT_LAZY_TYPE:
            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
        }
        if (isArrayImpl(newChild)) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes), currentDebugInfo = prevDebugInfo, returnFiber;
        if (getIteratorFn(newChild)) {
          prevDebugInfo = pushDebugInfo(newChild._debugInfo);
          key = getIteratorFn(newChild);
          if ("function" !== typeof key) throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
          var newChildren = key.call(newChild);
          if (newChildren === newChild) {
            if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren)) didWarnAboutGenerators || console.error("Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."), didWarnAboutGenerators = !0;
          } else newChild.entries !== key || didWarnAboutMaps || (console.error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
          returnFiber = reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes);
          currentDebugInfo = prevDebugInfo;
          return returnFiber;
        }
        if ("function" === typeof newChild.then) return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(newChild), lanes), currentDebugInfo = prevDebugInfo, returnFiber;
        if (newChild.$$typeof === REACT_CONTEXT_TYPE) return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, newChild), lanes);
        throwOnInvalidObjectType(returnFiber, newChild);
      }
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild) return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(prevDebugInfo, returnFiber.mode, lanes), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
      return deleteRemainingChildren(returnFiber, currentFirstChild);
    }
    return function (returnFiber, currentFirstChild, newChild, lanes) {
      var prevDebugInfo = currentDebugInfo;
      currentDebugInfo = null;
      try {
        thenableIndexCounter$1 = 0;
        var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes);
        thenableState$1 = null;
        return firstChildFiber;
      } catch (x) {
        if (x === SuspenseException) throw x;
        var fiber = createFiber(29, x, null, returnFiber.mode);
        fiber.lanes = lanes;
        fiber.return = returnFiber;
        var debugInfo = fiber._debugInfo = currentDebugInfo;
        fiber._debugOwner = returnFiber._debugOwner;
        if (null != debugInfo) for (var i = debugInfo.length - 1; 0 <= i; i--) if ("string" === typeof debugInfo[i].stack) {
          fiber._debugOwner = debugInfo[i];
          break;
        }
        return fiber;
      } finally {
        currentDebugInfo = prevDebugInfo;
      }
    };
  }
  function pushHiddenContext(fiber, context) {
    var prevEntangledRenderLanes = entangledRenderLanes;
    push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
    push(currentTreeHiddenStackCursor, context, fiber);
    entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
  }
  function reuseHiddenContextOnStack(fiber) {
    push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
    push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);
  }
  function popHiddenContext(fiber) {
    entangledRenderLanes = prevEntangledRenderLanesCursor.current;
    pop(currentTreeHiddenStackCursor, fiber);
    pop(prevEntangledRenderLanesCursor, fiber);
  }
  function pushPrimaryTreeSuspenseHandler(handler) {
    var current = handler.alternate;
    push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask, handler);
    push(suspenseHandlerStackCursor, handler, handler);
    null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
  }
  function pushOffscreenSuspenseHandler(fiber) {
    if (22 === fiber.tag) {
      if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
        var current = fiber.alternate;
        null !== current && null !== current.memoizedState && (shellBoundary = fiber);
      }
    } else reuseSuspenseHandlerOnStack(fiber);
  }
  function reuseSuspenseHandlerOnStack(fiber) {
    push(suspenseStackCursor, suspenseStackCursor.current, fiber);
    push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current, fiber);
  }
  function popSuspenseHandler(fiber) {
    pop(suspenseHandlerStackCursor, fiber);
    shellBoundary === fiber && (shellBoundary = null);
    pop(suspenseStackCursor, fiber);
  }
  function findFirstSuspended(row) {
    for (var node = row; null !== node;) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || state.data === SUSPENSE_FALLBACK_START_DATA)) return node;
      } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
        if (0 !== (node.flags & 128)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === row) break;
      for (; null === node.sibling;) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
    return null;
  }
  function createCache() {
    return {
      controller: new AbortControllerLocal(),
      data: new Map(),
      refCount: 0
    };
  }
  function retainCache(cache) {
    cache.controller.signal.aborted && console.warn("A cache instance was retained after it was already freed. This likely indicates a bug in React.");
    cache.refCount++;
  }
  function releaseCache(cache) {
    cache.refCount--;
    0 > cache.refCount && console.warn("A cache instance was released after it was already freed. This likely indicates a bug in React.");
    0 === cache.refCount && scheduleCallback$2(NormalPriority, function () {
      cache.controller.abort();
    });
  }
  function entangleAsyncAction(transition, thenable) {
    if (null === currentEntangledListeners) {
      var entangledListeners = currentEntangledListeners = [];
      currentEntangledPendingCount = 0;
      currentEntangledLane = requestTransitionLane();
      currentEntangledActionThenable = {
        status: "pending",
        value: void 0,
        then: function (resolve) {
          entangledListeners.push(resolve);
        }
      };
    }
    currentEntangledPendingCount++;
    thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
    return thenable;
  }
  function pingEngtangledActionScope() {
    if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
      null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
      var listeners = currentEntangledListeners;
      currentEntangledListeners = null;
      currentEntangledLane = 0;
      currentEntangledActionThenable = null;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
    }
  }
  function chainThenableValue(thenable, result) {
    var listeners = [],
      thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function (resolve) {
          listeners.push(resolve);
        }
      };
    thenable.then(function () {
      thenableWithOverride.status = "fulfilled";
      thenableWithOverride.value = result;
      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
    }, function (error) {
      thenableWithOverride.status = "rejected";
      thenableWithOverride.reason = error;
      for (error = 0; error < listeners.length; error++) (0, listeners[error])(void 0);
    });
    return thenableWithOverride;
  }
  function peekCacheFromPool() {
    var cacheResumedFromPreviousRender = resumedCache.current;
    return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
  }
  function pushTransition(offscreenWorkInProgress, prevCachePool) {
    null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
  }
  function getSuspendedCache() {
    var cacheFromPool = peekCacheFromPool();
    return null === cacheFromPool ? null : {
      parent: CacheContext._currentValue,
      pool: cacheFromPool
    };
  }
  function mountHookTypesDev() {
    var hookName = currentHookNameInDev;
    null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
  }
  function updateHookTypesDev() {
    var hookName = currentHookNameInDev;
    if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
      var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
      if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), null !== hookTypesDev)) {
        for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
          var oldHookName = hookTypesDev[i],
            newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
          for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length;) oldHookName += " ";
          oldHookName += newHookName + "\n";
          table += oldHookName;
        }
        console.error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
      }
    }
  }
  function checkDepsAreArrayDev(deps) {
    void 0 === deps || null === deps || isArrayImpl(deps) || console.error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
  }
  function warnOnUseFormStateInDev() {
    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
    didWarnAboutUseFormState.has(componentName) || (didWarnAboutUseFormState.add(componentName), console.error("ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.", componentName));
  }
  function throwInvalidHookError() {
    throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
    if (ignorePreviousDependencies) return !1;
    if (null === prevDeps) return console.error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
    nextDeps.length !== prevDeps.length && console.error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) if (!objectIs(nextDeps[i], prevDeps[i])) return !1;
    return !0;
  }
  function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber$1 = workInProgress;
    hookTypesDev = null !== current ? current._debugHookTypes : null;
    hookTypesUpdateIndexDev = -1;
    ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
    if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component)) nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber$1), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error("async/await is not yet supported in Client Components, only Server Components. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."));
    workInProgress.memoizedState = null;
    workInProgress.updateQueue = null;
    workInProgress.lanes = 0;
    ReactSharedInternals.H = null !== current && null !== current.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
    shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress.mode & StrictLegacyMode) !== NoMode;
    var children = callComponentInDEV(Component, props, secondArg);
    shouldDoubleInvokeUserFnsInHooksDEV = !1;
    didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(workInProgress, Component, props, secondArg));
    if (nextRenderLanes) {
      setIsStrictModeForDevtools(!0);
      try {
        children = renderWithHooksAgain(workInProgress, Component, props, secondArg);
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    finishRenderingHooks(current, workInProgress);
    return children;
  }
  function finishRenderingHooks(current, workInProgress) {
    workInProgress._debugHookTypes = hookTypesDev;
    null === workInProgress.dependencies ? null !== thenableState && (workInProgress.dependencies = {
      lanes: 0,
      firstContext: null,
      _debugThenableState: thenableState
    }) : workInProgress.dependencies._debugThenableState = thenableState;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
    renderLanes = 0;
    hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
    hookTypesUpdateIndexDev = -1;
    null !== current && (current.flags & 31457280) !== (workInProgress.flags & 31457280) && console.error("Internal React error: Expected static flag was missing. Please notify the React team.");
    didScheduleRenderPhaseUpdate = !1;
    thenableIndexCounter = 0;
    thenableState = null;
    if (didRenderTooFewHooks) throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
    null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = !0));
    needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = !1, current = !0) : current = !1;
    current && (workInProgress = getComponentNameFromFiber(workInProgress) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress) || didWarnAboutAsyncClientComponent.has(workInProgress) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress), console.error("`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary.")));
  }
  function renderWithHooksAgain(workInProgress, Component, props, secondArg) {
    currentlyRenderingFiber$1 = workInProgress;
    var numberOfReRenders = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
      thenableIndexCounter = 0;
      didScheduleRenderPhaseUpdateDuringThisPass = !1;
      if (numberOfReRenders >= RE_RENDER_LIMIT) throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
      numberOfReRenders += 1;
      ignorePreviousDependencies = !1;
      workInProgressHook = currentHook = null;
      if (null != workInProgress.updateQueue) {
        var children = workInProgress.updateQueue;
        children.lastEffect = null;
        children.events = null;
        children.stores = null;
        null != children.memoCache && (children.memoCache.index = 0);
      }
      hookTypesUpdateIndexDev = -1;
      ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
      children = callComponentInDEV(Component, props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
    return children;
  }
  function TransitionAwareHostComponent() {
    var dispatcher = ReactSharedInternals.H,
      maybeThenable = dispatcher.useState()[0];
    maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
    dispatcher = dispatcher.useState()[0];
    (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber$1.flags |= 1024);
    return maybeThenable;
  }
  function checkDidRenderIdHook() {
    var didRenderIdHook = 0 !== localIdCounter;
    localIdCounter = 0;
    return didRenderIdHook;
  }
  function bailoutHooks(current, workInProgress, lanes) {
    workInProgress.updateQueue = current.updateQueue;
    workInProgress.flags = (workInProgress.mode & StrictEffectsMode) !== NoMode ? workInProgress.flags & -201328645 : workInProgress.flags & -2053;
    current.lanes &= ~lanes;
  }
  function resetHooksOnUnwind(workInProgress) {
    if (didScheduleRenderPhaseUpdate) {
      for (workInProgress = workInProgress.memoizedState; null !== workInProgress;) {
        var queue = workInProgress.queue;
        null !== queue && (queue.pending = null);
        workInProgress = workInProgress.next;
      }
      didScheduleRenderPhaseUpdate = !1;
    }
    renderLanes = 0;
    hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;
    hookTypesUpdateIndexDev = -1;
    currentHookNameInDev = null;
    didScheduleRenderPhaseUpdateDuringThisPass = !1;
    thenableIndexCounter = localIdCounter = 0;
    thenableState = null;
  }
  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
    return workInProgressHook;
  }
  function updateWorkInProgressHook() {
    if (null === currentHook) {
      var nextCurrentHook = currentlyRenderingFiber$1.alternate;
      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
    } else nextCurrentHook = currentHook.next;
    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState : workInProgressHook.next;
    if (null !== nextWorkInProgressHook) workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;else {
      if (null === nextCurrentHook) {
        if (null === currentlyRenderingFiber$1.alternate) throw Error("Update hook called on initial render. This is likely a bug in React. Please file an issue.");
        throw Error("Rendered more hooks than during the previous render.");
      }
      currentHook = nextCurrentHook;
      nextCurrentHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        baseQueue: currentHook.baseQueue,
        queue: currentHook.queue,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
    }
    return workInProgressHook;
  }
  function useThenable(thenable) {
    var index = thenableIndexCounter;
    thenableIndexCounter += 1;
    null === thenableState && (thenableState = createThenableState());
    thenable = trackUsedThenable(thenableState, thenable, index);
    index = currentlyRenderingFiber$1;
    null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
    return thenable;
  }
  function use(usable) {
    if (null !== usable && "object" === typeof usable) {
      if ("function" === typeof usable.then) return useThenable(usable);
      if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
    }
    throw Error("An unsupported type was passed to use(): " + String(usable));
  }
  function useMemoCache(size) {
    var memoCache = null,
      updateQueue = currentlyRenderingFiber$1.updateQueue;
    null !== updateQueue && (memoCache = updateQueue.memoCache);
    if (null == memoCache) {
      var current = currentlyRenderingFiber$1.alternate;
      null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
        data: current.data.map(function (array) {
          return array.slice();
        }),
        index: 0
      })));
    }
    null == memoCache && (memoCache = {
      data: [],
      index: 0
    });
    null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = updateQueue);
    updateQueue.memoCache = memoCache;
    updateQueue = memoCache.data[memoCache.index];
    if (void 0 === updateQueue || ignorePreviousDependencies) for (updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++) updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;else updateQueue.length !== size && console.error("Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.", updateQueue.length, size);
    memoCache.index++;
    return updateQueue;
  }
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  function mountReducer(reducer, initialArg, init) {
    var hook = mountWorkInProgressHook();
    if (void 0 !== init) {
      var initialState = init(initialArg);
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          init(initialArg);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
    } else initialState = initialArg;
    hook.memoizedState = hook.baseState = initialState;
    reducer = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: reducer,
      lastRenderedState: initialState
    };
    hook.queue = reducer;
    reducer = reducer.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, reducer);
    return [hook.memoizedState, reducer];
  }
  function updateReducer(reducer) {
    var hook = updateWorkInProgressHook();
    return updateReducerImpl(hook, currentHook, reducer);
  }
  function updateReducerImpl(hook, current, reducer) {
    var queue = hook.queue;
    if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
    queue.lastRenderedReducer = reducer;
    var baseQueue = hook.baseQueue,
      pendingQueue = queue.pending;
    if (null !== pendingQueue) {
      if (null !== baseQueue) {
        var baseFirst = baseQueue.next;
        baseQueue.next = pendingQueue.next;
        pendingQueue.next = baseFirst;
      }
      current.baseQueue !== baseQueue && console.error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
      current.baseQueue = baseQueue = pendingQueue;
      queue.pending = null;
    }
    pendingQueue = hook.baseState;
    if (null === baseQueue) hook.memoizedState = pendingQueue;else {
      current = baseQueue.next;
      var newBaseQueueFirst = baseFirst = null,
        newBaseQueueLast = null,
        update = current,
        didReadFromEntangledAsyncAction = !1;
      do {
        var updateLane = update.lane & -536870913;
        if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
          var revertLane = update.revertLane;
          if (0 === revertLane) null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
            lane: 0,
            revertLane: 0,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);else if ((renderLanes & revertLane) === revertLane) {
            update = update.next;
            revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
            continue;
          } else updateLane = {
            lane: 0,
            revertLane: update.revertLane,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber$1.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
          updateLane = update.action;
          shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
          pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
        } else revertLane = {
          lane: updateLane,
          revertLane: update.revertLane,
          action: update.action,
          hasEagerState: update.hasEagerState,
          eagerState: update.eagerState,
          next: null
        }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber$1.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
        update = update.next;
      } while (null !== update && update !== current);
      null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
      if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = !0, didReadFromEntangledAsyncAction && (reducer = currentEntangledActionThenable, null !== reducer))) throw reducer;
      hook.memoizedState = pendingQueue;
      hook.baseState = baseFirst;
      hook.baseQueue = newBaseQueueLast;
      queue.lastRenderedState = pendingQueue;
    }
    null === baseQueue && (queue.lanes = 0);
    return [hook.memoizedState, queue.dispatch];
  }
  function rerenderReducer(reducer) {
    var hook = updateWorkInProgressHook(),
      queue = hook.queue;
    if (null === queue) throw Error("Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)");
    queue.lastRenderedReducer = reducer;
    var dispatch = queue.dispatch,
      lastRenderPhaseUpdate = queue.pending,
      newState = hook.memoizedState;
    if (null !== lastRenderPhaseUpdate) {
      queue.pending = null;
      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      do newState = reducer(newState, update.action), update = update.next; while (update !== lastRenderPhaseUpdate);
      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);
      hook.memoizedState = newState;
      null === hook.baseQueue && (hook.baseState = newState);
      queue.lastRenderedState = newState;
    }
    return [newState, dispatch];
  }
  function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber$1,
      hook = mountWorkInProgressHook();
    if (isHydrating) {
      if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      var nextSnapshot = getServerSnapshot();
      didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
    } else {
      nextSnapshot = getSnapshot();
      didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0));
      if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
      0 !== (workInProgressRootRenderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
    }
    hook.memoizedState = nextSnapshot;
    getServerSnapshot = {
      value: nextSnapshot,
      getSnapshot: getSnapshot
    };
    hook.queue = getServerSnapshot;
    mountEffect(subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe), [subscribe]);
    fiber.flags |= 2048;
    pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, getServerSnapshot, nextSnapshot, getSnapshot), {
      destroy: void 0
    }, null);
    return nextSnapshot;
  }
  function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber$1,
      hook = updateWorkInProgressHook(),
      isHydrating$jscomp$0 = isHydrating;
    if (isHydrating$jscomp$0) {
      if (void 0 === getServerSnapshot) throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
      getServerSnapshot = getServerSnapshot();
    } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
      var cachedSnapshot = getSnapshot();
      objectIs(getServerSnapshot, cachedSnapshot) || (console.error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
    }
    if (cachedSnapshot = !objectIs((currentHook || hook).memoizedState, getServerSnapshot)) hook.memoizedState = getServerSnapshot, didReceiveUpdate = !0;
    hook = hook.queue;
    var create = subscribeToStore.bind(null, fiber, hook, subscribe);
    updateEffectImpl(2048, Passive, create, [subscribe]);
    if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
      fiber.flags |= 2048;
      pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, hook, getServerSnapshot, getSnapshot), {
        destroy: void 0
      }, null);
      if (null === workInProgressRoot) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
      isHydrating$jscomp$0 || 0 !== (renderLanes & 60) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    return getServerSnapshot;
  }
  function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
    fiber.flags |= 16384;
    fiber = {
      getSnapshot: getSnapshot,
      value: renderedSnapshot
    };
    getSnapshot = currentlyRenderingFiber$1.updateQueue;
    null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
  }
  function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
    inst.value = nextSnapshot;
    inst.getSnapshot = getSnapshot;
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  }
  function subscribeToStore(fiber, inst, subscribe) {
    return subscribe(function () {
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    });
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return !0;
    }
  }
  function forceStoreRerender(fiber) {
    var root = enqueueConcurrentRenderForLane(fiber, 2);
    null !== root && scheduleUpdateOnFiber(root, fiber, 2);
  }
  function mountStateImpl(initialState) {
    var hook = mountWorkInProgressHook();
    if ("function" === typeof initialState) {
      var initialStateInitializer = initialState;
      initialState = initialStateInitializer();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(!0);
        try {
          initialStateInitializer();
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
    }
    hook.memoizedState = hook.baseState = initialState;
    hook.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialState
    };
    return hook;
  }
  function mountState(initialState) {
    initialState = mountStateImpl(initialState);
    var queue = initialState.queue,
      dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
    queue.dispatch = dispatch;
    return [initialState.memoizedState, dispatch];
  }
  function mountOptimistic(passthrough) {
    var hook = mountWorkInProgressHook();
    hook.memoizedState = hook.baseState = passthrough;
    var queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: null,
      lastRenderedState: null
    };
    hook.queue = queue;
    hook = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !0, queue);
    queue.dispatch = hook;
    return [passthrough, hook];
  }
  function updateOptimistic(passthrough, reducer) {
    var hook = updateWorkInProgressHook();
    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
  }
  function updateOptimisticImpl(hook, current, passthrough, reducer) {
    hook.baseState = passthrough;
    return updateReducerImpl(hook, currentHook, "function" === typeof reducer ? reducer : basicStateReducer);
  }
  function rerenderOptimistic(passthrough, reducer) {
    var hook = updateWorkInProgressHook();
    if (null !== currentHook) return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    hook.baseState = passthrough;
    return [passthrough, hook.queue.dispatch];
  }
  function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
    if (isRenderPhaseUpdate(fiber)) throw Error("Cannot update form state while rendering.");
    fiber = actionQueue.action;
    if (null !== fiber) {
      var actionNode = {
        payload: payload,
        action: fiber,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function (listener) {
          actionNode.listeners.push(listener);
        }
      };
      null !== ReactSharedInternals.T ? setPendingState(!0) : actionNode.isTransition = !1;
      setState(actionNode);
      setPendingState = actionQueue.pending;
      null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
    }
  }
  function runActionStateAction(actionQueue, node) {
    var action = node.action,
      payload = node.payload,
      prevState = actionQueue.state;
    if (node.isTransition) {
      var prevTransition = ReactSharedInternals.T,
        currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      ReactSharedInternals.T._updatedFibers = new Set();
      try {
        var returnValue = action(prevState, payload),
          onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        handleActionReturnValue(actionQueue, node, returnValue);
      } catch (error) {
        onActionError(actionQueue, node, error);
      } finally {
        ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
      }
    } else try {
      currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
    } catch (error$3) {
      onActionError(actionQueue, node, error$3);
    }
  }
  function handleActionReturnValue(actionQueue, node, returnValue) {
    null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(function (nextState) {
      onActionSuccess(actionQueue, node, nextState);
    }, function (error) {
      return onActionError(actionQueue, node, error);
    }), node.isTransition || console.error("An async function was passed to useActionState, but it was dispatched outside of an action context. This is likely not what you intended. Either pass the dispatch function to an `action` prop, or dispatch manually inside `startTransition`")) : onActionSuccess(actionQueue, node, returnValue);
  }
  function onActionSuccess(actionQueue, actionNode, nextState) {
    actionNode.status = "fulfilled";
    actionNode.value = nextState;
    notifyActionListeners(actionNode);
    actionQueue.state = nextState;
    actionNode = actionQueue.pending;
    null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
  }
  function onActionError(actionQueue, actionNode, error) {
    var last = actionQueue.pending;
    actionQueue.pending = null;
    if (null !== last) {
      last = last.next;
      do actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next; while (actionNode !== last);
    }
    actionQueue.action = null;
  }
  function notifyActionListeners(actionNode) {
    actionNode = actionNode.listeners;
    for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
  }
  function actionStateReducer(oldState, newState) {
    return newState;
  }
  function mountActionState(action, initialStateProp) {
    if (isHydrating) {
      var ssrFormState = workInProgressRoot.formState;
      if (null !== ssrFormState) {
        a: {
          var isMatching = currentlyRenderingFiber$1;
          if (isHydrating) {
            if (nextHydratableInstance) {
              b: {
                var markerInstance = nextHydratableInstance;
                for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType;) {
                  if (!inRootOrSingleton) {
                    markerInstance = null;
                    break b;
                  }
                  markerInstance = getNextHydratable(markerInstance.nextSibling);
                  if (null === markerInstance) {
                    markerInstance = null;
                    break b;
                  }
                }
                inRootOrSingleton = markerInstance.data;
                markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
              }
              if (markerInstance) {
                nextHydratableInstance = getNextHydratable(markerInstance.nextSibling);
                isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
                break a;
              }
            }
            throwOnHydrationMismatch(isMatching);
          }
          isMatching = !1;
        }
        isMatching && (initialStateProp = ssrFormState[0]);
      }
    }
    ssrFormState = mountWorkInProgressHook();
    ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
    isMatching = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: actionStateReducer,
      lastRenderedState: initialStateProp
    };
    ssrFormState.queue = isMatching;
    ssrFormState = dispatchSetState.bind(null, currentlyRenderingFiber$1, isMatching);
    isMatching.dispatch = ssrFormState;
    isMatching = mountStateImpl(!1);
    inRootOrSingleton = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, !1, isMatching.queue);
    isMatching = mountWorkInProgressHook();
    markerInstance = {
      state: initialStateProp,
      dispatch: null,
      action: action,
      pending: null
    };
    isMatching.queue = markerInstance;
    ssrFormState = dispatchActionState.bind(null, currentlyRenderingFiber$1, markerInstance, inRootOrSingleton, ssrFormState);
    markerInstance.dispatch = ssrFormState;
    isMatching.memoizedState = action;
    return [initialStateProp, ssrFormState, !1];
  }
  function updateActionState(action) {
    var stateHook = updateWorkInProgressHook();
    return updateActionStateImpl(stateHook, currentHook, action);
  }
  function updateActionStateImpl(stateHook, currentStateHook, action) {
    currentStateHook = updateReducerImpl(stateHook, currentStateHook, actionStateReducer)[0];
    stateHook = updateReducer(basicStateReducer)[0];
    currentStateHook = "object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then ? useThenable(currentStateHook) : currentStateHook;
    var actionQueueHook = updateWorkInProgressHook(),
      actionQueue = actionQueueHook.queue,
      dispatch = actionQueue.dispatch;
    action !== actionQueueHook.memoizedState && (currentlyRenderingFiber$1.flags |= 2048, pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), {
      destroy: void 0
    }, null));
    return [currentStateHook, dispatch, stateHook];
  }
  function actionStateActionEffect(actionQueue, action) {
    actionQueue.action = action;
  }
  function rerenderActionState(action) {
    var stateHook = updateWorkInProgressHook(),
      currentStateHook = currentHook;
    if (null !== currentStateHook) return updateActionStateImpl(stateHook, currentStateHook, action);
    updateWorkInProgressHook();
    stateHook = stateHook.memoizedState;
    currentStateHook = updateWorkInProgressHook();
    var dispatch = currentStateHook.queue.dispatch;
    currentStateHook.memoizedState = action;
    return [stateHook, dispatch, !1];
  }
  function pushEffect(tag, create, inst, deps) {
    tag = {
      tag: tag,
      create: create,
      inst: inst,
      deps: deps,
      next: null
    };
    create = currentlyRenderingFiber$1.updateQueue;
    null === create && (create = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = create);
    inst = create.lastEffect;
    null === inst ? create.lastEffect = tag.next = tag : (deps = inst.next, inst.next = tag, tag.next = deps, create.lastEffect = tag);
    return tag;
  }
  function mountRef(initialValue) {
    var hook = mountWorkInProgressHook();
    initialValue = {
      current: initialValue
    };
    return hook.memoizedState = initialValue;
  }
  function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = mountWorkInProgressHook();
    currentlyRenderingFiber$1.flags |= fiberFlags;
    hook.memoizedState = pushEffect(HasEffect | hookFlags, create, {
      destroy: void 0
    }, void 0 === deps ? null : deps);
  }
  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var inst = hook.memoizedState.inst;
    null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushEffect(hookFlags, create, inst, deps) : (currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, deps));
  }
  function mountEffect(create, deps) {
    (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(142608384, Passive, create, deps) : mountEffectImpl(8390656, Passive, create, deps);
  }
  function mountLayoutEffect(create, deps) {
    var fiberFlags = 4194308;
    (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
    return mountEffectImpl(fiberFlags, Layout, create, deps);
  }
  function imperativeHandleEffect(create, ref) {
    if ("function" === typeof ref) {
      create = create();
      var refCleanup = ref(create);
      return function () {
        "function" === typeof refCleanup ? refCleanup() : ref(null);
      };
    }
    if (null !== ref && void 0 !== ref) return ref.hasOwnProperty("current") || console.error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(ref).join(", ") + "}"), create = create(), ref.current = create, function () {
      ref.current = null;
    };
  }
  function mountImperativeHandle(ref, create, deps) {
    "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    var fiberFlags = 4194308;
    (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 67108864);
    mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
  }
  function updateImperativeHandle(ref, create, deps) {
    "function" !== typeof create && console.error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", null !== create ? typeof create : "null");
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    updateEffectImpl(4, Layout, imperativeHandleEffect.bind(null, create, ref), deps);
  }
  function mountCallback(callback, deps) {
    mountWorkInProgressHook().memoizedState = [callback, void 0 === deps ? null : deps];
    return callback;
  }
  function updateCallback(callback, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    hook.memoizedState = [callback, deps];
    return callback;
  }
  function mountMemo(nextCreate, deps) {
    var hook = mountWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var nextValue = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    hook.memoizedState = [nextValue, deps];
    return nextValue;
  }
  function updateMemo(nextCreate, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1])) return prevState[0];
    prevState = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(!0);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    hook.memoizedState = [prevState, deps];
    return prevState;
  }
  function mountDeferredValue(value, initialValue) {
    var hook = mountWorkInProgressHook();
    return mountDeferredValueImpl(hook, value, initialValue);
  }
  function updateDeferredValue(value, initialValue) {
    var hook = updateWorkInProgressHook();
    return updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
  }
  function rerenderDeferredValue(value, initialValue) {
    var hook = updateWorkInProgressHook();
    return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(hook, currentHook.memoizedState, value, initialValue);
  }
  function mountDeferredValueImpl(hook, value, initialValue) {
    if (void 0 === initialValue || 0 !== (renderLanes & 1073741824)) return hook.memoizedState = value;
    hook.memoizedState = initialValue;
    hook = requestDeferredLane();
    currentlyRenderingFiber$1.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return initialValue;
  }
  function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
    if (objectIs(value, prevValue)) return value;
    if (null !== currentTreeHiddenStackCursor.current) return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = !0), hook;
    if (0 === (renderLanes & 42)) return didReceiveUpdate = !0, hook.memoizedState = value;
    hook = requestDeferredLane();
    currentlyRenderingFiber$1.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return prevValue;
  }
  function startTransition(fiber, queue, pendingState, finishedState, callback) {
    var previousPriority = ReactDOMSharedInternals.p;
    ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    dispatchOptimisticSetState(fiber, !1, queue, pendingState);
    currentTransition._updatedFibers = new Set();
    try {
      var returnValue = callback(),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
        var thenableForFinishedState = chainThenableValue(returnValue, finishedState);
        dispatchSetStateInternal(fiber, queue, thenableForFinishedState, requestUpdateLane(fiber));
      } else dispatchSetStateInternal(fiber, queue, finishedState, requestUpdateLane(fiber));
    } catch (error) {
      dispatchSetStateInternal(fiber, queue, {
        then: function () {},
        status: "rejected",
        reason: error
      }, requestUpdateLane(fiber));
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."));
    }
  }
  function startHostTransition(formFiber, pendingState, action, formData) {
    if (5 !== formFiber.tag) throw Error("Expected the form instance to be a HostComponent. This is a bug in React.");
    var queue = ensureFormComponentIsStateful(formFiber).queue;
    startTransition(formFiber, queue, pendingState, NotPendingTransition, null === action ? noop$2 : function () {
      requestFormReset$1(formFiber);
      return action(formData);
    });
  }
  function ensureFormComponentIsStateful(formFiber) {
    var existingStateHook = formFiber.memoizedState;
    if (null !== existingStateHook) return existingStateHook;
    existingStateHook = {
      memoizedState: NotPendingTransition,
      baseState: NotPendingTransition,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: NotPendingTransition
      },
      next: null
    };
    var initialResetState = {};
    existingStateHook.next = {
      memoizedState: initialResetState,
      baseState: initialResetState,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialResetState
      },
      next: null
    };
    formFiber.memoizedState = existingStateHook;
    formFiber = formFiber.alternate;
    null !== formFiber && (formFiber.memoizedState = existingStateHook);
    return existingStateHook;
  }
  function requestFormReset$1(formFiber) {
    null === ReactSharedInternals.T && console.error("requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition.");
    var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
    dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane(formFiber));
  }
  function mountTransition() {
    var stateHook = mountStateImpl(!1);
    stateHook = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, !0, !1);
    mountWorkInProgressHook().memoizedState = stateHook;
    return [!1, stateHook];
  }
  function updateTransition() {
    var booleanOrThenable = updateReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
  }
  function rerenderTransition() {
    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],
      start = updateWorkInProgressHook().memoizedState;
    return ["boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable), start];
  }
  function useHostTransitionStatus() {
    return readContext(HostTransitionContext);
  }
  function mountId() {
    var hook = mountWorkInProgressHook(),
      identifierPrefix = workInProgressRoot.identifierPrefix;
    if (isHydrating) {
      var treeId = treeContextOverflow;
      var idWithLeadingBit = treeContextId;
      treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
      identifierPrefix = ":" + identifierPrefix + "R" + treeId;
      treeId = localIdCounter++;
      0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
      identifierPrefix += ":";
    } else treeId = globalClientIdCounter++, identifierPrefix = ":" + identifierPrefix + "r" + treeId.toString(32) + ":";
    return hook.memoizedState = identifierPrefix;
  }
  function mountRefresh() {
    return mountWorkInProgressHook().memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);
  }
  function refreshCache(fiber, seedKey) {
    for (var provider = fiber.return; null !== provider;) {
      switch (provider.tag) {
        case 24:
        case 3:
          var lane = requestUpdateLane(provider);
          fiber = createUpdate(lane);
          var root = enqueueUpdate(provider, fiber, lane);
          null !== root && (scheduleUpdateOnFiber(root, provider, lane), entangleTransitions(root, provider, lane));
          provider = createCache();
          null !== seedKey && void 0 !== seedKey && null !== root && console.error("The seed argument is not enabled outside experimental channels.");
          fiber.payload = {
            cache: provider
          };
          return;
      }
      provider = provider.return;
    }
  }
  function dispatchReducerAction(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0) {
    "function" === typeof JSCompiler_OptimizeArgumentsArray_p0 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
    JSCompiler_OptimizeArgumentsArray_p0 = requestUpdateLane(fiber);
    action = {
      lane: JSCompiler_OptimizeArgumentsArray_p0,
      revertLane: 0,
      action: action,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p0), null !== action && (scheduleUpdateOnFiber(action, fiber, JSCompiler_OptimizeArgumentsArray_p0), entangleTransitionUpdate(action, queue, JSCompiler_OptimizeArgumentsArray_p0)));
    markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p0);
  }
  function dispatchSetState(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1) {
    "function" === typeof JSCompiler_OptimizeArgumentsArray_p1 && console.error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
    JSCompiler_OptimizeArgumentsArray_p1 = requestUpdateLane(fiber);
    dispatchSetStateInternal(fiber, queue, action, JSCompiler_OptimizeArgumentsArray_p1);
    markStateUpdateScheduled(fiber, JSCompiler_OptimizeArgumentsArray_p1);
  }
  function dispatchSetStateInternal(fiber, queue, action, lane) {
    var update = {
      lane: lane,
      revertLane: 0,
      action: action,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);else {
      var alternate = fiber.alternate;
      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
        try {
          var currentState = queue.lastRenderedState,
            eagerState = alternate(currentState, action);
          update.hasEagerState = !0;
          update.eagerState = eagerState;
          if (objectIs(eagerState, currentState)) return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), !1;
        } catch (error) {} finally {
          ReactSharedInternals.H = prevDispatcher;
        }
      }
      action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
      if (null !== action) return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), !0;
    }
    return !1;
  }
  function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
    null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error("An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition.");
    action = {
      lane: 2,
      revertLane: requestTransitionLane(),
      action: action,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) {
      if (throwIfDuringRender) throw Error("Cannot update optimistic state while rendering.");
      console.error("Cannot call startTransition while rendering.");
    } else throwIfDuringRender = enqueueConcurrentHookUpdate(fiber, queue, action, 2), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    markStateUpdateScheduled(fiber, 2);
  }
  function isRenderPhaseUpdate(fiber) {
    var alternate = fiber.alternate;
    return fiber === currentlyRenderingFiber$1 || null !== alternate && alternate === currentlyRenderingFiber$1;
  }
  function enqueueRenderPhaseUpdate(queue, update) {
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
    var pending = queue.pending;
    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
    queue.pending = update;
  }
  function entangleTransitionUpdate(root, queue, lane) {
    if (0 !== (lane & 4194176)) {
      var queueLanes = queue.lanes;
      queueLanes &= root.pendingLanes;
      lane |= queueLanes;
      queue.lanes = lane;
      markRootEntangled(root, lane);
    }
  }
  function warnOnInvalidCallback(callback) {
    if (null !== callback && "function" !== typeof callback) {
      var key = String(callback);
      didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback));
    }
  }
  function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {
    var prevState = workInProgress.memoizedState,
      partialState = getDerivedStateFromProps(nextProps, prevState);
    if (workInProgress.mode & StrictLegacyMode) {
      setIsStrictModeForDevtools(!0);
      try {
        partialState = getDerivedStateFromProps(nextProps, prevState);
      } finally {
        setIsStrictModeForDevtools(!1);
      }
    }
    void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", ctor)));
    prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
    workInProgress.memoizedState = prevState;
    0 === workInProgress.lanes && (workInProgress.updateQueue.baseState = prevState);
  }
  function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {
    var instance = workInProgress.stateNode;
    if ("function" === typeof instance.shouldComponentUpdate) {
      oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          oldProps = instance.shouldComponentUpdate(newProps, newState, nextContext);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      void 0 === oldProps && console.error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
      return oldProps;
    }
    return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
  }
  function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {
    var oldState = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== oldState && (workInProgress = getComponentNameFromFiber(workInProgress) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress) || (didWarnAboutStateAssignmentForComponent.add(workInProgress), console.error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", workInProgress)), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
  }
  function resolveClassComponentProps(Component, baseProps) {
    var newProps = baseProps;
    if ("ref" in baseProps) {
      newProps = {};
      for (var propName in baseProps) "ref" !== propName && (newProps[propName] = baseProps[propName]);
    }
    if (Component = Component.defaultProps) {
      newProps === baseProps && (newProps = assign({}, newProps));
      for (var _propName in Component) void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
    }
    return newProps;
  }
  function defaultOnUncaughtError(error, errorInfo) {
    reportGlobalError(error);
    error = componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.";
    var prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
      componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
    ReactSharedInternals.getCurrentStack = function () {
      return componentStack;
    };
    try {
      console.warn("%s\n\n%s\n", error, "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries.");
    } finally {
      ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
    }
  }
  function defaultOnCaughtError(error, errorInfo) {
    var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.",
      recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + "."),
      prevGetCurrentStack = ReactSharedInternals.getCurrentStack,
      componentStack = null != errorInfo.componentStack ? errorInfo.componentStack : "";
    ReactSharedInternals.getCurrentStack = function () {
      return componentStack;
    };
    try {
      "object" === typeof error && null !== error && "string" === typeof error.environmentName ? bindToConsole("error", ["%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage], error.environmentName)() : console.error("%o\n\n%s\n\n%s\n", error, componentNameMessage, recreateMessage);
    } finally {
      ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
    }
  }
  function defaultOnRecoverableError(error) {
    reportGlobalError(error);
  }
  function logUncaughtError(root, errorInfo) {
    try {
      componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
      errorBoundaryName = null;
      var error = errorInfo.value;
      if (null !== ReactSharedInternals.actQueue) ReactSharedInternals.thrownErrors.push(error);else {
        var onUncaughtError = root.onUncaughtError;
        onUncaughtError(error, {
          componentStack: errorInfo.stack
        });
      }
    } catch (e$4) {
      setTimeout(function () {
        throw e$4;
      });
    }
  }
  function logCaughtError(root, boundary, errorInfo) {
    try {
      componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
      errorBoundaryName = getComponentNameFromFiber(boundary);
      var onCaughtError = root.onCaughtError;
      onCaughtError(errorInfo.value, {
        componentStack: errorInfo.stack,
        errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
      });
    } catch (e$5) {
      setTimeout(function () {
        throw e$5;
      });
    }
  }
  function createRootErrorUpdate(root, errorInfo, lane) {
    lane = createUpdate(lane);
    lane.tag = CaptureUpdate;
    lane.payload = {
      element: null
    };
    lane.callback = function () {
      runWithFiberInDEV(errorInfo.source, logUncaughtError, root, errorInfo);
    };
    return lane;
  }
  function createClassErrorUpdate(lane) {
    lane = createUpdate(lane);
    lane.tag = CaptureUpdate;
    return lane;
  }
  function initializeClassErrorUpdate(update, root, fiber, errorInfo) {
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;
      update.payload = function () {
        return getDerivedStateFromError(error);
      };
      update.callback = function () {
        markFailedErrorBoundaryForHotReloading(fiber);
        runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
      };
    }
    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function () {
      markFailedErrorBoundaryForHotReloading(fiber);
      runWithFiberInDEV(errorInfo.source, logCaughtError, root, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
      callComponentDidCatchInDEV(this, errorInfo);
      "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
    });
  }
  function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {
    sourceFiber.flags |= 32768;
    isDevToolsPresent && restorePendingUpdaters(root, rootRenderLanes);
    if (null !== value && "object" === typeof value && "function" === typeof value.then) {
      returnFiber = sourceFiber.alternate;
      null !== returnFiber && propagateParentContextChanges(returnFiber, sourceFiber, rootRenderLanes, !0);
      isHydrating && (didSuspendOrErrorDEV = !0);
      sourceFiber = suspenseHandlerStackCursor.current;
      if (null !== sourceFiber) {
        switch (sourceFiber.tag) {
          case 13:
            return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = new Set([value]) : returnFiber.add(value), attachPingListener(root, value, rootRenderLanes)), !1;
          case 22:
            return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
              transitions: null,
              markerInstances: null,
              retryQueue: new Set([value])
            }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = new Set([value]) : sourceFiber.add(value)), attachPingListener(root, value, rootRenderLanes)), !1;
        }
        throw Error("Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React.");
      }
      attachPingListener(root, value, rootRenderLanes);
      renderDidSuspendDelayIfPossible();
      return !1;
    }
    if (isHydrating) return didSuspendOrErrorDEV = !0, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.", {
      cause: value
    }), sourceFiber))) : (value !== HydrationMismatchException && queueHydrationError(createCapturedValueAtFiber(Error("There was an error while hydrating but React was able to recover by instead client rendering the entire root.", {
      cause: value
    }), sourceFiber)), root = root.current.alternate, root.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(root.stateNode, value, rootRenderLanes), enqueueCapturedUpdate(root, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), !1;
    var error = createCapturedValueAtFiber(Error("There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.", {
      cause: value
    }), sourceFiber);
    null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
    workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
    if (null === returnFiber) return !0;
    value = createCapturedValueAtFiber(value, sourceFiber);
    sourceFiber = returnFiber;
    do {
      switch (sourceFiber.tag) {
        case 3:
          return sourceFiber.flags |= 65536, root = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root, root = createRootErrorUpdate(sourceFiber.stateNode, value, root), enqueueCapturedUpdate(sourceFiber, root), !1;
        case 1:
          if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error)))) return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(rootRenderLanes, root, sourceFiber, value), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), !1;
      }
      sourceFiber = sourceFiber.return;
    } while (null !== sourceFiber);
    return !1;
  }
  function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {
    workInProgress.child = null === current ? mountChildFibers(workInProgress, null, nextChildren, renderLanes) : reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);
  }
  function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {
    Component = Component.render;
    var ref = workInProgress.ref;
    if ("ref" in nextProps) {
      var propsWithoutRef = {};
      for (var key in nextProps) "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
    } else propsWithoutRef = nextProps;
    prepareToReadContext(workInProgress);
    markComponentRenderStarted(workInProgress);
    nextProps = renderWithHooks(current, workInProgress, Component, propsWithoutRef, ref, renderLanes);
    key = checkDidRenderIdHook();
    markComponentRenderStopped();
    if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    isHydrating && key && pushMaterializedTreeId(workInProgress);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    return workInProgress.child;
  }
  function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
    if (null === current) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare) return Component = resolveFunctionForHotReloading(type), workInProgress.tag = 15, workInProgress.type = Component, validateFunctionComponentInDev(workInProgress, type), updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes);
      current = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);
      current.ref = workInProgress.ref;
      current.return = workInProgress;
      return workInProgress.child = current;
    }
    type = current.child;
    if (!checkScheduledUpdateOrContext(current, renderLanes)) {
      var prevProps = type.memoizedProps;
      Component = Component.compare;
      Component = null !== Component ? Component : shallowEqual;
      if (Component(prevProps, nextProps) && current.ref === workInProgress.ref) return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    workInProgress.flags |= 1;
    current = createWorkInProgress(type, nextProps);
    current.ref = workInProgress.ref;
    current.return = workInProgress;
    return workInProgress.child = current;
  }
  function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {
    if (null !== current) {
      var prevProps = current.memoizedProps;
      if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) if (didReceiveUpdate = !1, workInProgress.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes)) 0 !== (current.flags & 131072) && (didReceiveUpdate = !0);else return workInProgress.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
    return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);
  }
  function updateOffscreenComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
      nextChildren = nextProps.children,
      nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & OffscreenDetached),
      prevState = null !== current ? current.memoizedState : null;
    markRef(current, workInProgress);
    if ("hidden" === nextProps.mode || nextIsDetached) {
      if (0 !== (workInProgress.flags & 128)) {
        nextProps = null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;
        if (null !== current) {
          nextChildren = workInProgress.child = current.child;
          for (nextIsDetached = 0; null !== nextChildren;) nextIsDetached = nextIsDetached | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
          workInProgress.childLanes = nextIsDetached & ~nextProps;
        } else workInProgress.childLanes = 0, workInProgress.child = null;
        return deferHiddenOffscreenComponent(current, workInProgress, nextProps, renderLanes);
      }
      if (0 !== (renderLanes & 536870912)) workInProgress.memoizedState = {
        baseLanes: 0,
        cachePool: null
      }, null !== current && pushTransition(workInProgress, null !== prevState ? prevState.cachePool : null), null !== prevState ? pushHiddenContext(workInProgress, prevState) : reuseHiddenContextOnStack(workInProgress), pushOffscreenSuspenseHandler(workInProgress);else return workInProgress.lanes = workInProgress.childLanes = 536870912, deferHiddenOffscreenComponent(current, workInProgress, null !== prevState ? prevState.baseLanes | renderLanes : renderLanes, renderLanes);
    } else null !== prevState ? (pushTransition(workInProgress, prevState.cachePool), pushHiddenContext(workInProgress, prevState), reuseSuspenseHandlerOnStack(workInProgress), workInProgress.memoizedState = null) : (null !== current && pushTransition(workInProgress, null), reuseHiddenContextOnStack(workInProgress), reuseSuspenseHandlerOnStack(workInProgress));
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
  }
  function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {
    var JSCompiler_inline_result = peekCacheFromPool();
    JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
      parent: CacheContext._currentValue,
      pool: JSCompiler_inline_result
    };
    workInProgress.memoizedState = {
      baseLanes: nextBaseLanes,
      cachePool: JSCompiler_inline_result
    };
    null !== current && pushTransition(workInProgress, null);
    reuseHiddenContextOnStack(workInProgress);
    pushOffscreenSuspenseHandler(workInProgress);
    null !== current && propagateParentContextChanges(current, workInProgress, renderLanes, !0);
    return null;
  }
  function markRef(current, workInProgress) {
    var ref = workInProgress.ref;
    if (null === ref) null !== current && null !== current.ref && (workInProgress.flags |= 2097664);else {
      if ("function" !== typeof ref && "object" !== typeof ref) throw Error("Expected ref to be a function, an object returned by React.createRef(), or undefined/null.");
      if (null === current || current.ref !== ref) workInProgress.flags |= 2097664;
    }
  }
  function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {
    if (Component.prototype && "function" === typeof Component.prototype.render) {
      var componentName = getComponentNameFromType(Component) || "Unknown";
      didWarnAboutBadClass[componentName] || (console.error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
    }
    workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);
    null === current && (validateFunctionComponentInDev(workInProgress, workInProgress.type), Component.contextTypes && (componentName = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName] || (didWarnAboutContextTypes[componentName] = !0, console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)", componentName))));
    prepareToReadContext(workInProgress);
    markComponentRenderStarted(workInProgress);
    Component = renderWithHooks(current, workInProgress, Component, nextProps, void 0, renderLanes);
    nextProps = checkDidRenderIdHook();
    markComponentRenderStopped();
    if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    isHydrating && nextProps && pushMaterializedTreeId(workInProgress);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, Component, renderLanes);
    return workInProgress.child;
  }
  function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {
    prepareToReadContext(workInProgress);
    markComponentRenderStarted(workInProgress);
    hookTypesUpdateIndexDev = -1;
    ignorePreviousDependencies = null !== current && current.type !== workInProgress.type;
    workInProgress.updateQueue = null;
    nextProps = renderWithHooksAgain(workInProgress, Component, nextProps, secondArg);
    finishRenderingHooks(current, workInProgress);
    Component = checkDidRenderIdHook();
    markComponentRenderStopped();
    if (null !== current && !didReceiveUpdate) return bailoutHooks(current, workInProgress, renderLanes), bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    isHydrating && Component && pushMaterializedTreeId(workInProgress);
    workInProgress.flags |= 1;
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    return workInProgress.child;
  }
  function updateClassComponent(current$jscomp$0, workInProgress, Component, nextProps, renderLanes) {
    switch (shouldErrorImpl(workInProgress)) {
      case !1:
        var _instance = workInProgress.stateNode,
          state = new workInProgress.type(workInProgress.memoizedProps, _instance.context).state;
        _instance.updater.enqueueSetState(_instance, state, null);
        break;
      case !0:
        workInProgress.flags |= 128;
        workInProgress.flags |= 65536;
        _instance = Error("Simulated error coming from DevTools");
        var lane = renderLanes & -renderLanes;
        workInProgress.lanes |= lane;
        state = workInProgressRoot;
        if (null === state) throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        lane = createClassErrorUpdate(lane);
        initializeClassErrorUpdate(lane, state, workInProgress, createCapturedValueAtFiber(_instance, workInProgress));
        enqueueCapturedUpdate(workInProgress, lane);
    }
    prepareToReadContext(workInProgress);
    if (null === workInProgress.stateNode) {
      state = emptyContextObject;
      _instance = Component.contextType;
      "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(Component) || "Component", lane));
      "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
      _instance = new Component(nextProps, state);
      if (workInProgress.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          _instance = new Component(nextProps, state);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      state = workInProgress.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
      _instance.updater = classComponentUpdater;
      workInProgress.stateNode = _instance;
      _instance._reactInternals = workInProgress;
      _instance._reactInternalInstance = fakeInternalInstance;
      "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", state, null === _instance.state ? "null" : "undefined", state)));
      if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
        var foundWillUpdateName = lane = state = null;
        "function" === typeof _instance.componentWillMount && !0 !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
        "function" === typeof _instance.componentWillReceiveProps && !0 !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
        "function" === typeof _instance.componentWillUpdate && !0 !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
        if (null !== state || null !== lane || null !== foundWillUpdateName) {
          _instance = getComponentNameFromType(Component) || "Component";
          var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
          didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles", _instance, newApiName, null !== state ? "\n  " + state : "", null !== lane ? "\n  " + lane : "", null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""));
        }
      }
      _instance = workInProgress.stateNode;
      state = getComponentNameFromType(Component) || "Component";
      _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error("No `render` method found on the %s instance: did you accidentally return an object from the constructor?", state) : console.error("No `render` method found on the %s instance: you may have forgotten to define `render`.", state));
      !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", state);
      _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", state);
      _instance.contextType && console.error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", state);
      Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error("%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)", state));
      Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error("%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)", state));
      "function" === typeof _instance.componentShouldUpdate && console.error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", state);
      Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(Component) || "A pure component");
      "function" === typeof _instance.componentDidUnmount && console.error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", state);
      "function" === typeof _instance.componentDidReceiveProps && console.error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", state);
      "function" === typeof _instance.componentWillRecieveProps && console.error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", state);
      "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", state);
      lane = _instance.props !== nextProps;
      void 0 !== _instance.props && lane && console.error("When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", state);
      _instance.defaultProps && console.error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", state, state);
      "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(Component)));
      "function" === typeof _instance.getDerivedStateFromProps && console.error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
      "function" === typeof _instance.getDerivedStateFromError && console.error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", state);
      "function" === typeof Component.getSnapshotBeforeUpdate && console.error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", state);
      (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
      "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", state);
      _instance = workInProgress.stateNode;
      _instance.props = nextProps;
      _instance.state = workInProgress.memoizedState;
      _instance.refs = {};
      initializeUpdateQueue(workInProgress);
      state = Component.contextType;
      _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
      _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", state)));
      workInProgress.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, _instance);
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, _instance);
      _instance.state = workInProgress.memoizedState;
      state = Component.getDerivedStateFromProps;
      "function" === typeof state && (applyDerivedStateFromProps(workInProgress, Component, state, nextProps), _instance.state = workInProgress.memoizedState);
      "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress) || "Component"), classComponentUpdater.enqueueReplaceState(_instance, _instance.state, null)), processUpdateQueue(workInProgress, nextProps, _instance, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress.memoizedState);
      "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308);
      (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864);
      _instance = !0;
    } else if (null === current$jscomp$0) {
      _instance = workInProgress.stateNode;
      var unresolvedOldProps = workInProgress.memoizedProps;
      lane = resolveClassComponentProps(Component, unresolvedOldProps);
      _instance.props = lane;
      var oldContext = _instance.context;
      foundWillUpdateName = Component.contextType;
      state = emptyContextObject;
      "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
      newApiName = Component.getDerivedStateFromProps;
      foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
      unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;
      foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, state);
      hasForceUpdate = !1;
      var oldState = workInProgress.memoizedState;
      _instance.state = oldState;
      processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
      suspendIfUpdateReadFromEntangledAsyncAction();
      oldContext = workInProgress.memoizedState;
      unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(workInProgress, Component, newApiName, nextProps), oldContext = workInProgress.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, lane, nextProps, oldState, oldContext, state)) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864)) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress.flags |= 4194308), (workInProgress.mode & StrictEffectsMode) !== NoMode && (workInProgress.flags |= 67108864), _instance = !1);
    } else {
      _instance = workInProgress.stateNode;
      cloneUpdateQueue(current$jscomp$0, workInProgress);
      state = workInProgress.memoizedProps;
      foundWillUpdateName = resolveClassComponentProps(Component, state);
      _instance.props = foundWillUpdateName;
      newApiName = workInProgress.pendingProps;
      oldState = _instance.context;
      oldContext = Component.contextType;
      lane = emptyContextObject;
      "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
      unresolvedOldProps = Component.getDerivedStateFromProps;
      (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(workInProgress, _instance, nextProps, lane);
      hasForceUpdate = !1;
      oldState = workInProgress.memoizedState;
      _instance.state = oldState;
      processUpdateQueue(workInProgress, nextProps, _instance, renderLanes);
      suspendIfUpdateReadFromEntangledAsyncAction();
      var newState = workInProgress.memoizedState;
      state !== newApiName || oldState !== newState || hasForceUpdate || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(workInProgress, Component, unresolvedOldProps, nextProps), newState = workInProgress.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(workInProgress, Component, foundWillUpdateName, nextProps, oldState, newState, lane) || null !== current$jscomp$0 && null !== current$jscomp$0.dependencies && checkIfContextChanged(current$jscomp$0.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(nextProps, newState, lane)), "function" === typeof _instance.componentDidUpdate && (workInProgress.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), workInProgress.memoizedProps = nextProps, workInProgress.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current$jscomp$0.memoizedProps && oldState === current$jscomp$0.memoizedState || (workInProgress.flags |= 1024), _instance = !1);
    }
    lane = _instance;
    markRef(current$jscomp$0, workInProgress);
    state = 0 !== (workInProgress.flags & 128);
    if (lane || state) {
      lane = workInProgress.stateNode;
      ReactSharedInternals.getCurrentStack = null === workInProgress ? null : getCurrentFiberStackInDev;
      isRendering = !1;
      current = workInProgress;
      if (state && "function" !== typeof Component.getDerivedStateFromError) Component = null, profilerStartTime = -1;else {
        markComponentRenderStarted(workInProgress);
        Component = callRenderInDEV(lane);
        if (workInProgress.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            callRenderInDEV(lane);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        markComponentRenderStopped();
      }
      workInProgress.flags |= 1;
      null !== current$jscomp$0 && state ? (workInProgress.child = reconcileChildFibers(workInProgress, current$jscomp$0.child, null, renderLanes), workInProgress.child = reconcileChildFibers(workInProgress, null, Component, renderLanes)) : reconcileChildren(current$jscomp$0, workInProgress, Component, renderLanes);
      workInProgress.memoizedState = lane.state;
      current$jscomp$0 = workInProgress.child;
    } else current$jscomp$0 = bailoutOnAlreadyFinishedWork(current$jscomp$0, workInProgress, renderLanes);
    renderLanes = workInProgress.stateNode;
    _instance && renderLanes.props !== nextProps && (didWarnAboutReassigningProps || console.error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress) || "a component"), didWarnAboutReassigningProps = !0);
    return current$jscomp$0;
  }
  function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {
    resetHydrationState();
    workInProgress.flags |= 256;
    reconcileChildren(current, workInProgress, nextChildren, renderLanes);
    return workInProgress.child;
  }
  function validateFunctionComponentInDev(workInProgress, Component) {
    Component && Component.childContextTypes && console.error("childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...", Component.displayName || Component.name || "Component");
    "function" === typeof Component.getDerivedStateFromProps && (workInProgress = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] || (console.error("%s: Function components do not support getDerivedStateFromProps.", workInProgress), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress] = !0));
    "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error("%s: Function components do not support contextType.", Component), didWarnAboutContextTypeOnFunctionComponent[Component] = !0));
  }
  function mountSuspenseOffscreenState(renderLanes) {
    return {
      baseLanes: renderLanes,
      cachePool: getSuspendedCache()
    };
  }
  function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {
    current = null !== current ? current.childLanes & ~renderLanes : 0;
    primaryTreeDidDefer && (current |= workInProgressDeferredLane);
    return current;
  }
  function updateSuspenseComponent(current, workInProgress, renderLanes) {
    var JSCompiler_object_inline_digest_2317;
    var JSCompiler_object_inline_stack_2318 = workInProgress.pendingProps;
    shouldSuspendImpl(workInProgress) && (workInProgress.flags |= 128);
    var JSCompiler_object_inline_componentStack_2319 = !1;
    var didSuspend = 0 !== (workInProgress.flags & 128);
    (JSCompiler_object_inline_digest_2317 = didSuspend) || (JSCompiler_object_inline_digest_2317 = null !== current && null === current.memoizedState ? !1 : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
    JSCompiler_object_inline_digest_2317 && (JSCompiler_object_inline_componentStack_2319 = !0, workInProgress.flags &= -129);
    JSCompiler_object_inline_digest_2317 = 0 !== (workInProgress.flags & 32);
    workInProgress.flags &= -33;
    if (null === current) {
      if (isHydrating) {
        JSCompiler_object_inline_componentStack_2319 ? pushPrimaryTreeSuspenseHandler(workInProgress) : reuseSuspenseHandlerOnStack(workInProgress);
        if (isHydrating) {
          var JSCompiler_object_inline_message_2316 = nextHydratableInstance;
          var JSCompiler_temp;
          if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2316)) {
            c: {
              var instance = JSCompiler_object_inline_message_2316;
              for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType;) {
                if (!JSCompiler_temp) {
                  JSCompiler_temp = null;
                  break c;
                }
                instance = getNextHydratable(instance.nextSibling);
                if (null === instance) {
                  JSCompiler_temp = null;
                  break c;
                }
              }
              JSCompiler_temp = instance;
            }
            null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress.memoizedState = {
              dehydrated: JSCompiler_temp,
              treeContext: null !== treeContextProvider ? {
                id: treeContextId,
                overflow: treeContextOverflow
              } : null,
              retryLane: 536870912
            }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress, workInProgress.child = instance, hydrationParentFiber = workInProgress, nextHydratableInstance = null, JSCompiler_temp = !0) : JSCompiler_temp = !1;
            JSCompiler_temp = !JSCompiler_temp;
          }
          JSCompiler_temp && (warnNonHydratedInstance(workInProgress, JSCompiler_object_inline_message_2316), throwOnHydrationMismatch(workInProgress));
        }
        JSCompiler_object_inline_message_2316 = workInProgress.memoizedState;
        if (null !== JSCompiler_object_inline_message_2316 && (JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_message_2316.dehydrated, null !== JSCompiler_object_inline_message_2316)) return JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA ? workInProgress.lanes = 16 : workInProgress.lanes = 536870912, null;
        popSuspenseHandler(workInProgress);
      }
      JSCompiler_object_inline_message_2316 = JSCompiler_object_inline_stack_2318.children;
      JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_stack_2318.fallback;
      if (JSCompiler_object_inline_componentStack_2319) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = workInProgress.mode, JSCompiler_object_inline_message_2316 = mountWorkInProgressOffscreenFiber({
        mode: "hidden",
        children: JSCompiler_object_inline_message_2316
      }, JSCompiler_object_inline_componentStack_2319), JSCompiler_object_inline_stack_2318 = createFiberFromFragment(JSCompiler_object_inline_stack_2318, JSCompiler_object_inline_componentStack_2319, renderLanes, null), JSCompiler_object_inline_message_2316.return = workInProgress, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_message_2316.sibling = JSCompiler_object_inline_stack_2318, workInProgress.child = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319 = workInProgress.child, JSCompiler_object_inline_componentStack_2319.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
      pushPrimaryTreeSuspenseHandler(workInProgress);
      return mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_message_2316);
    }
    var prevState = current.memoizedState;
    if (null !== prevState && (JSCompiler_object_inline_message_2316 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2316)) {
      if (didSuspend) workInProgress.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags &= -257, workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)) : null !== workInProgress.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress), workInProgress.child = current.child, workInProgress.flags |= 128, workInProgress = null) : (reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress.mode, JSCompiler_object_inline_stack_2318 = mountWorkInProgressOffscreenFiber({
        mode: "visible",
        children: JSCompiler_object_inline_stack_2318.children
      }, JSCompiler_object_inline_message_2316), JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_message_2316, renderLanes, null), JSCompiler_object_inline_componentStack_2319.flags |= 2, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_componentStack_2319.return = workInProgress, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress.child = JSCompiler_object_inline_stack_2318, reconcileChildFibers(workInProgress, current.child, null, renderLanes), JSCompiler_object_inline_stack_2318 = workInProgress.child, JSCompiler_object_inline_stack_2318.memoizedState = mountSuspenseOffscreenState(renderLanes), JSCompiler_object_inline_stack_2318.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, workInProgress = JSCompiler_object_inline_componentStack_2319);else if (pushPrimaryTreeSuspenseHandler(workInProgress), isHydrating && console.error("We should not be hydrating here. This is a bug in React. Please file a bug."), JSCompiler_object_inline_message_2316.data === SUSPENSE_FALLBACK_START_DATA) {
        JSCompiler_object_inline_digest_2317 = JSCompiler_object_inline_message_2316.nextSibling && JSCompiler_object_inline_message_2316.nextSibling.dataset;
        if (JSCompiler_object_inline_digest_2317) {
          JSCompiler_temp = JSCompiler_object_inline_digest_2317.dgst;
          var message = JSCompiler_object_inline_digest_2317.msg;
          instance = JSCompiler_object_inline_digest_2317.stck;
          var componentStack = JSCompiler_object_inline_digest_2317.cstck;
        }
        JSCompiler_object_inline_message_2316 = message;
        JSCompiler_object_inline_digest_2317 = JSCompiler_temp;
        JSCompiler_object_inline_stack_2318 = instance;
        JSCompiler_temp = JSCompiler_object_inline_componentStack_2319 = componentStack;
        JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_message_2316 ? Error(JSCompiler_object_inline_message_2316) : Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
        JSCompiler_object_inline_componentStack_2319.stack = JSCompiler_object_inline_stack_2318 || "";
        JSCompiler_object_inline_componentStack_2319.digest = JSCompiler_object_inline_digest_2317;
        JSCompiler_object_inline_digest_2317 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
        JSCompiler_object_inline_stack_2318 = {
          value: JSCompiler_object_inline_componentStack_2319,
          source: null,
          stack: JSCompiler_object_inline_digest_2317
        };
        "string" === typeof JSCompiler_object_inline_digest_2317 && CapturedStacks.set(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_stack_2318);
        queueHydrationError(JSCompiler_object_inline_stack_2318);
        workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
      } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress, renderLanes, !1), JSCompiler_object_inline_digest_2317 = 0 !== (renderLanes & current.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2317) {
        JSCompiler_object_inline_digest_2317 = workInProgressRoot;
        if (null !== JSCompiler_object_inline_digest_2317) {
          JSCompiler_object_inline_stack_2318 = renderLanes & -renderLanes;
          if (0 !== (JSCompiler_object_inline_stack_2318 & 42)) JSCompiler_object_inline_stack_2318 = 1;else switch (JSCompiler_object_inline_stack_2318) {
            case 2:
              JSCompiler_object_inline_stack_2318 = 1;
              break;
            case 8:
              JSCompiler_object_inline_stack_2318 = 4;
              break;
            case 32:
              JSCompiler_object_inline_stack_2318 = 16;
              break;
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
              JSCompiler_object_inline_stack_2318 = 64;
              break;
            case 268435456:
              JSCompiler_object_inline_stack_2318 = 134217728;
              break;
            default:
              JSCompiler_object_inline_stack_2318 = 0;
          }
          JSCompiler_object_inline_stack_2318 = 0 !== (JSCompiler_object_inline_stack_2318 & (JSCompiler_object_inline_digest_2317.suspendedLanes | renderLanes)) ? 0 : JSCompiler_object_inline_stack_2318;
          if (0 !== JSCompiler_object_inline_stack_2318 && JSCompiler_object_inline_stack_2318 !== prevState.retryLane) throw prevState.retryLane = JSCompiler_object_inline_stack_2318, enqueueConcurrentRenderForLane(current, JSCompiler_object_inline_stack_2318), scheduleUpdateOnFiber(JSCompiler_object_inline_digest_2317, current, JSCompiler_object_inline_stack_2318), SelectiveHydrationException;
        }
        JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
        workInProgress = retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);
      } else JSCompiler_object_inline_message_2316.data === SUSPENSE_PENDING_START_DATA ? (workInProgress.flags |= 128, workInProgress.child = current.child, workInProgress = retryDehydratedSuspenseBoundary.bind(null, current), JSCompiler_object_inline_message_2316._reactRetry = workInProgress, workInProgress = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(JSCompiler_object_inline_message_2316.nextSibling), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !1, null !== current && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress), workInProgress = mountSuspensePrimaryChildren(workInProgress, JSCompiler_object_inline_stack_2318.children), workInProgress.flags |= 4096);
      return workInProgress;
    }
    if (JSCompiler_object_inline_componentStack_2319) return reuseSuspenseHandlerOnStack(workInProgress), JSCompiler_object_inline_componentStack_2319 = JSCompiler_object_inline_stack_2318.fallback, JSCompiler_object_inline_message_2316 = workInProgress.mode, JSCompiler_temp = current.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2318 = createWorkInProgress(JSCompiler_temp, {
      mode: "hidden",
      children: JSCompiler_object_inline_stack_2318.children
    }), JSCompiler_object_inline_stack_2318.subtreeFlags = JSCompiler_temp.subtreeFlags & 31457280, null !== instance ? JSCompiler_object_inline_componentStack_2319 = createWorkInProgress(instance, JSCompiler_object_inline_componentStack_2319) : (JSCompiler_object_inline_componentStack_2319 = createFiberFromFragment(JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_message_2316, renderLanes, null), JSCompiler_object_inline_componentStack_2319.flags |= 2), JSCompiler_object_inline_componentStack_2319.return = workInProgress, JSCompiler_object_inline_stack_2318.return = workInProgress, JSCompiler_object_inline_stack_2318.sibling = JSCompiler_object_inline_componentStack_2319, workInProgress.child = JSCompiler_object_inline_stack_2318, JSCompiler_object_inline_stack_2318 = JSCompiler_object_inline_componentStack_2319, JSCompiler_object_inline_componentStack_2319 = workInProgress.child, JSCompiler_object_inline_message_2316 = current.child.memoizedState, null === JSCompiler_object_inline_message_2316 ? JSCompiler_object_inline_message_2316 = mountSuspenseOffscreenState(renderLanes) : (JSCompiler_temp = JSCompiler_object_inline_message_2316.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? {
      parent: instance,
      pool: instance
    } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2316 = {
      baseLanes: JSCompiler_object_inline_message_2316.baseLanes | renderLanes,
      cachePool: JSCompiler_temp
    }), JSCompiler_object_inline_componentStack_2319.memoizedState = JSCompiler_object_inline_message_2316, JSCompiler_object_inline_componentStack_2319.childLanes = getRemainingWorkInPrimaryTree(current, JSCompiler_object_inline_digest_2317, renderLanes), workInProgress.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2318;
    pushPrimaryTreeSuspenseHandler(workInProgress);
    renderLanes = current.child;
    current = renderLanes.sibling;
    renderLanes = createWorkInProgress(renderLanes, {
      mode: "visible",
      children: JSCompiler_object_inline_stack_2318.children
    });
    renderLanes.return = workInProgress;
    renderLanes.sibling = null;
    null !== current && (JSCompiler_object_inline_digest_2317 = workInProgress.deletions, null === JSCompiler_object_inline_digest_2317 ? (workInProgress.deletions = [current], workInProgress.flags |= 16) : JSCompiler_object_inline_digest_2317.push(current));
    workInProgress.child = renderLanes;
    workInProgress.memoizedState = null;
    return renderLanes;
  }
  function mountSuspensePrimaryChildren(workInProgress, primaryChildren) {
    primaryChildren = mountWorkInProgressOffscreenFiber({
      mode: "visible",
      children: primaryChildren
    }, workInProgress.mode);
    primaryChildren.return = workInProgress;
    return workInProgress.child = primaryChildren;
  }
  function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
    return createFiberFromOffscreen(offscreenProps, mode, 0, null);
  }
  function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {
    reconcileChildFibers(workInProgress, current.child, null, renderLanes);
    current = mountSuspensePrimaryChildren(workInProgress, workInProgress.pendingProps.children);
    current.flags |= 2;
    workInProgress.memoizedState = null;
    return current;
  }
  function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {
    fiber.lanes |= renderLanes;
    var alternate = fiber.alternate;
    null !== alternate && (alternate.lanes |= renderLanes);
    scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);
  }
  function validateSuspenseListNestedChild(childSlot, index) {
    var isAnArray = isArrayImpl(childSlot);
    childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
    return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", isAnArray, index, isAnArray), !1) : !0;
  }
  function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {
    var renderState = workInProgress.memoizedState;
    null === renderState ? workInProgress.memoizedState = {
      isBackwards: isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail: tail,
      tailMode: tailMode
    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
  }
  function updateSuspenseListComponent(current, workInProgress, renderLanes) {
    var nextProps = workInProgress.pendingProps,
      revealOrder = nextProps.revealOrder,
      tailMode = nextProps.tail;
    nextProps = nextProps.children;
    if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder]) if (didWarnAboutRevealOrder[revealOrder] = !0, "string" === typeof revealOrder) switch (revealOrder.toLowerCase()) {
      case "together":
      case "forwards":
      case "backwards":
        console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
        break;
      case "forward":
      case "backward":
        console.error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
        break;
      default:
        console.error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
    } else console.error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
    void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = !0, console.error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = !0, console.error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
    a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && !1 !== nextProps) if (isArrayImpl(nextProps)) for (var i = 0; i < nextProps.length; i++) {
      if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
    } else if (i = getIteratorFn(nextProps), "function" === typeof i) {
      if (i = i.call(nextProps)) for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
        if (!validateSuspenseListNestedChild(step.value, _i)) break a;
        _i++;
      }
    } else console.error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
    reconcileChildren(current, workInProgress, nextProps, renderLanes);
    nextProps = suspenseStackCursor.current;
    if (0 !== (nextProps & ForceSuspenseFallback)) nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress.flags |= 128;else {
      if (null !== current && 0 !== (current.flags & 128)) a: for (current = workInProgress.child; null !== current;) {
        if (13 === current.tag) null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (19 === current.tag) scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress) break a;
        for (; null === current.sibling;) {
          if (null === current.return || current.return === workInProgress) break a;
          current = current.return;
        }
        current.sibling.return = current.return;
        current = current.sibling;
      }
      nextProps &= SubtreeSuspenseContextMask;
    }
    push(suspenseStackCursor, nextProps, workInProgress);
    switch (revealOrder) {
      case "forwards":
        renderLanes = workInProgress.child;
        for (revealOrder = null; null !== renderLanes;) current = renderLanes.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes), renderLanes = renderLanes.sibling;
        renderLanes = revealOrder;
        null === renderLanes ? (revealOrder = workInProgress.child, workInProgress.child = null) : (revealOrder = renderLanes.sibling, renderLanes.sibling = null);
        initSuspenseListRenderState(workInProgress, !1, revealOrder, renderLanes, tailMode);
        break;
      case "backwards":
        renderLanes = null;
        revealOrder = workInProgress.child;
        for (workInProgress.child = null; null !== revealOrder;) {
          current = revealOrder.alternate;
          if (null !== current && null === findFirstSuspended(current)) {
            workInProgress.child = revealOrder;
            break;
          }
          current = revealOrder.sibling;
          revealOrder.sibling = renderLanes;
          renderLanes = revealOrder;
          revealOrder = current;
        }
        initSuspenseListRenderState(workInProgress, !0, renderLanes, null, tailMode);
        break;
      case "together":
        initSuspenseListRenderState(workInProgress, !1, null, null, void 0);
        break;
      default:
        workInProgress.memoizedState = null;
    }
    return workInProgress.child;
  }
  function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {
    null !== current && (workInProgress.dependencies = current.dependencies);
    profilerStartTime = -1;
    workInProgressRootSkippedLanes |= workInProgress.lanes;
    if (0 === (renderLanes & workInProgress.childLanes)) if (null !== current) {
      if (propagateParentContextChanges(current, workInProgress, renderLanes, !1), 0 === (renderLanes & workInProgress.childLanes)) return null;
    } else return null;
    if (null !== current && workInProgress.child !== current.child) throw Error("Resuming work not yet implemented.");
    if (null !== workInProgress.child) {
      current = workInProgress.child;
      renderLanes = createWorkInProgress(current, current.pendingProps);
      workInProgress.child = renderLanes;
      for (renderLanes.return = workInProgress; null !== current.sibling;) current = current.sibling, renderLanes = renderLanes.sibling = createWorkInProgress(current, current.pendingProps), renderLanes.return = workInProgress;
      renderLanes.sibling = null;
    }
    return workInProgress.child;
  }
  function checkScheduledUpdateOrContext(current, renderLanes) {
    if (0 !== (current.lanes & renderLanes)) return !0;
    current = current.dependencies;
    return null !== current && checkIfContextChanged(current) ? !0 : !1;
  }
  function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {
    switch (workInProgress.tag) {
      case 3:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
        resetHydrationState();
        break;
      case 27:
      case 5:
        pushHostContext(workInProgress);
        break;
      case 4:
        pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
        break;
      case 10:
        pushProvider(workInProgress, workInProgress.type, workInProgress.memoizedProps.value);
        break;
      case 12:
        0 !== (renderLanes & workInProgress.childLanes) && (workInProgress.flags |= 4);
        workInProgress.flags |= 2048;
        var stateNode = workInProgress.stateNode;
        stateNode.effectDuration = -0;
        stateNode.passiveEffectDuration = -0;
        break;
      case 13:
        stateNode = workInProgress.memoizedState;
        if (null !== stateNode) {
          if (null !== stateNode.dehydrated) return pushPrimaryTreeSuspenseHandler(workInProgress), workInProgress.flags |= 128, null;
          if (0 !== (renderLanes & workInProgress.child.childLanes)) return updateSuspenseComponent(current, workInProgress, renderLanes);
          pushPrimaryTreeSuspenseHandler(workInProgress);
          current = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
          return null !== current ? current.sibling : null;
        }
        pushPrimaryTreeSuspenseHandler(workInProgress);
        break;
      case 19:
        var didSuspendBefore = 0 !== (current.flags & 128);
        stateNode = 0 !== (renderLanes & workInProgress.childLanes);
        stateNode || (propagateParentContextChanges(current, workInProgress, renderLanes, !1), stateNode = 0 !== (renderLanes & workInProgress.childLanes));
        if (didSuspendBefore) {
          if (stateNode) return updateSuspenseListComponent(current, workInProgress, renderLanes);
          workInProgress.flags |= 128;
        }
        didSuspendBefore = workInProgress.memoizedState;
        null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
        push(suspenseStackCursor, suspenseStackCursor.current, workInProgress);
        if (stateNode) break;else return null;
      case 22:
      case 23:
        return workInProgress.lanes = 0, updateOffscreenComponent(current, workInProgress, renderLanes);
      case 24:
        pushProvider(workInProgress, CacheContext, current.memoizedState.cache);
    }
    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
  }
  function beginWork(current, workInProgress, renderLanes) {
    if (workInProgress._debugNeedsRemount && null !== current) {
      renderLanes = createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes);
      var returnFiber = workInProgress.return;
      if (null === returnFiber) throw Error("Cannot swap the root fiber.");
      current.alternate = null;
      workInProgress.alternate = null;
      renderLanes.index = workInProgress.index;
      renderLanes.sibling = workInProgress.sibling;
      renderLanes.return = workInProgress.return;
      renderLanes.ref = workInProgress.ref;
      renderLanes._debugInfo = workInProgress._debugInfo;
      if (workInProgress === returnFiber.child) returnFiber.child = renderLanes;else {
        var prevSibling = returnFiber.child;
        if (null === prevSibling) throw Error("Expected parent to have a child.");
        for (; prevSibling.sibling !== workInProgress;) if (prevSibling = prevSibling.sibling, null === prevSibling) throw Error("Expected to find the previous sibling.");
        prevSibling.sibling = renderLanes;
      }
      workInProgress = returnFiber.deletions;
      null === workInProgress ? (returnFiber.deletions = [current], returnFiber.flags |= 16) : workInProgress.push(current);
      renderLanes.flags |= 2;
      return renderLanes;
    }
    if (null !== current) {
      if (current.memoizedProps !== workInProgress.pendingProps || workInProgress.type !== current.type) didReceiveUpdate = !0;else {
        if (!checkScheduledUpdateOrContext(current, renderLanes) && 0 === (workInProgress.flags & 128)) return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);
        didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;
      }
    } else {
      didReceiveUpdate = !1;
      if (returnFiber = isHydrating) warnIfNotHydrating(), returnFiber = 0 !== (workInProgress.flags & 1048576);
      returnFiber && (returnFiber = workInProgress.index, warnIfNotHydrating(), pushTreeId(workInProgress, treeForkCount, returnFiber));
    }
    workInProgress.lanes = 0;
    switch (workInProgress.tag) {
      case 16:
        a: if (returnFiber = workInProgress.pendingProps, current = callLazyInitInDEV(workInProgress.elementType), workInProgress.type = current, "function" === typeof current) shouldConstruct(current) ? (returnFiber = resolveClassComponentProps(current, returnFiber), workInProgress.tag = 1, workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateClassComponent(null, workInProgress, current, returnFiber, renderLanes)) : (workInProgress.tag = 0, validateFunctionComponentInDev(workInProgress, current), workInProgress.type = current = resolveFunctionForHotReloading(current), workInProgress = updateFunctionComponent(null, workInProgress, current, returnFiber, renderLanes));else {
          if (void 0 !== current && null !== current) if (prevSibling = current.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
            workInProgress.tag = 11;
            workInProgress.type = current = resolveForwardRefForHotReloading(current);
            workInProgress = updateForwardRef(null, workInProgress, current, returnFiber, renderLanes);
            break a;
          } else if (prevSibling === REACT_MEMO_TYPE) {
            workInProgress.tag = 14;
            workInProgress = updateMemoComponent(null, workInProgress, current, returnFiber, renderLanes);
            break a;
          }
          workInProgress = "";
          null !== current && "object" === typeof current && current.$$typeof === REACT_LAZY_TYPE && (workInProgress = " Did you wrap a component in React.lazy() more than once?");
          current = getComponentNameFromType(current) || current;
          throw Error("Element type is invalid. Received a promise that resolves to: " + current + ". Lazy element type must resolve to a class or function." + workInProgress);
        }
        return workInProgress;
      case 0:
        return updateFunctionComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 1:
        return returnFiber = workInProgress.type, prevSibling = resolveClassComponentProps(returnFiber, workInProgress.pendingProps), updateClassComponent(current, workInProgress, returnFiber, prevSibling, renderLanes);
      case 3:
        a: {
          pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);
          if (null === current) throw Error("Should have a current fiber. This is a bug in React.");
          var nextProps = workInProgress.pendingProps;
          prevSibling = workInProgress.memoizedState;
          returnFiber = prevSibling.element;
          cloneUpdateQueue(current, workInProgress);
          processUpdateQueue(workInProgress, nextProps, null, renderLanes);
          var nextState = workInProgress.memoizedState;
          nextProps = nextState.cache;
          pushProvider(workInProgress, CacheContext, nextProps);
          nextProps !== prevSibling.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0);
          suspendIfUpdateReadFromEntangledAsyncAction();
          nextProps = nextState.element;
          if (prevSibling.isDehydrated) {
            if (prevSibling = {
              element: nextProps,
              isDehydrated: !1,
              cache: nextState.cache
            }, workInProgress.updateQueue.baseState = prevSibling, workInProgress.memoizedState = prevSibling, workInProgress.flags & 256) {
              workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
              break a;
            } else if (nextProps !== returnFiber) {
              returnFiber = createCapturedValueAtFiber(Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress);
              queueHydrationError(returnFiber);
              workInProgress = mountHostRootWithoutHydrating(current, workInProgress, nextProps, renderLanes);
              break a;
            } else for (nextHydratableInstance = getNextHydratable(workInProgress.stateNode.containerInfo.firstChild), hydrationParentFiber = workInProgress, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, hydrationDiffRootDEV = null, rootOrSingletonContext = !0, current = mountChildFibers(workInProgress, null, nextProps, renderLanes), workInProgress.child = current; current;) current.flags = current.flags & -3 | 4096, current = current.sibling;
          } else {
            resetHydrationState();
            if (nextProps === returnFiber) {
              workInProgress = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
              break a;
            }
            reconcileChildren(current, workInProgress, nextProps, renderLanes);
          }
          workInProgress = workInProgress.child;
        }
        return workInProgress;
      case 26:
        return markRef(current, workInProgress), null === current ? (current = getResource(workInProgress.type, null, workInProgress.pendingProps, null)) ? workInProgress.memoizedState = current : isHydrating || (current = workInProgress.type, renderLanes = workInProgress.pendingProps, returnFiber = requiredContext(rootInstanceStackCursor.current), returnFiber = getOwnerDocumentFromRootContainer(returnFiber).createElement(current), returnFiber[internalInstanceKey] = workInProgress, returnFiber[internalPropsKey] = renderLanes, setInitialProperties(returnFiber, current, renderLanes), markNodeAsHoistable(returnFiber), workInProgress.stateNode = returnFiber) : workInProgress.memoizedState = getResource(workInProgress.type, current.memoizedProps, workInProgress.pendingProps, current.memoizedState), null;
      case 27:
        return pushHostContext(workInProgress), null === current && isHydrating && (prevSibling = requiredContext(rootInstanceStackCursor.current), returnFiber = getHostContext(), prevSibling = workInProgress.stateNode = resolveSingletonInstance(workInProgress.type, workInProgress.pendingProps, prevSibling, returnFiber, !1), didSuspendOrErrorDEV || (returnFiber = diffHydratedProperties(prevSibling, workInProgress.type, workInProgress.pendingProps, returnFiber), null !== returnFiber && (buildHydrationDiffNode(workInProgress, 0).serverProps = returnFiber)), hydrationParentFiber = workInProgress, rootOrSingletonContext = !0, nextHydratableInstance = getNextHydratable(prevSibling.firstChild)), returnFiber = workInProgress.pendingProps.children, null !== current || isHydrating ? reconcileChildren(current, workInProgress, returnFiber, renderLanes) : workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes), markRef(current, workInProgress), workInProgress.child;
      case 5:
        return null === current && isHydrating && (nextProps = getHostContext(), returnFiber = validateDOMNesting(workInProgress.type, nextProps.ancestorInfo), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(prevSibling, workInProgress.type, workInProgress.pendingProps, rootOrSingletonContext), null !== nextState ? (workInProgress.stateNode = nextState, didSuspendOrErrorDEV || (nextProps = diffHydratedProperties(nextState, workInProgress.type, workInProgress.pendingProps, nextProps), null !== nextProps && (buildHydrationDiffNode(workInProgress, 0).serverProps = nextProps)), hydrationParentFiber = workInProgress, nextHydratableInstance = getNextHydratable(nextState.firstChild), rootOrSingletonContext = !1, nextProps = !0) : nextProps = !1, nextState = !nextProps), nextState && (returnFiber && warnNonHydratedInstance(workInProgress, prevSibling), throwOnHydrationMismatch(workInProgress))), pushHostContext(workInProgress), prevSibling = workInProgress.type, nextProps = workInProgress.pendingProps, nextState = null !== current ? current.memoizedProps : null, returnFiber = nextProps.children, shouldSetTextContent(prevSibling, nextProps) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress.flags |= 32), null !== workInProgress.memoizedState && (prevSibling = renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, renderLanes), HostTransitionContext._currentValue = prevSibling), markRef(current, workInProgress), reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
      case 6:
        return null === current && isHydrating && (current = workInProgress.pendingProps, renderLanes = getHostContext().ancestorInfo.current, current = null != renderLanes ? validateTextNesting(current, renderLanes.tag) : !0, renderLanes = nextHydratableInstance, (returnFiber = !renderLanes) || (returnFiber = canHydrateTextInstance(renderLanes, workInProgress.pendingProps, rootOrSingletonContext), null !== returnFiber ? (workInProgress.stateNode = returnFiber, hydrationParentFiber = workInProgress, nextHydratableInstance = null, returnFiber = !0) : returnFiber = !1, returnFiber = !returnFiber), returnFiber && (current && warnNonHydratedInstance(workInProgress, renderLanes), throwOnHydrationMismatch(workInProgress))), null;
      case 13:
        return updateSuspenseComponent(current, workInProgress, renderLanes);
      case 4:
        return pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo), returnFiber = workInProgress.pendingProps, null === current ? workInProgress.child = reconcileChildFibers(workInProgress, null, returnFiber, renderLanes) : reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
      case 11:
        return updateForwardRef(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 7:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps, renderLanes), workInProgress.child;
      case 8:
        return reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
      case 12:
        return workInProgress.flags |= 4, workInProgress.flags |= 2048, returnFiber = workInProgress.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
      case 10:
        return returnFiber = workInProgress.type, prevSibling = workInProgress.pendingProps, nextProps = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, console.error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?")), pushProvider(workInProgress, returnFiber, nextProps), reconcileChildren(current, workInProgress, prevSibling.children, renderLanes), workInProgress.child;
      case 9:
        return prevSibling = workInProgress.type._context, returnFiber = workInProgress.pendingProps.children, "function" !== typeof returnFiber && console.error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress), returnFiber = callComponentInDEV(returnFiber, prevSibling, void 0), markComponentRenderStopped(), workInProgress.flags |= 1, reconcileChildren(current, workInProgress, returnFiber, renderLanes), workInProgress.child;
      case 14:
        return updateMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 15:
        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);
      case 19:
        return updateSuspenseListComponent(current, workInProgress, renderLanes);
      case 22:
        return updateOffscreenComponent(current, workInProgress, renderLanes);
      case 24:
        return prepareToReadContext(workInProgress), returnFiber = readContext(CacheContext), null === current ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, nextProps = createCache(), prevSibling.pooledCache = nextProps, retainCache(nextProps), null !== nextProps && (prevSibling.pooledCacheLanes |= renderLanes), prevSibling = nextProps), workInProgress.memoizedState = {
          parent: returnFiber,
          cache: prevSibling
        }, initializeUpdateQueue(workInProgress), pushProvider(workInProgress, CacheContext, prevSibling)) : (0 !== (current.lanes & renderLanes) && (cloneUpdateQueue(current, workInProgress), processUpdateQueue(workInProgress, null, null, renderLanes), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current.memoizedState, nextProps = workInProgress.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
          parent: returnFiber,
          cache: returnFiber
        }, workInProgress.memoizedState = prevSibling, 0 === workInProgress.lanes && (workInProgress.memoizedState = workInProgress.updateQueue.baseState = prevSibling), pushProvider(workInProgress, CacheContext, returnFiber)) : (returnFiber = nextProps.cache, pushProvider(workInProgress, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(workInProgress, [CacheContext], renderLanes, !0))), reconcileChildren(current, workInProgress, workInProgress.pendingProps.children, renderLanes), workInProgress.child;
      case 29:
        throw workInProgress.pendingProps;
    }
    throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
  }
  function resetContextDependencies() {
    lastContextDependency = currentlyRenderingFiber = null;
    isDisallowedContextReadInDEV = !1;
  }
  function pushProvider(providerFiber, context, nextValue) {
    push(valueCursor, context._currentValue, providerFiber);
    context._currentValue = nextValue;
    push(rendererCursorDEV, context._currentRenderer, providerFiber);
    void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
    context._currentRenderer = rendererSigil;
  }
  function popProvider(context, providerFiber) {
    context._currentValue = valueCursor.current;
    var currentRenderer = rendererCursorDEV.current;
    pop(rendererCursorDEV, providerFiber);
    context._currentRenderer = currentRenderer;
    pop(valueCursor, providerFiber);
  }
  function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {
    for (; null !== parent;) {
      var alternate = parent.alternate;
      (parent.childLanes & renderLanes) !== renderLanes ? (parent.childLanes |= renderLanes, null !== alternate && (alternate.childLanes |= renderLanes)) : null !== alternate && (alternate.childLanes & renderLanes) !== renderLanes && (alternate.childLanes |= renderLanes);
      if (parent === propagationRoot) break;
      parent = parent.return;
    }
    parent !== propagationRoot && console.error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
  }
  function propagateContextChanges(workInProgress, contexts, renderLanes, forcePropagateEntireTree) {
    var fiber = workInProgress.child;
    null !== fiber && (fiber.return = workInProgress);
    for (; null !== fiber;) {
      var list = fiber.dependencies;
      if (null !== list) {
        var nextFiber = fiber.child;
        list = list.firstContext;
        a: for (; null !== list;) {
          var dependency = list;
          list = fiber;
          for (var i = 0; i < contexts.length; i++) if (dependency.context === contexts[i]) {
            list.lanes |= renderLanes;
            dependency = list.alternate;
            null !== dependency && (dependency.lanes |= renderLanes);
            scheduleContextWorkOnParentPath(list.return, renderLanes, workInProgress);
            forcePropagateEntireTree || (nextFiber = null);
            break a;
          }
          list = dependency.next;
        }
      } else if (18 === fiber.tag) {
        nextFiber = fiber.return;
        if (null === nextFiber) throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");
        nextFiber.lanes |= renderLanes;
        list = nextFiber.alternate;
        null !== list && (list.lanes |= renderLanes);
        scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);
        nextFiber = null;
      } else nextFiber = fiber.child;
      if (null !== nextFiber) nextFiber.return = fiber;else for (nextFiber = fiber; null !== nextFiber;) {
        if (nextFiber === workInProgress) {
          nextFiber = null;
          break;
        }
        fiber = nextFiber.sibling;
        if (null !== fiber) {
          fiber.return = nextFiber.return;
          nextFiber = fiber;
          break;
        }
        nextFiber = nextFiber.return;
      }
      fiber = nextFiber;
    }
  }
  function propagateParentContextChanges(current, workInProgress, renderLanes, forcePropagateEntireTree) {
    current = null;
    for (var parent = workInProgress, isInsidePropagationBailout = !1; null !== parent;) {
      if (!isInsidePropagationBailout) if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;else if (0 !== (parent.flags & 262144)) break;
      if (10 === parent.tag) {
        var currentParent = parent.alternate;
        if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
        currentParent = currentParent.memoizedProps;
        if (null !== currentParent) {
          var context = parent.type;
          objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
        }
      } else if (parent === hostTransitionProviderCursor.current) {
        currentParent = parent.alternate;
        if (null === currentParent) throw Error("Should have a current fiber. This is a bug in React.");
        currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
      }
      parent = parent.return;
    }
    null !== current && propagateContextChanges(workInProgress, current, renderLanes, forcePropagateEntireTree);
    workInProgress.flags |= 262144;
  }
  function checkIfContextChanged(currentDependencies) {
    for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies;) {
      if (!objectIs(currentDependencies.context._currentValue, currentDependencies.memoizedValue)) return !0;
      currentDependencies = currentDependencies.next;
    }
    return !1;
  }
  function prepareToReadContext(workInProgress) {
    currentlyRenderingFiber = workInProgress;
    lastContextDependency = null;
    workInProgress = workInProgress.dependencies;
    null !== workInProgress && (workInProgress.firstContext = null);
  }
  function readContext(context) {
    isDisallowedContextReadInDEV && console.error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
    return readContextForConsumer(currentlyRenderingFiber, context);
  }
  function readContextDuringReconciliation(consumer, context) {
    null === currentlyRenderingFiber && prepareToReadContext(consumer);
    return readContextForConsumer(consumer, context);
  }
  function readContextForConsumer(consumer, context) {
    var value = context._currentValue;
    context = {
      context: context,
      memoizedValue: value,
      next: null
    };
    if (null === lastContextDependency) {
      if (null === consumer) throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      lastContextDependency = context;
      consumer.dependencies = {
        lanes: 0,
        firstContext: context,
        _debugThenableState: null
      };
      consumer.flags |= 524288;
    } else lastContextDependency = lastContextDependency.next = context;
    return value;
  }
  function initializeUpdateQueue(fiber) {
    fiber.updateQueue = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null,
        lanes: 0,
        hiddenCallbacks: null
      },
      callbacks: null
    };
  }
  function cloneUpdateQueue(current, workInProgress) {
    current = current.updateQueue;
    workInProgress.updateQueue === current && (workInProgress.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
  }
  function createUpdate(lane) {
    return {
      lane: lane,
      tag: UpdateState,
      payload: null,
      callback: null,
      next: null
    };
  }
  function enqueueUpdate(fiber, update, lane) {
    var updateQueue = fiber.updateQueue;
    if (null === updateQueue) return null;
    updateQueue = updateQueue.shared;
    if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
      var componentName = getComponentNameFromFiber(fiber);
      console.error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s", componentName);
      didWarnUpdateInsideUpdate = !0;
    }
    if ((executionContext & RenderContext) !== NoContext) return componentName = updateQueue.pending, null === componentName ? update.next = update : (update.next = componentName.next, componentName.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
    enqueueUpdate$1(fiber, updateQueue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function entangleTransitions(root, fiber, lane) {
    fiber = fiber.updateQueue;
    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194176))) {
      var queueLanes = fiber.lanes;
      queueLanes &= root.pendingLanes;
      lane |= queueLanes;
      fiber.lanes = lane;
      markRootEntangled(root, lane);
    }
  }
  function enqueueCapturedUpdate(workInProgress, capturedUpdate) {
    var queue = workInProgress.updateQueue,
      current = workInProgress.alternate;
    if (null !== current && (current = current.updateQueue, queue === current)) {
      var newFirst = null,
        newLast = null;
      queue = queue.firstBaseUpdate;
      if (null !== queue) {
        do {
          var clone = {
            lane: queue.lane,
            tag: queue.tag,
            payload: queue.payload,
            callback: null,
            next: null
          };
          null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
          queue = queue.next;
        } while (null !== queue);
        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
      } else newFirst = newLast = capturedUpdate;
      queue = {
        baseState: current.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: current.shared,
        callbacks: current.callbacks
      };
      workInProgress.updateQueue = queue;
      return;
    }
    workInProgress = queue.lastBaseUpdate;
    null === workInProgress ? queue.firstBaseUpdate = capturedUpdate : workInProgress.next = capturedUpdate;
    queue.lastBaseUpdate = capturedUpdate;
  }
  function suspendIfUpdateReadFromEntangledAsyncAction() {
    if (didReadFromEntangledAsyncAction) {
      var entangledActionThenable = currentEntangledActionThenable;
      if (null !== entangledActionThenable) throw entangledActionThenable;
    }
  }
  function processUpdateQueue(workInProgress, props, instance$jscomp$0, renderLanes) {
    didReadFromEntangledAsyncAction = !1;
    var queue = workInProgress.updateQueue;
    hasForceUpdate = !1;
    currentlyProcessingQueue = queue.shared;
    var firstBaseUpdate = queue.firstBaseUpdate,
      lastBaseUpdate = queue.lastBaseUpdate,
      pendingQueue = queue.shared.pending;
    if (null !== pendingQueue) {
      queue.shared.pending = null;
      var lastPendingUpdate = pendingQueue,
        firstPendingUpdate = lastPendingUpdate.next;
      lastPendingUpdate.next = null;
      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
      lastBaseUpdate = lastPendingUpdate;
      var current = workInProgress.alternate;
      null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
    }
    if (null !== firstBaseUpdate) {
      var newState = queue.baseState;
      lastBaseUpdate = 0;
      current = firstPendingUpdate = lastPendingUpdate = null;
      pendingQueue = firstBaseUpdate;
      do {
        var updateLane = pendingQueue.lane & -536870913,
          isHiddenUpdate = updateLane !== pendingQueue.lane;
        if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
          0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = !0);
          null !== current && (current = current.next = {
            lane: 0,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: null,
            next: null
          });
          a: {
            updateLane = workInProgress;
            var partialState = pendingQueue;
            var nextProps = props,
              instance = instance$jscomp$0;
            switch (partialState.tag) {
              case ReplaceState:
                partialState = partialState.payload;
                if ("function" === typeof partialState) {
                  isDisallowedContextReadInDEV = !0;
                  var nextState = partialState.call(instance, newState, nextProps);
                  if (updateLane.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(!0);
                    try {
                      partialState.call(instance, newState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(!1);
                    }
                  }
                  isDisallowedContextReadInDEV = !1;
                  newState = nextState;
                  break a;
                }
                newState = partialState;
                break a;
              case CaptureUpdate:
                updateLane.flags = updateLane.flags & -65537 | 128;
              case UpdateState:
                nextState = partialState.payload;
                if ("function" === typeof nextState) {
                  isDisallowedContextReadInDEV = !0;
                  partialState = nextState.call(instance, newState, nextProps);
                  if (updateLane.mode & StrictLegacyMode) {
                    setIsStrictModeForDevtools(!0);
                    try {
                      nextState.call(instance, newState, nextProps);
                    } finally {
                      setIsStrictModeForDevtools(!1);
                    }
                  }
                  isDisallowedContextReadInDEV = !1;
                } else partialState = nextState;
                if (null === partialState || void 0 === partialState) break a;
                newState = assign({}, newState, partialState);
                break a;
              case ForceUpdate:
                hasForceUpdate = !0;
            }
          }
          updateLane = pendingQueue.callback;
          null !== updateLane && (workInProgress.flags |= 64, isHiddenUpdate && (workInProgress.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
        } else isHiddenUpdate = {
          lane: updateLane,
          tag: pendingQueue.tag,
          payload: pendingQueue.payload,
          callback: pendingQueue.callback,
          next: null
        }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
        pendingQueue = pendingQueue.next;
        if (null === pendingQueue) if (pendingQueue = queue.shared.pending, null === pendingQueue) break;else isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
      } while (1);
      null === current && (lastPendingUpdate = newState);
      queue.baseState = lastPendingUpdate;
      queue.firstBaseUpdate = firstPendingUpdate;
      queue.lastBaseUpdate = current;
      null === firstBaseUpdate && (queue.shared.lanes = 0);
      workInProgressRootSkippedLanes |= lastBaseUpdate;
      workInProgress.lanes = lastBaseUpdate;
      workInProgress.memoizedState = newState;
    }
    currentlyProcessingQueue = null;
  }
  function callCallback(callback, context) {
    if ("function" !== typeof callback) throw Error("Invalid argument passed as callback. Expected a function. Instead received: " + callback);
    callback.call(context);
  }
  function commitHiddenCallbacks(updateQueue, context) {
    var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
    if (null !== hiddenCallbacks) for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++) callCallback(hiddenCallbacks[updateQueue], context);
  }
  function commitCallbacks(updateQueue, context) {
    var callbacks = updateQueue.callbacks;
    if (null !== callbacks) for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++) callCallback(callbacks[updateQueue], context);
  }
  function shouldProfile(current) {
    return (current.mode & ProfileMode) !== NoMode;
  }
  function commitHookLayoutEffects(finishedWork, hookFlags) {
    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
  }
  function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
  }
  function commitHookEffectListMount(flags, finishedWork) {
    try {
      var updateQueue = finishedWork.updateQueue,
        lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), lastEffect = runWithFiberInDEV(finishedWork, callCreateInDEV, updateQueue), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
            var hookName = void 0;
            hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
            var addendum = void 0;
            addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
            runWithFiberInDEV(finishedWork, function (n, a) {
              console.error("%s must not return anything besides a function, which is used for clean-up.%s", n, a);
            }, hookName, addendum);
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
    try {
      var updateQueue = finishedWork.updateQueue,
        lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            var inst = updateQueue.inst,
              destroy = inst.destroy;
            void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !0), runWithFiberInDEV(finishedWork, callDestroyInDEV, finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = !1), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHookPassiveMountEffects(finishedWork, hookFlags) {
    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
  }
  function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor), recordEffectDuration()) : commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);
  }
  function commitClassCallbacks(finishedWork) {
    var updateQueue = finishedWork.updateQueue;
    if (null !== updateQueue) {
      var instance = finishedWork.stateNode;
      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
      try {
        runWithFiberInDEV(finishedWork, commitCallbacks, updateQueue, instance);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
  function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
    return instance.getSnapshotBeforeUpdate(prevProps, prevState);
  }
  function commitClassSnapshot(finishedWork, current) {
    var prevProps = current.memoizedProps,
      prevState = current.memoizedState;
    current = finishedWork.stateNode;
    finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), current.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
    try {
      var resolvedPrevProps = resolveClassComponentProps(finishedWork.type, prevProps, finishedWork.elementType === finishedWork.type);
      var snapshot = runWithFiberInDEV(finishedWork, callGetSnapshotBeforeUpdates, current, resolvedPrevProps, prevState);
      prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
      void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function () {
        console.error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
      }));
      current.__reactInternalSnapshotBeforeUpdate = snapshot;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
    instance.props = resolveClassComponentProps(current.type, current.memoizedProps);
    instance.state = current.memoizedState;
    shouldProfile(current) ? (startEffectTimer(), runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance), recordEffectDuration()) : runWithFiberInDEV(current, callComponentWillUnmountInDEV, current, nearestMountedAncestor, instance);
  }
  function commitAttachRef(finishedWork) {
    var ref = finishedWork.ref;
    if (null !== ref) {
      var instance = finishedWork.stateNode;
      if ("function" === typeof ref) {
        if (shouldProfile(finishedWork)) try {
          startEffectTimer(), finishedWork.refCleanup = ref(instance);
        } finally {
          recordEffectDuration();
        } else finishedWork.refCleanup = ref(instance);
      } else "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instance;
    }
  }
  function safelyAttachRef(current, nearestMountedAncestor) {
    try {
      runWithFiberInDEV(current, commitAttachRef, current);
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyDetachRef(current, nearestMountedAncestor) {
    var ref = current.ref,
      refCleanup = current.refCleanup;
    if (null !== ref) if ("function" === typeof refCleanup) try {
      if (shouldProfile(current)) try {
        startEffectTimer(), runWithFiberInDEV(current, refCleanup);
      } finally {
        recordEffectDuration(current);
      } else runWithFiberInDEV(current, refCleanup);
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    } finally {
      current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
    } else if ("function" === typeof ref) try {
      if (shouldProfile(current)) try {
        startEffectTimer(), runWithFiberInDEV(current, ref, null);
      } finally {
        recordEffectDuration(current);
      } else runWithFiberInDEV(current, ref, null);
    } catch (error$6) {
      captureCommitPhaseError(current, nearestMountedAncestor, error$6);
    } else ref.current = null;
  }
  function commitProfiler(finishedWork, current, commitStartTime, effectDuration) {
    var _finishedWork$memoize = finishedWork.memoizedProps,
      id = _finishedWork$memoize.id,
      onCommit = _finishedWork$memoize.onCommit;
    _finishedWork$memoize = _finishedWork$memoize.onRender;
    current = null === current ? "mount" : "update";
    currentUpdateIsNested && (current = "nested-update");
    "function" === typeof _finishedWork$memoize && _finishedWork$memoize(id, current, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitStartTime);
    "function" === typeof onCommit && onCommit(finishedWork.memoizedProps.id, current, effectDuration, commitStartTime);
  }
  function commitProfilerPostCommitImpl(finishedWork, current, commitStartTime, passiveEffectDuration) {
    var _finishedWork$memoize2 = finishedWork.memoizedProps;
    finishedWork = _finishedWork$memoize2.id;
    _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
    current = null === current ? "mount" : "update";
    currentUpdateIsNested && (current = "nested-update");
    "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(finishedWork, current, passiveEffectDuration, commitStartTime);
  }
  function commitHostMount(finishedWork) {
    var type = finishedWork.type,
      props = finishedWork.memoizedProps,
      instance = finishedWork.stateNode;
    try {
      runWithFiberInDEV(finishedWork, commitMount, instance, type, props, finishedWork);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHostUpdate(finishedWork, newProps, oldProps) {
    try {
      runWithFiberInDEV(finishedWork, commitUpdate, finishedWork.stateNode, finishedWork.type, oldProps, newProps, finishedWork);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag || 4 === fiber.tag;
  }
  function getHostSibling(fiber) {
    a: for (;;) {
      for (; null === fiber.sibling;) {
        if (null === fiber.return || isHostParent(fiber.return)) return null;
        fiber = fiber.return;
      }
      fiber.sibling.return = fiber.return;
      for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 27 !== fiber.tag && 18 !== fiber.tag;) {
        if (fiber.flags & 2) continue a;
        if (null === fiber.child || 4 === fiber.tag) continue a;else fiber.child.return = fiber, fiber = fiber.child;
      }
      if (!(fiber.flags & 2)) return fiber.stateNode;
    }
  }
  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag) node = node.stateNode, before ? 8 === parent.nodeType ? parent.parentNode.insertBefore(node, before) : parent.insertBefore(node, before) : (8 === parent.nodeType ? (before = parent.parentNode, before.insertBefore(node, parent)) : (before = parent, before.appendChild(node)), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
  }
  function insertOrAppendPlacementNode(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag) node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);else if (4 !== tag && 27 !== tag && (node = node.child, null !== node)) for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node;) insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
  }
  function commitPlacement(finishedWork) {
    if (27 !== finishedWork.tag) {
      a: {
        for (var parent = finishedWork.return; null !== parent;) {
          if (isHostParent(parent)) {
            var parentFiber = parent;
            break a;
          }
          parent = parent.return;
        }
        throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      }
      switch (parentFiber.tag) {
        case 27:
          parent = parentFiber.stateNode;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
          break;
        case 5:
          parent = parentFiber.stateNode;
          parentFiber.flags & 32 && (resetTextContent(parent), parentFiber.flags &= -33);
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, parentFiber, parent);
          break;
        case 3:
        case 4:
          parent = parentFiber.stateNode.containerInfo;
          parentFiber = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(finishedWork, parentFiber, parent);
          break;
        default:
          throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
  }
  function commitBeforeMutationEffects(root, firstChild) {
    root = root.containerInfo;
    eventsEnabled = _enabled;
    root = getActiveElementDeep(root);
    if (hasSelectionCapabilities(root)) {
      if ("selectionStart" in root) var JSCompiler_temp = {
        start: root.selectionStart,
        end: root.selectionEnd
      };else a: {
        JSCompiler_temp = (JSCompiler_temp = root.ownerDocument) && JSCompiler_temp.defaultView || window;
        var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
        if (selection && 0 !== selection.rangeCount) {
          JSCompiler_temp = selection.anchorNode;
          var anchorOffset = selection.anchorOffset,
            focusNode = selection.focusNode;
          selection = selection.focusOffset;
          try {
            JSCompiler_temp.nodeType, focusNode.nodeType;
          } catch (e$2) {
            JSCompiler_temp = null;
            break a;
          }
          var length = 0,
            start = -1,
            end = -1,
            indexWithinAnchor = 0,
            indexWithinFocus = 0,
            node = root,
            parentNode = null;
          b: for (;;) {
            for (var next;;) {
              node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
              node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
              3 === node.nodeType && (length += node.nodeValue.length);
              if (null === (next = node.firstChild)) break;
              parentNode = node;
              node = next;
            }
            for (;;) {
              if (node === root) break b;
              parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
              parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
              if (null !== (next = node.nextSibling)) break;
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
          JSCompiler_temp = -1 === start || -1 === end ? null : {
            start: start,
            end: end
          };
        } else JSCompiler_temp = null;
      }
      JSCompiler_temp = JSCompiler_temp || {
        start: 0,
        end: 0
      };
    } else JSCompiler_temp = null;
    selectionInformation = {
      focusedElem: root,
      selectionRange: JSCompiler_temp
    };
    _enabled = !1;
    for (nextEffect = firstChild; null !== nextEffect;) if (firstChild = nextEffect, root = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root) root.return = firstChild, nextEffect = root;else for (; null !== nextEffect;) {
      root = firstChild = nextEffect;
      JSCompiler_temp = root.alternate;
      anchorOffset = root.flags;
      switch (root.tag) {
        case 0:
          break;
        case 11:
        case 15:
          break;
        case 1:
          0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root, JSCompiler_temp);
          break;
        case 3:
          if (0 !== (anchorOffset & 1024)) if (root = root.stateNode.containerInfo, JSCompiler_temp = root.nodeType, 9 === JSCompiler_temp) clearContainerSparingly(root);else if (1 === JSCompiler_temp) switch (root.nodeName) {
            case "HEAD":
            case "HTML":
            case "BODY":
              clearContainerSparingly(root);
              break;
            default:
              root.textContent = "";
          }
          break;
        case 5:
        case 26:
        case 27:
        case 6:
        case 4:
        case 17:
          break;
        default:
          if (0 !== (anchorOffset & 1024)) throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
      }
      root = firstChild.sibling;
      if (null !== root) {
        root.return = firstChild.return;
        nextEffect = root;
        break;
      }
      nextEffect = firstChild.return;
    }
    firstChild = shouldFireAfterActiveInstanceBlur;
    shouldFireAfterActiveInstanceBlur = !1;
    return firstChild;
  }
  function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
        break;
      case 1:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 4) if (finishedRoot = finishedWork.stateNode, null === current) finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, finishedRoot);else {
          var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);
          current = current.memoizedState;
          finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), finishedRoot.state !== finishedWork.memoizedState && console.error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
          shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate), recordEffectDuration()) : runWithFiberInDEV(finishedWork, callComponentDidUpdateInDEV, finishedWork, finishedRoot, prevProps, current, finishedRoot.__reactInternalSnapshotBeforeUpdate);
        }
        flags & 64 && commitClassCallbacks(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 3:
        current = pushNestedEffectDurations();
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
          prevProps = null;
          if (null !== finishedWork.child) switch (finishedWork.child.tag) {
            case 27:
            case 5:
              prevProps = finishedWork.child.stateNode;
              break;
            case 1:
              prevProps = finishedWork.child.stateNode;
          }
          try {
            runWithFiberInDEV(finishedWork, commitCallbacks, flags, prevProps);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        finishedRoot.effectDuration += popNestedEffectDurations(current);
        break;
      case 26:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 27:
      case 5:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        null === current && flags & 4 && commitHostMount(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        if (flags & 4) {
          flags = pushNestedEffectDurations();
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          finishedRoot = finishedWork.stateNode;
          finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
          try {
            runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, finishedRoot.effectDuration);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        prevProps = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
        if (!prevProps) {
          current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
          var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,
            prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevProps;
          (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, 0 !== (finishedWork.subtreeFlags & 8772)) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        }
        flags & 512 && ("manual" === finishedWork.memoizedProps.mode ? safelyAttachRef(finishedWork, finishedWork.return) : safelyDetachRef(finishedWork, finishedWork.return));
        break;
      default:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
    }
  }
  function detachFiberAfterEffects(fiber) {
    var alternate = fiber.alternate;
    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
    fiber.child = null;
    fiber.deletions = null;
    fiber.sibling = null;
    5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
    fiber.stateNode = null;
    fiber._debugOwner = null;
    fiber.return = null;
    fiber.dependencies = null;
    fiber.memoizedProps = null;
    fiber.memoizedState = null;
    fiber.pendingProps = null;
    fiber.stateNode = null;
    fiber.updateQueue = null;
  }
  function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
    for (parent = parent.child; null !== parent;) commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
  }
  function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount) try {
      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
    } catch (err) {
      hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
    }
    switch (deletedFiber.tag) {
      case 26:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
        break;
      case 27:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        var prevHostParent = hostParent,
          prevHostParentIsContainer = hostParentIsContainer;
        hostParent = deletedFiber.stateNode;
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        deletedFiber = deletedFiber.stateNode;
        for (finishedRoot = deletedFiber.attributes; finishedRoot.length;) deletedFiber.removeAttributeNode(finishedRoot[0]);
        detachDeletedInstance(deletedFiber);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 5:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      case 6:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = null;
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        if (null !== hostParent) if (hostParentIsContainer) try {
          runWithFiberInDEV(deletedFiber, removeChildFromContainer, hostParent, deletedFiber.stateNode);
        } catch (error) {
          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
        } else try {
          runWithFiberInDEV(deletedFiber, removeChild, hostParent, deletedFiber.stateNode);
        } catch (error) {
          captureCommitPhaseError(deletedFiber, nearestMountedAncestor, error);
        }
        break;
      case 18:
        null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, deletedFiber = deletedFiber.stateNode, 8 === finishedRoot.nodeType ? clearSuspenseBoundary(finishedRoot.parentNode, deletedFiber) : 1 === finishedRoot.nodeType && clearSuspenseBoundary(finishedRoot, deletedFiber), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
        break;
      case 4:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = deletedFiber.stateNode.containerInfo;
        hostParentIsContainer = !0;
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(Insertion, deletedFiber, nearestMountedAncestor);
        offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(deletedFiber, nearestMountedAncestor, Layout);
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        break;
      case 1:
        offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, prevHostParent));
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        break;
      case 21:
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        break;
      case 22:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
        offscreenSubtreeWasHidden = prevHostParent;
        break;
      default:
        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
    }
  }
  function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot)))) try {
      runWithFiberInDEV(finishedWork, commitHydratedSuspenseInstance, finishedRoot);
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function getRetryCache(finishedWork) {
    switch (finishedWork.tag) {
      case 13:
      case 19:
        var retryCache = finishedWork.stateNode;
        null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
        return retryCache;
      case 22:
        return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
      default:
        throw Error("Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React.");
    }
  }
  function attachSuspenseRetryListeners(finishedWork, wakeables) {
    var retryCache = getRetryCache(finishedWork);
    wakeables.forEach(function (wakeable) {
      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
      if (!retryCache.has(wakeable)) {
        retryCache.add(wakeable);
        if (isDevToolsPresent) if (null !== inProgressLanes && null !== inProgressRoot) restorePendingUpdaters(inProgressRoot, inProgressLanes);else throw Error("Expected finished root and lanes to be set. This is a bug in React.");
        wakeable.then(retry, retry);
      }
    });
  }
  function commitMutationEffects(root, finishedWork, committedLanes) {
    inProgressLanes = committedLanes;
    inProgressRoot = root;
    commitMutationEffectsOnFiber(finishedWork, root);
    inProgressRoot = inProgressLanes = null;
  }
  function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
    var deletions = parentFiber.deletions;
    if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
      var root = root$jscomp$0,
        returnFiber = parentFiber,
        deletedFiber = deletions[i],
        parent = returnFiber;
      a: for (; null !== parent;) {
        switch (parent.tag) {
          case 27:
          case 5:
            hostParent = parent.stateNode;
            hostParentIsContainer = !1;
            break a;
          case 3:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
          case 4:
            hostParent = parent.stateNode.containerInfo;
            hostParentIsContainer = !0;
            break a;
        }
        parent = parent.return;
      }
      if (null === hostParent) throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
      commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);
      hostParent = null;
      hostParentIsContainer = !1;
      root = deletedFiber;
      returnFiber = root.alternate;
      null !== returnFiber && (returnFiber.return = null);
      root.return = null;
    }
    if (parentFiber.subtreeFlags & 13878) for (parentFiber = parentFiber.child; null !== parentFiber;) commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
  }
  function commitMutationEffectsOnFiber(finishedWork, root) {
    var current = finishedWork.alternate,
      flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout | HasEffect));
        break;
      case 1:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
        break;
      case 26:
        var hoistableRoot = currentHoistableRoot;
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (flags & 4) if (root = null !== current ? current.memoizedState : null, flags = finishedWork.memoizedState, null === current) {
          if (null === flags) {
            if (null === finishedWork.stateNode) {
              a: {
                flags = finishedWork.type;
                current = finishedWork.memoizedProps;
                root = hoistableRoot.ownerDocument || hoistableRoot;
                b: switch (flags) {
                  case "title":
                    hoistableRoot = root.getElementsByTagName("title")[0];
                    if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop")) hoistableRoot = root.createElement(flags), root.head.insertBefore(hoistableRoot, root.querySelector("head > title"));
                    setInitialProperties(hoistableRoot, flags, current);
                    hoistableRoot[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(hoistableRoot);
                    flags = hoistableRoot;
                    break a;
                  case "link":
                    var maybeNodes = getHydratableHoistableCache("link", "href", root).get(flags + (current.href || ""));
                    if (maybeNodes) for (var i = 0; i < maybeNodes.length; i++) if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current.href ? null : current.href) && hoistableRoot.getAttribute("rel") === (null == current.rel ? null : current.rel) && hoistableRoot.getAttribute("title") === (null == current.title ? null : current.title) && hoistableRoot.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                      maybeNodes.splice(i, 1);
                      break b;
                    }
                    hoistableRoot = root.createElement(flags);
                    setInitialProperties(hoistableRoot, flags, current);
                    root.head.appendChild(hoistableRoot);
                    break;
                  case "meta":
                    if (maybeNodes = getHydratableHoistableCache("meta", "content", root).get(flags + (current.content || ""))) for (i = 0; i < maybeNodes.length; i++) if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(current.content, "content"), hoistableRoot.getAttribute("content") === (null == current.content ? null : "" + current.content) && hoistableRoot.getAttribute("name") === (null == current.name ? null : current.name) && hoistableRoot.getAttribute("property") === (null == current.property ? null : current.property) && hoistableRoot.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                      maybeNodes.splice(i, 1);
                      break b;
                    }
                    hoistableRoot = root.createElement(flags);
                    setInitialProperties(hoistableRoot, flags, current);
                    root.head.appendChild(hoistableRoot);
                    break;
                  default:
                    throw Error('getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.');
                }
                hoistableRoot[internalInstanceKey] = finishedWork;
                markNodeAsHoistable(hoistableRoot);
                flags = hoistableRoot;
              }
              finishedWork.stateNode = flags;
            } else mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);
          } else finishedWork.stateNode = acquireResource(hoistableRoot, flags, finishedWork.memoizedProps);
        } else root !== flags ? (null === root ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : root.count--, null === flags ? mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode) : acquireResource(hoistableRoot, flags, finishedWork.memoizedProps)) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(finishedWork, finishedWork.memoizedProps, current.memoizedProps);
        break;
      case 27:
        if (flags & 4 && null === finishedWork.alternate) {
          hoistableRoot = finishedWork.stateNode;
          maybeNodes = finishedWork.memoizedProps;
          try {
            for (i = hoistableRoot.firstChild; i;) {
              var nextNode = i.nextSibling,
                nodeName = i.nodeName;
              i[internalHoistableMarker] || "HEAD" === nodeName || "BODY" === nodeName || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === i.rel.toLowerCase() || hoistableRoot.removeChild(i);
              i = nextNode;
            }
            runWithFiberInDEV(finishedWork, acquireSingletonInstance, finishedWork.type, maybeNodes, hoistableRoot, finishedWork);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      case 5:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (finishedWork.flags & 32) {
          root = finishedWork.stateNode;
          try {
            runWithFiberInDEV(finishedWork, resetTextContent, root);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        flags & 4 && null != finishedWork.stateNode && (root = finishedWork.memoizedProps, commitHostUpdate(finishedWork, root, null !== current ? current.memoizedProps : root));
        flags & 1024 && (needsFormReset = !0, "form" !== finishedWork.type && console.error("Unexpected host component type. Expected a form. This is a bug in React."));
        break;
      case 6:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        if (flags & 4) {
          if (null === finishedWork.stateNode) throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
          flags = finishedWork.memoizedProps;
          current = null !== current ? current.memoizedProps : flags;
          root = finishedWork.stateNode;
          try {
            runWithFiberInDEV(finishedWork, commitTextUpdate, root, current, flags);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 3:
        hoistableRoot = pushNestedEffectDurations();
        tagCaches = null;
        maybeNodes = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(root.containerInfo);
        recursivelyTraverseMutationEffects(root, finishedWork);
        currentHoistableRoot = maybeNodes;
        commitReconciliationEffects(finishedWork);
        if (flags & 4 && null !== current && current.memoizedState.isDehydrated) try {
          runWithFiberInDEV(finishedWork, commitHydratedContainer, root.containerInfo);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        needsFormReset && (needsFormReset = !1, recursivelyResetForms(finishedWork));
        root.effectDuration += popNestedEffectDurations(hoistableRoot);
        break;
      case 4:
        flags = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        currentHoistableRoot = flags;
        break;
      case 12:
        flags = pushNestedEffectDurations();
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
        break;
      case 13:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now$1());
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 22:
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        i = null !== finishedWork.memoizedState;
        nextNode = null !== current && null !== current.memoizedState;
        nodeName = offscreenSubtreeIsHidden;
        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = nodeName || i;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || nextNode;
        recursivelyTraverseMutationEffects(root, finishedWork);
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = nodeName;
        commitReconciliationEffects(finishedWork);
        root = finishedWork.stateNode;
        root._current = finishedWork;
        root._visibility &= ~OffscreenDetached;
        root._visibility |= root._pendingVisibility & OffscreenDetached;
        if (flags & 8192 && (root._visibility = i ? root._visibility & ~OffscreenVisible : root._visibility | OffscreenVisible, i && (root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden, null === current || nextNode || root || recursivelyTraverseDisappearLayoutEffects(finishedWork)), null === finishedWork.memoizedProps || "manual" !== finishedWork.memoizedProps.mode)) a: for (current = null, root = finishedWork;;) {
          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {
            if (null === current) {
              nextNode = current = root;
              try {
                hoistableRoot = nextNode.stateNode, i ? runWithFiberInDEV(nextNode, hideInstance, hoistableRoot) : runWithFiberInDEV(nextNode, unhideInstance, nextNode.stateNode, nextNode.memoizedProps);
              } catch (error) {
                captureCommitPhaseError(nextNode, nextNode.return, error);
              }
            }
          } else if (6 === root.tag) {
            if (null === current) {
              nextNode = root;
              try {
                maybeNodes = nextNode.stateNode, i ? runWithFiberInDEV(nextNode, hideTextInstance, maybeNodes) : runWithFiberInDEV(nextNode, unhideTextInstance, maybeNodes, nextNode.memoizedProps);
              } catch (error) {
                captureCommitPhaseError(nextNode, nextNode.return, error);
              }
            }
          } else if ((22 !== root.tag && 23 !== root.tag || null === root.memoizedState || root === finishedWork) && null !== root.child) {
            root.child.return = root;
            root = root.child;
            continue;
          }
          if (root === finishedWork) break a;
          for (; null === root.sibling;) {
            if (null === root.return || root.return === finishedWork) break a;
            current === root && (current = null);
            root = root.return;
          }
          current === root && (current = null);
          root.sibling.return = root.return;
          root = root.sibling;
        }
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
        break;
      case 19:
        recursivelyTraverseMutationEffects(root, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 21:
        break;
      default:
        recursivelyTraverseMutationEffects(root, finishedWork), commitReconciliationEffects(finishedWork);
    }
  }
  function commitReconciliationEffects(finishedWork) {
    var flags = finishedWork.flags;
    if (flags & 2) {
      try {
        runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
      finishedWork.flags &= -3;
    }
    flags & 4096 && (finishedWork.flags &= -4097);
  }
  function recursivelyResetForms(parentFiber) {
    if (parentFiber.subtreeFlags & 1024) for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var fiber = parentFiber;
      recursivelyResetForms(fiber);
      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
      parentFiber = parentFiber.sibling;
    }
  }
  function commitLayoutEffects(finishedWork, root, committedLanes) {
    inProgressLanes = committedLanes;
    inProgressRoot = root;
    commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);
    inProgressRoot = inProgressLanes = null;
  }
  function recursivelyTraverseLayoutEffects(root, parentFiber) {
    if (parentFiber.subtreeFlags & 8772) for (parentFiber = parentFiber.child; null !== parentFiber;) commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
  }
  function disappearLayoutEffects(finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookLayoutUnmountEffects(finishedWork, finishedWork.return, Layout);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 1:
        safelyDetachRef(finishedWork, finishedWork.return);
        var instance = finishedWork.stateNode;
        "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 26:
      case 27:
      case 5:
        safelyDetachRef(finishedWork, finishedWork.return);
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      case 22:
        safelyDetachRef(finishedWork, finishedWork.return);
        null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
        break;
      default:
        recursivelyTraverseDisappearLayoutEffects(finishedWork);
    }
  }
  function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
    for (parentFiber = parentFiber.child; null !== parentFiber;) disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
  }
  function reappearLayoutEffects(finishedRoot, current, finishedWork, includeWorkInProgressEffects) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        commitHookLayoutEffects(finishedWork, Layout);
        break;
      case 1:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        current = finishedWork.stateNode;
        "function" === typeof current.componentDidMount && runWithFiberInDEV(finishedWork, callComponentDidMountInDEV, finishedWork, current);
        current = finishedWork.updateQueue;
        if (null !== current) {
          finishedRoot = finishedWork.stateNode;
          try {
            runWithFiberInDEV(finishedWork, commitHiddenCallbacks, current, finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 26:
      case 27:
      case 5:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        if (includeWorkInProgressEffects && flags & 4) {
          flags = pushNestedEffectDurations();
          recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
          includeWorkInProgressEffects = finishedWork.stateNode;
          includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
          try {
            runWithFiberInDEV(finishedWork, commitProfiler, finishedWork, current, commitStartTime, includeWorkInProgressEffects.effectDuration);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        } else recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        break;
      case 13:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 22:
        null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
        safelyAttachRef(finishedWork, finishedWork.return);
        break;
      default:
        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);
    }
  }
  function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
    for (parentFiber = parentFiber.child; null !== parentFiber;) reappearLayoutEffects(finishedRoot, parentFiber.alternate, parentFiber, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
  }
  function commitOffscreenPassiveMountEffects(current, finishedWork) {
    var previousCache = null;
    null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
    current = null;
    null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
    current !== previousCache && (null != current && retainCache(current), null != previousCache && releaseCache(previousCache));
  }
  function commitCachePassiveMountEffect(current, finishedWork) {
    current = null;
    null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
    finishedWork = finishedWork.memoizedState.cache;
    finishedWork !== current && (retainCache(finishedWork), null != current && releaseCache(current));
  }
  function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {
    if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveMountOnFiber(root, parentFiber, committedLanes, committedTransitions), parentFiber = parentFiber.sibling;
  }
  function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
        break;
      case 3:
        var prevEffectDuration = pushNestedEffectDurations();
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
        finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
        break;
      case 12:
        if (flags & 2048) {
          prevEffectDuration = pushNestedEffectDurations();
          recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
          finishedRoot = finishedWork.stateNode;
          finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
          try {
            runWithFiberInDEV(finishedWork, commitProfilerPostCommitImpl, finishedWork, finishedWork.alternate, commitStartTime, finishedRoot.passiveEffectDuration);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        } else recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        break;
      case 23:
        break;
      case 22:
        prevEffectDuration = finishedWork.stateNode;
        null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, 0 !== (finishedWork.subtreeFlags & 10256)));
        flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
        break;
      case 24:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);
    }
  }
  function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
    for (parentFiber = parentFiber.child; null !== parentFiber;) reconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects), parentFiber = parentFiber.sibling;
  }
  function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        commitHookPassiveMountEffects(finishedWork, Passive);
        break;
      case 23:
        break;
      case 22:
        var _instance2 = finishedWork.stateNode;
        null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects));
        includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
        break;
      case 24:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
        includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);
    }
  }
  function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
    if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var finishedRoot = finishedRoot$jscomp$0,
        finishedWork = parentFiber,
        flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 22:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitOffscreenPassiveMountEffects(finishedWork.alternate, finishedWork);
          break;
        case 24:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyAccumulateSuspenseyCommit(parentFiber) {
    if (parentFiber.subtreeFlags & suspenseyCommitFlag) for (parentFiber = parentFiber.child; null !== parentFiber;) accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function accumulateSuspenseyCommitOnFiber(fiber) {
    switch (fiber.tag) {
      case 26:
        recursivelyAccumulateSuspenseyCommit(fiber);
        fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);
        break;
      case 5:
        recursivelyAccumulateSuspenseyCommit(fiber);
        break;
      case 3:
      case 4:
        var previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
        recursivelyAccumulateSuspenseyCommit(fiber);
        currentHoistableRoot = previousHoistableRoot;
        break;
      case 22:
        null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
        break;
      default:
        recursivelyAccumulateSuspenseyCommit(fiber);
    }
  }
  function detachAlternateSiblings(parentFiber) {
    var previousFiber = parentFiber.alternate;
    if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
      previousFiber.child = null;
      do previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber; while (null !== parentFiber);
    }
  }
  function recursivelyTraversePassiveUnmountEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
      }
      detachAlternateSiblings(parentFiber);
    }
    if (parentFiber.subtreeFlags & 10256) for (parentFiber = parentFiber.child; null !== parentFiber;) commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function commitPassiveUnmountOnFiber(finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);
        break;
      case 3:
        var prevEffectDuration = pushNestedEffectDurations();
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
        break;
      case 12:
        prevEffectDuration = pushNestedEffectDurations();
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
        break;
      case 22:
        prevEffectDuration = finishedWork.stateNode;
        null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      default:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
    }
  }
  function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions) for (var i = 0; i < deletions.length; i++) {
        var childToDelete = deletions[i];
        nextEffect = childToDelete;
        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);
      }
      detachAlternateSiblings(parentFiber);
    }
    for (parentFiber = parentFiber.child; null !== parentFiber;) disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
  }
  function disconnectPassiveEffect(finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive);
        recursivelyTraverseDisconnectPassiveEffects(finishedWork);
        break;
      case 22:
        var instance = finishedWork.stateNode;
        instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
        break;
      default:
        recursivelyTraverseDisconnectPassiveEffects(finishedWork);
    }
  }
  function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
    for (; null !== nextEffect;) {
      var fiber = nextEffect,
        current = fiber;
      switch (current.tag) {
        case 0:
        case 11:
        case 15:
          commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);
          break;
        case 23:
        case 22:
          null !== current.memoizedState && null !== current.memoizedState.cachePool && (current = current.memoizedState.cachePool.pool, null != current && retainCache(current));
          break;
        case 24:
          releaseCache(current.memoizedState.cache);
      }
      current = fiber.child;
      if (null !== current) current.return = fiber, nextEffect = current;else a: for (fiber = deletedSubtreeRoot; null !== nextEffect;) {
        current = nextEffect;
        var sibling = current.sibling,
          returnFiber = current.return;
        detachFiberAfterEffects(current);
        if (current === fiber) {
          nextEffect = null;
          break a;
        }
        if (null !== sibling) {
          sibling.return = returnFiber;
          nextEffect = sibling;
          break a;
        }
        nextEffect = returnFiber;
      }
    }
  }
  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.refCleanup = this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
    this.actualDuration = -0;
    this.actualStartTime = -1.1;
    this.treeBaseDuration = this.selfBaseDuration = -0;
    this._debugOwner = this._debugInfo = null;
    this._debugNeedsRemount = !1;
    this._debugHookTypes = null;
    hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
  }
  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }
  function createWorkInProgress(current, pendingProps) {
    var workInProgress = current.alternate;
    null === workInProgress ? (workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode), workInProgress.elementType = current.elementType, workInProgress.type = current.type, workInProgress.stateNode = current.stateNode, workInProgress._debugOwner = current._debugOwner, workInProgress._debugHookTypes = current._debugHookTypes, workInProgress.alternate = current, current.alternate = workInProgress) : (workInProgress.pendingProps = pendingProps, workInProgress.type = current.type, workInProgress.flags = 0, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.actualDuration = -0, workInProgress.actualStartTime = -1.1);
    workInProgress.flags = current.flags & 31457280;
    workInProgress.childLanes = current.childLanes;
    workInProgress.lanes = current.lanes;
    workInProgress.child = current.child;
    workInProgress.memoizedProps = current.memoizedProps;
    workInProgress.memoizedState = current.memoizedState;
    workInProgress.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    workInProgress.dependencies = null === pendingProps ? null : {
      lanes: pendingProps.lanes,
      firstContext: pendingProps.firstContext,
      _debugThenableState: pendingProps._debugThenableState
    };
    workInProgress.sibling = current.sibling;
    workInProgress.index = current.index;
    workInProgress.ref = current.ref;
    workInProgress.refCleanup = current.refCleanup;
    workInProgress.selfBaseDuration = current.selfBaseDuration;
    workInProgress.treeBaseDuration = current.treeBaseDuration;
    workInProgress._debugInfo = current._debugInfo;
    workInProgress._debugNeedsRemount = current._debugNeedsRemount;
    switch (workInProgress.tag) {
      case 0:
      case 15:
        workInProgress.type = resolveFunctionForHotReloading(current.type);
        break;
      case 1:
        workInProgress.type = resolveFunctionForHotReloading(current.type);
        break;
      case 11:
        workInProgress.type = resolveForwardRefForHotReloading(current.type);
    }
    return workInProgress;
  }
  function resetWorkInProgress(workInProgress, renderLanes) {
    workInProgress.flags &= 31457282;
    var current = workInProgress.alternate;
    null === current ? (workInProgress.childLanes = 0, workInProgress.lanes = renderLanes, workInProgress.child = null, workInProgress.subtreeFlags = 0, workInProgress.memoizedProps = null, workInProgress.memoizedState = null, workInProgress.updateQueue = null, workInProgress.dependencies = null, workInProgress.stateNode = null, workInProgress.selfBaseDuration = 0, workInProgress.treeBaseDuration = 0) : (workInProgress.childLanes = current.childLanes, workInProgress.lanes = current.lanes, workInProgress.child = current.child, workInProgress.subtreeFlags = 0, workInProgress.deletions = null, workInProgress.memoizedProps = current.memoizedProps, workInProgress.memoizedState = current.memoizedState, workInProgress.updateQueue = current.updateQueue, workInProgress.type = current.type, renderLanes = current.dependencies, workInProgress.dependencies = null === renderLanes ? null : {
      lanes: renderLanes.lanes,
      firstContext: renderLanes.firstContext,
      _debugThenableState: renderLanes._debugThenableState
    }, workInProgress.selfBaseDuration = current.selfBaseDuration, workInProgress.treeBaseDuration = current.treeBaseDuration);
    return workInProgress;
  }
  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
    var fiberTag = 0,
      resolvedType = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);else if ("string" === typeof type) fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;else a: switch (type) {
      case REACT_FRAGMENT_TYPE:
        return createFiberFromFragment(pendingProps.children, mode, lanes, key);
      case REACT_STRICT_MODE_TYPE:
        fiberTag = 8;
        mode |= StrictLegacyMode;
        mode |= StrictEffectsMode;
        break;
      case REACT_PROFILER_TYPE:
        return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof type.id), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = {
          effectDuration: 0,
          passiveEffectDuration: 0
        }, key;
      case REACT_SUSPENSE_TYPE:
        return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
      case REACT_SUSPENSE_LIST_TYPE:
        return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
      case REACT_OFFSCREEN_TYPE:
        return createFiberFromOffscreen(pendingProps, mode, lanes, key);
      default:
        if ("object" === typeof type && null !== type) switch (type.$$typeof) {
          case REACT_PROVIDER_TYPE:
          case REACT_CONTEXT_TYPE:
            fiberTag = 10;
            break a;
          case REACT_CONSUMER_TYPE:
            fiberTag = 9;
            break a;
          case REACT_FORWARD_REF_TYPE:
            fiberTag = 11;
            resolvedType = resolveForwardRefForHotReloading(resolvedType);
            break a;
          case REACT_MEMO_TYPE:
            fiberTag = 14;
            break a;
          case REACT_LAZY_TYPE:
            fiberTag = 16;
            resolvedType = null;
            break a;
        }
        resolvedType = "";
        if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
        null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
        (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
        fiberTag = 29;
        pendingProps = Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType));
        resolvedType = null;
    }
    key = createFiber(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = resolvedType;
    key.lanes = lanes;
    key._debugOwner = owner;
    return key;
  }
  function createFiberFromElement(element, mode, lanes) {
    mode = createFiberFromTypeAndProps(element.type, element.key, element.props, element._owner, mode, lanes);
    mode._debugOwner = element._owner;
    return mode;
  }
  function createFiberFromFragment(elements, mode, lanes, key) {
    elements = createFiber(7, elements, key, mode);
    elements.lanes = lanes;
    return elements;
  }
  function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
    pendingProps = createFiber(22, pendingProps, key, mode);
    pendingProps.elementType = REACT_OFFSCREEN_TYPE;
    pendingProps.lanes = lanes;
    var primaryChildInstance = {
      _visibility: OffscreenVisible,
      _pendingVisibility: OffscreenVisible,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null,
      _current: null,
      detach: function () {
        var instance = primaryChildInstance,
          fiber = instance._current;
        if (null === fiber) throw Error("Calling Offscreen.detach before instance handle has been set.");
        if (0 === (instance._pendingVisibility & OffscreenDetached)) {
          var root = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root && (instance._pendingVisibility |= OffscreenDetached, scheduleUpdateOnFiber(root, fiber, 2));
        }
      },
      attach: function () {
        var instance = primaryChildInstance,
          fiber = instance._current;
        if (null === fiber) throw Error("Calling Offscreen.detach before instance handle has been set.");
        if (0 !== (instance._pendingVisibility & OffscreenDetached)) {
          var root = enqueueConcurrentRenderForLane(fiber, 2);
          null !== root && (instance._pendingVisibility &= ~OffscreenDetached, scheduleUpdateOnFiber(root, fiber, 2));
        }
      }
    };
    pendingProps.stateNode = primaryChildInstance;
    return pendingProps;
  }
  function createFiberFromText(content, mode, lanes) {
    content = createFiber(6, content, null, mode);
    content.lanes = lanes;
    return content;
  }
  function createFiberFromPortal(portal, mode, lanes) {
    mode = createFiber(4, null !== portal.children ? portal.children : [], portal.key, mode);
    mode.lanes = lanes;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }
  function markUpdate(workInProgress) {
    workInProgress.flags |= 4;
  }
  function preloadResourceAndSuspendIfNeeded(workInProgress, resource) {
    if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded) workInProgress.flags &= -16777217;else if (workInProgress.flags |= 16777216, !preloadResource(resource)) {
      resource = suspenseHandlerStackCursor.current;
      if (null !== resource && ((workInProgressRootRenderLanes & 4194176) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary)) throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      workInProgress.flags |= 8192;
    }
  }
  function scheduleRetryEffect(workInProgress, retryQueue) {
    null !== retryQueue && (workInProgress.flags |= 4);
    workInProgress.flags & 16384 && (retryQueue = 22 !== workInProgress.tag ? claimNextRetryLane() : 536870912, workInProgress.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
  }
  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    if (!isHydrating) switch (renderState.tailMode) {
      case "hidden":
        hasRenderedATailFallback = renderState.tail;
        for (var lastTailNode = null; null !== hasRenderedATailFallback;) null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
        null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
        break;
      case "collapsed":
        lastTailNode = renderState.tail;
        for (var _lastTailNode = null; null !== lastTailNode;) null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
        null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
    }
  }
  function bubbleProperties(completedWork) {
    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child,
      newChildLanes = 0,
      subtreeFlags = 0;
    if (didBailout) {
      if ((completedWork.mode & ProfileMode) !== NoMode) {
        for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2;) newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 31457280, subtreeFlags |= _child2.flags & 31457280, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
        completedWork.treeBaseDuration = _treeBaseDuration;
      } else for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;) newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 31457280, subtreeFlags |= _treeBaseDuration.flags & 31457280, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
    } else if ((completedWork.mode & ProfileMode) !== NoMode) {
      _treeBaseDuration = completedWork.actualDuration;
      _child2 = completedWork.selfBaseDuration;
      for (var child = completedWork.child; null !== child;) newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
      completedWork.actualDuration = _treeBaseDuration;
      completedWork.treeBaseDuration = _child2;
    } else for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration;) newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
    completedWork.subtreeFlags |= subtreeFlags;
    completedWork.childLanes = newChildLanes;
    return didBailout;
  }
  function completeWork(current, workInProgress, renderLanes) {
    var newProps = workInProgress.pendingProps;
    popTreeContext(workInProgress);
    switch (workInProgress.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bubbleProperties(workInProgress), null;
      case 1:
        return bubbleProperties(workInProgress), null;
      case 3:
        newProps = workInProgress.stateNode;
        renderLanes = null;
        null !== current && (renderLanes = current.memoizedState.cache);
        workInProgress.memoizedState.cache !== renderLanes && (workInProgress.flags |= 2048);
        popProvider(CacheContext, workInProgress);
        popHostContainer(workInProgress);
        newProps.pendingContext && (newProps.context = newProps.pendingContext, newProps.pendingContext = null);
        if (null === current || null === current.child) popHydrationState(workInProgress) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress)) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress.flags & 256) || (workInProgress.flags |= 1024, null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null));
        bubbleProperties(workInProgress);
        return null;
      case 26:
        return renderLanes = workInProgress.memoizedState, null === current ? (markUpdate(workInProgress), null !== renderLanes ? (bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217)) : renderLanes ? renderLanes !== current.memoizedState ? (markUpdate(workInProgress), bubbleProperties(workInProgress), preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes)) : (bubbleProperties(workInProgress), workInProgress.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress), bubbleProperties(workInProgress), workInProgress.flags &= -16777217), null;
      case 27:
        popHostContext(workInProgress);
        renderLanes = requiredContext(rootInstanceStackCursor.current);
        var _type = workInProgress.type;
        if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
          if (!newProps) {
            if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            bubbleProperties(workInProgress);
            return null;
          }
          current = getHostContext();
          popHydrationState(workInProgress) ? prepareToHydrateHostInstance(workInProgress, current) : (current = resolveSingletonInstance(_type, newProps, renderLanes, current, !0), workInProgress.stateNode = current, markUpdate(workInProgress));
        }
        bubbleProperties(workInProgress);
        return null;
      case 5:
        popHostContext(workInProgress);
        renderLanes = workInProgress.type;
        if (null !== current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
          if (!newProps) {
            if (null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            bubbleProperties(workInProgress);
            return null;
          }
          _type = getHostContext();
          if (popHydrationState(workInProgress)) prepareToHydrateHostInstance(workInProgress, _type);else {
            current = requiredContext(rootInstanceStackCursor.current);
            validateDOMNesting(renderLanes, _type.ancestorInfo);
            _type = _type.context;
            current = getOwnerDocumentFromRootContainer(current);
            switch (_type) {
              case HostContextNamespaceSvg:
                current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                break;
              case HostContextNamespaceMath:
                current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                break;
              default:
                switch (renderLanes) {
                  case "svg":
                    current = current.createElementNS(SVG_NAMESPACE, renderLanes);
                    break;
                  case "math":
                    current = current.createElementNS(MATH_NAMESPACE, renderLanes);
                    break;
                  case "script":
                    current = current.createElement("div");
                    current.innerHTML = "<script>\x3c/script>";
                    current = current.removeChild(current.firstChild);
                    break;
                  case "select":
                    current = "string" === typeof newProps.is ? current.createElement("select", {
                      is: newProps.is
                    }) : current.createElement("select");
                    newProps.multiple ? current.multiple = !0 : newProps.size && (current.size = newProps.size);
                    break;
                  default:
                    current = "string" === typeof newProps.is ? current.createElement(renderLanes, {
                      is: newProps.is
                    }) : current.createElement(renderLanes), -1 === renderLanes.indexOf("-") && (renderLanes !== renderLanes.toLowerCase() && console.error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", renderLanes), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current) || hasOwnProperty.call(warnedUnknownTags, renderLanes) || (warnedUnknownTags[renderLanes] = !0, console.error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", renderLanes)));
                }
            }
            current[internalInstanceKey] = workInProgress;
            current[internalPropsKey] = newProps;
            a: for (_type = workInProgress.child; null !== _type;) {
              if (5 === _type.tag || 6 === _type.tag) current.appendChild(_type.stateNode);else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
                _type.child.return = _type;
                _type = _type.child;
                continue;
              }
              if (_type === workInProgress) break a;
              for (; null === _type.sibling;) {
                if (null === _type.return || _type.return === workInProgress) break a;
                _type = _type.return;
              }
              _type.sibling.return = _type.return;
              _type = _type.sibling;
            }
            workInProgress.stateNode = current;
            a: switch (setInitialProperties(current, renderLanes, newProps), renderLanes) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                current = !!newProps.autoFocus;
                break a;
              case "img":
                current = !0;
                break a;
              default:
                current = !1;
            }
            current && markUpdate(workInProgress);
          }
        }
        bubbleProperties(workInProgress);
        workInProgress.flags &= -16777217;
        return null;
      case 6:
        if (current && null != workInProgress.stateNode) current.memoizedProps !== newProps && markUpdate(workInProgress);else {
          if ("string" !== typeof newProps && null === workInProgress.stateNode) throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
          current = requiredContext(rootInstanceStackCursor.current);
          renderLanes = getHostContext();
          if (popHydrationState(workInProgress)) {
            current = workInProgress.stateNode;
            newProps = workInProgress.memoizedProps;
            _type = !didSuspendOrErrorDEV;
            renderLanes = null;
            var returnFiber = hydrationParentFiber;
            if (null !== returnFiber) switch (returnFiber.tag) {
              case 3:
                _type && (_type = diffHydratedTextForDevWarnings(current, newProps, renderLanes), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
                break;
              case 27:
              case 5:
                renderLanes = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(current, newProps, renderLanes), null !== _type && (buildHydrationDiffNode(workInProgress, 0).serverProps = _type));
            }
            current[internalInstanceKey] = workInProgress;
            current = current.nodeValue === newProps || null !== renderLanes && !0 === renderLanes.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, newProps) ? !0 : !1;
            current || throwOnHydrationMismatch(workInProgress);
          } else renderLanes = renderLanes.ancestorInfo.current, null != renderLanes && validateTextNesting(newProps, renderLanes.tag), current = getOwnerDocumentFromRootContainer(current).createTextNode(newProps), current[internalInstanceKey] = workInProgress, workInProgress.stateNode = current;
        }
        bubbleProperties(workInProgress);
        return null;
      case 13:
        newProps = workInProgress.memoizedState;
        if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
          _type = popHydrationState(workInProgress);
          if (null !== newProps && null !== newProps.dehydrated) {
            if (null === current) {
              if (!_type) throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
              _type = workInProgress.memoizedState;
              _type = null !== _type ? _type.dehydrated : null;
              if (!_type) throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
              _type[internalInstanceKey] = workInProgress;
              bubbleProperties(workInProgress);
              (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
            } else emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress.flags & 128) && (workInProgress.memoizedState = null), workInProgress.flags |= 4, bubbleProperties(workInProgress), (workInProgress.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress.child, null !== _type && (workInProgress.treeBaseDuration -= _type.treeBaseDuration));
            _type = !1;
          } else null !== hydrationErrors && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null), _type = !0;
          if (!_type) {
            if (workInProgress.flags & 256) return popSuspenseHandler(workInProgress), workInProgress;
            popSuspenseHandler(workInProgress);
            return null;
          }
        }
        popSuspenseHandler(workInProgress);
        if (0 !== (workInProgress.flags & 128)) return workInProgress.lanes = renderLanes, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress;
        newProps = null !== newProps;
        current = null !== current && null !== current.memoizedState;
        newProps && (renderLanes = workInProgress.child, _type = null, null !== renderLanes.alternate && null !== renderLanes.alternate.memoizedState && null !== renderLanes.alternate.memoizedState.cachePool && (_type = renderLanes.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== renderLanes.memoizedState && null !== renderLanes.memoizedState.cachePool && (returnFiber = renderLanes.memoizedState.cachePool.pool), returnFiber !== _type && (renderLanes.flags |= 2048));
        newProps !== current && newProps && (workInProgress.child.flags |= 8192);
        scheduleRetryEffect(workInProgress, workInProgress.updateQueue);
        bubbleProperties(workInProgress);
        (workInProgress.mode & ProfileMode) !== NoMode && newProps && (current = workInProgress.child, null !== current && (workInProgress.treeBaseDuration -= current.treeBaseDuration));
        return null;
      case 4:
        return popHostContainer(workInProgress), null === current && listenToAllSupportedEvents(workInProgress.stateNode.containerInfo), bubbleProperties(workInProgress), null;
      case 10:
        return popProvider(workInProgress.type, workInProgress), bubbleProperties(workInProgress), null;
      case 19:
        pop(suspenseStackCursor, workInProgress);
        _type = workInProgress.memoizedState;
        if (null === _type) return bubbleProperties(workInProgress), null;
        newProps = 0 !== (workInProgress.flags & 128);
        returnFiber = _type.rendering;
        if (null === returnFiber) {
          if (newProps) cutOffTailIfNeeded(_type, !1);else {
            if (workInProgressRootExitStatus !== RootInProgress || null !== current && 0 !== (current.flags & 128)) for (current = workInProgress.child; null !== current;) {
              returnFiber = findFirstSuspended(current);
              if (null !== returnFiber) {
                workInProgress.flags |= 128;
                cutOffTailIfNeeded(_type, !1);
                current = returnFiber.updateQueue;
                workInProgress.updateQueue = current;
                scheduleRetryEffect(workInProgress, current);
                workInProgress.subtreeFlags = 0;
                current = renderLanes;
                for (newProps = workInProgress.child; null !== newProps;) resetWorkInProgress(newProps, current), newProps = newProps.sibling;
                push(suspenseStackCursor, suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress);
                return workInProgress.child;
              }
              current = current.sibling;
            }
            null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
          }
        } else {
          if (!newProps) if (current = findFirstSuspended(returnFiber), null !== current) {
            if (workInProgress.flags |= 128, newProps = !0, current = current.updateQueue, workInProgress.updateQueue = current, scheduleRetryEffect(workInProgress, current), cutOffTailIfNeeded(_type, !0), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating) return bubbleProperties(workInProgress), null;
          } else 2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes && (workInProgress.flags |= 128, newProps = !0, cutOffTailIfNeeded(_type, !1), workInProgress.lanes = 4194304);
          _type.isBackwards ? (returnFiber.sibling = workInProgress.child, workInProgress.child = returnFiber) : (current = _type.last, null !== current ? current.sibling = returnFiber : workInProgress.child = returnFiber, _type.last = returnFiber);
        }
        if (null !== _type.tail) return current = _type.tail, _type.rendering = current, _type.tail = current.sibling, _type.renderingStartTime = now$1(), current.sibling = null, renderLanes = suspenseStackCursor.current, renderLanes = newProps ? renderLanes & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes, workInProgress), current;
        bubbleProperties(workInProgress);
        return null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), newProps = null !== workInProgress.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress.flags |= 8192) : newProps && (workInProgress.flags |= 8192), newProps ? 0 !== (renderLanes & 536870912) && 0 === (workInProgress.flags & 128) && (bubbleProperties(workInProgress), workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192)) : bubbleProperties(workInProgress), newProps = workInProgress.updateQueue, null !== newProps && scheduleRetryEffect(workInProgress, newProps.retryQueue), newProps = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (newProps = current.memoizedState.cachePool.pool), renderLanes = null, null !== workInProgress.memoizedState && null !== workInProgress.memoizedState.cachePool && (renderLanes = workInProgress.memoizedState.cachePool.pool), renderLanes !== newProps && (workInProgress.flags |= 2048), null !== current && pop(resumedCache, workInProgress), null;
      case 24:
        return newProps = null, null !== current && (newProps = current.memoizedState.cache), workInProgress.memoizedState.cache !== newProps && (workInProgress.flags |= 2048), popProvider(CacheContext, workInProgress), bubbleProperties(workInProgress), null;
      case 25:
        return null;
    }
    throw Error("Unknown unit of work tag (" + workInProgress.tag + "). This error is likely caused by a bug in React. Please file an issue.");
  }
  function unwindWork(current, workInProgress) {
    popTreeContext(workInProgress);
    switch (workInProgress.tag) {
      case 1:
        return current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
      case 3:
        return popProvider(CacheContext, workInProgress), popHostContainer(workInProgress), current = workInProgress.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress.flags = current & -65537 | 128, workInProgress) : null;
      case 26:
      case 27:
      case 5:
        return popHostContext(workInProgress), null;
      case 13:
        popSuspenseHandler(workInProgress);
        current = workInProgress.memoizedState;
        if (null !== current && null !== current.dehydrated) {
          if (null === workInProgress.alternate) throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
          resetHydrationState();
        }
        current = workInProgress.flags;
        return current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
      case 19:
        return pop(suspenseStackCursor, workInProgress), null;
      case 4:
        return popHostContainer(workInProgress), null;
      case 10:
        return popProvider(workInProgress.type, workInProgress), null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress), popHiddenContext(workInProgress), null !== current && pop(resumedCache, workInProgress), current = workInProgress.flags, current & 65536 ? (workInProgress.flags = current & -65537 | 128, (workInProgress.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress), workInProgress) : null;
      case 24:
        return popProvider(CacheContext, workInProgress), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function unwindInterruptedWork(current, interruptedWork) {
    popTreeContext(interruptedWork);
    switch (interruptedWork.tag) {
      case 3:
        popProvider(CacheContext, interruptedWork);
        popHostContainer(interruptedWork);
        break;
      case 26:
      case 27:
      case 5:
        popHostContext(interruptedWork);
        break;
      case 4:
        popHostContainer(interruptedWork);
        break;
      case 13:
        popSuspenseHandler(interruptedWork);
        break;
      case 19:
        pop(suspenseStackCursor, interruptedWork);
        break;
      case 10:
        popProvider(interruptedWork.type, interruptedWork);
        break;
      case 22:
      case 23:
        popSuspenseHandler(interruptedWork);
        popHiddenContext(interruptedWork);
        null !== current && pop(resumedCache, interruptedWork);
        break;
      case 24:
        popProvider(CacheContext, interruptedWork);
    }
  }
  function onCommitRoot() {
    commitHooks.forEach(function (commitHook) {
      return commitHook();
    });
  }
  function isConcurrentActEnvironment() {
    var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
    isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error("The current testing environment is not configured to support act(...)");
    return isReactActEnvironmentGlobal;
  }
  function requestUpdateLane(fiber) {
    if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes) return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
    var transition = ReactSharedInternals.T;
    return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
  }
  function requestDeferredLane() {
    0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
    var suspenseHandler = suspenseHandlerStackCursor.current;
    null !== suspenseHandler && (suspenseHandler.flags |= 32);
    return workInProgressDeferredLane;
  }
  function scheduleUpdateOnFiber(root, fiber, lane) {
    isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
    isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0);
    if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) prepareFreshStack(root, 0), markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
    markRootUpdated$1(root, lane);
    if (0 !== (executionContext & RenderContext) && root === workInProgressRoot) {
      if (isRendering) switch (fiber.tag) {
        case 0:
        case 11:
        case 15:
          root = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
          didWarnAboutUpdateInRenderForAnotherComponent.has(root) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render", fiber, root, root));
          break;
        case 1:
          didWarnAboutUpdateInRender || (console.error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = !0);
      }
    } else isDevToolsPresent && addFiberToLanesMap(root, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane, !1)), ensureRootIsScheduled(root);
  }
  function performWorkOnRoot(root, lanes, forceSync) {
    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
    var shouldTimeSlice = !forceSync && 0 === (lanes & 60) && 0 === (lanes & root.expiredLanes) || checkIfRootIsPrerendering(root, lanes),
      exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes, !0),
      renderWasConcurrent = shouldTimeSlice;
    do {
      if (exitStatus === RootInProgress) {
        workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root, lanes, 0, !1);
        break;
      } else if (exitStatus === RootDidNotComplete) markRootSuspended(root, lanes, 0, !workInProgressRootDidSkipSuspendedSiblings);else {
        forceSync = root.current.alternate;
        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
          exitStatus = renderRootSync(root, lanes, !1);
          renderWasConcurrent = !1;
          continue;
        }
        if (exitStatus === RootErrored) {
          renderWasConcurrent = lanes;
          if (root.errorRecoveryDisabledLanes & renderWasConcurrent) var errorRetryLanes = 0;else errorRetryLanes = root.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
          if (0 !== errorRetryLanes) {
            lanes = errorRetryLanes;
            a: {
              exitStatus = root;
              var errorRetryLanes$jscomp$0 = errorRetryLanes;
              errorRetryLanes = workInProgressRootConcurrentErrors;
              var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
              wasRootDehydrated && (prepareFreshStack(exitStatus, errorRetryLanes$jscomp$0).flags |= 256);
              errorRetryLanes$jscomp$0 = renderRootSync(exitStatus, errorRetryLanes$jscomp$0, !1);
              if (errorRetryLanes$jscomp$0 !== RootErrored) {
                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                  exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
                  workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                  exitStatus = RootSuspendedWithDelay;
                  break a;
                }
                exitStatus = workInProgressRootRecoverableErrors;
                workInProgressRootRecoverableErrors = errorRetryLanes;
                null !== exitStatus && queueRecoverableErrors(exitStatus);
              }
              exitStatus = errorRetryLanes$jscomp$0;
            }
            renderWasConcurrent = !1;
            if (exitStatus !== RootErrored) continue;
          }
        }
        if (exitStatus === RootFatalErrored) {
          prepareFreshStack(root, 0);
          markRootSuspended(root, lanes, 0, !0);
          break;
        }
        a: {
          shouldTimeSlice = root;
          switch (exitStatus) {
            case RootInProgress:
            case RootFatalErrored:
              throw Error("Root did not complete. This is a bug in React.");
            case RootSuspendedWithDelay:
              if ((lanes & 4194176) === lanes) {
                markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
                break a;
              }
              break;
            case RootErrored:
              workInProgressRootRecoverableErrors = null;
              break;
            case RootSuspended:
            case RootCompleted:
              break;
            default:
              throw Error("Unknown root exit status.");
          }
          shouldTimeSlice.finishedWork = forceSync;
          shouldTimeSlice.finishedLanes = lanes;
          if (null !== ReactSharedInternals.actQueue) commitRoot(shouldTimeSlice, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, IMMEDIATE_COMMIT, renderStartTime, 0);else {
            if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < exitStatus)) {
              markRootSuspended(shouldTimeSlice, lanes, workInProgressDeferredLane, !workInProgressRootDidSkipSuspendedSiblings);
              if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, THROTTLED_COMMIT, renderStartTime, 0), exitStatus);
              break a;
            }
            commitRootWhenReady(shouldTimeSlice, forceSync, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane, workInProgressRootInterleavedUpdatedLanes, workInProgressSuspendedRetryLanes, workInProgressRootDidSkipSuspendedSiblings, IMMEDIATE_COMMIT, renderStartTime, 0);
          }
        }
      }
      break;
    } while (1);
    ensureRootIsScheduled(root);
  }
  function queueRecoverableErrors(errors) {
    null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
  }
  function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
    var subtreeFlags = finishedWork.subtreeFlags;
    if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408)) if (suspendedState = {
      stylesheets: null,
      count: 0,
      unsuspend: noop
    }, accumulateSuspenseyCommitOnFiber(finishedWork), finishedWork = waitForCommitToBeReady(), null !== finishedWork) {
      root.cancelPendingCommit = finishedWork(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, SUSPENDED_COMMIT, completedRenderStartTime, completedRenderEndTime));
      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);
      return;
    }
    commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
  }
  function isRenderConsistentWithExternalStores(finishedWork) {
    for (var node = finishedWork;;) {
      var tag = node.tag;
      if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag))) for (var i = 0; i < tag.length; i++) {
        var check = tag[i],
          getSnapshot = check.getSnapshot;
        check = check.value;
        try {
          if (!objectIs(getSnapshot(), check)) return !1;
        } catch (error) {
          return !1;
        }
      }
      tag = node.child;
      if (node.subtreeFlags & 16384 && null !== tag) tag.return = node, node = tag;else {
        if (node === finishedWork) break;
        for (; null === node.sibling;) {
          if (null === node.return || node.return === finishedWork) return !0;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return !0;
  }
  function markRootSuspended(root, suspendedLanes, spawnedLane, didAttemptEntireTree) {
    suspendedLanes &= ~workInProgressRootPingedLanes;
    suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
    root.suspendedLanes |= suspendedLanes;
    root.pingedLanes &= ~suspendedLanes;
    didAttemptEntireTree && (root.warmLanes |= suspendedLanes);
    didAttemptEntireTree = root.expirationTimes;
    for (var lanes = suspendedLanes; 0 < lanes;) {
      var index = 31 - clz32(lanes),
        lane = 1 << index;
      didAttemptEntireTree[index] = -1;
      lanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);
  }
  function flushSyncWork$1() {
    return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0, !1), !1) : !0;
  }
  function resetWorkInProgressStack() {
    if (null !== workInProgress) {
      if (workInProgressSuspendedReason === NotSuspended) var interruptedWork = workInProgress.return;else interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
      for (; null !== interruptedWork;) unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
      workInProgress = null;
    }
  }
  function prepareFreshStack(root, lanes) {
    root.finishedWork = null;
    root.finishedLanes = 0;
    var timeoutHandle = root.timeoutHandle;
    timeoutHandle !== noTimeout && (root.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
    timeoutHandle = root.cancelPendingCommit;
    null !== timeoutHandle && (root.cancelPendingCommit = null, timeoutHandle());
    resetWorkInProgressStack();
    workInProgressRoot = root;
    workInProgress = timeoutHandle = createWorkInProgress(root.current, null);
    workInProgressRootRenderLanes = lanes;
    workInProgressSuspendedReason = NotSuspended;
    workInProgressThrownValue = null;
    workInProgressRootDidSkipSuspendedSiblings = !1;
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
    workInProgressRootDidAttachPingListener = !1;
    workInProgressRootExitStatus = RootInProgress;
    workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
    workInProgressRootDidIncludeRecursiveRenderUpdate = !1;
    0 !== (lanes & 8) && (lanes |= lanes & 32);
    var allEntangledLanes = root.entangledLanes;
    if (0 !== allEntangledLanes) for (root = root.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes;) {
      var index = 31 - clz32(allEntangledLanes),
        lane = 1 << index;
      lanes |= root[index];
      allEntangledLanes &= ~lane;
    }
    entangledRenderLanes = lanes;
    finishQueueingConcurrentUpdates();
    ReactStrictModeWarnings.discardPendingWarnings();
    return timeoutHandle;
  }
  function handleThrow(root, thrownValue) {
    currentlyRenderingFiber$1 = null;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    ReactSharedInternals.getCurrentStack = null;
    isRendering = !1;
    current = null;
    thrownValue === SuspenseException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
    workInProgressThrownValue = thrownValue;
    var erroredWork = workInProgress;
    if (null === erroredWork) workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));else switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
      case SuspendedOnError:
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
        break;
      case SuspendedOnData:
      case SuspendedOnImmediate:
      case SuspendedOnDeprecatedThrowPromise:
      case SuspendedAndReadyToContinue:
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(erroredWork, thrownValue, workInProgressRootRenderLanes);
    }
  }
  function pushDispatcher() {
    var prevDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
  }
  function pushAsyncDispatcher() {
    var prevAsyncDispatcher = ReactSharedInternals.A;
    ReactSharedInternals.A = DefaultAsyncDispatcher;
    return prevAsyncDispatcher;
  }
  function renderDidSuspendDelayIfPossible() {
    workInProgressRootExitStatus = RootSuspendedWithDelay;
    workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194176) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = !0);
    0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane, !1);
  }
  function renderRootSync(root, lanes, shouldYieldForPrerendering) {
    var prevExecutionContext = executionContext;
    executionContext |= RenderContext;
    var prevDispatcher = pushDispatcher(),
      prevAsyncDispatcher = pushAsyncDispatcher();
    if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
      if (isDevToolsPresent) {
        var memoizedUpdaters = root.memoizedUpdaters;
        0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
        movePendingFibersToMemoized(root, lanes);
      }
      workInProgressTransitions = null;
      prepareFreshStack(root, lanes);
    }
    markRenderStarted(lanes);
    lanes = !1;
    memoizedUpdaters = workInProgressRootExitStatus;
    a: do try {
      if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
        var unitOfWork = workInProgress,
          thrownValue = workInProgressThrownValue;
        switch (workInProgressSuspendedReason) {
          case SuspendedOnHydration:
            resetWorkInProgressStack();
            memoizedUpdaters = RootDidNotComplete;
            break a;
          case SuspendedOnImmediate:
          case SuspendedOnData:
          case SuspendedOnDeprecatedThrowPromise:
            null === suspenseHandlerStackCursor.current && (lanes = !0);
            var reason = workInProgressSuspendedReason;
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
            if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
              memoizedUpdaters = RootInProgress;
              break a;
            }
            break;
          default:
            reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);
        }
      }
      workLoopSync();
      memoizedUpdaters = workInProgressRootExitStatus;
      break;
    } catch (thrownValue$8) {
      handleThrow(root, thrownValue$8);
    } while (1);
    lanes && root.shellSuspendCounter++;
    resetContextDependencies();
    executionContext = prevExecutionContext;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    markRenderStopped();
    null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
    return memoizedUpdaters;
  }
  function workLoopSync() {
    for (; null !== workInProgress;) performUnitOfWork(workInProgress);
  }
  function renderRootConcurrent(root, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= RenderContext;
    var prevDispatcher = pushDispatcher(),
      prevAsyncDispatcher = pushAsyncDispatcher();
    if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
      if (isDevToolsPresent) {
        var memoizedUpdaters = root.memoizedUpdaters;
        0 < memoizedUpdaters.size && (restorePendingUpdaters(root, workInProgressRootRenderLanes), memoizedUpdaters.clear());
        movePendingFibersToMemoized(root, lanes);
      }
      workInProgressTransitions = null;
      workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
      prepareFreshStack(root, lanes);
    } else workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);
    markRenderStarted(lanes);
    a: do try {
      if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
        case SuspendedOnError:
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnError);
          break;
        case SuspendedOnData:
          if (isThenableResolved(memoizedUpdaters)) {
            workInProgressSuspendedReason = NotSuspended;
            workInProgressThrownValue = null;
            replaySuspendedUnitOfWork(lanes);
            break;
          }
          lanes = function () {
            workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root && (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
            ensureRootIsScheduled(root);
          };
          memoizedUpdaters.then(lanes, lanes);
          break a;
        case SuspendedOnImmediate:
          workInProgressSuspendedReason = SuspendedAndReadyToContinue;
          break a;
        case SuspendedOnInstance:
          workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
          break a;
        case SuspendedAndReadyToContinue:
          isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedAndReadyToContinue));
          break;
        case SuspendedOnInstanceAndReadyToContinue:
          var resource = null;
          switch (workInProgress.tag) {
            case 26:
              resource = workInProgress.memoizedState;
            case 5:
            case 27:
              var hostFiber = workInProgress;
              if (resource ? preloadResource(resource) : 1) {
                workInProgressSuspendedReason = NotSuspended;
                workInProgressThrownValue = null;
                var sibling = hostFiber.sibling;
                if (null !== sibling) workInProgress = sibling;else {
                  var returnFiber = hostFiber.return;
                  null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                }
                break b;
              }
              break;
            default:
              console.error("Unexpected type of fiber triggered a suspensey commit. This is a bug in React.");
          }
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnInstanceAndReadyToContinue);
          break;
        case SuspendedOnDeprecatedThrowPromise:
          workInProgressSuspendedReason = NotSuspended;
          workInProgressThrownValue = null;
          throwAndUnwindWorkLoop(root, lanes, memoizedUpdaters, SuspendedOnDeprecatedThrowPromise);
          break;
        case SuspendedOnHydration:
          resetWorkInProgressStack();
          workInProgressRootExitStatus = RootDidNotComplete;
          break a;
        default:
          throw Error("Unexpected SuspendedReason. This is a bug in React.");
      }
      null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrent();
      break;
    } catch (thrownValue$9) {
      handleThrow(root, thrownValue$9);
    } while (1);
    resetContextDependencies();
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    executionContext = prevExecutionContext;
    if (null !== workInProgress) return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
    markRenderStopped();
    workInProgressRoot = null;
    workInProgressRootRenderLanes = 0;
    finishQueueingConcurrentUpdates();
    return workInProgressRootExitStatus;
  }
  function workLoopConcurrent() {
    for (; null !== workInProgress && !shouldYield();) performUnitOfWork(workInProgress);
  }
  function performUnitOfWork(unitOfWork) {
    var current = unitOfWork.alternate;
    (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current = runWithFiberInDEV(unitOfWork, beginWork, current, unitOfWork, entangledRenderLanes);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === current ? completeUnitOfWork(unitOfWork) : workInProgress = current;
  }
  function replaySuspendedUnitOfWork(unitOfWork) {
    var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function replayBeginWork(unitOfWork) {
    var current = unitOfWork.alternate,
      isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
    isProfilingMode && startProfilerTimer(unitOfWork);
    switch (unitOfWork.tag) {
      case 15:
      case 0:
        current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type, void 0, workInProgressRootRenderLanes);
        break;
      case 11:
        current = replayFunctionComponent(current, unitOfWork, unitOfWork.pendingProps, unitOfWork.type.render, unitOfWork.ref, workInProgressRootRenderLanes);
        break;
      case 5:
        resetHooksOnUnwind(unitOfWork);
      default:
        unwindInterruptedWork(current, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current = beginWork(current, unitOfWork, entangledRenderLanes);
    }
    isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
    return current;
  }
  function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, suspendedReason) {
    resetContextDependencies();
    resetHooksOnUnwind(unitOfWork);
    thenableState$1 = null;
    thenableIndexCounter$1 = 0;
    var returnFiber = unitOfWork.return;
    try {
      if (throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes)) {
        workInProgressRootExitStatus = RootFatalErrored;
        logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
        workInProgress = null;
        return;
      }
    } catch (error) {
      if (null !== returnFiber) throw workInProgress = returnFiber, error;
      workInProgressRootExitStatus = RootFatalErrored;
      logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));
      workInProgress = null;
      return;
    }
    if (unitOfWork.flags & 32768) {
      if (isHydrating || suspendedReason === SuspendedOnError) root = !0;else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912)) root = !1;else if (workInProgressRootDidSkipSuspendedSiblings = root = !0, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise) suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
      unwindUnitOfWork(unitOfWork, root);
    } else completeUnitOfWork(unitOfWork);
  }
  function completeUnitOfWork(unitOfWork) {
    var completedWork = unitOfWork;
    do {
      if (0 !== (completedWork.flags & 32768)) {
        unwindUnitOfWork(completedWork, workInProgressRootDidSkipSuspendedSiblings);
        return;
      }
      var current = completedWork.alternate;
      unitOfWork = completedWork.return;
      startProfilerTimer(completedWork);
      current = runWithFiberInDEV(completedWork, completeWork, current, completedWork, entangledRenderLanes);
      (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
      if (null !== current) {
        workInProgress = current;
        return;
      }
      completedWork = completedWork.sibling;
      if (null !== completedWork) {
        workInProgress = completedWork;
        return;
      }
      workInProgress = completedWork = unitOfWork;
    } while (null !== completedWork);
    workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
  }
  function unwindUnitOfWork(unitOfWork, skipSiblings) {
    do {
      var next = unwindWork(unitOfWork.alternate, unitOfWork);
      if (null !== next) {
        next.flags &= 32767;
        workInProgress = next;
        return;
      }
      if ((unitOfWork.mode & ProfileMode) !== NoMode) {
        stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
        next = unitOfWork.actualDuration;
        for (var child = unitOfWork.child; null !== child;) next += child.actualDuration, child = child.sibling;
        unitOfWork.actualDuration = next;
      }
      next = unitOfWork.return;
      null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
      if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
        workInProgress = unitOfWork;
        return;
      }
      workInProgress = unitOfWork = next;
    } while (null !== unitOfWork);
    workInProgressRootExitStatus = RootDidNotComplete;
    workInProgress = null;
  }
  function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
    var prevTransition = ReactSharedInternals.T,
      previousUpdateLanePriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = DiscreteEventPriority, ReactSharedInternals.T = null, commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane, updatedLanes, suspendedRetryLanes, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime);
    } finally {
      ReactSharedInternals.T = prevTransition, ReactDOMSharedInternals.p = previousUpdateLanePriority;
    }
  }
  function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane, updatedLanes, suspendedRetryLanes) {
    do flushPassiveEffects(); while (null !== rootWithPendingPassiveEffects);
    ReactStrictModeWarnings.flushLegacyContextWarning();
    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Should not already be working.");
    var finishedWork = root.finishedWork;
    didIncludeRenderPhaseUpdate = root.finishedLanes;
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(didIncludeRenderPhaseUpdate);
    if (null === finishedWork) return markCommitStopped(), null;
    0 === didIncludeRenderPhaseUpdate && console.error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
    root.finishedWork = null;
    root.finishedLanes = 0;
    if (finishedWork === root.current) throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
    root.callbackNode = null;
    root.callbackPriority = 0;
    root.cancelPendingCommit = null;
    var remainingLanes = finishedWork.lanes | finishedWork.childLanes;
    remainingLanes |= concurrentlyUpdatedLanes;
    markRootFinished(root, didIncludeRenderPhaseUpdate, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes);
    root === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
    0 === (finishedWork.subtreeFlags & 10256) && 0 === (finishedWork.flags & 10256) || rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveEffectsRemainingLanes = remainingLanes, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority$1, function () {
      flushPassiveEffects(!0);
      return null;
    }));
    commitStartTime = now();
    transitions = 0 !== (finishedWork.flags & 15990);
    0 !== (finishedWork.subtreeFlags & 15990) || transitions ? (transitions = ReactSharedInternals.T, ReactSharedInternals.T = null, spawnedLane = ReactDOMSharedInternals.p, ReactDOMSharedInternals.p = DiscreteEventPriority, updatedLanes = executionContext, executionContext |= CommitContext, commitBeforeMutationEffects(root, finishedWork), commitMutationEffects(root, finishedWork, didIncludeRenderPhaseUpdate), restoreSelection(selectionInformation, root.containerInfo), _enabled = !!eventsEnabled, selectionInformation = eventsEnabled = null, root.current = finishedWork, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(didIncludeRenderPhaseUpdate), commitLayoutEffects(finishedWork, root, didIncludeRenderPhaseUpdate), null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped(), requestPaint(), executionContext = updatedLanes, ReactDOMSharedInternals.p = spawnedLane, ReactSharedInternals.T = transitions) : root.current = finishedWork;
    (transitions = rootDoesHavePassiveEffects) ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root, pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate) : (releaseRootPooledCache(root, remainingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
    remainingLanes = root.pendingLanes;
    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
    transitions || commitDoubleInvokeEffectsInDEV(root);
    onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);
    isDevToolsPresent && root.memoizedUpdaters.clear();
    onCommitRoot();
    ensureRootIsScheduled(root);
    if (null !== recoverableErrors) for (renderPriorityLevel = root.onRecoverableError, finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) remainingLanes = recoverableErrors[finishedWork], transitions = makeErrorInfo(remainingLanes.stack), runWithFiberInDEV(remainingLanes.source, renderPriorityLevel, remainingLanes.value, transitions);
    0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();
    remainingLanes = root.pendingLanes;
    0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = !0, root === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root)) : nestedUpdateCount = 0;
    flushSyncWorkAcrossRoots_impl(0, !1);
    markCommitStopped();
    return null;
  }
  function makeErrorInfo(componentStack) {
    componentStack = {
      componentStack: componentStack
    };
    Object.defineProperty(componentStack, "digest", {
      get: function () {
        console.error('You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.');
      }
    });
    return componentStack;
  }
  function releaseRootPooledCache(root, remainingLanes) {
    0 === (root.pooledCacheLanes &= remainingLanes) && (remainingLanes = root.pooledCache, null != remainingLanes && (root.pooledCache = null, releaseCache(remainingLanes)));
  }
  function flushPassiveEffects() {
    if (null !== rootWithPendingPassiveEffects) {
      var root = rootWithPendingPassiveEffects,
        remainingLanes = pendingPassiveEffectsRemainingLanes;
      pendingPassiveEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),
        priority = 0 === DefaultEventPriority || DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
      renderPriority = ReactSharedInternals.T;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = priority;
        ReactSharedInternals.T = null;
        if (null === rootWithPendingPassiveEffects) var JSCompiler_inline_result = !1;else {
          priority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = rootWithPendingPassiveEffects,
            lanes = pendingPassiveEffectsLanes;
          rootWithPendingPassiveEffects = null;
          pendingPassiveEffectsLanes = 0;
          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) throw Error("Cannot flush passive effects while already rendering.");
          isFlushingPassiveEffects = !0;
          didScheduleUpdateDuringPassiveEffects = !1;
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(root$jscomp$0, root$jscomp$0.current, lanes, priority);
          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
          commitDoubleInvokeEffectsInDEV(root$jscomp$0);
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, !1);
          didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
          didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = !1;
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot) try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {
            hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
          }
          var stateNode = root$jscomp$0.current.stateNode;
          stateNode.effectDuration = 0;
          stateNode.passiveEffectDuration = 0;
          JSCompiler_inline_result = !0;
        }
        return JSCompiler_inline_result;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root, remainingLanes);
      }
    }
    return !1;
  }
  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
    rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
    null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
  }
  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
    isRunningInsertionEffect = !1;
    if (3 === sourceFiber.tag) captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);else {
      for (; null !== nearestMountedAncestor;) {
        if (3 === nearestMountedAncestor.tag) {
          captureCommitPhaseErrorOnRoot(nearestMountedAncestor, sourceFiber, error);
          return;
        }
        if (1 === nearestMountedAncestor.tag) {
          var instance = nearestMountedAncestor.stateNode;
          if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
            error = createClassErrorUpdate(2);
            instance = enqueueUpdate(nearestMountedAncestor, error, 2);
            null !== instance && (initializeClassErrorUpdate(error, instance, nearestMountedAncestor, sourceFiber), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
            return;
          }
        }
        nearestMountedAncestor = nearestMountedAncestor.return;
      }
      console.error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error);
    }
  }
  function attachPingListener(root, wakeable, lanes) {
    var pingCache = root.pingCache;
    if (null === pingCache) {
      pingCache = root.pingCache = new PossiblyWeakMap();
      var threadIDs = new Set();
      pingCache.set(wakeable, threadIDs);
    } else threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = new Set(), pingCache.set(wakeable, threadIDs));
    threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = !0, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root, lanes), wakeable.then(pingCache, pingCache));
  }
  function pingSuspendedRoot(root, wakeable, pingedLanes) {
    var pingCache = root.pingCache;
    null !== pingCache && pingCache.delete(wakeable);
    root.pingedLanes |= root.suspendedLanes & pingedLanes;
    root.warmLanes &= ~pingedLanes;
    isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act");
    workInProgressRoot === root && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
    ensureRootIsScheduled(root);
  }
  function retryTimedOutBoundary(boundaryFiber, retryLane) {
    0 === retryLane && (retryLane = claimNextRetryLane());
    boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
    null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
  }
  function retryDehydratedSuspenseBoundary(boundaryFiber) {
    var suspenseState = boundaryFiber.memoizedState,
      retryLane = 0;
    null !== suspenseState && (retryLane = suspenseState.retryLane);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function resolveRetryWakeable(boundaryFiber, wakeable) {
    var retryLane = 0;
    switch (boundaryFiber.tag) {
      case 13:
        var retryCache = boundaryFiber.stateNode;
        var suspenseState = boundaryFiber.memoizedState;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        break;
      case 19:
        retryCache = boundaryFiber.stateNode;
        break;
      case 22:
        retryCache = boundaryFiber.stateNode._retryCache;
        break;
      default:
        throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
    }
    null !== retryCache && retryCache.delete(wakeable);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
    if (0 !== (parentFiber.subtreeFlags & 33562624)) for (parentFiber = parentFiber.child; null !== parentFiber;) {
      var root = root$jscomp$0,
        fiber = parentFiber,
        isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
      isStrictModeFiber = isInStrictMode || isStrictModeFiber;
      22 !== fiber.tag ? fiber.flags & 33554432 ? isStrictModeFiber && runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isStrictModeFiber) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(fiber, doubleInvokeEffectsOnFiber, root, fiber) : fiber.subtreeFlags & 33554432 && runWithFiberInDEV(fiber, recursivelyTraverseAndDoubleInvokeEffectsInDEV, root, fiber, isStrictModeFiber));
      parentFiber = parentFiber.sibling;
    }
  }
  function doubleInvokeEffectsOnFiber(root, fiber) {
    var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !0;
    setIsStrictModeForDevtools(!0);
    try {
      disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root, fiber.alternate, fiber, !1), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root, fiber, 0, null, !1);
    } finally {
      setIsStrictModeForDevtools(!1);
    }
  }
  function commitDoubleInvokeEffectsInDEV(root) {
    var doubleInvokeEffects = !0;
    root.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = !1);
    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);
  }
  function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
    if ((executionContext & RenderContext) === NoContext) {
      var tag = fiber.tag;
      if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
        tag = getComponentNameFromFiber(fiber) || "ReactComponent";
        if (null !== didWarnStateUpdateForNotYetMountedComponent) {
          if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
          didWarnStateUpdateForNotYetMountedComponent.add(tag);
        } else didWarnStateUpdateForNotYetMountedComponent = new Set([tag]);
        runWithFiberInDEV(fiber, function () {
          console.error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        });
      }
    }
  }
  function restorePendingUpdaters(root, lanes) {
    isDevToolsPresent && root.memoizedUpdaters.forEach(function (schedulingFiber) {
      addFiberToLanesMap(root, schedulingFiber, lanes);
    });
  }
  function scheduleCallback$1(priorityLevel, callback) {
    var actQueue = ReactSharedInternals.actQueue;
    return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
  }
  function warnIfUpdatesNotWrappedWithActDEV(fiber) {
    isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function () {
      console.error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
    });
  }
  function ensureRootIsScheduled(root) {
    root !== lastScheduledRoot && null === root.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root : lastScheduledRoot = lastScheduledRoot.next = root);
    mightHavePendingSyncWork = !0;
    null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = !0, scheduleImmediateTask(processRootScheduleInMicrotask)) : didScheduleMicrotask || (didScheduleMicrotask = !0, scheduleImmediateTask(processRootScheduleInMicrotask));
  }
  function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
    if (!isFlushingWork && mightHavePendingSyncWork) {
      isFlushingWork = !0;
      do {
        var didPerformSomeWork = !1;
        for (var root = firstScheduledRoot; null !== root;) {
          if (!onlyLegacy) if (0 !== syncTransitionLanes) {
            var pendingLanes = root.pendingLanes;
            if (0 === pendingLanes) var nextLanes = 0;else {
              var suspendedLanes = root.suspendedLanes,
                pingedLanes = root.pingedLanes;
              nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
              nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
              nextLanes = nextLanes & 201326677 ? nextLanes & 201326677 | 1 : nextLanes ? nextLanes | 2 : 0;
            }
            0 !== nextLanes && (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
          } else nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(root, root === workInProgressRoot ? nextLanes : 0), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root, nextLanes) || (didPerformSomeWork = !0, performSyncWorkOnRoot(root, nextLanes));
          root = root.next;
        }
      } while (didPerformSomeWork);
      isFlushingWork = !1;
    }
  }
  function processRootScheduleInMicrotask() {
    mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = !1;
    var syncTransitionLanes = 0;
    0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
    for (var currentTime = now$1(), prev = null, root = firstScheduledRoot; null !== root;) {
      var next = root.next,
        nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);
      if (0 === nextLanes) root.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);else if (prev = root, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3)) mightHavePendingSyncWork = !0;
      root = next;
    }
    flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);
  }
  function scheduleTaskForRootDuringMicrotask(root, currentTime) {
    for (var suspendedLanes = root.suspendedLanes, pingedLanes = root.pingedLanes, expirationTimes = root.expirationTimes, lanes = root.pendingLanes & -62914561; 0 < lanes;) {
      var index = 31 - clz32(lanes),
        lane = 1 << index,
        expirationTime = expirationTimes[index];
      if (-1 === expirationTime) {
        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes)) expirationTimes[index] = computeExpirationTime(lane, currentTime);
      } else expirationTime <= currentTime && (root.expiredLanes |= lane);
      lanes &= ~lane;
    }
    currentTime = workInProgressRoot;
    suspendedLanes = workInProgressRootRenderLanes;
    suspendedLanes = getNextLanes(root, root === currentTime ? suspendedLanes : 0);
    pingedLanes = root.callbackNode;
    if (0 === suspendedLanes || root === currentTime && workInProgressSuspendedReason === SuspendedOnData || null !== root.cancelPendingCommit) return null !== pingedLanes && cancelCallback(pingedLanes), root.callbackNode = null, root.callbackPriority = 0;
    if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root, suspendedLanes)) {
      currentTime = suspendedLanes & -suspendedLanes;
      if (currentTime !== root.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode) cancelCallback(pingedLanes);else return currentTime;
      switch (lanesToEventPriority(suspendedLanes)) {
        case DiscreteEventPriority:
        case ContinuousEventPriority:
          suspendedLanes = UserBlockingPriority;
          break;
        case DefaultEventPriority:
          suspendedLanes = NormalPriority$1;
          break;
        case IdleEventPriority:
          suspendedLanes = IdlePriority;
          break;
        default:
          suspendedLanes = NormalPriority$1;
      }
      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);
      null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
      root.callbackPriority = currentTime;
      root.callbackNode = suspendedLanes;
      return currentTime;
    }
    null !== pingedLanes && cancelCallback(pingedLanes);
    root.callbackPriority = 2;
    root.callbackNode = null;
    return 2;
  }
  function performWorkOnRootViaSchedulerTask(root, didTimeout) {
    nestedUpdateScheduled = currentUpdateIsNested = !1;
    var originalCallbackNode = root.callbackNode;
    if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode) return null;
    var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
    workInProgressRootRenderLanes$jscomp$0 = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0);
    if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
    performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);
    scheduleTaskForRootDuringMicrotask(root, now$1());
    return null != root.callbackNode && root.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root) : null;
  }
  function performSyncWorkOnRoot(root, lanes) {
    if (flushPassiveEffects()) return null;
    currentUpdateIsNested = nestedUpdateScheduled;
    nestedUpdateScheduled = !1;
    performWorkOnRoot(root, lanes, !0);
  }
  function cancelCallback(callbackNode) {
    callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
  }
  function scheduleImmediateTask(cb) {
    null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function () {
      cb();
      return null;
    });
    scheduleMicrotask(function () {
      (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(ImmediatePriority, cb) : cb();
    });
  }
  function requestTransitionLane() {
    0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
    return currentEventTransitionLane;
  }
  function coerceFormActionProp(actionProp) {
    if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp) return null;
    if ("function" === typeof actionProp) return actionProp;
    checkAttributeStringCoercion(actionProp, "action");
    return sanitizeURL("" + actionProp);
  }
  function createFormDataWithSubmitter(form, submitter) {
    var temp = submitter.ownerDocument.createElement("input");
    temp.name = submitter.name;
    temp.value = submitter.value;
    form.id && temp.setAttribute("form", form.id);
    submitter.parentNode.insertBefore(temp, submitter);
    form = new FormData(form);
    temp.parentNode.removeChild(temp);
    return form;
  }
  function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
    if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
      var action = coerceFormActionProp((nativeEventTarget[internalPropsKey] || null).action),
        submitter = nativeEvent.submitter;
      submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
      var event = new SyntheticEvent("action", "action", null, nativeEvent, nativeEventTarget);
      dispatchQueue.push({
        event: event,
        listeners: [{
          instance: null,
          listener: function () {
            if (nativeEvent.defaultPrevented) {
              if (0 !== currentEventTransitionLane) {
                var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget),
                  pendingState = {
                    pending: !0,
                    data: formData,
                    method: nativeEventTarget.method,
                    action: action
                  };
                Object.freeze(pendingState);
                startHostTransition(maybeTargetInst, pendingState, null, formData);
              }
            } else "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), pendingState = {
              pending: !0,
              data: formData,
              method: nativeEventTarget.method,
              action: action
            }, Object.freeze(pendingState), startHostTransition(maybeTargetInst, pendingState, action, formData));
          },
          currentTarget: nativeEventTarget
        }]
      });
    }
  }
  function processDispatchQueue(dispatchQueue, eventSystemFlags) {
    eventSystemFlags = 0 !== (eventSystemFlags & 4);
    for (var i = 0; i < dispatchQueue.length; i++) {
      var _dispatchQueue$i = dispatchQueue[i];
      a: {
        var previousInstance = void 0,
          event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        if (eventSystemFlags) for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],
            instance = _dispatchListeners$i.instance,
            currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped()) break a;
          previousInstance = event;
          previousInstance.currentTarget = currentTarget;
          try {
            _dispatchListeners$i(previousInstance);
          } catch (error) {
            reportGlobalError(error);
          }
          previousInstance.currentTarget = null;
          previousInstance = instance;
        } else for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
          instance = _dispatchListeners$i.instance;
          currentTarget = _dispatchListeners$i.currentTarget;
          _dispatchListeners$i = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped()) break a;
          previousInstance = event;
          previousInstance.currentTarget = currentTarget;
          try {
            _dispatchListeners$i(previousInstance);
          } catch (error) {
            reportGlobalError(error);
          }
          previousInstance.currentTarget = null;
          previousInstance = instance;
        }
      }
    }
  }
  function listenToNonDelegatedEvent(domEventName, targetElement) {
    nonDelegatedEvents.has(domEventName) || console.error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
    var listenerSet = targetElement[internalEventHandlersKey];
    void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = new Set());
    var listenerSetKey = domEventName + "__bubble";
    listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, !1), listenerSet.add(listenerSetKey));
  }
  function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
    nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
    var eventSystemFlags = 0;
    isCapturePhaseListener && (eventSystemFlags |= 4);
    addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
  }
  function listenToAllSupportedEvents(rootContainerElement) {
    if (!rootContainerElement[listeningMarker]) {
      rootContainerElement[listeningMarker] = !0;
      allNativeEvents.forEach(function (domEventName) {
        "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));
      });
      var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, ownerDocument));
    }
  }
  function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
    switch (getEventPriority(domEventName)) {
      case DiscreteEventPriority:
        var listenerWrapper = dispatchDiscreteEvent;
        break;
      case ContinuousEventPriority:
        listenerWrapper = dispatchContinuousEvent;
        break;
      default:
        listenerWrapper = dispatchEvent;
    }
    eventSystemFlags = listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
    listenerWrapper = void 0;
    !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = !0);
    isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      capture: !0,
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !0) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);
  }
  function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
    var ancestorInst = targetInst$jscomp$0;
    if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0) a: for (;;) {
      if (null === targetInst$jscomp$0) return;
      var nodeTag = targetInst$jscomp$0.tag;
      if (3 === nodeTag || 4 === nodeTag) {
        var container = targetInst$jscomp$0.stateNode.containerInfo;
        if (container === targetContainer || 8 === container.nodeType && container.parentNode === targetContainer) break;
        if (4 === nodeTag) for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag;) {
          var grandTag = nodeTag.tag;
          if (3 === grandTag || 4 === grandTag) if (grandTag = nodeTag.stateNode.containerInfo, grandTag === targetContainer || 8 === grandTag.nodeType && grandTag.parentNode === targetContainer) return;
          nodeTag = nodeTag.return;
        }
        for (; null !== container;) {
          nodeTag = getClosestInstanceFromNode(container);
          if (null === nodeTag) return;
          grandTag = nodeTag.tag;
          if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
            targetInst$jscomp$0 = ancestorInst = nodeTag;
            continue a;
          }
          container = container.parentNode;
        }
      }
      targetInst$jscomp$0 = targetInst$jscomp$0.return;
    }
    batchedUpdates$1(function () {
      var targetInst = ancestorInst,
        nativeEventTarget = getEventTarget(nativeEvent),
        dispatchQueue = [];
      a: {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (void 0 !== reactName) {
          var SyntheticEventCtor = SyntheticEvent,
            reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (0 === getEventCharCode(nativeEvent)) break a;
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (2 === nativeEvent.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
            case "scrollend":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
            case "toggle":
            case "beforetoggle":
              SyntheticEventCtor = SyntheticToggleEvent;
          }
          var inCapturePhase = 0 !== (eventSystemFlags & 4),
            accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName),
            reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
          inCapturePhase = [];
          for (var instance = targetInst, lastHostComponent; null !== instance;) {
            var _instance2 = instance;
            lastHostComponent = _instance2.stateNode;
            _instance2 = _instance2.tag;
            5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(createDispatchListener(instance, _instance2, lastHostComponent)));
            if (accumulateTargetOnly) break;
            instance = instance.return;
          }
          0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
            event: reactName,
            listeners: inCapturePhase
          }));
        }
      }
      if (0 === (eventSystemFlags & 7)) {
        a: {
          reactName = "mouseover" === domEventName || "pointerover" === domEventName;
          SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
          if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey])) break a;
          if (SyntheticEventCtor || reactName) {
            reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
            if (SyntheticEventCtor) {
              if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase)) reactEventType = null;
            } else SyntheticEventCtor = null, reactEventType = targetInst;
            if (SyntheticEventCtor !== reactEventType) {
              inCapturePhase = SyntheticMouseEvent;
              _instance2 = "onMouseLeave";
              reactEventName = "onMouseEnter";
              instance = "mouse";
              if ("pointerout" === domEventName || "pointerover" === domEventName) inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
              accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
              lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
              reactName = new inCapturePhase(_instance2, instance + "leave", SyntheticEventCtor, nativeEvent, nativeEventTarget);
              reactName.target = accumulateTargetOnly;
              reactName.relatedTarget = lastHostComponent;
              _instance2 = null;
              getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(reactEventName, instance + "enter", reactEventType, nativeEvent, nativeEventTarget), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
              accumulateTargetOnly = _instance2;
              if (SyntheticEventCtor && reactEventType) b: {
                inCapturePhase = SyntheticEventCtor;
                reactEventName = reactEventType;
                instance = 0;
                for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent)) instance++;
                lastHostComponent = 0;
                for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2)) lastHostComponent++;
                for (; 0 < instance - lastHostComponent;) inCapturePhase = getParent(inCapturePhase), instance--;
                for (; 0 < lastHostComponent - instance;) reactEventName = getParent(reactEventName), lastHostComponent--;
                for (; instance--;) {
                  if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate) break b;
                  inCapturePhase = getParent(inCapturePhase);
                  reactEventName = getParent(reactEventName);
                }
                inCapturePhase = null;
              } else inCapturePhase = null;
              null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(dispatchQueue, reactName, SyntheticEventCtor, inCapturePhase, !1);
              null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(dispatchQueue, accumulateTargetOnly, reactEventType, inCapturePhase, !0);
            }
          }
        }
        a: {
          reactName = targetInst ? getNodeFromInstance(targetInst) : window;
          SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
          if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type) var getTargetInstFunc = getTargetInstForChangeEvent;else if (isTextInputElement(reactName)) {
            if (isInputEventSupported) getTargetInstFunc = getTargetInstForInputOrChangeEvent;else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              var handleEventFunc = handleEventsForInputEventPolyfill;
            }
          } else SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
          if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
            createAndAccumulateChangeEvent(dispatchQueue, getTargetInstFunc, nativeEvent, nativeEventTarget);
            break a;
          }
          handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
          "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
        }
        handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable) activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
            break;
          case "focusout":
            lastSelection = activeElementInst = activeElement = null;
            break;
          case "mousedown":
            mouseDown = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = !1;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) break;
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
        var fallbackData;
        if (canUseCompositionEvent) b: {
          switch (domEventName) {
            case "compositionstart":
              var eventType = "onCompositionStart";
              break b;
            case "compositionend":
              eventType = "onCompositionEnd";
              break b;
            case "compositionupdate":
              eventType = "onCompositionUpdate";
              break b;
          }
          eventType = void 0;
        } else isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
        eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = !0)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget), dispatchQueue.push({
          event: eventType,
          listeners: handleEventFunc
        }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
        if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent)) eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget), dispatchQueue.push({
          event: handleEventFunc,
          listeners: eventType
        }), handleEventFunc.data = fallbackData);
        extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      }
      processDispatchQueue(dispatchQueue, eventSystemFlags);
    });
  }
  function createDispatchListener(instance, listener, currentTarget) {
    return {
      instance: instance,
      listener: listener,
      currentTarget: currentTarget
    };
  }
  function accumulateTwoPhaseListeners(targetFiber, reactName) {
    for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber;) {
      var _instance3 = targetFiber,
        stateNode = _instance3.stateNode;
      _instance3 = _instance3.tag;
      5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(createDispatchListener(targetFiber, _instance3, stateNode)), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(createDispatchListener(targetFiber, _instance3, stateNode)));
      targetFiber = targetFiber.return;
    }
    return listeners;
  }
  function getParent(inst) {
    if (null === inst) return null;
    do inst = inst.return; while (inst && 5 !== inst.tag && 27 !== inst.tag);
    return inst ? inst : null;
  }
  function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
    for (var registrationName = event._reactName, listeners = []; null !== target && target !== common;) {
      var _instance4 = target,
        alternate = _instance4.alternate,
        stateNode = _instance4.stateNode;
      _instance4 = _instance4.tag;
      if (null !== alternate && alternate === common) break;
      5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(createDispatchListener(target, stateNode, alternate))) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(createDispatchListener(target, stateNode, alternate))));
      target = target.return;
    }
    0 !== listeners.length && dispatchQueue.push({
      event: event,
      listeners: listeners
    });
  }
  function validatePropertiesInDevelopment(type, props) {
    validateProperties$2(type, props);
    "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = !0, "select" === type && props.multiple ? console.error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : console.error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
    var eventRegistry = {
      registrationNameDependencies: registrationNameDependencies,
      possibleRegistrationNames: possibleRegistrationNames
    };
    isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
    props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
  }
  function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
    serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
  }
  function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
    attributeNames.forEach(function (attributeName) {
      serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
    });
  }
  function warnForInvalidEventListener(registrationName, listener) {
    !1 === listener ? console.error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : console.error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
  }
  function normalizeHTML(parent, html) {
    parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName) : parent.ownerDocument.createElement(parent.tagName);
    parent.innerHTML = html;
    return parent.innerHTML;
  }
  function normalizeMarkupForTextOrAttribute(markup) {
    willCoercionThrow(markup) && (console.error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.", typeName(markup)), testStringCoercion(markup));
    return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
  }
  function checkForUnmatchedText(serverText, clientText) {
    clientText = normalizeMarkupForTextOrAttribute(clientText);
    return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;
  }
  function noop$1() {}
  function setProp(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "children":
        if ("string" === typeof value) validateTextNesting(value, tag), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);else if ("number" === typeof value || "bigint" === typeof value) validateTextNesting("" + value, tag), "body" !== tag && setTextContent(domElement, "" + value);
        break;
      case "className":
        setValueForKnownAttribute(domElement, "class", value);
        break;
      case "tabIndex":
        setValueForKnownAttribute(domElement, "tabindex", value);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        setValueForKnownAttribute(domElement, key, value);
        break;
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "data":
        if ("object" !== tag) {
          setValueForKnownAttribute(domElement, "data", value);
          break;
        }
      case "src":
      case "href":
        if ("" === value && ("a" !== tag || "href" !== key)) {
          "src" === key ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', key, key);
          domElement.removeAttribute(key);
          break;
        }
        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        checkAttributeStringCoercion(value, key);
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "action":
      case "formAction":
        null != value && ("form" === tag ? "formAction" === key ? console.error("You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>.") : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden.")), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."))) : "input" === tag || "button" === tag ? "action" === key ? console.error("You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>.") : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = !0, console.error('Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.')), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = !0, console.error("Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden.")), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = !0, console.error("Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."))) : (didWarnFormActionType = !0, console.error('A button can only specify a formAction along with type="submit" or no type.')) : (didWarnFormActionType = !0, console.error('An input can only specify a formAction along with type="submit" or type="image".')) : "action" === key ? console.error("You can only pass the action prop to <form>.") : console.error("You can only pass the formAction prop to <input> or <button>."));
        if ("function" === typeof value) {
          domElement.setAttribute(key, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
          break;
        } else "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(domElement, tag, "formEncType", props.formEncType, props, null), setProp(domElement, tag, "formMethod", props.formMethod, props, null), setProp(domElement, tag, "formTarget", props.formTarget, props, null)) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
        if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        checkAttributeStringCoercion(value, key);
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "onClick":
        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
        break;
      case "onScroll":
        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
        break;
      case "onScrollEnd":
        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            domElement.innerHTML = key;
          }
        }
        break;
      case "multiple":
        domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "muted":
        domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
          domElement.removeAttribute("xlink:href");
          break;
        }
        checkAttributeStringCoercion(value, key);
        key = sanitizeURL("" + value);
        domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
        break;
      case "inert":
        "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", key));
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
        break;
      case "capture":
      case "download":
        !0 === value ? domElement.setAttribute(key, "") : !1 !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
        break;
      case "rowSpan":
      case "start":
        null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
        break;
      case "popover":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        setValueForAttribute(domElement, "popover", value);
        break;
      case "xlinkActuate":
        setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:actuate", value);
        break;
      case "xlinkArcrole":
        setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:arcrole", value);
        break;
      case "xlinkRole":
        setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:role", value);
        break;
      case "xlinkShow":
        setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:show", value);
        break;
      case "xlinkTitle":
        setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:title", value);
        break;
      case "xlinkType":
        setValueForNamespacedAttribute(domElement, xlinkNamespace, "xlink:type", value);
        break;
      case "xmlBase":
        setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:base", value);
        break;
      case "xmlLang":
        setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:lang", value);
        break;
      case "xmlSpace":
        setValueForNamespacedAttribute(domElement, xmlNamespace, "xml:space", value);
        break;
      case "is":
        null != prevValue && console.error('Cannot update the "is" prop after it has been initialized.');
        setValueForAttribute(domElement, "is", value);
        break;
      case "innerText":
      case "textContent":
        break;
      case "popoverTarget":
        didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = !0, console.error("The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.", value));
      default:
        !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
    }
  }
  function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value)) throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information.");
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
            domElement.innerHTML = key;
          }
        }
        break;
      case "children":
        "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
        break;
      case "onScroll":
        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
        break;
      case "onScrollEnd":
        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
        break;
      case "onClick":
        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (registrationNameDependencies.hasOwnProperty(key)) null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);else a: {
          if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
            "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
            domElement.addEventListener(tag, value, props);
            break a;
          }
          key in domElement ? domElement[key] = value : !0 === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
        }
    }
  }
  function setInitialProperties(domElement, tag, props) {
    validatePropertiesInDevelopment(tag, props);
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        var hasSrc = !1,
          hasSrcSet = !1,
          propKey;
        for (propKey in props) if (props.hasOwnProperty(propKey)) {
          var propValue = props[propKey];
          if (null != propValue) switch (propKey) {
            case "src":
              hasSrc = !0;
              break;
            case "srcSet":
              hasSrcSet = !0;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            default:
              setProp(domElement, tag, propKey, propValue, props, null);
          }
        }
        hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
        hasSrc && setProp(domElement, tag, "src", props.src, props, null);
        return;
      case "input":
        checkControlledValueProps("input", props);
        listenToNonDelegatedEvent("invalid", domElement);
        var defaultValue = propKey = propValue = hasSrcSet = null,
          checked = null,
          defaultChecked = null;
        for (hasSrc in props) if (props.hasOwnProperty(hasSrc)) {
          var _propValue = props[hasSrc];
          if (null != _propValue) switch (hasSrc) {
            case "name":
              hasSrcSet = _propValue;
              break;
            case "type":
              propValue = _propValue;
              break;
            case "checked":
              checked = _propValue;
              break;
            case "defaultChecked":
              defaultChecked = _propValue;
              break;
            case "value":
              propKey = _propValue;
              break;
            case "defaultValue":
              defaultValue = _propValue;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != _propValue) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              break;
            default:
              setProp(domElement, tag, hasSrc, _propValue, props, null);
          }
        }
        validateInputProps(domElement, props);
        initInput(domElement, propKey, defaultValue, checked, defaultChecked, propValue, hasSrcSet, !1);
        track(domElement);
        return;
      case "select":
        checkControlledValueProps("select", props);
        listenToNonDelegatedEvent("invalid", domElement);
        hasSrc = propValue = propKey = null;
        for (hasSrcSet in props) if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue)) switch (hasSrcSet) {
          case "value":
            propKey = defaultValue;
            break;
          case "defaultValue":
            propValue = defaultValue;
            break;
          case "multiple":
            hasSrc = defaultValue;
          default:
            setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
        }
        validateSelectProps(domElement, props);
        tag = propKey;
        props = propValue;
        domElement.multiple = !!hasSrc;
        null != tag ? updateOptions(domElement, !!hasSrc, tag, !1) : null != props && updateOptions(domElement, !!hasSrc, props, !0);
        return;
      case "textarea":
        checkControlledValueProps("textarea", props);
        listenToNonDelegatedEvent("invalid", domElement);
        propKey = hasSrcSet = hasSrc = null;
        for (propValue in props) if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue)) switch (propValue) {
          case "value":
            hasSrc = defaultValue;
            break;
          case "defaultValue":
            hasSrcSet = defaultValue;
            break;
          case "children":
            propKey = defaultValue;
            break;
          case "dangerouslySetInnerHTML":
            if (null != defaultValue) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            break;
          default:
            setProp(domElement, tag, propValue, defaultValue, props, null);
        }
        validateTextareaProps(domElement, props);
        initTextarea(domElement, hasSrc, hasSrcSet, propKey);
        track(domElement);
        return;
      case "option":
        validateOptionProps(domElement, props);
        for (checked in props) if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc)) switch (checked) {
          case "selected":
            domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
            break;
          default:
            setProp(domElement, tag, checked, hasSrc, props, null);
        }
        return;
      case "dialog":
        listenToNonDelegatedEvent("cancel", domElement);
        listenToNonDelegatedEvent("close", domElement);
        break;
      case "iframe":
      case "object":
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "video":
      case "audio":
        for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++) listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
        break;
      case "image":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", domElement);
        break;
      case "embed":
      case "source":
      case "link":
        listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (defaultChecked in props) if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc)) switch (defaultChecked) {
          case "children":
          case "dangerouslySetInnerHTML":
            throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
          default:
            setProp(domElement, tag, defaultChecked, hasSrc, props, null);
        }
        return;
      default:
        if (isCustomElement(tag)) {
          for (_propValue in props) props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(domElement, tag, _propValue, hasSrc, props, void 0));
          return;
        }
    }
    for (defaultValue in props) props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
  }
  function updateProperties(domElement, tag, lastProps, nextProps) {
    validatePropertiesInDevelopment(tag, nextProps);
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var name = null,
          type = null,
          value = null,
          defaultValue = null,
          lastDefaultValue = null,
          checked = null,
          defaultChecked = null;
        for (propKey in lastProps) {
          var lastProp = lastProps[propKey];
          if (lastProps.hasOwnProperty(propKey) && null != lastProp) switch (propKey) {
            case "checked":
              break;
            case "value":
              break;
            case "defaultValue":
              lastDefaultValue = lastProp;
            default:
              nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
          }
        }
        for (var _propKey8 in nextProps) {
          var propKey = nextProps[_propKey8];
          lastProp = lastProps[_propKey8];
          if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp)) switch (_propKey8) {
            case "type":
              type = propKey;
              break;
            case "name":
              name = propKey;
              break;
            case "checked":
              checked = propKey;
              break;
            case "defaultChecked":
              defaultChecked = propKey;
              break;
            case "value":
              value = propKey;
              break;
            case "defaultValue":
              defaultValue = propKey;
              break;
            case "children":
            case "dangerouslySetInnerHTML":
              if (null != propKey) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              break;
            default:
              propKey !== lastProp && setProp(domElement, tag, _propKey8, propKey, nextProps, lastProp);
          }
        }
        tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
        nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
        tag || !nextProps || didWarnUncontrolledToControlled || (console.error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnUncontrolledToControlled = !0);
        !tag || nextProps || didWarnControlledToUncontrolled || (console.error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"), didWarnControlledToUncontrolled = !0);
        updateInput(domElement, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name);
        return;
      case "select":
        propKey = value = defaultValue = _propKey8 = null;
        for (type in lastProps) if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue) switch (type) {
          case "value":
            break;
          case "multiple":
            propKey = lastDefaultValue;
          default:
            nextProps.hasOwnProperty(type) || setProp(domElement, tag, type, null, nextProps, lastDefaultValue);
        }
        for (name in nextProps) if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue)) switch (name) {
          case "value":
            _propKey8 = type;
            break;
          case "defaultValue":
            defaultValue = type;
            break;
          case "multiple":
            value = type;
          default:
            type !== lastDefaultValue && setProp(domElement, tag, name, type, nextProps, lastDefaultValue);
        }
        nextProps = defaultValue;
        tag = value;
        lastProps = propKey;
        null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, !1) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, !0) : updateOptions(domElement, !!tag, tag ? [] : "", !1));
        return;
      case "textarea":
        propKey = _propKey8 = null;
        for (defaultValue in lastProps) if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue)) switch (defaultValue) {
          case "value":
            break;
          case "children":
            break;
          default:
            setProp(domElement, tag, defaultValue, null, nextProps, name);
        }
        for (value in nextProps) if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type)) switch (value) {
          case "value":
            _propKey8 = name;
            break;
          case "defaultValue":
            propKey = name;
            break;
          case "children":
            break;
          case "dangerouslySetInnerHTML":
            if (null != name) throw Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            break;
          default:
            name !== type && setProp(domElement, tag, value, name, nextProps, type);
        }
        updateTextarea(domElement, _propKey8, propKey);
        return;
      case "option":
        for (var _propKey13 in lastProps) if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13)) switch (_propKey13) {
          case "selected":
            domElement.selected = !1;
            break;
          default:
            setProp(domElement, tag, _propKey13, null, nextProps, _propKey8);
        }
        for (lastDefaultValue in nextProps) if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch (lastDefaultValue) {
          case "selected":
            domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
            break;
          default:
            setProp(domElement, tag, lastDefaultValue, _propKey8, nextProps, propKey);
        }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var _propKey15 in lastProps) _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(domElement, tag, _propKey15, null, nextProps, _propKey8);
        for (checked in nextProps) if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey)) switch (checked) {
          case "children":
          case "dangerouslySetInnerHTML":
            if (null != _propKey8) throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
            break;
          default:
            setProp(domElement, tag, checked, _propKey8, nextProps, propKey);
        }
        return;
      default:
        if (isCustomElement(tag)) {
          for (var _propKey17 in lastProps) _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(domElement, tag, _propKey17, void 0, nextProps, _propKey8);
          for (defaultChecked in nextProps) _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(domElement, tag, defaultChecked, _propKey8, nextProps, propKey);
          return;
        }
    }
    for (var _propKey19 in lastProps) _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
    for (lastProp in nextProps) _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
  }
  function getPropNameFromAttributeName(attrName) {
    switch (attrName) {
      case "class":
        return "className";
      case "for":
        return "htmlFor";
      default:
        return attrName;
    }
  }
  function getStylesObjectFromElement(domElement) {
    var serverValueInObjectForm = {};
    domElement = domElement.style;
    for (var i = 0; i < domElement.length; i++) {
      var styleName = domElement[i];
      serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
    }
    return serverValueInObjectForm;
  }
  function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
    if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0) console.error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");else if (canDiffStyleForHydrationWarning) {
      var clientValue;
      var delimiter = clientValue = "",
        styleName;
      for (styleName in value$jscomp$0) if (value$jscomp$0.hasOwnProperty(styleName)) {
        var value = value$jscomp$0[styleName];
        null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
      }
      clientValue = clientValue || null;
      value$jscomp$0 = domElement.getAttribute("style");
      value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
    }
  }
  function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
    extraAttributes.delete(attributeName);
    domElement = domElement.getAttribute(attributeName);
    if (null === domElement) switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        return;
    } else if (null != value) switch (typeof value) {
      case "function":
      case "symbol":
      case "boolean":
        break;
      default:
        if (checkAttributeStringCoercion(value, propKey), domElement === "" + value) return;
    }
    warnForPropDifference(propKey, domElement, value, serverDifferences);
  }
  function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
    extraAttributes.delete(attributeName);
    domElement = domElement.getAttribute(attributeName);
    if (null === domElement) {
      switch (typeof value) {
        case "function":
        case "symbol":
          return;
      }
      if (!value) return;
    } else switch (typeof value) {
      case "function":
      case "symbol":
        break;
      default:
        if (value) return;
    }
    warnForPropDifference(propKey, domElement, value, serverDifferences);
  }
  function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
    extraAttributes.delete(attributeName);
    domElement = domElement.getAttribute(attributeName);
    if (null === domElement) switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
        return;
    } else if (null != value) switch (typeof value) {
      case "function":
      case "symbol":
        break;
      default:
        if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value) return;
    }
    warnForPropDifference(propKey, domElement, value, serverDifferences);
  }
  function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
    extraAttributes.delete(attributeName);
    domElement = domElement.getAttribute(attributeName);
    if (null === domElement) switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        return;
      default:
        if (isNaN(value)) return;
    } else if (null != value) switch (typeof value) {
      case "function":
      case "symbol":
      case "boolean":
        break;
      default:
        if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value)) return;
    }
    warnForPropDifference(propKey, domElement, value, serverDifferences);
  }
  function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
    extraAttributes.delete(attributeName);
    domElement = domElement.getAttribute(attributeName);
    if (null === domElement) switch (typeof value) {
      case "undefined":
      case "function":
      case "symbol":
      case "boolean":
        return;
    } else if (null != value) switch (typeof value) {
      case "function":
      case "symbol":
      case "boolean":
        break;
      default:
        if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName) return;
    }
    warnForPropDifference(propKey, domElement, value, serverDifferences);
  }
  function diffHydratedProperties(domElement, tag, props, hostContext) {
    for (var serverDifferences = {}, extraAttributes = new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++) switch (attributes[i].name.toLowerCase()) {
      case "value":
        break;
      case "checked":
        break;
      case "selected":
        break;
      default:
        extraAttributes.add(attributes[i].name);
    }
    if (isCustomElement(tag)) for (var propKey in props) {
      if (props.hasOwnProperty(propKey)) {
        var value = props[propKey];
        if (null != value) if (registrationNameDependencies.hasOwnProperty(propKey)) "function" !== typeof value && warnForInvalidEventListener(propKey, value);else if (!0 !== props.suppressHydrationWarning) switch (propKey) {
          case "children":
            "string" !== typeof value && "number" !== typeof value || warnForPropDifference("children", domElement.textContent, value, serverDifferences);
            continue;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            continue;
          case "dangerouslySetInnerHTML":
            attributes = domElement.innerHTML;
            value = value ? value.__html : void 0;
            null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(propKey, attributes, value, serverDifferences));
            continue;
          case "style":
            extraAttributes.delete(propKey);
            diffHydratedStyles(domElement, value, serverDifferences);
            continue;
          case "offsetParent":
          case "offsetTop":
          case "offsetLeft":
          case "offsetWidth":
          case "offsetHeight":
          case "isContentEditable":
          case "outerText":
          case "outerHTML":
            extraAttributes.delete(propKey.toLowerCase());
            console.error("Assignment to read-only property will result in a no-op: `%s`", propKey);
            continue;
          case "className":
            extraAttributes.delete("class");
            attributes = getValueForAttributeOnCustomComponent(domElement, "class", value);
            warnForPropDifference("className", attributes, value, serverDifferences);
            continue;
          default:
            hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(domElement, propKey, value), warnForPropDifference(propKey, attributes, value, serverDifferences);
        }
      }
    } else for (value in props) if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) if (registrationNameDependencies.hasOwnProperty(value)) "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);else if (!0 !== props.suppressHydrationWarning) switch (value) {
      case "children":
        "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference("children", domElement.textContent, propKey, serverDifferences);
        continue;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "value":
      case "checked":
      case "selected":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        continue;
      case "dangerouslySetInnerHTML":
        attributes = domElement.innerHTML;
        propKey = propKey ? propKey.__html : void 0;
        null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = {
          __html: attributes
        }));
        continue;
      case "className":
        hydrateAttribute(domElement, value, "class", propKey, extraAttributes, serverDifferences);
        continue;
      case "tabIndex":
        hydrateAttribute(domElement, value, "tabindex", propKey, extraAttributes, serverDifferences);
        continue;
      case "style":
        extraAttributes.delete(value);
        diffHydratedStyles(domElement, propKey, serverDifferences);
        continue;
      case "multiple":
        extraAttributes.delete(value);
        warnForPropDifference(value, domElement.multiple, propKey, serverDifferences);
        continue;
      case "muted":
        extraAttributes.delete(value);
        warnForPropDifference(value, domElement.muted, propKey, serverDifferences);
        continue;
      case "autoFocus":
        extraAttributes.delete("autofocus");
        warnForPropDifference(value, domElement.autofocus, propKey, serverDifferences);
        continue;
      case "data":
        if ("object" !== tag) {
          extraAttributes.delete(value);
          attributes = domElement.getAttribute("data");
          warnForPropDifference(value, attributes, propKey, serverDifferences);
          continue;
        }
      case "src":
      case "href":
        if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
          "src" === value ? console.error('An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value) : console.error('An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.', value, value);
          hydrateSanitizedAttribute(domElement, value, value, null, extraAttributes, serverDifferences);
          continue;
        }
        hydrateSanitizedAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
        continue;
      case "action":
      case "formAction":
        attributes = domElement.getAttribute(value);
        if ("function" === typeof propKey) {
          extraAttributes.delete(value.toLowerCase());
          "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
          continue;
        } else if (attributes === EXPECTED_FORM_ACTION_URL) {
          extraAttributes.delete(value.toLowerCase());
          warnForPropDifference(value, "function", propKey, serverDifferences);
          continue;
        }
        hydrateSanitizedAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
        continue;
      case "xlinkHref":
        hydrateSanitizedAttribute(domElement, value, "xlink:href", propKey, extraAttributes, serverDifferences);
        continue;
      case "contentEditable":
        hydrateBooleanishAttribute(domElement, value, "contenteditable", propKey, extraAttributes, serverDifferences);
        continue;
      case "spellCheck":
        hydrateBooleanishAttribute(domElement, value, "spellcheck", propKey, extraAttributes, serverDifferences);
        continue;
      case "draggable":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        hydrateBooleanishAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
        continue;
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        hydrateBooleanAttribute(domElement, value, value.toLowerCase(), propKey, extraAttributes, serverDifferences);
        continue;
      case "capture":
      case "download":
        a: {
          i = domElement;
          var attributeName = attributes = value,
            serverDifferences$jscomp$0 = serverDifferences;
          extraAttributes.delete(attributeName);
          i = i.getAttribute(attributeName);
          if (null === i) switch (typeof propKey) {
            case "undefined":
            case "function":
            case "symbol":
              break a;
            default:
              if (!1 === propKey) break a;
          } else if (null != propKey) switch (typeof propKey) {
            case "function":
            case "symbol":
              break;
            case "boolean":
              if (!0 === propKey && "" === i) break a;
              break;
            default:
              if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey) break a;
          }
          warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
        }
        continue;
      case "cols":
      case "rows":
      case "size":
      case "span":
        a: {
          i = domElement;
          attributeName = attributes = value;
          serverDifferences$jscomp$0 = serverDifferences;
          extraAttributes.delete(attributeName);
          i = i.getAttribute(attributeName);
          if (null === i) switch (typeof propKey) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              break a;
            default:
              if (isNaN(propKey) || 1 > propKey) break a;
          } else if (null != propKey) switch (typeof propKey) {
            case "function":
            case "symbol":
            case "boolean":
              break;
            default:
              if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)) break a;
          }
          warnForPropDifference(attributes, i, propKey, serverDifferences$jscomp$0);
        }
        continue;
      case "rowSpan":
        hydrateNumericAttribute(domElement, value, "rowspan", propKey, extraAttributes, serverDifferences);
        continue;
      case "start":
        hydrateNumericAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
        continue;
      case "xHeight":
        hydrateAttribute(domElement, value, "x-height", propKey, extraAttributes, serverDifferences);
        continue;
      case "xlinkActuate":
        hydrateAttribute(domElement, value, "xlink:actuate", propKey, extraAttributes, serverDifferences);
        continue;
      case "xlinkArcrole":
        hydrateAttribute(domElement, value, "xlink:arcrole", propKey, extraAttributes, serverDifferences);
        continue;
      case "xlinkRole":
        hydrateAttribute(domElement, value, "xlink:role", propKey, extraAttributes, serverDifferences);
        continue;
      case "xlinkShow":
        hydrateAttribute(domElement, value, "xlink:show", propKey, extraAttributes, serverDifferences);
        continue;
      case "xlinkTitle":
        hydrateAttribute(domElement, value, "xlink:title", propKey, extraAttributes, serverDifferences);
        continue;
      case "xlinkType":
        hydrateAttribute(domElement, value, "xlink:type", propKey, extraAttributes, serverDifferences);
        continue;
      case "xmlBase":
        hydrateAttribute(domElement, value, "xml:base", propKey, extraAttributes, serverDifferences);
        continue;
      case "xmlLang":
        hydrateAttribute(domElement, value, "xml:lang", propKey, extraAttributes, serverDifferences);
        continue;
      case "xmlSpace":
        hydrateAttribute(domElement, value, "xml:space", propKey, extraAttributes, serverDifferences);
        continue;
      case "inert":
        "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = !0, console.error("Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.", value));
        hydrateBooleanAttribute(domElement, value, value, propKey, extraAttributes, serverDifferences);
        continue;
      default:
        if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
          i = getAttributeAlias(value);
          attributes = !1;
          hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(attributeName) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = !0, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
          a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0)) {
            if (attributeName.hasAttribute(serverDifferences$jscomp$0)) attributeName = attributeName.getAttribute(serverDifferences$jscomp$0), checkAttributeStringCoercion(i, serverDifferences$jscomp$0), i = attributeName === "" + i ? i : attributeName;else {
              switch (typeof i) {
                case "function":
                case "symbol":
                  break a;
                case "boolean":
                  if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName) break a;
              }
              i = void 0 === i ? void 0 : null;
            }
          } else i = void 0;
          attributes || warnForPropDifference(value, i, propKey, serverDifferences);
        }
    }
    0 < extraAttributes.size && !0 !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
    return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
  }
  function propNamesListJoin(list, combinator) {
    switch (list.length) {
      case 0:
        return "";
      case 1:
        return list[0];
      case 2:
        return list[0] + " " + combinator + " " + list[1];
      default:
        return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
    }
  }
  function getOwnerDocumentFromRootContainer(rootContainerElement) {
    return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
  }
  function getOwnHostContext(namespaceURI) {
    switch (namespaceURI) {
      case SVG_NAMESPACE:
        return HostContextNamespaceSvg;
      case MATH_NAMESPACE:
        return HostContextNamespaceMath;
      default:
        return HostContextNamespaceNone;
    }
  }
  function getChildHostContextProd(parentNamespace, type) {
    if (parentNamespace === HostContextNamespaceNone) switch (type) {
      case "svg":
        return HostContextNamespaceSvg;
      case "math":
        return HostContextNamespaceMath;
      default:
        return HostContextNamespaceNone;
    }
    return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
  }
  function shouldSetTextContent(type, props) {
    return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
  }
  function shouldAttemptEagerTransition() {
    var event = window.event;
    if (event && "popstate" === event.type) {
      if (event === currentPopstateTransitionEvent) return !1;
      currentPopstateTransitionEvent = event;
      return !0;
    }
    currentPopstateTransitionEvent = null;
    return !1;
  }
  function handleErrorInNextTick(error) {
    setTimeout(function () {
      throw error;
    });
  }
  function commitMount(domElement, type, newProps) {
    switch (type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        newProps.autoFocus && domElement.focus();
        break;
      case "img":
        newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
    }
  }
  function commitUpdate(domElement, type, oldProps, newProps) {
    updateProperties(domElement, type, oldProps, newProps);
    domElement[internalPropsKey] = newProps;
  }
  function resetTextContent(domElement) {
    setTextContent(domElement, "");
  }
  function commitTextUpdate(textInstance, oldText, newText) {
    textInstance.nodeValue = newText;
  }
  function removeChild(parentInstance, child) {
    parentInstance.removeChild(child);
  }
  function removeChildFromContainer(container, child) {
    8 === container.nodeType ? container.parentNode.removeChild(child) : container.removeChild(child);
  }
  function clearSuspenseBoundary(parentInstance, suspenseInstance) {
    var node = suspenseInstance,
      depth = 0;
    do {
      var nextNode = node.nextSibling;
      parentInstance.removeChild(node);
      if (nextNode && 8 === nextNode.nodeType) if (node = nextNode.data, node === SUSPENSE_END_DATA) {
        if (0 === depth) {
          parentInstance.removeChild(nextNode);
          retryIfBlockedOn(suspenseInstance);
          return;
        }
        depth--;
      } else node !== SUSPENSE_START_DATA && node !== SUSPENSE_PENDING_START_DATA && node !== SUSPENSE_FALLBACK_START_DATA || depth++;
      node = nextNode;
    } while (node);
    retryIfBlockedOn(suspenseInstance);
  }
  function hideInstance(instance) {
    instance = instance.style;
    "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
  }
  function hideTextInstance(textInstance) {
    textInstance.nodeValue = "";
  }
  function unhideInstance(instance, props) {
    props = props[STYLE];
    props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
    instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
  }
  function unhideTextInstance(textInstance, text) {
    textInstance.nodeValue = text;
  }
  function clearContainerSparingly(container) {
    var nextNode = container.firstChild;
    nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
    for (; nextNode;) {
      var node = nextNode;
      nextNode = nextNode.nextSibling;
      switch (node.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          clearContainerSparingly(node);
          detachDeletedInstance(node);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if ("stylesheet" === node.rel.toLowerCase()) continue;
      }
      container.removeChild(node);
    }
  }
  function canHydrateInstance(instance, type, props, inRootOrSingleton) {
    for (; 1 === instance.nodeType;) {
      var anyProps = props;
      if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
        if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type)) break;
      } else if (!inRootOrSingleton) {
        if ("input" === type && "hidden" === instance.type) {
          checkAttributeStringCoercion(anyProps.name, "name");
          var name = null == anyProps.name ? null : "" + anyProps.name;
          if ("hidden" === anyProps.type && instance.getAttribute("name") === name) return instance;
        } else return instance;
      } else if (!instance[internalHoistableMarker]) switch (type) {
        case "meta":
          if (!instance.hasAttribute("itemprop")) break;
          return instance;
        case "link":
          name = instance.getAttribute("rel");
          if ("stylesheet" === name && instance.hasAttribute("data-precedence")) break;else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title)) break;
          return instance;
        case "style":
          if (instance.hasAttribute("data-precedence")) break;
          return instance;
        case "script":
          name = instance.getAttribute("src");
          if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop")) break;
          return instance;
        default:
          return instance;
      }
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) break;
    }
    return null;
  }
  function canHydrateTextInstance(instance, text, inRootOrSingleton) {
    if ("" === text) return null;
    for (; 3 !== instance.nodeType;) {
      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton) return null;
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) return null;
    }
    return instance;
  }
  function getNextHydratable(node) {
    for (; null != node; node = node.nextSibling) {
      var nodeType = node.nodeType;
      if (1 === nodeType || 3 === nodeType) break;
      if (8 === nodeType) {
        nodeType = node.data;
        if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING) break;
        if (nodeType === SUSPENSE_END_DATA) return null;
      }
    }
    return node;
  }
  function describeHydratableInstanceForDevWarnings(instance) {
    if (1 === instance.nodeType) {
      for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
        var attr = attributes[i];
        serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
      }
      return {
        type: JSCompiler_temp_const,
        props: serverDifferences
      };
    }
    return 8 === instance.nodeType ? {
      type: "Suspense",
      props: {}
    } : instance.nodeValue;
  }
  function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
    return null === parentProps || !0 !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
  }
  function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
    suspenseInstance = suspenseInstance.nextSibling;
    for (var depth = 0; suspenseInstance;) {
      if (8 === suspenseInstance.nodeType) {
        var data = suspenseInstance.data;
        if (data === SUSPENSE_END_DATA) {
          if (0 === depth) return getNextHydratable(suspenseInstance.nextSibling);
          depth--;
        } else data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
      }
      suspenseInstance = suspenseInstance.nextSibling;
    }
    return null;
  }
  function getParentSuspenseInstance(targetInstance) {
    targetInstance = targetInstance.previousSibling;
    for (var depth = 0; targetInstance;) {
      if (8 === targetInstance.nodeType) {
        var data = targetInstance.data;
        if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
          if (0 === depth) return targetInstance;
          depth--;
        } else data === SUSPENSE_END_DATA && depth++;
      }
      targetInstance = targetInstance.previousSibling;
    }
    return null;
  }
  function commitHydratedContainer(container) {
    retryIfBlockedOn(container);
  }
  function commitHydratedSuspenseInstance(suspenseInstance) {
    retryIfBlockedOn(suspenseInstance);
  }
  function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
    validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
    props = getOwnerDocumentFromRootContainer(rootContainerInstance);
    switch (type) {
      case "html":
        type = props.documentElement;
        if (!type) throw Error("React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page.");
        return type;
      case "head":
        type = props.head;
        if (!type) throw Error("React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page.");
        return type;
      case "body":
        type = props.body;
        if (!type) throw Error("React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page.");
        return type;
      default:
        throw Error("resolveSingletonInstance was called with an element type that is not supported. This is a bug in React.");
    }
  }
  function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
    if (getInstanceFromNode(instance)) {
      var tagName = instance.tagName.toLowerCase();
      console.error("You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.", tagName, tagName, tagName);
    }
    switch (type) {
      case "html":
      case "head":
      case "body":
        break;
      default:
        console.error("acquireSingletonInstance was called with an element type that is not supported. This is a bug in React.");
    }
    for (tagName = instance.attributes; tagName.length;) instance.removeAttributeNode(tagName[0]);
    setInitialProperties(instance, type, props);
    instance[internalInstanceKey] = internalInstanceHandle;
    instance[internalPropsKey] = props;
  }
  function getHoistableRoot(container) {
    return "function" === typeof container.getRootNode ? container.getRootNode() : container.ownerDocument;
  }
  function preconnectAs(rel, href, crossOrigin) {
    var ownerDocument = globalDocument;
    if (ownerDocument && "string" === typeof href && href) {
      var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
      limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
      "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
      preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = {
        rel: rel,
        crossOrigin: crossOrigin,
        href: href
      }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
    }
  }
  function getResource(type, currentProps, pendingProps, currentResource) {
    var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
    if (!resourceRoot) throw Error('"resourceRoot" was expected to exist. This is a bug in React.');
    switch (type) {
      case "meta":
      case "title":
        return null;
      case "style":
        return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, currentProps.set(pendingProps, currentResource)), currentResource) : {
          type: "void",
          instance: null,
          count: 0,
          state: null
        };
      case "link":
        if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
          type = getStyleKey(pendingProps.href);
          var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles,
            _resource = _styles.get(type);
          if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: {
              loading: NotLoaded,
              preload: null
            }
          }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(getStylesheetSelectorFromKey(type))) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
            var preloadProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            };
            preloadPropsMap.set(type, preloadProps);
            _styles || preloadStylesheet(resourceRoot, type, preloadProps, _resource.state);
          }
          if (currentProps && null === currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
          return _resource;
        }
        if (currentProps && null !== currentResource) throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error("Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps);
        return null;
      case "script":
        return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, currentProps.set(pendingProps, currentResource)), currentResource) : {
          type: "void",
          instance: null,
          count: 0,
          state: null
        };
      default:
        throw Error('getResource encountered a type it did not expect: "' + type + '". this is a bug in React.');
    }
  }
  function describeLinkForResourceErrorDEV(props) {
    var describedProps = 0,
      description = "<link";
    "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
    "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
    "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
    Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
    return description + " />";
  }
  function getStyleKey(href) {
    return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
  }
  function getStylesheetSelectorFromKey(key) {
    return 'link[rel="stylesheet"][' + key + "]";
  }
  function stylesheetPropsFromRawProps(rawProps) {
    return assign({}, rawProps, {
      "data-precedence": rawProps.precedence,
      precedence: null
    });
  }
  function preloadStylesheet(ownerDocument, key, preloadProps, state) {
    ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function () {
      return state.loading |= Loaded;
    }), key.addEventListener("error", function () {
      return state.loading |= Errored;
    }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
  }
  function getScriptKey(src) {
    return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
  }
  function getScriptSelectorFromKey(key) {
    return "script[async]" + key;
  }
  function acquireResource(hoistableRoot, resource, props) {
    resource.count++;
    if (null === resource.instance) switch (resource.type) {
      case "style":
        var instance = hoistableRoot.querySelector('style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]');
        if (instance) return resource.instance = instance, markNodeAsHoistable(instance), instance;
        var styleProps = assign({}, props, {
          "data-href": props.href,
          "data-precedence": props.precedence,
          href: null,
          precedence: null
        });
        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
        markNodeAsHoistable(instance);
        setInitialProperties(instance, "style", styleProps);
        insertStylesheet(instance, props.precedence, hoistableRoot);
        return resource.instance = instance;
      case "stylesheet":
        styleProps = getStyleKey(props.href);
        var _instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(styleProps));
        if (_instance) return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
        instance = stylesheetPropsFromRawProps(props);
        (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
        _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
        markNodeAsHoistable(_instance);
        var linkInstance = _instance;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(_instance, "link", instance);
        resource.state.loading |= Inserted;
        insertStylesheet(_instance, props.precedence, hoistableRoot);
        return resource.instance = _instance;
      case "script":
        _instance = getScriptKey(props.src);
        if (styleProps = hoistableRoot.querySelector(getScriptSelectorFromKey(_instance))) return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
        instance = props;
        if (styleProps = preloadPropsMap.get(_instance)) instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        styleProps = hoistableRoot.createElement("script");
        markNodeAsHoistable(styleProps);
        setInitialProperties(styleProps, "link", instance);
        hoistableRoot.head.appendChild(styleProps);
        return resource.instance = styleProps;
      case "void":
        return null;
      default:
        throw Error('acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.');
    } else "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
    return resource.instance;
  }
  function insertStylesheet(instance, precedence, root) {
    for (var nodes = root.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (node.dataset.precedence === precedence) prior = node;else if (prior !== last) break;
    }
    prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root.nodeType ? root.head : root, precedence.insertBefore(instance, precedence.firstChild));
  }
  function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
    null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
    null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
    null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
  }
  function adoptPreloadPropsForScript(scriptProps, preloadProps) {
    null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
    null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
    null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
  }
  function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
    if (null === tagCaches) {
      var cache = new Map();
      var caches = tagCaches = new Map();
      caches.set(ownerDocument, cache);
    } else caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = new Map(), caches.set(ownerDocument, cache));
    if (cache.has(type)) return cache;
    cache.set(type, null);
    ownerDocument = ownerDocument.getElementsByTagName(type);
    for (caches = 0; caches < ownerDocument.length; caches++) {
      var node = ownerDocument[caches];
      if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
        var nodeKey = node.getAttribute(keyAttribute) || "";
        nodeKey = type + nodeKey;
        var existing = cache.get(nodeKey);
        existing ? existing.push(node) : cache.set(nodeKey, [node]);
      }
    }
    return cache;
  }
  function mountHoistable(hoistableRoot, type, instance) {
    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
    hoistableRoot.head.insertBefore(instance, "title" === type ? hoistableRoot.querySelector("head > title") : null);
  }
  function isHostHoistableType(type, props, hostContext) {
    var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
    if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp) return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error("Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.", type, type), !1;
    switch (type) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
          outsideHostContainerContext && console.error('Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflic with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`, or move the <style> to the <style> tag.');
          break;
        }
        return !0;
      case "link":
        if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
          if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
            type = props.href;
            var onError = props.onError,
              disabled = props.disabled;
            hostContext = [];
            props.onLoad && hostContext.push("`onLoad`");
            onError && hostContext.push("`onError`");
            null != disabled && hostContext.push("`disabled`");
            onError = propNamesListJoin(hostContext, "and");
            onError += 1 === hostContext.length ? " prop" : " props";
            disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
            hostContext.length && console.error('React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.', type, disabled, onError);
          }
          outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error("Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag") : (props.onError || props.onLoad) && console.error("Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."));
          break;
        }
        switch (props.rel) {
          case "stylesheet":
            return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error('Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'), "string" === typeof type && null == props;
          default:
            return !0;
        }
      case "script":
        type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
        if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
          outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error("Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>.") : console.error("Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>.") : console.error('Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'));
          break;
        }
        return !0;
      case "noscript":
      case "template":
        outsideHostContainerContext && console.error("Cannot render <%s> outside the main document. Try moving it into the root <head> tag.", type);
    }
    return !1;
  }
  function preloadResource(resource) {
    return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? !1 : !0;
  }
  function noop() {}
  function suspendResource(hoistableRoot, resource, props) {
    if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
    var state = suspendedState;
    if ("stylesheet" === resource.type && ("string" !== typeof props.media || !1 !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
      if (null === resource.instance) {
        var key = getStyleKey(props.href),
          instance = hoistableRoot.querySelector(getStylesheetSelectorFromKey(key));
        if (instance) {
          hoistableRoot = instance._p;
          null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
          resource.state.loading |= Inserted;
          resource.instance = instance;
          markNodeAsHoistable(instance);
          return;
        }
        instance = hoistableRoot.ownerDocument || hoistableRoot;
        props = stylesheetPropsFromRawProps(props);
        (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
        instance = instance.createElement("link");
        markNodeAsHoistable(instance);
        var linkInstance = instance;
        linkInstance._p = new Promise(function (resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance, "link", props);
        resource.instance = instance;
      }
      null === state.stylesheets && (state.stylesheets = new Map());
      state.stylesheets.set(resource, hoistableRoot);
      (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
    }
  }
  function waitForCommitToBeReady() {
    if (null === suspendedState) throw Error("Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug.");
    var state = suspendedState;
    state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
    return 0 < state.count ? function (commit) {
      var stylesheetTimer = setTimeout(function () {
        state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
        if (state.unsuspend) {
          var unsuspend = state.unsuspend;
          state.unsuspend = null;
          unsuspend();
        }
      }, 6e4);
      state.unsuspend = commit;
      return function () {
        state.unsuspend = null;
        clearTimeout(stylesheetTimer);
      };
    } : null;
  }
  function onUnsuspend() {
    this.count--;
    if (0 === this.count) if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);else if (this.unsuspend) {
      var unsuspend = this.unsuspend;
      this.unsuspend = null;
      unsuspend();
    }
  }
  function insertSuspendedStylesheets(state, resources) {
    state.stylesheets = null;
    null !== state.unsuspend && (state.count++, precedencesByRoot = new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
  }
  function insertStylesheetIntoRoot(root, resource) {
    if (!(resource.state.loading & Inserted)) {
      var precedences = precedencesByRoot.get(root);
      if (precedences) var last = precedences.get(LAST_PRECEDENCE);else {
        precedences = new Map();
        precedencesByRoot.set(root, precedences);
        for (var nodes = root.querySelectorAll("link[data-precedence],style[data-precedence]"), i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media")) precedences.set(node.dataset.precedence, node), last = node;
        }
        last && precedences.set(LAST_PRECEDENCE, last);
      }
      nodes = resource.instance;
      node = nodes.getAttribute("data-precedence");
      i = precedences.get(node) || last;
      i === last && precedences.set(LAST_PRECEDENCE, nodes);
      precedences.set(node, nodes);
      this.count++;
      last = onUnsuspend.bind(this);
      nodes.addEventListener("load", last);
      nodes.addEventListener("error", last);
      i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root = 9 === root.nodeType ? root.head : root, root.insertBefore(nodes, root.firstChild));
      resource.state.loading |= Inserted;
    }
  }
  function bindToConsole(methodName, args, badgeName) {
    var offset = 0;
    switch (methodName) {
      case "dir":
      case "dirxml":
      case "groupEnd":
      case "table":
        return bind.apply(console[methodName], [console].concat(args));
      case "assert":
        offset = 1;
    }
    args = args.slice(0);
    "string" === typeof args[offset] ? args.splice(offset, 1, badgeFormat + args[offset], badgeStyle, pad + badgeName + pad, resetStyle) : args.splice(offset, 0, badgeFormat, badgeStyle, pad + badgeName + pad, resetStyle);
    args.unshift(console);
    return bind.apply(console[methodName], args);
  }
  function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
    this.tag = 1;
    this.containerInfo = containerInfo;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = noTimeout;
    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
    this.callbackPriority = 0;
    this.expirationTimes = createLaneMap(-1);
    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = createLaneMap(0);
    this.hiddenUpdates = createLaneMap(null);
    this.identifierPrefix = identifierPrefix;
    this.onUncaughtError = onUncaughtError;
    this.onCaughtError = onCaughtError;
    this.onRecoverableError = onRecoverableError;
    this.pooledCache = null;
    this.pooledCacheLanes = 0;
    this.formState = formState;
    this.incompleteTransitions = new Map();
    this.passiveEffectDuration = this.effectDuration = -0;
    this.memoizedUpdaters = new Set();
    containerInfo = this.pendingUpdatersLaneMap = [];
    for (tag = 0; 31 > tag; tag++) containerInfo.push(new Set());
    this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
  }
  function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
    containerInfo = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);
    tag = ConcurrentMode;
    !0 === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
    isDevToolsPresent && (tag |= ProfileMode);
    isStrictMode = createFiber(3, null, null, tag);
    containerInfo.current = isStrictMode;
    isStrictMode.stateNode = containerInfo;
    tag = createCache();
    retainCache(tag);
    containerInfo.pooledCache = tag;
    retainCache(tag);
    isStrictMode.memoizedState = {
      element: initialChildren,
      isDehydrated: hydrate,
      cache: tag
    };
    initializeUpdateQueue(isStrictMode);
    return containerInfo;
  }
  function getContextForSubtree(parentComponent) {
    if (!parentComponent) return emptyContextObject;
    parentComponent = emptyContextObject;
    return parentComponent;
  }
  function updateContainerSync(element, container, parentComponent, callback) {
    0 === container.tag && flushPassiveEffects();
    updateContainerImpl(container.current, 2, element, container, parentComponent, callback);
    return 2;
  }
  function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
    if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot) try {
      injectedHook.onScheduleFiberRoot(rendererID, container, element);
    } catch (err) {
      hasLoggedError || (hasLoggedError = !0, console.error("React instrumentation encountered an error: %s", err));
    }
    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
    parentComponent = getContextForSubtree(parentComponent);
    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, console.error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown"));
    container = createUpdate(lane);
    container.payload = {
      element: element
    };
    callback = void 0 === callback ? null : callback;
    null !== callback && ("function" !== typeof callback && console.error("Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), container.callback = callback);
    element = enqueueUpdate(rootFiber, container, lane);
    null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
  }
  function markRetryLaneImpl(fiber, retryLane) {
    fiber = fiber.memoizedState;
    if (null !== fiber && null !== fiber.dehydrated) {
      var a = fiber.retryLane;
      fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
    }
  }
  function markRetryLaneIfNotHydrated(fiber, retryLane) {
    markRetryLaneImpl(fiber, retryLane);
    (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
  }
  function attemptContinuousHydration(fiber) {
    if (13 === fiber.tag) {
      var root = enqueueConcurrentRenderForLane(fiber, 67108864);
      null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);
      markRetryLaneIfNotHydrated(fiber, 67108864);
    }
  }
  function getCurrentFiberForDevTools() {
    return current;
  }
  function getLaneLabelMap() {
    for (var map = new Map(), lane = 1, index = 0; 31 > index; index++) {
      var label = getLabelForLane(lane);
      map.set(lane, label);
      lane *= 2;
    }
    return map;
  }
  function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (_enabled) {
      var blockedOn = findInstanceBlockingEvent(nativeEvent);
      if (null === blockedOn) dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);else if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) nativeEvent.stopPropagation();else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
        for (; null !== blockedOn;) {
          var fiber = getInstanceFromNode(blockedOn);
          if (null !== fiber) switch (fiber.tag) {
            case 3:
              fiber = fiber.stateNode;
              if (fiber.current.memoizedState.isDehydrated) {
                var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                if (0 !== lanes) {
                  var root = fiber;
                  root.pendingLanes |= 2;
                  for (root.entangledLanes |= 2; lanes;) {
                    var lane = 1 << 31 - clz32(lanes);
                    root.entanglements[1] |= lane;
                    lanes &= ~lane;
                  }
                  ensureRootIsScheduled(fiber);
                  (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0, !1));
                }
              }
              break;
            case 13:
              root = enqueueConcurrentRenderForLane(fiber, 2), null !== root && scheduleUpdateOnFiber(root, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
          }
          fiber = findInstanceBlockingEvent(nativeEvent);
          null === fiber && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
          if (fiber === blockedOn) break;
          blockedOn = fiber;
        }
        null !== blockedOn && nativeEvent.stopPropagation();
      } else dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
    }
  }
  function findInstanceBlockingEvent(nativeEvent) {
    nativeEvent = getEventTarget(nativeEvent);
    return findInstanceBlockingTarget(nativeEvent);
  }
  function findInstanceBlockingTarget(targetNode) {
    return_targetInst = null;
    targetNode = getClosestInstanceFromNode(targetNode);
    if (null !== targetNode) {
      var nearestMounted = getNearestMountedFiber(targetNode);
      if (null === nearestMounted) targetNode = null;else {
        var tag = nearestMounted.tag;
        if (13 === tag) {
          targetNode = getSuspenseInstanceFromFiber(nearestMounted);
          if (null !== targetNode) return targetNode;
          targetNode = null;
        } else if (3 === tag) {
          if (nearestMounted.stateNode.current.memoizedState.isDehydrated) return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          targetNode = null;
        } else nearestMounted !== targetNode && (targetNode = null);
      }
    }
    return_targetInst = targetNode;
    return null;
  }
  function getEventPriority(domEventName) {
    switch (domEventName) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return DiscreteEventPriority;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return ContinuousEventPriority;
      case "message":
        switch (getCurrentPriorityLevel()) {
          case ImmediatePriority:
            return DiscreteEventPriority;
          case UserBlockingPriority:
            return ContinuousEventPriority;
          case NormalPriority$1:
          case LowPriority:
            return DefaultEventPriority;
          case IdlePriority:
            return IdleEventPriority;
          default:
            return DefaultEventPriority;
        }
      default:
        return DefaultEventPriority;
    }
  }
  function clearIfContinuousEvent(domEventName, nativeEvent) {
    switch (domEventName) {
      case "focusin":
      case "focusout":
        queuedFocus = null;
        break;
      case "dragenter":
      case "dragleave":
        queuedDrag = null;
        break;
      case "mouseover":
      case "mouseout":
        queuedMouse = null;
        break;
      case "pointerover":
      case "pointerout":
        queuedPointers.delete(nativeEvent.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        queuedPointerCaptures.delete(nativeEvent.pointerId);
    }
  }
  function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent) return existingQueuedEvent = {
      blockedOn: blockedOn,
      domEventName: domEventName,
      eventSystemFlags: eventSystemFlags,
      nativeEvent: nativeEvent,
      targetContainers: [targetContainer]
    }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
    existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
    blockedOn = existingQueuedEvent.targetContainers;
    null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
    return existingQueuedEvent;
  }
  function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    switch (domEventName) {
      case "focusin":
        return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
      case "dragenter":
        return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
      case "mouseover":
        return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent), !0;
      case "pointerover":
        var pointerId = nativeEvent.pointerId;
        queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent));
        return !0;
      case "gotpointercapture":
        return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)), !0;
    }
    return !1;
  }
  function attemptExplicitHydrationTarget(queuedTarget) {
    var targetInst = getClosestInstanceFromNode(queuedTarget.target);
    if (null !== targetInst) {
      var nearestMounted = getNearestMountedFiber(targetInst);
      if (null !== nearestMounted) if (targetInst = nearestMounted.tag, 13 === targetInst) {
        if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
          queuedTarget.blockedOn = targetInst;
          runWithPriority(queuedTarget.priority, function () {
            if (13 === nearestMounted.tag) {
              var lane = requestUpdateLane(nearestMounted),
                root = enqueueConcurrentRenderForLane(nearestMounted, lane);
              null !== root && scheduleUpdateOnFiber(root, nearestMounted, lane);
              markRetryLaneIfNotHydrated(nearestMounted, lane);
            }
          });
          return;
        }
      } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
        queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
        return;
      }
    }
    queuedTarget.blockedOn = null;
  }
  function attemptReplayContinuousQueuedEvent(queuedEvent) {
    if (null !== queuedEvent.blockedOn) return !1;
    for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length;) {
      var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
      if (null === nextBlockedOn) {
        nextBlockedOn = queuedEvent.nativeEvent;
        var nativeEventClone = new nextBlockedOn.constructor(nextBlockedOn.type, nextBlockedOn),
          event = nativeEventClone;
        null !== currentReplayingEvent && console.error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
        currentReplayingEvent = event;
        nextBlockedOn.target.dispatchEvent(nativeEventClone);
        null === currentReplayingEvent && console.error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
        currentReplayingEvent = null;
      } else return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, !1;
      targetContainers.shift();
    }
    return !0;
  }
  function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
    attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
  }
  function replayUnblockedEvents() {
    hasScheduledReplayAttempt = !1;
    null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
    null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
    null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
  }
  function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
    queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents)));
  }
  function scheduleReplayQueueIfNeeded(formReplayingQueue) {
    lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, function () {
      lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
      for (var i = 0; i < formReplayingQueue.length; i += 3) {
        var form = formReplayingQueue[i],
          submitterOrAction = formReplayingQueue[i + 1],
          formData = formReplayingQueue[i + 2];
        if ("function" !== typeof submitterOrAction) if (null === findInstanceBlockingTarget(submitterOrAction || form)) continue;else break;
        var formInst = getInstanceFromNode(form);
        null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
          pending: !0,
          data: formData,
          method: form.method,
          action: submitterOrAction
        }, Object.freeze(form), startHostTransition(formInst, form, submitterOrAction, formData));
      }
    }));
  }
  function retryIfBlockedOn(unblocked) {
    function unblock(queuedEvent) {
      return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
    }
    null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
    null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
    null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
    queuedPointers.forEach(unblock);
    queuedPointerCaptures.forEach(unblock);
    for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
      var queuedTarget = queuedExplicitHydrationTargets[i];
      queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
    }
    for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn);) attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
    i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
    if (null != i) for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
      var form = i[queuedTarget],
        submitterOrAction = i[queuedTarget + 1],
        formProps = form[internalPropsKey] || null;
      if ("function" === typeof submitterOrAction) formProps || scheduleReplayQueueIfNeeded(i);else if (formProps) {
        var action = null;
        if (submitterOrAction && submitterOrAction.hasAttribute("formAction")) {
          if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null) action = formProps.formAction;else {
            if (null !== findInstanceBlockingTarget(form)) continue;
          }
        } else action = formProps.action;
        "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
        scheduleReplayQueueIfNeeded(i);
      }
    }
  }
  function ReactDOMRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  function ReactDOMHydrationRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  function warnIfReactDOMContainerInDEV(container) {
    container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : console.error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
  }
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
  var Scheduler = __webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js"),
    React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
    ReactDOM = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js"),
    REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),
    REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
    REACT_PROVIDER_TYPE = Symbol.for("react.provider"),
    REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy");
  Symbol.for("react.scope");
  Symbol.for("react.debug_trace_mode");
  var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
  Symbol.for("react.legacy_hidden");
  Symbol.for("react.tracing_marker");
  var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
    MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
    REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
    ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    assign = Object.assign,
    disabledDepth = 0,
    prevLog,
    prevInfo,
    prevWarn,
    prevError,
    prevGroup,
    prevGroupCollapsed,
    prevGroupEnd;
  disabledLog.__reactDisabledLog = !0;
  var prefix,
    suffix,
    reentry = !1;
  var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
  var current = null,
    isRendering = !1,
    isArrayImpl = Array.isArray,
    ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    NotPending = Object.freeze({
      pending: !1,
      data: null,
      method: null,
      action: null
    }),
    valueStack = [];
  var fiberStack = [];
  var index$jscomp$0 = -1,
    contextStackCursor = createCursor(null),
    contextFiberStackCursor = createCursor(null),
    rootInstanceStackCursor = createCursor(null),
    hostTransitionProviderCursor = createCursor(null),
    hasOwnProperty = Object.prototype.hasOwnProperty,
    scheduleCallback$3 = Scheduler.unstable_scheduleCallback,
    cancelCallback$1 = Scheduler.unstable_cancelCallback,
    shouldYield = Scheduler.unstable_shouldYield,
    requestPaint = Scheduler.unstable_requestPaint,
    now$1 = Scheduler.unstable_now,
    getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
    ImmediatePriority = Scheduler.unstable_ImmediatePriority,
    UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
    NormalPriority$1 = Scheduler.unstable_NormalPriority,
    LowPriority = Scheduler.unstable_LowPriority,
    IdlePriority = Scheduler.unstable_IdlePriority,
    log$1 = Scheduler.log,
    unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,
    rendererID = null,
    injectedHook = null,
    injectedProfilingHooks = null,
    hasLoggedError = !1,
    isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,
    clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,
    log = Math.log,
    LN2 = Math.LN2,
    nextTransitionLane = 128,
    nextRetryLane = 4194304,
    DiscreteEventPriority = 2,
    ContinuousEventPriority = 8,
    DefaultEventPriority = 32,
    IdleEventPriority = 268435456,
    randomKey = Math.random().toString(36).slice(2),
    internalInstanceKey = "__reactFiber$" + randomKey,
    internalPropsKey = "__reactProps$" + randomKey,
    internalContainerInstanceKey = "__reactContainer$" + randomKey,
    internalEventHandlersKey = "__reactEvents$" + randomKey,
    internalEventHandlerListenersKey = "__reactListeners$" + randomKey,
    internalEventHandlesSetKey = "__reactHandles$" + randomKey,
    internalRootNodeResourcesKey = "__reactResources$" + randomKey,
    internalHoistableMarker = "__reactMarker$" + randomKey,
    allNativeEvents = new Set(),
    registrationNameDependencies = {},
    possibleRegistrationNames = {},
    canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
    hasReadOnlyValue = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    },
    VALID_ATTRIBUTE_NAME_REGEX = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
    illegalAttributeNameCache = {},
    validatedAttributeNameCache = {},
    escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g,
    didWarnValueDefaultValue$1 = !1,
    didWarnCheckedDefaultChecked = !1,
    didWarnSelectedSetOnOption = !1,
    didWarnInvalidChild = !1,
    didWarnInvalidInnerHTML = !1;
  var didWarnValueDefaultValue = !1;
  var valuePropNames = ["value", "defaultValue"],
    didWarnValDefaultVal = !1,
    needsEscaping = /["'&<>\n\t]|^\s|\s$/,
    specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(" "),
    inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(" "),
    buttonScopeTags = inScopeTags.concat(["button"]),
    impliedEndTags = "dd dt li option optgroup p rp rt".split(" "),
    emptyAncestorInfoDev = {
      current: null,
      formTag: null,
      aTagInScope: null,
      buttonTagInScope: null,
      nobrTagInScope: null,
      pTagInButtonScope: null,
      listItemTagAutoclosing: null,
      dlItemTagAutoclosing: null,
      containerTagInScope: null
    },
    didWarn = {},
    MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML",
    SVG_NAMESPACE = "http://www.w3.org/2000/svg",
    shorthandToLonghand = {
      animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(" "),
      background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(" "),
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(" "),
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(" "),
      fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(" "),
      gap: ["columnGap", "rowGap"],
      grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(" "),
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(" "),
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    },
    uppercasePattern = /([A-Z])/g,
    msPattern$1 = /^ms-/,
    badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/,
    msPattern = /^-ms-/,
    hyphenPattern = /-(.)/g,
    badStyleValueWithSemicolonPattern = /;\s*$/,
    warnedStyleNames = {},
    warnedStyleValues = {},
    warnedForNaNValue = !1,
    warnedForInfinityValue = !1,
    unitlessNumbers = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")),
    aliases = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]),
    possibleStandardNames = {
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      fetchpriority: "fetchPriority",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      inert: "inert",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      popover: "popover",
      popovertarget: "popoverTarget",
      popovertargetaction: "popoverTargetAction",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      transformorigin: "transformOrigin",
      "transform-origin": "transformOrigin",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    },
    ariaProperties = {
      "aria-current": 0,
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      "aria-hidden": 0,
      "aria-invalid": 0,
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    },
    warnedProperties$1 = {},
    rARIA$1 = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
    rARIACamel$1 = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
    didWarnValueNull = !1,
    warnedProperties = {},
    EVENT_NAME_REGEX = /^on./,
    INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/,
    rARIA = RegExp("^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
    rARIACamel = RegExp("^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
    isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i,
    currentReplayingEvent = null,
    restoreTarget = null,
    restoreQueue = null,
    isInsideEventHandler = !1,
    passiveBrowserEventsSupported = !1;
  if (canUseDOM) try {
    var options$jscomp$0 = {};
    Object.defineProperty(options$jscomp$0, "passive", {
      get: function () {
        passiveBrowserEventsSupported = !0;
      }
    });
    window.addEventListener("test", options$jscomp$0, options$jscomp$0);
    window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
  } catch (e) {
    passiveBrowserEventsSupported = !1;
  }
  var root = null,
    startText = null,
    fallbackText = null,
    EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    },
    SyntheticEvent = createSyntheticEvent(EventInterface),
    UIEventInterface = assign({}, EventInterface, {
      view: 0,
      detail: 0
    }),
    SyntheticUIEvent = createSyntheticEvent(UIEventInterface),
    lastMovementX,
    lastMovementY,
    lastMouseEvent,
    MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function (event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function (event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function (event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }),
    SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),
    DragEventInterface = assign({}, MouseEventInterface, {
      dataTransfer: 0
    }),
    SyntheticDragEvent = createSyntheticEvent(DragEventInterface),
    FocusEventInterface = assign({}, UIEventInterface, {
      relatedTarget: 0
    }),
    SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),
    AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }),
    SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),
    ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function (event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }),
    SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),
    CompositionEventInterface = assign({}, EventInterface, {
      data: 0
    }),
    SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),
    SyntheticInputEvent = SyntheticCompositionEvent,
    normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    },
    translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    },
    modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    },
    KeyboardEventInterface = assign({}, UIEventInterface, {
      key: function (nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function (event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function (event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function (event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    }),
    SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),
    PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }),
    SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),
    TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }),
    SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),
    TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }),
    SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),
    WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function (event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function (event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }),
    SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),
    ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    }),
    SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),
    END_KEYCODES = [9, 13, 27, 32],
    START_KEYCODE = 229,
    canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,
    documentMode = null;
  canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
  var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,
    useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode),
    SPACEBAR_CODE = 32,
    SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE),
    hasSpaceKeypress = !1,
    isComposing = !1,
    supportedInputTypes = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    },
    activeElement$1 = null,
    activeElementInst$1 = null,
    isInputEventSupported = !1;
  canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
  var objectIs = "function" === typeof Object.is ? Object.is : is,
    skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    activeElement = null,
    activeElementInst = null,
    lastSelection = null,
    mouseDown = !1,
    vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    },
    prefixedEventNames = {},
    style = {};
  canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
  var ANIMATION_END = getVendorPrefixedEventName("animationend"),
    ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),
    ANIMATION_START = getVendorPrefixedEventName("animationstart"),
    TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),
    TRANSITION_START = getVendorPrefixedEventName("transitionstart"),
    TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),
    TRANSITION_END = getVendorPrefixedEventName("transitionend"),
    topLevelEventsToReactNames = new Map(),
    simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(" "),
    OffscreenVisible = 1,
    OffscreenDetached = 2,
    OffscreenPassiveEffectsConnected = 4,
    concurrentQueues = [],
    concurrentQueuesIndex = 0,
    concurrentlyUpdatedLanes = 0,
    emptyContextObject = {};
  Object.freeze(emptyContextObject);
  var resolveFamily = null,
    failedBoundaries = null,
    NoMode = 0,
    ConcurrentMode = 1,
    ProfileMode = 2,
    StrictLegacyMode = 8,
    StrictEffectsMode = 16,
    NoStrictPassiveEffectsMode = 64,
    now = Scheduler.unstable_now,
    renderStartTime = -0,
    commitStartTime = -0,
    profilerStartTime = -1.1,
    profilerEffectDuration = -0,
    currentUpdateIsNested = !1,
    nestedUpdateScheduled = !1,
    ReactStrictModeWarnings = {
      recordUnsafeLifecycleWarnings: function () {},
      flushPendingUnsafeLifecycleWarnings: function () {},
      recordLegacyContextWarning: function () {},
      flushLegacyContextWarning: function () {},
      discardPendingWarnings: function () {}
    },
    pendingComponentWillMountWarnings = [],
    pendingUNSAFE_ComponentWillMountWarnings = [],
    pendingComponentWillReceivePropsWarnings = [],
    pendingUNSAFE_ComponentWillReceivePropsWarnings = [],
    pendingComponentWillUpdateWarnings = [],
    pendingUNSAFE_ComponentWillUpdateWarnings = [],
    didWarnAboutUnsafeLifecycles = new Set();
  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {
    didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && !0 !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && !0 !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && !0 !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
  };
  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {
    var componentWillMountUniqueNames = new Set();
    0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function (fiber) {
      componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
      didWarnAboutUnsafeLifecycles.add(fiber.type);
    }), pendingComponentWillMountWarnings = []);
    var UNSAFE_componentWillMountUniqueNames = new Set();
    0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {
      UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
      didWarnAboutUnsafeLifecycles.add(fiber.type);
    }), pendingUNSAFE_ComponentWillMountWarnings = []);
    var componentWillReceivePropsUniqueNames = new Set();
    0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {
      componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
      didWarnAboutUnsafeLifecycles.add(fiber.type);
    }), pendingComponentWillReceivePropsWarnings = []);
    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();
    0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {
      UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
      didWarnAboutUnsafeLifecycles.add(fiber.type);
    }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
    var componentWillUpdateUniqueNames = new Set();
    0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function (fiber) {
      componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
      didWarnAboutUnsafeLifecycles.add(fiber.type);
    }), pendingComponentWillUpdateWarnings = []);
    var UNSAFE_componentWillUpdateUniqueNames = new Set();
    0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {
      UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
      didWarnAboutUnsafeLifecycles.add(fiber.type);
    }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
    if (0 < UNSAFE_componentWillMountUniqueNames.size) {
      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
      console.error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
    }
    0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames), console.error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s", sortedNames));
    0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames), console.error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", sortedNames));
    0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn("componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
    0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(componentWillReceivePropsUniqueNames), console.warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
    0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn("componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", sortedNames));
  };
  var pendingLegacyContextWarning = new Map(),
    didWarnAboutLegacyContext = new Set();
  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {
    var strictRoot = null;
    for (var node = fiber; null !== node;) node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
    null === strictRoot ? console.error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.") : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
  };
  ReactStrictModeWarnings.flushLegacyContextWarning = function () {
    pendingLegacyContextWarning.forEach(function (fiberArray) {
      if (0 !== fiberArray.length) {
        var firstFiber = fiberArray[0],
          uniqueNames = new Set();
        fiberArray.forEach(function (fiber) {
          uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
          didWarnAboutLegacyContext.add(fiber.type);
        });
        var sortedNames = setToSortedString(uniqueNames);
        runWithFiberInDEV(firstFiber, function () {
          console.error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context", sortedNames);
        });
      }
    });
  };
  ReactStrictModeWarnings.discardPendingWarnings = function () {
    pendingComponentWillMountWarnings = [];
    pendingUNSAFE_ComponentWillMountWarnings = [];
    pendingComponentWillReceivePropsWarnings = [];
    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
    pendingComponentWillUpdateWarnings = [];
    pendingUNSAFE_ComponentWillUpdateWarnings = [];
    pendingLegacyContextWarning = new Map();
  };
  var CapturedStacks = new WeakMap(),
    forkStack = [],
    forkStackIndex = 0,
    treeForkProvider = null,
    treeForkCount = 0,
    idStack = [],
    idStackIndex = 0,
    treeContextProvider = null,
    treeContextId = 1,
    treeContextOverflow = "",
    hydrationParentFiber = null,
    nextHydratableInstance = null,
    isHydrating = !1,
    didSuspendOrErrorDEV = !1,
    hydrationDiffRootDEV = null,
    hydrationErrors = null,
    rootOrSingletonContext = !1,
    HydrationMismatchException = Error("Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),
    SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`"),
    SuspenseyCommitException = Error("Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."),
    noopSuspenseyCommitThenable = {
      then: function () {
        console.error('Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.');
      }
    },
    suspendedThenable = null,
    needsToResetSuspendedThenableDEV = !1,
    callComponent = {
      "react-stack-bottom-frame": function (Component, props, secondArg) {
        var wasRendering = isRendering;
        isRendering = !0;
        try {
          return Component(props, secondArg);
        } finally {
          isRendering = wasRendering;
        }
      }
    },
    callComponentInDEV = callComponent["react-stack-bottom-frame"].bind(callComponent),
    callRender = {
      "react-stack-bottom-frame": function (instance) {
        var wasRendering = isRendering;
        isRendering = !0;
        try {
          return instance.render();
        } finally {
          isRendering = wasRendering;
        }
      }
    },
    callRenderInDEV = callRender["react-stack-bottom-frame"].bind(callRender),
    callComponentDidMount = {
      "react-stack-bottom-frame": function (finishedWork, instance) {
        try {
          instance.componentDidMount();
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    },
    callComponentDidMountInDEV = callComponentDidMount["react-stack-bottom-frame"].bind(callComponentDidMount),
    callComponentDidUpdate = {
      "react-stack-bottom-frame": function (finishedWork, instance, prevProps, prevState, snapshot) {
        try {
          instance.componentDidUpdate(prevProps, prevState, snapshot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    },
    callComponentDidUpdateInDEV = callComponentDidUpdate["react-stack-bottom-frame"].bind(callComponentDidUpdate),
    callComponentDidCatch = {
      "react-stack-bottom-frame": function (instance, errorInfo) {
        var stack = errorInfo.stack;
        instance.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      }
    },
    callComponentDidCatchInDEV = callComponentDidCatch["react-stack-bottom-frame"].bind(callComponentDidCatch),
    callComponentWillUnmount = {
      "react-stack-bottom-frame": function (current, nearestMountedAncestor, instance) {
        try {
          instance.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
    },
    callComponentWillUnmountInDEV = callComponentWillUnmount["react-stack-bottom-frame"].bind(callComponentWillUnmount),
    callCreate = {
      "react-stack-bottom-frame": function (effect) {
        var create = effect.create;
        effect = effect.inst;
        create = create();
        return effect.destroy = create;
      }
    },
    callCreateInDEV = callCreate["react-stack-bottom-frame"].bind(callCreate),
    callDestroy = {
      "react-stack-bottom-frame": function (current, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
    },
    callDestroyInDEV = callDestroy["react-stack-bottom-frame"].bind(callDestroy),
    callLazyInit = {
      "react-stack-bottom-frame": function (lazy) {
        var init = lazy._init;
        return init(lazy._payload);
      }
    },
    callLazyInitInDEV = callLazyInit["react-stack-bottom-frame"].bind(callLazyInit),
    thenableState$1 = null,
    thenableIndexCounter$1 = 0,
    currentDebugInfo = null,
    didWarnAboutMaps;
  var didWarnAboutGenerators = didWarnAboutMaps = !1;
  var ownerHasKeyUseWarning = {};
  var ownerHasFunctionTypeWarning = {};
  var ownerHasSymbolTypeWarning = {};
  warnForMissingKey = function (returnFiber, workInProgress, child) {
    if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
      if ("object" !== typeof child._store) throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
      child._store.validated = 1;
      var componentName = getComponentNameFromFiber(returnFiber),
        componentKey = componentName || "null";
      if (!ownerHasKeyUseWarning[componentKey]) {
        ownerHasKeyUseWarning[componentKey] = !0;
        child = child._owner;
        returnFiber = returnFiber._debugOwner;
        var currentComponentErrorInfo = "";
        returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
        currentComponentErrorInfo || componentName && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName + ">.");
        var childOwnerAppendix = "";
        null != child && returnFiber !== child && (componentName = null, "number" === typeof child.tag ? componentName = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName = child.name), componentName && (childOwnerAppendix = " It was passed a child from " + componentName + "."));
        runWithFiberInDEV(workInProgress, function () {
          console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);
        });
      }
    }
  };
  var reconcileChildFibers = createChildReconciler(!0),
    mountChildFibers = createChildReconciler(!1),
    currentTreeHiddenStackCursor = createCursor(null),
    prevEntangledRenderLanesCursor = createCursor(0),
    suspenseHandlerStackCursor = createCursor(null),
    shellBoundary = null,
    SubtreeSuspenseContextMask = 1,
    ForceSuspenseFallback = 2,
    suspenseStackCursor = createCursor(0),
    NoFlags = 0,
    HasEffect = 1,
    Insertion = 2,
    Layout = 4,
    Passive = 8,
    AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function () {
      var listeners = [],
        signal = this.signal = {
          aborted: !1,
          addEventListener: function (type, listener) {
            listeners.push(listener);
          }
        };
      this.abort = function () {
        signal.aborted = !0;
        listeners.forEach(function (listener) {
          return listener();
        });
      };
    },
    scheduleCallback$2 = Scheduler.unstable_scheduleCallback,
    NormalPriority = Scheduler.unstable_NormalPriority,
    CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0,
      _currentRenderer: null,
      _currentRenderer2: null
    },
    currentEntangledListeners = null,
    currentEntangledPendingCount = 0,
    currentEntangledLane = 0,
    currentEntangledActionThenable = null,
    prevOnStartTransitionFinish = ReactSharedInternals.S;
  ReactSharedInternals.S = function (transition, returnValue) {
    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
    null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
  };
  var resumedCache = createCursor(null),
    didWarnUncachedGetSnapshot;
  var didWarnAboutMismatchedHooksForComponent = new Set();
  var didWarnAboutUseWrappedInTryCatch = new Set();
  var didWarnAboutAsyncClientComponent = new Set();
  var didWarnAboutUseFormState = new Set();
  var renderLanes = 0,
    currentlyRenderingFiber$1 = null,
    currentHook = null,
    workInProgressHook = null,
    didScheduleRenderPhaseUpdate = !1,
    didScheduleRenderPhaseUpdateDuringThisPass = !1,
    shouldDoubleInvokeUserFnsInHooksDEV = !1,
    localIdCounter = 0,
    thenableIndexCounter = 0,
    thenableState = null,
    globalClientIdCounter = 0,
    RE_RENDER_LIMIT = 25,
    currentHookNameInDev = null,
    hookTypesDev = null,
    hookTypesUpdateIndexDev = -1,
    ignorePreviousDependencies = !1;
  var createFunctionComponentUpdateQueue = function () {
    return {
      lastEffect: null,
      events: null,
      stores: null,
      memoCache: null
    };
  };
  var ContextOnlyDispatcher = {
    readContext: readContext,
    use: use,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useInsertionEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useSyncExternalStore: throwInvalidHookError,
    useId: throwInvalidHookError
  };
  ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;
  ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;
  ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;
  ContextOnlyDispatcher.useFormState = throwInvalidHookError;
  ContextOnlyDispatcher.useActionState = throwInvalidHookError;
  ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;
  var HooksDispatcherOnMountInDEV = null,
    HooksDispatcherOnMountWithHookTypesInDEV = null,
    HooksDispatcherOnUpdateInDEV = null,
    HooksDispatcherOnRerenderInDEV = null,
    InvalidNestedHooksDispatcherOnMountInDEV = null,
    InvalidNestedHooksDispatcherOnUpdateInDEV = null,
    InvalidNestedHooksDispatcherOnRerenderInDEV = null;
  HooksDispatcherOnMountInDEV = {
    readContext: function (context) {
      return readContext(context);
    },
    use: use,
    useCallback: function (callback, deps) {
      currentHookNameInDev = "useCallback";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountCallback(callback, deps);
    },
    useContext: function (context) {
      currentHookNameInDev = "useContext";
      mountHookTypesDev();
      return readContext(context);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = "useEffect";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountImperativeHandle(ref, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      mountEffectImpl(4, Insertion, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = "useMemo";
      mountHookTypesDev();
      checkDepsAreArrayDev(deps);
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      mountHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = "useRef";
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = "useState";
      mountHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useDebugValue: function () {
      currentHookNameInDev = "useDebugValue";
      mountHookTypesDev();
    },
    useDeferredValue: function (value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      mountHookTypesDev();
      return mountDeferredValue(value, initialValue);
    },
    useTransition: function () {
      currentHookNameInDev = "useTransition";
      mountHookTypesDev();
      return mountTransition();
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      mountHookTypesDev();
      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId: function () {
      currentHookNameInDev = "useId";
      mountHookTypesDev();
      return mountId();
    },
    useCacheRefresh: function () {
      currentHookNameInDev = "useCacheRefresh";
      mountHookTypesDev();
      return mountRefresh();
    }
  };
  HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;
  HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
  HooksDispatcherOnMountInDEV.useFormState = function (action, initialState) {
    currentHookNameInDev = "useFormState";
    mountHookTypesDev();
    warnOnUseFormStateInDev();
    return mountActionState(action, initialState);
  };
  HooksDispatcherOnMountInDEV.useActionState = function (action, initialState) {
    currentHookNameInDev = "useActionState";
    mountHookTypesDev();
    return mountActionState(action, initialState);
  };
  HooksDispatcherOnMountInDEV.useOptimistic = function (passthrough) {
    currentHookNameInDev = "useOptimistic";
    mountHookTypesDev();
    return mountOptimistic(passthrough);
  };
  HooksDispatcherOnMountWithHookTypesInDEV = {
    readContext: function (context) {
      return readContext(context);
    },
    use: use,
    useCallback: function (callback, deps) {
      currentHookNameInDev = "useCallback";
      updateHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context) {
      currentHookNameInDev = "useContext";
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = "useEffect";
      updateHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      updateHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      updateHookTypesDev();
      mountEffectImpl(4, Insertion, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      updateHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = "useMemo";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = "useRef";
      updateHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = "useState";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useDebugValue: function () {
      currentHookNameInDev = "useDebugValue";
      updateHookTypesDev();
    },
    useDeferredValue: function (value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      updateHookTypesDev();
      return mountDeferredValue(value, initialValue);
    },
    useTransition: function () {
      currentHookNameInDev = "useTransition";
      updateHookTypesDev();
      return mountTransition();
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      updateHookTypesDev();
      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId: function () {
      currentHookNameInDev = "useId";
      updateHookTypesDev();
      return mountId();
    },
    useCacheRefresh: function () {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return mountRefresh();
    }
  };
  HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;
  HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;
  HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function (action, initialState) {
    currentHookNameInDev = "useFormState";
    updateHookTypesDev();
    warnOnUseFormStateInDev();
    return mountActionState(action, initialState);
  };
  HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function (action, initialState) {
    currentHookNameInDev = "useActionState";
    updateHookTypesDev();
    return mountActionState(action, initialState);
  };
  HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function (passthrough) {
    currentHookNameInDev = "useOptimistic";
    updateHookTypesDev();
    return mountOptimistic(passthrough);
  };
  HooksDispatcherOnUpdateInDEV = {
    readContext: function (context) {
      return readContext(context);
    },
    use: use,
    useCallback: function (callback, deps) {
      currentHookNameInDev = "useCallback";
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context) {
      currentHookNameInDev = "useContext";
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = "useEffect";
      updateHookTypesDev();
      updateEffectImpl(2048, Passive, create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      updateHookTypesDev();
      return updateEffectImpl(4, Insertion, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      updateHookTypesDev();
      return updateEffectImpl(4, Layout, create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = "useMemo";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useRef: function () {
      currentHookNameInDev = "useRef";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useState: function () {
      currentHookNameInDev = "useState";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(basicStateReducer);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useDebugValue: function () {
      currentHookNameInDev = "useDebugValue";
      updateHookTypesDev();
    },
    useDeferredValue: function (value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      updateHookTypesDev();
      return updateDeferredValue(value, initialValue);
    },
    useTransition: function () {
      currentHookNameInDev = "useTransition";
      updateHookTypesDev();
      return updateTransition();
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId: function () {
      currentHookNameInDev = "useId";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useCacheRefresh: function () {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    }
  };
  HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;
  HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
  HooksDispatcherOnUpdateInDEV.useFormState = function (action) {
    currentHookNameInDev = "useFormState";
    updateHookTypesDev();
    warnOnUseFormStateInDev();
    return updateActionState(action);
  };
  HooksDispatcherOnUpdateInDEV.useActionState = function (action) {
    currentHookNameInDev = "useActionState";
    updateHookTypesDev();
    return updateActionState(action);
  };
  HooksDispatcherOnUpdateInDEV.useOptimistic = function (passthrough, reducer) {
    currentHookNameInDev = "useOptimistic";
    updateHookTypesDev();
    return updateOptimistic(passthrough, reducer);
  };
  HooksDispatcherOnRerenderInDEV = {
    readContext: function (context) {
      return readContext(context);
    },
    use: use,
    useCallback: function (callback, deps) {
      currentHookNameInDev = "useCallback";
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context) {
      currentHookNameInDev = "useContext";
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = "useEffect";
      updateHookTypesDev();
      updateEffectImpl(2048, Passive, create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      updateHookTypesDev();
      return updateEffectImpl(4, Insertion, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      updateHookTypesDev();
      return updateEffectImpl(4, Layout, create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = "useMemo";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useRef: function () {
      currentHookNameInDev = "useRef";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useState: function () {
      currentHookNameInDev = "useState";
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
      try {
        return rerenderReducer(basicStateReducer);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useDebugValue: function () {
      currentHookNameInDev = "useDebugValue";
      updateHookTypesDev();
    },
    useDeferredValue: function (value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      updateHookTypesDev();
      return rerenderDeferredValue(value, initialValue);
    },
    useTransition: function () {
      currentHookNameInDev = "useTransition";
      updateHookTypesDev();
      return rerenderTransition();
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId: function () {
      currentHookNameInDev = "useId";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useCacheRefresh: function () {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    }
  };
  HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;
  HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
  HooksDispatcherOnRerenderInDEV.useFormState = function (action) {
    currentHookNameInDev = "useFormState";
    updateHookTypesDev();
    warnOnUseFormStateInDev();
    return rerenderActionState(action);
  };
  HooksDispatcherOnRerenderInDEV.useActionState = function (action) {
    currentHookNameInDev = "useActionState";
    updateHookTypesDev();
    return rerenderActionState(action);
  };
  HooksDispatcherOnRerenderInDEV.useOptimistic = function (passthrough, reducer) {
    currentHookNameInDev = "useOptimistic";
    updateHookTypesDev();
    return rerenderOptimistic(passthrough, reducer);
  };
  InvalidNestedHooksDispatcherOnMountInDEV = {
    readContext: function (context) {
      warnInvalidContextAccess();
      return readContext(context);
    },
    use: function (usable) {
      warnInvalidHookAccess();
      return use(usable);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = "useCallback";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountCallback(callback, deps);
    },
    useContext: function (context) {
      currentHookNameInDev = "useContext";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return readContext(context);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = "useEffect";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountEffect(create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountImperativeHandle(ref, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      warnInvalidHookAccess();
      mountHookTypesDev();
      mountEffectImpl(4, Insertion, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountLayoutEffect(create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = "useMemo";
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountMemo(create, deps);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useRef: function (initialValue) {
      currentHookNameInDev = "useRef";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountRef(initialValue);
    },
    useState: function (initialState) {
      currentHookNameInDev = "useState";
      warnInvalidHookAccess();
      mountHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
      try {
        return mountState(initialState);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useDebugValue: function () {
      currentHookNameInDev = "useDebugValue";
      warnInvalidHookAccess();
      mountHookTypesDev();
    },
    useDeferredValue: function (value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountDeferredValue(value, initialValue);
    },
    useTransition: function () {
      currentHookNameInDev = "useTransition";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountTransition();
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId: function () {
      currentHookNameInDev = "useId";
      warnInvalidHookAccess();
      mountHookTypesDev();
      return mountId();
    },
    useCacheRefresh: function () {
      currentHookNameInDev = "useCacheRefresh";
      mountHookTypesDev();
      return mountRefresh();
    },
    useMemoCache: function (size) {
      warnInvalidHookAccess();
      return useMemoCache(size);
    }
  };
  InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;
  InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function (action, initialState) {
    currentHookNameInDev = "useFormState";
    warnInvalidHookAccess();
    mountHookTypesDev();
    return mountActionState(action, initialState);
  };
  InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function (action, initialState) {
    currentHookNameInDev = "useActionState";
    warnInvalidHookAccess();
    mountHookTypesDev();
    return mountActionState(action, initialState);
  };
  InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function (passthrough) {
    currentHookNameInDev = "useOptimistic";
    warnInvalidHookAccess();
    mountHookTypesDev();
    return mountOptimistic(passthrough);
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV = {
    readContext: function (context) {
      warnInvalidContextAccess();
      return readContext(context);
    },
    use: function (usable) {
      warnInvalidHookAccess();
      return use(usable);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = "useCallback";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context) {
      currentHookNameInDev = "useContext";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = "useEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      updateEffectImpl(2048, Passive, create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffectImpl(4, Insertion, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffectImpl(4, Layout, create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = "useMemo";
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useRef: function () {
      currentHookNameInDev = "useRef";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useState: function () {
      currentHookNameInDev = "useState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateReducer(basicStateReducer);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useDebugValue: function () {
      currentHookNameInDev = "useDebugValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
    },
    useDeferredValue: function (value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateDeferredValue(value, initialValue);
    },
    useTransition: function () {
      currentHookNameInDev = "useTransition";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateTransition();
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId: function () {
      currentHookNameInDev = "useId";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useCacheRefresh: function () {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useMemoCache: function (size) {
      warnInvalidHookAccess();
      return useMemoCache(size);
    }
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;
  InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function (action) {
    currentHookNameInDev = "useFormState";
    warnInvalidHookAccess();
    updateHookTypesDev();
    return updateActionState(action);
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function (action) {
    currentHookNameInDev = "useActionState";
    warnInvalidHookAccess();
    updateHookTypesDev();
    return updateActionState(action);
  };
  InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function (passthrough, reducer) {
    currentHookNameInDev = "useOptimistic";
    warnInvalidHookAccess();
    updateHookTypesDev();
    return updateOptimistic(passthrough, reducer);
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV = {
    readContext: function (context) {
      warnInvalidContextAccess();
      return readContext(context);
    },
    use: function (usable) {
      warnInvalidHookAccess();
      return use(usable);
    },
    useCallback: function (callback, deps) {
      currentHookNameInDev = "useCallback";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateCallback(callback, deps);
    },
    useContext: function (context) {
      currentHookNameInDev = "useContext";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return readContext(context);
    },
    useEffect: function (create, deps) {
      currentHookNameInDev = "useEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      updateEffectImpl(2048, Passive, create, deps);
    },
    useImperativeHandle: function (ref, create, deps) {
      currentHookNameInDev = "useImperativeHandle";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateImperativeHandle(ref, create, deps);
    },
    useInsertionEffect: function (create, deps) {
      currentHookNameInDev = "useInsertionEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffectImpl(4, Insertion, create, deps);
    },
    useLayoutEffect: function (create, deps) {
      currentHookNameInDev = "useLayoutEffect";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateEffectImpl(4, Layout, create, deps);
    },
    useMemo: function (create, deps) {
      currentHookNameInDev = "useMemo";
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return updateMemo(create, deps);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useReducer: function (reducer, initialArg, init) {
      currentHookNameInDev = "useReducer";
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return rerenderReducer(reducer, initialArg, init);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useRef: function () {
      currentHookNameInDev = "useRef";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useState: function () {
      currentHookNameInDev = "useState";
      warnInvalidHookAccess();
      updateHookTypesDev();
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
      try {
        return rerenderReducer(basicStateReducer);
      } finally {
        ReactSharedInternals.H = prevDispatcher;
      }
    },
    useDebugValue: function () {
      currentHookNameInDev = "useDebugValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
    },
    useDeferredValue: function (value, initialValue) {
      currentHookNameInDev = "useDeferredValue";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderDeferredValue(value, initialValue);
    },
    useTransition: function () {
      currentHookNameInDev = "useTransition";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return rerenderTransition();
    },
    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {
      currentHookNameInDev = "useSyncExternalStore";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
    },
    useId: function () {
      currentHookNameInDev = "useId";
      warnInvalidHookAccess();
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useCacheRefresh: function () {
      currentHookNameInDev = "useCacheRefresh";
      updateHookTypesDev();
      return updateWorkInProgressHook().memoizedState;
    },
    useMemoCache: function (size) {
      warnInvalidHookAccess();
      return useMemoCache(size);
    }
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;
  InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function (action) {
    currentHookNameInDev = "useFormState";
    warnInvalidHookAccess();
    updateHookTypesDev();
    return rerenderActionState(action);
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function (action) {
    currentHookNameInDev = "useActionState";
    warnInvalidHookAccess();
    updateHookTypesDev();
    return rerenderActionState(action);
  };
  InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function (passthrough, reducer) {
    currentHookNameInDev = "useOptimistic";
    warnInvalidHookAccess();
    updateHookTypesDev();
    return rerenderOptimistic(passthrough, reducer);
  };
  var fakeInternalInstance = {};
  var didWarnAboutStateAssignmentForComponent = new Set();
  var didWarnAboutUninitializedState = new Set();
  var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
  var didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
  var didWarnAboutDirectlyAssigningPropsToState = new Set();
  var didWarnAboutUndefinedDerivedState = new Set();
  var didWarnAboutContextTypes$1 = new Set();
  var didWarnAboutChildContextTypes = new Set();
  var didWarnAboutInvalidateContextType = new Set();
  var didWarnOnInvalidCallback = new Set();
  Object.freeze(fakeInternalInstance);
  var classComponentUpdater = {
      isMounted: function (component) {
        var owner = current;
        if (null !== owner && isRendering && 1 === owner.tag) {
          var instance = owner.stateNode;
          instance._warnedAboutRefsInRender || console.error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(owner) || "A component");
          instance._warnedAboutRefsInRender = !0;
        }
        return (component = component._reactInternals) ? getNearestMountedFiber(component) === component : !1;
      },
      enqueueSetState: function (inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst),
          update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        markStateUpdateScheduled(inst, lane);
      },
      enqueueReplaceState: function (inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst),
          update = createUpdate(lane);
        update.tag = ReplaceState;
        update.payload = payload;
        void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        markStateUpdateScheduled(inst, lane);
      },
      enqueueForceUpdate: function (inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(inst),
          update = createUpdate(lane);
        update.tag = ForceUpdate;
        void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
      }
    },
    reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error: error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    },
    componentName = null,
    errorBoundaryName = null,
    SelectiveHydrationException = Error("This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."),
    didReceiveUpdate = !1;
  var didWarnAboutBadClass = {};
  var didWarnAboutContextTypeOnFunctionComponent = {};
  var didWarnAboutContextTypes = {};
  var didWarnAboutGetDerivedStateOnFunctionComponent = {};
  var didWarnAboutReassigningProps = !1;
  var didWarnAboutRevealOrder = {};
  var didWarnAboutTailOptions = {};
  var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0
    },
    hasWarnedAboutUsingNoValuePropOnContextProvider = !1,
    valueCursor = createCursor(null);
  var rendererCursorDEV = createCursor(null);
  var rendererSigil = {};
  var currentlyRenderingFiber = null,
    lastContextDependency = null,
    isDisallowedContextReadInDEV = !1,
    UpdateState = 0,
    ReplaceState = 1,
    ForceUpdate = 2,
    CaptureUpdate = 3,
    hasForceUpdate = !1;
  var didWarnUpdateInsideUpdate = !1;
  var currentlyProcessingQueue = null;
  var didReadFromEntangledAsyncAction = !1,
    didWarnAboutUndefinedSnapshotBeforeUpdate = null;
  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
  var offscreenSubtreeIsHidden = !1,
    offscreenSubtreeWasHidden = !1,
    needsFormReset = !1,
    PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,
    nextEffect = null,
    inProgressLanes = null,
    inProgressRoot = null,
    shouldFireAfterActiveInstanceBlur = !1,
    hostParent = null,
    hostParentIsContainer = !1,
    currentHoistableRoot = null,
    suspenseyCommitFlag = 8192;
  var hasBadMapPolyfill = !1;
  try {
    var nonExtensibleObject = Object.preventExtensions({});
    new Map([[nonExtensibleObject, null]]);
    new Set([nonExtensibleObject]);
  } catch (e$7) {
    hasBadMapPolyfill = !0;
  }
  var DefaultAsyncDispatcher = {
    getCacheForType: function (resourceType) {
      var cache = readContext(CacheContext),
        cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
      return cacheForType;
    },
    getOwner: function () {
      return current;
    }
  };
  if ("function" === typeof Symbol && Symbol.for) {
    var symbolFor = Symbol.for;
    symbolFor("selector.component");
    symbolFor("selector.has_pseudo_class");
    symbolFor("selector.role");
    symbolFor("selector.test_id");
    symbolFor("selector.text");
  }
  var commitHooks = [],
    PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,
    NoContext = 0,
    RenderContext = 2,
    CommitContext = 4,
    RootInProgress = 0,
    RootFatalErrored = 1,
    RootErrored = 2,
    RootSuspended = 3,
    RootSuspendedWithDelay = 4,
    RootCompleted = 5,
    RootDidNotComplete = 6,
    executionContext = NoContext,
    workInProgressRoot = null,
    workInProgress = null,
    workInProgressRootRenderLanes = 0,
    NotSuspended = 0,
    SuspendedOnError = 1,
    SuspendedOnData = 2,
    SuspendedOnImmediate = 3,
    SuspendedOnInstance = 4,
    SuspendedOnInstanceAndReadyToContinue = 5,
    SuspendedOnDeprecatedThrowPromise = 6,
    SuspendedAndReadyToContinue = 7,
    SuspendedOnHydration = 8,
    workInProgressSuspendedReason = NotSuspended,
    workInProgressThrownValue = null,
    workInProgressRootDidSkipSuspendedSiblings = !1,
    workInProgressRootIsPrerendering = !1,
    workInProgressRootDidAttachPingListener = !1,
    entangledRenderLanes = 0,
    workInProgressRootExitStatus = RootInProgress,
    workInProgressRootSkippedLanes = 0,
    workInProgressRootInterleavedUpdatedLanes = 0,
    workInProgressRootPingedLanes = 0,
    workInProgressDeferredLane = 0,
    workInProgressSuspendedRetryLanes = 0,
    workInProgressRootConcurrentErrors = null,
    workInProgressRootRecoverableErrors = null,
    workInProgressRootDidIncludeRecursiveRenderUpdate = !1,
    globalMostRecentFallbackTime = 0,
    FALLBACK_THROTTLE_MS = 300,
    workInProgressRootRenderTargetTime = Infinity,
    RENDER_TIMEOUT_MS = 500,
    workInProgressTransitions = null,
    legacyErrorBoundariesThatAlreadyFailed = null,
    rootDoesHavePassiveEffects = !1,
    rootWithPendingPassiveEffects = null,
    pendingPassiveEffectsLanes = 0,
    pendingPassiveEffectsRemainingLanes = 0,
    pendingPassiveTransitions = null,
    NESTED_UPDATE_LIMIT = 50,
    nestedUpdateCount = 0,
    rootWithNestedUpdates = null,
    isFlushingPassiveEffects = !1,
    didScheduleUpdateDuringPassiveEffects = !1,
    NESTED_PASSIVE_UPDATE_LIMIT = 50,
    nestedPassiveUpdateCount = 0,
    rootWithPassiveNestedUpdates = null,
    isRunningInsertionEffect = !1,
    IMMEDIATE_COMMIT = 0,
    SUSPENDED_COMMIT = 1,
    THROTTLED_COMMIT = 2,
    didWarnStateUpdateForNotYetMountedComponent = null,
    didWarnAboutUpdateInRender = !1;
  var didWarnAboutUpdateInRenderForAnotherComponent = new Set();
  var fakeActCallbackNode$1 = {},
    firstScheduledRoot = null,
    lastScheduledRoot = null,
    didScheduleMicrotask = !1,
    didScheduleMicrotask_act = !1,
    mightHavePendingSyncWork = !1,
    isFlushingWork = !1,
    currentEventTransitionLane = 0,
    fakeActCallbackNode = {};
  (function () {
    for (var i = 0; i < simpleEventPluginEvents.length; i++) {
      var eventName = simpleEventPluginEvents[i],
        domEventName = eventName.toLowerCase();
      eventName = eventName[0].toUpperCase() + eventName.slice(1);
      registerSimpleEvent(domEventName, "on" + eventName);
    }
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
  })();
  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
  registerTwoPhaseEvent("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  registerTwoPhaseEvent("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  registerTwoPhaseEvent("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  registerTwoPhaseEvent("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  registerTwoPhaseEvent("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    nonDelegatedEvents = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)),
    listeningMarker = "_reactListening" + Math.random().toString(36).slice(2),
    didWarnControlledToUncontrolled = !1,
    didWarnUncontrolledToControlled = !1,
    didWarnFormActionType = !1,
    didWarnFormActionName = !1,
    didWarnFormActionTarget = !1,
    didWarnFormActionMethod = !1,
    didWarnPopoverTargetObject = !1;
  var didWarnForNewBooleanPropsWithEmptyValue = {};
  var canDiffStyleForHydrationWarning = !0;
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g,
    NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g,
    xlinkNamespace = "http://www.w3.org/1999/xlink",
    xmlNamespace = "http://www.w3.org/XML/1998/namespace",
    EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')",
    SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning",
    SUSPENSE_START_DATA = "$",
    SUSPENSE_END_DATA = "/$",
    SUSPENSE_PENDING_START_DATA = "$?",
    SUSPENSE_FALLBACK_START_DATA = "$!",
    FORM_STATE_IS_MATCHING = "F!",
    FORM_STATE_IS_NOT_MATCHING = "F",
    STYLE = "style",
    HostContextNamespaceNone = 0,
    HostContextNamespaceSvg = 1,
    HostContextNamespaceMath = 2,
    eventsEnabled = null,
    selectionInformation = null,
    warnedUnknownTags = {
      dialog: !0,
      webview: !0
    },
    currentPopstateTransitionEvent = null,
    scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,
    cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,
    noTimeout = -1,
    localPromise = "function" === typeof Promise ? Promise : void 0,
    scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function (callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout,
    NotLoaded = 0,
    Loaded = 1,
    Errored = 2,
    Settled = 3,
    Inserted = 4,
    preloadPropsMap = new Map(),
    preconnectsSet = new Set(),
    previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: function () {
      var previousWasRendering = previousDispatcher.f(),
        wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    },
    r: function (form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    },
    D: function (href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    },
    C: function (href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    },
    L: function (href, as, options) {
      previousDispatcher.L(href, as, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
        "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSrcSet) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(options.imageSizes) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key = preloadSelector;
        switch (as) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) || (href = assign({
          rel: "preload",
          href: "image" === as && options && options.imageSrcSet ? void 0 : href,
          as: as
        }, options), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
      }
    },
    m: function (href, options) {
      previousDispatcher.m(href, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as = options && "string" === typeof options.as ? options.as : "script",
          preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]',
          key = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key) && (href = assign({
          rel: "modulepreload",
          href: href
        }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key))) return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    },
    X: function (src, options) {
      previousDispatcher.X(src, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
          key = getScriptKey(src),
          resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
          src: src,
          async: !0
        }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    },
    S: function (href, precedence, options) {
      previousDispatcher.S(href, precedence, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,
          key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state = {
            loading: NotLoaded,
            preload: null
          };
          if (resource = ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) state.loading = Loaded | Inserted;else {
            href = assign({
              rel: "stylesheet",
              href: href,
              "data-precedence": precedence
            }, options);
            (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function (resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function () {
              state.loading |= Loaded;
            });
            link.addEventListener("error", function () {
              state.loading |= Errored;
            });
            state.loading |= Inserted;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state: state
          };
          styles.set(key, resource);
        }
      }
    },
    M: function (src, options) {
      previousDispatcher.M(src, options);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,
          key = getScriptKey(src),
          resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({
          src: src,
          async: !0,
          type: "module"
        }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
  };
  var globalDocument = "undefined" === typeof document ? null : document,
    tagCaches = null,
    suspendedState = null,
    LAST_PRECEDENCE = null,
    precedencesByRoot = null,
    NotPendingTransition = NotPending,
    HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: NotPendingTransition,
      _currentValue2: NotPendingTransition,
      _threadCount: 0
    },
    badgeFormat = "%c%s%c ",
    badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px",
    resetStyle = "",
    pad = " ",
    bind = Function.prototype.bind;
  var didWarnAboutNestedUpdates = !1;
  var overrideHookState = null,
    overrideHookStateDeletePath = null,
    overrideHookStateRenamePath = null,
    overrideProps = null,
    overridePropsDeletePath = null,
    overridePropsRenamePath = null,
    scheduleUpdate = null,
    setErrorHandler = null,
    setSuspenseHandler = null;
  overrideHookState = function (fiber, id, path, value) {
    id = findHook(fiber, id);
    null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
  };
  overrideHookStateDeletePath = function (fiber, id, path) {
    id = findHook(fiber, id);
    null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
  };
  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {
    id = findHook(fiber, id);
    null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
  };
  overrideProps = function (fiber, path, value) {
    fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
    fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
    path = enqueueConcurrentRenderForLane(fiber, 2);
    null !== path && scheduleUpdateOnFiber(path, fiber, 2);
  };
  overridePropsDeletePath = function (fiber, path) {
    fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
    fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
    path = enqueueConcurrentRenderForLane(fiber, 2);
    null !== path && scheduleUpdateOnFiber(path, fiber, 2);
  };
  overridePropsRenamePath = function (fiber, oldPath, newPath) {
    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
    fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
    oldPath = enqueueConcurrentRenderForLane(fiber, 2);
    null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
  };
  scheduleUpdate = function (fiber) {
    var root = enqueueConcurrentRenderForLane(fiber, 2);
    null !== root && scheduleUpdateOnFiber(root, fiber, 2);
  };
  setErrorHandler = function (newShouldErrorImpl) {
    shouldErrorImpl = newShouldErrorImpl;
  };
  setSuspenseHandler = function (newShouldSuspendImpl) {
    shouldSuspendImpl = newShouldSuspendImpl;
  };
  var _enabled = !0,
    return_targetInst = null,
    hasScheduledReplayAttempt = !1,
    queuedFocus = null,
    queuedDrag = null,
    queuedMouse = null,
    queuedPointers = new Map(),
    queuedPointerCaptures = new Map(),
    queuedExplicitHydrationTargets = [],
    discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "),
    lastScheduledReplayQueue = null;
  ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function (children, JSCompiler_OptimizeArgumentsArray_p2) {
    var root = this._internalRoot;
    if (null === root) throw Error("Cannot update an unmounted root.");
    "function" === typeof JSCompiler_OptimizeArgumentsArray_p2 ? console.error("does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : isValidContainer(JSCompiler_OptimizeArgumentsArray_p2) ? console.error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : "undefined" !== typeof JSCompiler_OptimizeArgumentsArray_p2 && console.error("You passed a second argument to root.render(...) but it only accepts one argument.");
    JSCompiler_OptimizeArgumentsArray_p2 = root.current;
    var lane = requestUpdateLane(JSCompiler_OptimizeArgumentsArray_p2);
    updateContainerImpl(JSCompiler_OptimizeArgumentsArray_p2, lane, children, root, null, null);
  };
  ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function (JSCompiler_OptimizeArgumentsArray_p3) {
    "function" === typeof JSCompiler_OptimizeArgumentsArray_p3 && console.error("does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
    JSCompiler_OptimizeArgumentsArray_p3 = this._internalRoot;
    if (null !== JSCompiler_OptimizeArgumentsArray_p3) {
      this._internalRoot = null;
      var container = JSCompiler_OptimizeArgumentsArray_p3.containerInfo;
      (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
      updateContainerSync(null, JSCompiler_OptimizeArgumentsArray_p3, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
  ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {
    if (target) {
      var updatePriority = resolveUpdatePriority();
      target = {
        blockedOn: null,
        target: target,
        priority: updatePriority
      };
      for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++);
      queuedExplicitHydrationTargets.splice(i, 0, target);
      0 === i && attemptExplicitHydrationTarget(target);
    }
  };
  (function () {
    var isomorphicReactPackageVersion = React.version;
    if ("19.0.0" !== isomorphicReactPackageVersion) throw Error('Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.0.0\nLearn more: https://react.dev/warnings/version-mismatch"));
  })();
  "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills");
  ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {
    var fiber = componentOrElement._reactInternals;
    if (void 0 === fiber) {
      if ("function" === typeof componentOrElement.render) throw Error("Unable to find node on an unmounted component.");
      componentOrElement = Object.keys(componentOrElement).join(",");
      throw Error("Argument appears to not be a ReactComponent. Keys: " + componentOrElement);
    }
    componentOrElement = findCurrentFiberUsingSlowPath(fiber);
    componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
    componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
    return componentOrElement;
  };
  if (!function () {
    var internals = {
      bundleType: 1,
      version: "19.0.0",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      findFiberByHostInstance: getClosestInstanceFromNode,
      reconcilerVersion: "19.0.0"
    };
    internals.overrideHookState = overrideHookState;
    internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
    internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
    internals.overrideProps = overrideProps;
    internals.overridePropsDeletePath = overridePropsDeletePath;
    internals.overridePropsRenamePath = overridePropsRenamePath;
    internals.scheduleUpdate = scheduleUpdate;
    internals.setErrorHandler = setErrorHandler;
    internals.setSuspenseHandler = setSuspenseHandler;
    internals.scheduleRefresh = scheduleRefresh;
    internals.scheduleRoot = scheduleRoot;
    internals.setRefreshHandler = setRefreshHandler;
    internals.getCurrentFiber = getCurrentFiberForDevTools;
    internals.getLaneLabelMap = getLaneLabelMap;
    internals.injectProfilingHooks = injectProfilingHooks;
    return injectInternals(internals);
  }() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
    var protocol = window.location.protocol;
    /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""), "font-weight:bold");
  }
  exports.createRoot = function (container, options) {
    if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
    warnIfReactDOMContainerInDEV(container);
    var isStrictMode = !1,
      identifierPrefix = "",
      onUncaughtError = defaultOnUncaughtError,
      onCaughtError = defaultOnCaughtError,
      onRecoverableError = defaultOnRecoverableError,
      transitionCallbacks = null;
    null !== options && void 0 !== options && (options.hydrate ? console.warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"), !0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
    options = createFiberRoot(container, 1, !1, null, null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);
    container[internalContainerInstanceKey] = options.current;
    listenToAllSupportedEvents(8 === container.nodeType ? container.parentNode : container);
    return new ReactDOMRoot(options);
  };
  exports.hydrateRoot = function (container, initialChildren, options) {
    if (!isValidContainer(container)) throw Error("Target container is not a DOM element.");
    warnIfReactDOMContainerInDEV(container);
    void 0 === initialChildren && console.error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
    var isStrictMode = !1,
      identifierPrefix = "",
      onUncaughtError = defaultOnUncaughtError,
      onCaughtError = defaultOnCaughtError,
      onRecoverableError = defaultOnRecoverableError,
      transitionCallbacks = null,
      formState = null;
    null !== options && void 0 !== options && (!0 === options.unstable_strictMode && (isStrictMode = !0), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
    initialChildren = createFiberRoot(container, 1, !0, initialChildren, null != options ? options : null, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState);
    initialChildren.context = getContextForSubtree(null);
    options = initialChildren.current;
    isStrictMode = requestUpdateLane(options);
    identifierPrefix = createUpdate(isStrictMode);
    identifierPrefix.callback = null;
    enqueueUpdate(options, identifierPrefix, isStrictMode);
    initialChildren.current.lanes = isStrictMode;
    markRootUpdated$1(initialChildren, isStrictMode);
    ensureRootIsScheduled(initialChildren);
    container[internalContainerInstanceKey] = initialChildren.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMHydrationRoot(initialChildren);
  };
  exports.version = "19.0.0";
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



 true && function () {
  function noop() {}
  function testStringCoercion(value) {
    return "" + value;
  }
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    try {
      testStringCoercion(key);
      var JSCompiler_inline_result = !1;
    } catch (e) {
      JSCompiler_inline_result = !0;
    }
    JSCompiler_inline_result && (console.error("The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"), testStringCoercion(key));
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children: children,
      containerInfo: containerInfo,
      implementation: implementation
    };
  }
  function getCrossOriginStringAs(as, input) {
    if ("font" === as) return "";
    if ("string" === typeof input) return "use-credentials" === input ? input : "";
  }
  function getValueDescriptorExpectingObjectForWarning(thing) {
    return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
  }
  function getValueDescriptorExpectingEnumForWarning(thing) {
    return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
  }
  function resolveDispatcher() {
    var dispatcher = ReactSharedInternals.H;
    null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    return dispatcher;
  }
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
  var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
    Internals = {
      d: {
        f: noop,
        r: function () {
          throw Error("Invalid form element. requestFormReset must be passed a form that was rendered by React.");
        },
        D: noop,
        C: noop,
        L: noop,
        m: noop,
        X: noop,
        S: noop,
        M: noop
      },
      p: 0,
      findDOMNode: null
    },
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
  exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  exports.createPortal = function (children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType) throw Error("Target container is not a DOM element.");
    return createPortal$1(children, container, null, key);
  };
  exports.flushSync = function (fn) {
    var previousTransition = ReactSharedInternals.T,
      previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
    }
  };
  exports.preconnect = function (href, options) {
    "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error("ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.", getValueDescriptorExpectingEnumForWarning(options)) : null != options && "string" !== typeof options.crossOrigin && console.error("ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.", getValueDescriptorExpectingObjectForWarning(options.crossOrigin)) : console.error("ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  exports.prefetchDNS = function (href) {
    if ("string" !== typeof href || !href) console.error("ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));else if (1 < arguments.length) {
      var options = arguments[1];
      "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options)) : console.error("ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.", getValueDescriptorExpectingEnumForWarning(options));
    }
    "string" === typeof href && Internals.d.D(href);
  };
  exports.preinit = function (href, options) {
    "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error("ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.", getValueDescriptorExpectingEnumForWarning(options)) : "style" !== options.as && "script" !== options.as && console.error('ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".', getValueDescriptorExpectingEnumForWarning(options.as)) : console.error("ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.", getValueDescriptorExpectingObjectForWarning(href));
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as = options.as,
        crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),
        integrity = "string" === typeof options.integrity ? options.integrity : void 0,
        fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as ? Internals.d.S(href, "string" === typeof options.precedence ? options.precedence : void 0, {
        crossOrigin: crossOrigin,
        integrity: integrity,
        fetchPriority: fetchPriority
      }) : "script" === as && Internals.d.X(href, {
        crossOrigin: crossOrigin,
        integrity: integrity,
        fetchPriority: fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  exports.preinitModule = function (href, options) {
    var encountered = "";
    "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
    void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
    if (encountered) console.error("ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s", encountered);else switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
      case "script":
        break;
      default:
        encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error('ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)', encountered, href);
    }
    if ("string" === typeof href) if ("object" === typeof options && null !== options) {
      if (null == options.as || "script" === options.as) encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.M(href, {
        crossOrigin: encountered,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    } else null == options && Internals.d.M(href);
  };
  exports.preload = function (href, options) {
    var encountered = "";
    "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
    null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
    encountered && console.error('ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s', encountered);
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      encountered = options.as;
      var crossOrigin = getCrossOriginStringAs(encountered, options.crossOrigin);
      Internals.d.L(href, encountered, {
        crossOrigin: crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  exports.preloadModule = function (href, options) {
    var encountered = "";
    "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
    void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
    encountered && console.error('ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s', encountered);
    "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(options.as, options.crossOrigin), Internals.d.m(href, {
      as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
      crossOrigin: encountered,
      integrity: "string" === typeof options.integrity ? options.integrity : void 0
    })) : Internals.d.m(href));
  };
  exports.requestFormReset = function (form) {
    Internals.d.r(form);
  };
  exports.unstable_batchedUpdates = function (fn, a) {
    return fn(a);
  };
  exports.useFormState = function (action, initialState, permalink) {
    return resolveDispatcher().useFormState(action, initialState, permalink);
  };
  exports.useFormStatus = function () {
    return resolveDispatcher().useHostTransitionStatus();
  };
  exports.version = "19.0.0";
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();

/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}
if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom-client.development.js */ "./node_modules/react-dom/cjs/react-dom-client.development.js");
}

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}
if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}

/***/ }),

/***/ "./node_modules/react-refresh/cjs/react-refresh-runtime.development.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/react-refresh/cjs/react-refresh-runtime.development.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React vundefined
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



if (true) {
  (function () {
    'use strict';

    // ATTENTION
    // When adding new symbols to this file,
    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
    // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = 0xeac7;
    var REACT_PORTAL_TYPE = 0xeaca;
    var REACT_FRAGMENT_TYPE = 0xeacb;
    var REACT_STRICT_MODE_TYPE = 0xeacc;
    var REACT_PROFILER_TYPE = 0xead2;
    var REACT_PROVIDER_TYPE = 0xeacd;
    var REACT_CONTEXT_TYPE = 0xeace;
    var REACT_FORWARD_REF_TYPE = 0xead0;
    var REACT_SUSPENSE_TYPE = 0xead1;
    var REACT_SUSPENSE_LIST_TYPE = 0xead8;
    var REACT_MEMO_TYPE = 0xead3;
    var REACT_LAZY_TYPE = 0xead4;
    var REACT_SCOPE_TYPE = 0xead7;
    var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
    var REACT_OFFSCREEN_TYPE = 0xeae2;
    var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
    var REACT_CACHE_TYPE = 0xeae4;
    if (typeof Symbol === 'function' && Symbol.for) {
      var symbolFor = Symbol.for;
      REACT_ELEMENT_TYPE = symbolFor('react.element');
      REACT_PORTAL_TYPE = symbolFor('react.portal');
      REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
      REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
      REACT_PROFILER_TYPE = symbolFor('react.profiler');
      REACT_PROVIDER_TYPE = symbolFor('react.provider');
      REACT_CONTEXT_TYPE = symbolFor('react.context');
      REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
      REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
      REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
      REACT_MEMO_TYPE = symbolFor('react.memo');
      REACT_LAZY_TYPE = symbolFor('react.lazy');
      REACT_SCOPE_TYPE = symbolFor('react.scope');
      REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
      REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
      REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
      REACT_CACHE_TYPE = symbolFor('react.cache');
    }
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
    // It's OK to reference families, but use WeakMap/Set for types.

    var allFamiliesByID = new Map();
    var allFamiliesByType = new PossiblyWeakMap();
    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
    // that have actually been edited here. This keeps checks fast.
    // $FlowIssue

    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
    // It is an array of [Family, NextType] tuples.

    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.

    var helpersByRendererID = new Map();
    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.

    var mountedRoots = new Set(); // If a root captures an error, we remember it so we can retry on edit.

    var failedRoots = new Set(); // In environments that support WeakMap, we also remember the last element for every root.
    // It needs to be weak because we do this even for roots that failed to mount.
    // If there is no WeakMap, we won't attempt to do retrying.
    // $FlowIssue

    var rootElements =
    // $FlowIssue
    typeof WeakMap === 'function' ? new WeakMap() : null;
    var isPerformingRefresh = false;
    function computeFullKey(signature) {
      if (signature.fullKey !== null) {
        return signature.fullKey;
      }
      var fullKey = signature.ownKey;
      var hooks;
      try {
        hooks = signature.getCustomHooks();
      } catch (err) {
        // This can happen in an edge case, e.g. if expression like Foo.useSomething
        // depends on Foo which is lazily initialized during rendering.
        // In that case just assume we'll have to remount.
        signature.forceReset = true;
        signature.fullKey = fullKey;
        return fullKey;
      }
      for (var i = 0; i < hooks.length; i++) {
        var hook = hooks[i];
        if (typeof hook !== 'function') {
          // Something's wrong. Assume we need to remount.
          signature.forceReset = true;
          signature.fullKey = fullKey;
          return fullKey;
        }
        var nestedHookSignature = allSignaturesByType.get(hook);
        if (nestedHookSignature === undefined) {
          // No signature means Hook wasn't in the source code, e.g. in a library.
          // We'll skip it because we can assume it won't change during this session.
          continue;
        }
        var nestedHookKey = computeFullKey(nestedHookSignature);
        if (nestedHookSignature.forceReset) {
          signature.forceReset = true;
        }
        fullKey += '\n---\n' + nestedHookKey;
      }
      signature.fullKey = fullKey;
      return fullKey;
    }
    function haveEqualSignatures(prevType, nextType) {
      var prevSignature = allSignaturesByType.get(prevType);
      var nextSignature = allSignaturesByType.get(nextType);
      if (prevSignature === undefined && nextSignature === undefined) {
        return true;
      }
      if (prevSignature === undefined || nextSignature === undefined) {
        return false;
      }
      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
        return false;
      }
      if (nextSignature.forceReset) {
        return false;
      }
      return true;
    }
    function isReactClass(type) {
      return type.prototype && type.prototype.isReactComponent;
    }
    function canPreserveStateBetween(prevType, nextType) {
      if (isReactClass(prevType) || isReactClass(nextType)) {
        return false;
      }
      if (haveEqualSignatures(prevType, nextType)) {
        return true;
      }
      return false;
    }
    function resolveFamily(type) {
      // Only check updated types to keep lookups fast.
      return updatedFamiliesByType.get(type);
    } // If we didn't care about IE11, we could use new Map/Set(iterable).

    function cloneMap(map) {
      var clone = new Map();
      map.forEach(function (value, key) {
        clone.set(key, value);
      });
      return clone;
    }
    function cloneSet(set) {
      var clone = new Set();
      set.forEach(function (value) {
        clone.add(value);
      });
      return clone;
    } // This is a safety mechanism to protect against rogue getters and Proxies.

    function getProperty(object, property) {
      try {
        return object[property];
      } catch (err) {
        // Intentionally ignore.
        return undefined;
      }
    }
    function performReactRefresh() {
      if (pendingUpdates.length === 0) {
        return null;
      }
      if (isPerformingRefresh) {
        return null;
      }
      isPerformingRefresh = true;
      try {
        var staleFamilies = new Set();
        var updatedFamilies = new Set();
        var updates = pendingUpdates;
        pendingUpdates = [];
        updates.forEach(function (_ref) {
          var family = _ref[0],
            nextType = _ref[1];
          // Now that we got a real edit, we can create associations
          // that will be read by the React reconciler.
          var prevType = family.current;
          updatedFamiliesByType.set(prevType, family);
          updatedFamiliesByType.set(nextType, family);
          family.current = nextType; // Determine whether this should be a re-render or a re-mount.

          if (canPreserveStateBetween(prevType, nextType)) {
            updatedFamilies.add(family);
          } else {
            staleFamilies.add(family);
          }
        }); // TODO: rename these fields to something more meaningful.

        var update = {
          updatedFamilies: updatedFamilies,
          // Families that will re-render preserving state
          staleFamilies: staleFamilies // Families that will be remounted
        };
        helpersByRendererID.forEach(function (helpers) {
          // Even if there are no roots, set the handler on first update.
          // This ensures that if *new* roots are mounted, they'll use the resolve handler.
          helpers.setRefreshHandler(resolveFamily);
        });
        var didError = false;
        var firstError = null; // We snapshot maps and sets that are mutated during commits.
        // If we don't do this, there is a risk they will be mutated while
        // we iterate over them. For example, trying to recover a failed root
        // may cause another root to be added to the failed list -- an infinite loop.

        var failedRootsSnapshot = cloneSet(failedRoots);
        var mountedRootsSnapshot = cloneSet(mountedRoots);
        var helpersByRootSnapshot = cloneMap(helpersByRoot);
        failedRootsSnapshot.forEach(function (root) {
          var helpers = helpersByRootSnapshot.get(root);
          if (helpers === undefined) {
            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
          }
          if (!failedRoots.has(root)) {// No longer failed.
          }
          if (rootElements === null) {
            return;
          }
          if (!rootElements.has(root)) {
            return;
          }
          var element = rootElements.get(root);
          try {
            helpers.scheduleRoot(root, element);
          } catch (err) {
            if (!didError) {
              didError = true;
              firstError = err;
            } // Keep trying other roots.
          }
        });
        mountedRootsSnapshot.forEach(function (root) {
          var helpers = helpersByRootSnapshot.get(root);
          if (helpers === undefined) {
            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
          }
          if (!mountedRoots.has(root)) {// No longer mounted.
          }
          try {
            helpers.scheduleRefresh(root, update);
          } catch (err) {
            if (!didError) {
              didError = true;
              firstError = err;
            } // Keep trying other roots.
          }
        });
        if (didError) {
          throw firstError;
        }
        return update;
      } finally {
        isPerformingRefresh = false;
      }
    }
    function register(type, id) {
      {
        if (type === null) {
          return;
        }
        if (typeof type !== 'function' && typeof type !== 'object') {
          return;
        } // This can happen in an edge case, e.g. if we register
        // return value of a HOC but it returns a cached component.
        // Ignore anything but the first registration for each type.

        if (allFamiliesByType.has(type)) {
          return;
        } // Create family or remember to update it.
        // None of this bookkeeping affects reconciliation
        // until the first performReactRefresh() call above.

        var family = allFamiliesByID.get(id);
        if (family === undefined) {
          family = {
            current: type
          };
          allFamiliesByID.set(id, family);
        } else {
          pendingUpdates.push([family, type]);
        }
        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.

        if (typeof type === 'object' && type !== null) {
          switch (getProperty(type, '$$typeof')) {
            case REACT_FORWARD_REF_TYPE:
              register(type.render, id + '$render');
              break;
            case REACT_MEMO_TYPE:
              register(type.type, id + '$type');
              break;
          }
        }
      }
    }
    function setSignature(type, key) {
      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
      {
        if (!allSignaturesByType.has(type)) {
          allSignaturesByType.set(type, {
            forceReset: forceReset,
            ownKey: key,
            fullKey: null,
            getCustomHooks: getCustomHooks || function () {
              return [];
            }
          });
        } // Visit inner types because we might not have signed them.

        if (typeof type === 'object' && type !== null) {
          switch (getProperty(type, '$$typeof')) {
            case REACT_FORWARD_REF_TYPE:
              setSignature(type.render, key, forceReset, getCustomHooks);
              break;
            case REACT_MEMO_TYPE:
              setSignature(type.type, key, forceReset, getCustomHooks);
              break;
          }
        }
      }
    } // This is lazily called during first render for a type.
    // It captures Hook list at that time so inline requires don't break comparisons.

    function collectCustomHooksForSignature(type) {
      {
        var signature = allSignaturesByType.get(type);
        if (signature !== undefined) {
          computeFullKey(signature);
        }
      }
    }
    function getFamilyByID(id) {
      {
        return allFamiliesByID.get(id);
      }
    }
    function getFamilyByType(type) {
      {
        return allFamiliesByType.get(type);
      }
    }
    function findAffectedHostInstances(families) {
      {
        var affectedInstances = new Set();
        mountedRoots.forEach(function (root) {
          var helpers = helpersByRoot.get(root);
          if (helpers === undefined) {
            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
          }
          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
          instancesForRoot.forEach(function (inst) {
            affectedInstances.add(inst);
          });
        });
        return affectedInstances;
      }
    }
    function injectIntoGlobalHook(globalObject) {
      {
        // For React Native, the global hook will be set up by require('react-devtools-core').
        // That code will run before us. So we need to monkeypatch functions on existing hook.
        // For React Web, the global hook will be set up by the extension.
        // This will also run before us.
        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook === undefined) {
          // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
          // Note that in this case it's important that renderer code runs *after* this method call.
          // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
          var nextID = 0;
          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
            renderers: new Map(),
            supportsFiber: true,
            inject: function (injected) {
              return nextID++;
            },
            onScheduleFiberRoot: function (id, root, children) {},
            onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},
            onCommitFiberUnmount: function () {}
          };
        }
        if (hook.isDisabled) {
          // This isn't a real property on the hook, but it can be set to opt out
          // of DevTools integration and associated warnings and logs.
          // Using console['warn'] to evade Babel and ESLint
          console['warn']('Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' + 'Fast Refresh is not compatible with this shim and will be disabled.');
          return;
        } // Here, we just want to get a reference to scheduleRefresh.

        var oldInject = hook.inject;
        hook.inject = function (injected) {
          var id = oldInject.apply(this, arguments);
          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
            // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
          }
          return id;
        }; // Do the same for any already injected roots.
        // This is useful if ReactDOM has already been initialized.
        // https://github.com/facebook/react/issues/17626

        hook.renderers.forEach(function (injected, id) {
          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
            // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
          }
        }); // We also want to track currently mounted roots.

        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;
        var oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || function () {};
        hook.onScheduleFiberRoot = function (id, root, children) {
          if (!isPerformingRefresh) {
            // If it was intentionally scheduled, don't attempt to restore.
            // This includes intentionally scheduled unmounts.
            failedRoots.delete(root);
            if (rootElements !== null) {
              rootElements.set(root, children);
            }
          }
          return oldOnScheduleFiberRoot.apply(this, arguments);
        };
        hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {
          var helpers = helpersByRendererID.get(id);
          if (helpers !== undefined) {
            helpersByRoot.set(root, helpers);
            var current = root.current;
            var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
            // This logic is copy-pasted from similar logic in the DevTools backend.
            // If this breaks with some refactoring, you'll want to update DevTools too.

            if (alternate !== null) {
              var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
              var isMounted = current.memoizedState != null && current.memoizedState.element != null;
              if (!wasMounted && isMounted) {
                // Mount a new root.
                mountedRoots.add(root);
                failedRoots.delete(root);
              } else if (wasMounted && isMounted) ;else if (wasMounted && !isMounted) {
                // Unmount an existing root.
                mountedRoots.delete(root);
                if (didError) {
                  // We'll remount it on future edits.
                  failedRoots.add(root);
                } else {
                  helpersByRoot.delete(root);
                }
              } else if (!wasMounted && !isMounted) {
                if (didError) {
                  // We'll remount it on future edits.
                  failedRoots.add(root);
                }
              }
            } else {
              // Mount a new root.
              mountedRoots.add(root);
            }
          } // Always call the decorated DevTools hook.

          return oldOnCommitFiberRoot.apply(this, arguments);
        };
      }
    }
    function hasUnrecoverableErrors() {
      // TODO: delete this after removing dependency in RN.
      return false;
    } // Exposed for testing.

    function _getMountedRootCount() {
      {
        return mountedRoots.size;
      }
    } // This is a wrapper over more primitive functions for setting signature.
    // Signatures let us decide whether the Hook order has changed on refresh.
    //
    // This function is intended to be used as a transform target, e.g.:
    // var _s = createSignatureFunctionForTransform()
    //
    // function Hello() {
    //   const [foo, setFoo] = useState(0);
    //   const value = useCustomHook();
    //   _s(); /* Call without arguments triggers collecting the custom Hook list.
    //          * This doesn't happen during the module evaluation because we
    //          * don't want to change the module order with inline requires.
    //          * Next calls are noops. */
    //   return <h1>Hi</h1>;
    // }
    //
    // /* Call with arguments attaches the signature to the type: */
    // _s(
    //   Hello,
    //   'useState{[foo, setFoo]}(0)',
    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
    // );

    function createSignatureFunctionForTransform() {
      {
        var savedType;
        var hasCustomHooks;
        var didCollectHooks = false;
        return function (type, key, forceReset, getCustomHooks) {
          if (typeof key === 'string') {
            // We're in the initial phase that associates signatures
            // with the functions. Note this may be called multiple times
            // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).
            if (!savedType) {
              // We're in the innermost call, so this is the actual type.
              savedType = type;
              hasCustomHooks = typeof getCustomHooks === 'function';
            } // Set the signature for all types (even wrappers!) in case
            // they have no signatures of their own. This is to prevent
            // problems like https://github.com/facebook/react/issues/20417.

            if (type != null && (typeof type === 'function' || typeof type === 'object')) {
              setSignature(type, key, forceReset, getCustomHooks);
            }
            return type;
          } else {
            // We're in the _s() call without arguments, which means
            // this is the time to collect custom Hook signatures.
            // Only do this once. This path is hot and runs *inside* every render!
            if (!didCollectHooks && hasCustomHooks) {
              didCollectHooks = true;
              collectCustomHooksForSignature(savedType);
            }
          }
        };
      }
    }
    function isLikelyComponentType(type) {
      {
        switch (typeof type) {
          case 'function':
            {
              // First, deal with classes.
              if (type.prototype != null) {
                if (type.prototype.isReactComponent) {
                  // React class.
                  return true;
                }
                var ownNames = Object.getOwnPropertyNames(type.prototype);
                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
                  // This looks like a class.
                  return false;
                } // eslint-disable-next-line no-proto

                if (type.prototype.__proto__ !== Object.prototype) {
                  // It has a superclass.
                  return false;
                } // Pass through.
                // This looks like a regular function with empty prototype.
              } // For plain functions and arrows, use name as a heuristic.

              var name = type.name || type.displayName;
              return typeof name === 'string' && /^[A-Z]/.test(name);
            }
          case 'object':
            {
              if (type != null) {
                switch (getProperty(type, '$$typeof')) {
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_MEMO_TYPE:
                    // Definitely React components.
                    return true;
                  default:
                    return false;
                }
              }
              return false;
            }
          default:
            {
              return false;
            }
        }
      }
    }
    exports._getMountedRootCount = _getMountedRootCount;
    exports.collectCustomHooksForSignature = collectCustomHooksForSignature;
    exports.createSignatureFunctionForTransform = createSignatureFunctionForTransform;
    exports.findAffectedHostInstances = findAffectedHostInstances;
    exports.getFamilyByID = getFamilyByID;
    exports.getFamilyByType = getFamilyByType;
    exports.hasUnrecoverableErrors = hasUnrecoverableErrors;
    exports.injectIntoGlobalHook = injectIntoGlobalHook;
    exports.isLikelyComponentType = isLikelyComponentType;
    exports.performReactRefresh = performReactRefresh;
    exports.register = register;
    exports.setSignature = setSignature;
  })();
}

/***/ }),

/***/ "./node_modules/react-refresh/runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react-refresh/runtime.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-refresh-runtime.development.js */ "./node_modules/react-refresh/cjs/react-refresh-runtime.development.js");
}

/***/ }),

/***/ "./node_modules/react-router/dist/development/chunk-GNGMS2XR.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/react-router/dist/development/chunk-GNGMS2XR.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Action: () => (/* binding */ Action),
/* harmony export */   Await: () => (/* binding */ Await),
/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),
/* harmony export */   DataRouterContext: () => (/* binding */ DataRouterContext),
/* harmony export */   DataRouterStateContext: () => (/* binding */ DataRouterStateContext),
/* harmony export */   ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),
/* harmony export */   FetchersContext: () => (/* binding */ FetchersContext),
/* harmony export */   Form: () => (/* binding */ Form),
/* harmony export */   FrameworkContext: () => (/* binding */ FrameworkContext),
/* harmony export */   HashRouter: () => (/* binding */ HashRouter),
/* harmony export */   HistoryRouter: () => (/* binding */ HistoryRouter),
/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),
/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),
/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),
/* harmony export */   Link: () => (/* binding */ Link),
/* harmony export */   Links: () => (/* binding */ Links),
/* harmony export */   LocationContext: () => (/* binding */ LocationContext),
/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),
/* harmony export */   Meta: () => (/* binding */ Meta),
/* harmony export */   NavLink: () => (/* binding */ NavLink),
/* harmony export */   Navigate: () => (/* binding */ Navigate),
/* harmony export */   NavigationContext: () => (/* binding */ NavigationContext),
/* harmony export */   Outlet: () => (/* binding */ Outlet),
/* harmony export */   PrefetchPageLinks: () => (/* binding */ PrefetchPageLinks),
/* harmony export */   RemixErrorBoundary: () => (/* binding */ RemixErrorBoundary),
/* harmony export */   Route: () => (/* binding */ Route),
/* harmony export */   RouteContext: () => (/* binding */ RouteContext),
/* harmony export */   Router: () => (/* binding */ Router),
/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),
/* harmony export */   Routes: () => (/* binding */ Routes),
/* harmony export */   Scripts: () => (/* binding */ Scripts),
/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),
/* harmony export */   ServerMode: () => (/* binding */ ServerMode),
/* harmony export */   ServerRouter: () => (/* binding */ ServerRouter),
/* harmony export */   SingleFetchRedirectSymbol: () => (/* binding */ SingleFetchRedirectSymbol),
/* harmony export */   StaticRouter: () => (/* binding */ StaticRouter),
/* harmony export */   StaticRouterProvider: () => (/* binding */ StaticRouterProvider),
/* harmony export */   ViewTransitionContext: () => (/* binding */ ViewTransitionContext),
/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),
/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),
/* harmony export */   createClientRoutes: () => (/* binding */ createClientRoutes),
/* harmony export */   createClientRoutesWithHMRRevalidationOptOut: () => (/* binding */ createClientRoutesWithHMRRevalidationOptOut),
/* harmony export */   createCookie: () => (/* binding */ createCookie),
/* harmony export */   createCookieSessionStorage: () => (/* binding */ createCookieSessionStorage),
/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),
/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),
/* harmony export */   createMemorySessionStorage: () => (/* binding */ createMemorySessionStorage),
/* harmony export */   createPath: () => (/* binding */ createPath),
/* harmony export */   createRequestHandler: () => (/* binding */ createRequestHandler),
/* harmony export */   createRouter: () => (/* binding */ createRouter),
/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),
/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromElements),
/* harmony export */   createRoutesStub: () => (/* binding */ createRoutesStub),
/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),
/* harmony export */   createSession: () => (/* binding */ createSession),
/* harmony export */   createSessionStorage: () => (/* binding */ createSessionStorage),
/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler2),
/* harmony export */   createStaticRouter: () => (/* binding */ createStaticRouter),
/* harmony export */   data: () => (/* binding */ data),
/* harmony export */   decodeViaTurboStream: () => (/* binding */ decodeViaTurboStream),
/* harmony export */   deserializeErrors: () => (/* binding */ deserializeErrors2),
/* harmony export */   generatePath: () => (/* binding */ generatePath),
/* harmony export */   getPatchRoutesOnNavigationFunction: () => (/* binding */ getPatchRoutesOnNavigationFunction),
/* harmony export */   getSingleFetchDataStrategy: () => (/* binding */ getSingleFetchDataStrategy),
/* harmony export */   href: () => (/* binding */ href),
/* harmony export */   invariant: () => (/* binding */ invariant),
/* harmony export */   isCookie: () => (/* binding */ isCookie),
/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),
/* harmony export */   isSession: () => (/* binding */ isSession),
/* harmony export */   mapRouteProperties: () => (/* binding */ mapRouteProperties),
/* harmony export */   matchPath: () => (/* binding */ matchPath),
/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),
/* harmony export */   parsePath: () => (/* binding */ parsePath),
/* harmony export */   redirect: () => (/* binding */ redirect),
/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),
/* harmony export */   renderMatches: () => (/* binding */ renderMatches),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   resolvePath: () => (/* binding */ resolvePath),
/* harmony export */   setDevServerHooks: () => (/* binding */ setDevServerHooks),
/* harmony export */   shouldHydrateRouteLoader: () => (/* binding */ shouldHydrateRouteLoader),
/* harmony export */   unstable_RouterContextProvider: () => (/* binding */ unstable_RouterContextProvider),
/* harmony export */   unstable_createContext: () => (/* binding */ unstable_createContext),
/* harmony export */   useActionData: () => (/* binding */ useActionData),
/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),
/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),
/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),
/* harmony export */   useBlocker: () => (/* binding */ useBlocker),
/* harmony export */   useFetcher: () => (/* binding */ useFetcher),
/* harmony export */   useFetchers: () => (/* binding */ useFetchers),
/* harmony export */   useFogOFWarDiscovery: () => (/* binding */ useFogOFWarDiscovery),
/* harmony export */   useFormAction: () => (/* binding */ useFormAction),
/* harmony export */   useHref: () => (/* binding */ useHref),
/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),
/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),
/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),
/* harmony export */   useLocation: () => (/* binding */ useLocation),
/* harmony export */   useMatch: () => (/* binding */ useMatch),
/* harmony export */   useMatches: () => (/* binding */ useMatches),
/* harmony export */   useNavigate: () => (/* binding */ useNavigate),
/* harmony export */   useNavigation: () => (/* binding */ useNavigation),
/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),
/* harmony export */   useOutlet: () => (/* binding */ useOutlet),
/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),
/* harmony export */   useParams: () => (/* binding */ useParams),
/* harmony export */   usePrompt: () => (/* binding */ usePrompt),
/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),
/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),
/* harmony export */   useRouteError: () => (/* binding */ useRouteError),
/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),
/* harmony export */   useRoutes: () => (/* binding */ useRoutes),
/* harmony export */   useScrollRestoration: () => (/* binding */ useScrollRestoration),
/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),
/* harmony export */   useSubmit: () => (/* binding */ useSubmit),
/* harmony export */   useViewTransitionState: () => (/* binding */ useViewTransitionState)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var turbo_stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! turbo-stream */ "./node_modules/turbo-stream/dist/turbo-stream.mjs");
/* harmony import */ var cookie__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! cookie */ "./node_modules/react-router/node_modules/cookie/dist/index.js");
/* harmony import */ var set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! set-cookie-parser */ "./node_modules/set-cookie-parser/lib/set-cookie.js");
/**
 * react-router v7.4.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var __typeError = msg => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);

// lib/router/history.ts
var Action = /* @__PURE__ */(Action2 => {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
  return Action2;
})(Action || {});
var PopStateEventType = "popstate";
function createMemoryHistory(options = {}) {
  let {
    initialEntries = ["/"],
    initialIndex,
    v5Compat = false
  } = options;
  let entries;
  entries = initialEntries.map((entry, index2) => createMemoryLocation(entry, typeof entry === "string" ? null : entry.state, index2 === 0 ? "default" : void 0));
  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);
  let action = "POP" /* Pop */;
  let listener = null;
  function clampIndex(n) {
    return Math.min(Math.max(n, 0), entries.length - 1);
  }
  function getCurrentLocation() {
    return entries[index];
  }
  function createMemoryLocation(to, state = null, key) {
    let location = createLocation(entries ? getCurrentLocation().pathname : "/", to, state, key);
    warning(location.pathname.charAt(0) === "/", `relative pathnames are not supported in memory history: ${JSON.stringify(to)}`);
    return location;
  }
  function createHref2(to) {
    return typeof to === "string" ? to : createPath(to);
  }
  let history = {
    get index() {
      return index;
    },
    get action() {
      return action;
    },
    get location() {
      return getCurrentLocation();
    },
    createHref: createHref2,
    createURL(to) {
      return new URL(createHref2(to), "http://localhost");
    },
    encodeLocation(to) {
      let path = typeof to === "string" ? parsePath(to) : to;
      return {
        pathname: path.pathname || "",
        search: path.search || "",
        hash: path.hash || ""
      };
    },
    push(to, state) {
      action = "PUSH" /* Push */;
      let nextLocation = createMemoryLocation(to, state);
      index += 1;
      entries.splice(index, entries.length, nextLocation);
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 1
        });
      }
    },
    replace(to, state) {
      action = "REPLACE" /* Replace */;
      let nextLocation = createMemoryLocation(to, state);
      entries[index] = nextLocation;
      if (v5Compat && listener) {
        listener({
          action,
          location: nextLocation,
          delta: 0
        });
      }
    },
    go(delta) {
      action = "POP" /* Pop */;
      let nextIndex = clampIndex(index + delta);
      let nextLocation = entries[nextIndex];
      index = nextIndex;
      if (listener) {
        listener({
          action,
          location: nextLocation,
          delta
        });
      }
    },
    listen(fn) {
      listener = fn;
      return () => {
        listener = null;
      };
    }
  };
  return history;
}
function createBrowserHistory(options = {}) {
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function createHashHistory(options = {}) {
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash = ""
    } = parsePath(window2.location.hash.substring(1));
    if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
      pathname = "/" + pathname;
    }
    return createLocation("", {
      pathname,
      search,
      hash
    },
    // state defaults to `null` because `window.history.state` does
    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || "default");
  }
  function createHashHref(window2, to) {
    let base = window2.document.querySelector("base");
    let href2 = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href2 = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href2 + "#" + (typeof to === "string" ? to : createPath(to));
  }
  function validateHashLocation(location, to) {
    warning(location.pathname.charAt(0) === "/", `relative pathnames are not supported in hash history.push(${JSON.stringify(to)})`);
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {}
  }
}
function createKey() {
  return Math.random().toString(36).substring(2, 10);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state = null, key) {
  let location = {
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: "",
    ...(typeof to === "string" ? parsePath(to) : to),
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  };
  return location;
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref2, validateLocation, options = {}) {
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = "POP" /* Pop */;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState({
      ...globalHistory.state,
      idx: index
    }, "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = "POP" /* Pop */;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = "PUSH" /* Push */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to, state) {
    action = "REPLACE" /* Replace */;
    let location = createLocation(history.location, to, state);
    if (validateLocation) validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href2 = typeof to === "string" ? to : createPath(to);
    href2 = href2.replace(/ $/, "%20");
    invariant(base, `No window.location.(origin|href) available to create URL for href: ${href2}`);
    return new URL(href2, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref2(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n) {
      return globalHistory.go(n);
    }
  };
  return history;
}

// lib/router/utils.ts
function unstable_createContext(defaultValue) {
  return {
    defaultValue
  };
}
var _map;
var unstable_RouterContextProvider = class {
  constructor(init) {
    __privateAdd(this, _map, /* @__PURE__ */new Map());
    if (init) {
      for (let [context, value] of init) {
        this.set(context, value);
      }
    }
  }
  get(context) {
    if (__privateGet(this, _map).has(context)) {
      return __privateGet(this, _map).get(context);
    }
    if (context.defaultValue !== void 0) {
      return context.defaultValue;
    }
    throw new Error("No value found for context");
  }
  set(context, value) {
    __privateGet(this, _map).set(context, value);
  }
};
_map = new WeakMap();
var immutableRouteKeys = /* @__PURE__ */new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath = [], manifest = {}) {
  return routes.map((route, index) => {
    let treePath = [...parentPath, String(index)];
    let id = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, `Cannot specify children on an index route`);
    invariant(!manifest[id], `Found a route id collision on id "${id}".  Route id's must be globally unique within Data Router usages`);
    if (isIndexRoute(route)) {
      let indexRoute = {
        ...route,
        ...mapRouteProperties2(route),
        id
      };
      manifest[id] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = {
        ...route,
        ...mapRouteProperties2(route),
        id,
        children: void 0
      };
      manifest[id] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i], decoded, allowPartial);
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let {
    route,
    pathname,
    params
  } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "") {
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`);
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route.index !== true, `Index routes must not have child routes. Please remove all child routes from route path "${path}".`);
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map(subpath => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(exploded => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = s => s === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ?
  // If two routes are siblings, we should try to match the earlier sibling
  // first. This allows people to have fine-grained control over the matching
  // behavior by simply putting routes with identical paths in the order they
  // want them tried.
  a[a.length - 1] - b[b.length - 1] :
  // Otherwise, it doesn't really make sense to rank non-siblings by index,
  // so they sort equally.
  0;
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function generatePath(originalPath, params = {}) {
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`);
    path = path.replace(/\*$/, "/*");
  }
  const prefix = path.startsWith("/") ? "/" : "";
  const stringify = p => p == null ? "" : typeof p === "string" ? p : String(p);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;
    if (isLastSegment && segment === "*") {
      const star = "*";
      return stringify(params[star]);
    }
    const keyMatch = segment.match(/^:([\w-]+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, `Missing ":${key}" param`);
      return stringify(param);
    }
    return segment.replace(/\?$/g, "");
  }).filter(segment => !!segment);
  return prefix + segments.join("/");
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce((memo2, {
    paramName,
    isOptional
  }, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index];
    if (isOptional && !value) {
      memo2[paramName] = void 0;
    } else {
      memo2[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`);
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else {}
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map(v => decodeURIComponent(v).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error}).`);
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach(segment => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(path)}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map((match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = {
      ...toArg
    };
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = paths => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = pathname => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = search => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = hash => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
var DataWithResponseInit = class {
  constructor(data2, init) {
    this.type = "DataWithResponseInit";
    this.data = data2;
    this.init = init || null;
  }
};
function data(data2, init) {
  return new DataWithResponseInit(data2, typeof init === "number" ? {
    status: init
  } : init);
}
var redirect = (url, init = 302) => {
  let responseInit = init;
  if (typeof responseInit === "number") {
    responseInit = {
      status: responseInit
    };
  } else if (typeof responseInit.status === "undefined") {
    responseInit.status = 302;
  }
  let headers = new Headers(responseInit.headers);
  headers.set("Location", url);
  return new Response(null, {
    ...responseInit,
    headers
  });
};
var redirectDocument = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Reload-Document", "true");
  return response;
};
var replace = (url, init) => {
  let response = redirect(url, init);
  response.headers.set("X-Remix-Replace", "true");
  return response;
};
var ErrorResponseImpl = class {
  constructor(status, statusText, data2, internal = false) {
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data2 instanceof Error) {
      this.data = data2.toString();
      this.error = data2;
    } else {
      this.data = data2;
    }
  }
};
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}

// lib/router/router.ts
var validMutationMethodsArr = ["POST", "PUT", "PATCH", "DELETE"];
var validMutationMethods = new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["GET", ...validMutationMethodsArr];
var validRequestMethods = new Set(validRequestMethodsArr);
var redirectStatusCodes = /* @__PURE__ */new Set([301, 302, 303, 307, 308]);
var redirectPreserveMethodStatusCodes = /* @__PURE__ */new Set([307, 308]);
var IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
var IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var defaultMapRouteProperties = route => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
var TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
var ResetLoaderDataSymbol = Symbol("ResetLoaderData");
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties2 = init.mapRouteProperties || defaultMapRouteProperties;
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  let dataStrategyImpl = init.dataStrategy || defaultDataStrategyWithMiddleware;
  let future = {
    unstable_middleware: false,
    ...init.future
  };
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */new Set();
  let savedScrollPositions2 = null;
  let getScrollRestorationKey2 = null;
  let getScrollPosition = null;
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialMatchesIsFOW = false;
  let initialErrors = null;
  if (initialMatches == null && !init.patchRoutesOnNavigation) {
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  if (initialMatches && !init.hydrationData) {
    let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);
    if (fogOfWar.active) {
      initialMatches = null;
    }
  }
  let initialized;
  if (!initialMatches) {
    initialized = false;
    initialMatches = [];
    let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);
    if (fogOfWar.active && fogOfWar.matches) {
      initialMatchesIsFOW = true;
      initialMatches = fogOfWar.matches;
    }
  } else if (initialMatches.some(m => m.route.lazy)) {
    initialized = false;
  } else if (!initialMatches.some(m => m.route.loader)) {
    initialized = true;
  } else {
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    if (errors) {
      let idx = initialMatches.findIndex(m => errors[m.route.id] !== void 0);
      initialized = initialMatches.slice(0, idx + 1).every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
    } else {
      initialized = initialMatches.every(m => !shouldLoadRouteOnHydration(m.route, loaderData, errors));
    }
  }
  let router;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */new Map(),
    blockers: /* @__PURE__ */new Map()
  };
  let pendingAction = "POP" /* Pop */;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let pendingViewTransitionEnabled = false;
  let appliedViewTransitions = /* @__PURE__ */new Map();
  let removePageHideEventListener = null;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledFetcherLoads = /* @__PURE__ */new Set();
  let fetchControllers = /* @__PURE__ */new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */new Map();
  let fetchRedirectIds = /* @__PURE__ */new Set();
  let fetchLoadMatches = /* @__PURE__ */new Map();
  let activeFetchers = /* @__PURE__ */new Map();
  let fetchersQueuedForDeletion = /* @__PURE__ */new Set();
  let blockerFunctions = /* @__PURE__ */new Map();
  let unblockBlockerHistoryUpdate = void 0;
  let pendingRevalidationDfd = null;
  function initialize() {
    unlistenHistory = init.history.listen(({
      action: historyAction,
      location,
      delta
    }) => {
      if (unblockBlockerHistoryUpdate) {
        unblockBlockerHistoryUpdate();
        unblockBlockerHistoryUpdate = void 0;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location,
        historyAction
      });
      if (blockerKey && delta != null) {
        let nextHistoryUpdatePromise = new Promise(resolve => {
          unblockBlockerHistoryUpdate = resolve;
        });
        init.history.go(delta * -1);
        updateBlocker(blockerKey, {
          state: "blocked",
          location,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location
            });
            nextHistoryUpdatePromise.then(() => init.history.go(delta));
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location);
    });
    if (isBrowser2) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    if (!state.initialized) {
      startNavigation("POP" /* Pop */, state.location, {
        initialHydration: true
      });
    }
    return router;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_, key) => deleteFetcher(key));
    state.blockers.forEach((_, key) => deleteBlocker(key));
  }
  function subscribe(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  function updateState(newState, opts = {}) {
    state = {
      ...state,
      ...newState
    };
    let unmountedFetchers = [];
    let mountedFetchers = [];
    state.fetchers.forEach((fetcher, key) => {
      if (fetcher.state === "idle") {
        if (fetchersQueuedForDeletion.has(key)) {
          unmountedFetchers.push(key);
        } else {
          mountedFetchers.push(key);
        }
      }
    });
    fetchersQueuedForDeletion.forEach(key => {
      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
        unmountedFetchers.push(key);
      }
    });
    [...subscribers].forEach(subscriber => subscriber(state, {
      deletedFetchers: unmountedFetchers,
      viewTransitionOpts: opts.viewTransitionOpts,
      flushSync: opts.flushSync === true
    }));
    unmountedFetchers.forEach(key => deleteFetcher(key));
    mountedFetchers.forEach(key => state.fetchers.delete(key));
  }
  function completeNavigation(location, newState, {
    flushSync
  } = {}) {
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && location.state?._isRedirect !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && location.state?._isRedirect !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation) {} else if (pendingAction === "POP" /* Pop */) {} else if (pendingAction === "PUSH" /* Push */) {
      init.history.push(location, location.state);
    } else if (pendingAction === "REPLACE" /* Replace */) {
      init.history.replace(location, location.state);
    }
    let viewTransitionOpts;
    if (pendingAction === "POP" /* Pop */) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location
        };
      } else if (appliedViewTransitions.has(location.pathname)) {
        viewTransitionOpts = {
          currentLocation: location,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location.pathname);
      } else {
        toPaths = /* @__PURE__ */new Set([location.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location
      };
    }
    updateState({
      ...newState,
      // matches, errors, fetchers go through as-is
      actionData,
      loaderData,
      historyAction: pendingAction,
      location,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }, {
      viewTransitionOpts,
      flushSync: flushSync === true
    });
    pendingAction = "POP" /* Pop */;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    pendingRevalidationDfd?.resolve();
    pendingRevalidationDfd = null;
  }
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, to, opts?.fromRouteId, opts?.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = {
      ...nextLocation,
      ...init.history.encodeLocation(nextLocation)
    };
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = "PUSH" /* Push */;
    if (userReplace === true) {
      historyAction = "REPLACE" /* Replace */;
    } else if (userReplace === false) {} else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = "REPLACE" /* Replace */;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let flushSync = (opts && opts.flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.viewTransition,
      flushSync
    });
  }
  function revalidate() {
    if (!pendingRevalidationDfd) {
      pendingRevalidationDfd = createDeferred();
    }
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    let promise = pendingRevalidationDfd.promise;
    if (state.navigation.state === "submitting") {
      return promise;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return promise;
    }
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation,
      // Proxy through any rending view transition
      enableViewTransition: pendingViewTransitionEnabled === true
    });
    return promise;
  }
  async function startNavigation(historyAction, location, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = opts?.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ?
    // `matchRoutes()` has already been called if we're in here via `router.initialize()`
    state.matches : matchRoutes(routesToUse, location, basename);
    let flushSync = (opts && opts.flushSync) === true;
    if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location, {
        matches
      }, {
        flushSync
      });
      return;
    }
    let fogOfWar = checkFogOfWar(matches, routesToUse, location.pathname);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      let {
        error,
        notFoundMatches,
        route
      } = handleNavigational404(location.pathname);
      completeNavigation(location, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);
    let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);
    let pendingActionResult;
    if (opts && opts.pendingError) {
      pendingActionResult = [findNearestBoundary(matches).route.id, {
        type: "error" /* error */,
        error: opts.pendingError
      }];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(request, location, opts.submission, matches, scopedContext, fogOfWar.active, {
        replace: opts.replace,
        flushSync
      });
      if (actionResult.shortCircuited) {
        return;
      }
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult;
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null;
          completeNavigation(location, {
            matches: actionResult.matches,
            loaderData: {},
            errors: {
              [routeId]: result.error
            }
          });
          return;
        }
      }
      matches = actionResult.matches || matches;
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location, opts.submission);
      flushSync = false;
      fogOfWar.active = false;
      request = createClientSideRequest(init.history, request.url, request.signal);
    }
    let {
      shortCircuited,
      matches: updatedMatches,
      loaderData,
      errors
    } = await handleLoaders(request, location, matches, scopedContext, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location, {
      matches: updatedMatches || matches,
      ...getActionDataForCommit(pendingActionResult),
      loaderData,
      errors
    });
  }
  async function handleAction(request, location, submission, matches, scopedContext, isFogOfWar, opts = {}) {
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [boundaryId, {
            type: "error" /* error */,
            error: discoverResult.error
          }]
        };
      } else if (!discoverResult.matches) {
        let {
          notFoundMatches,
          error,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          pendingActionResult: [route.id, {
            type: "error" /* error */,
            error
          }]
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let result;
    let actionMatch = getTargetMatch(matches, location);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: "error" /* error */,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy("action", request, [actionMatch], matches, scopedContext, null);
      result = results[actionMatch.route.id];
      if (!result) {
        for (let match of matches) {
          if (results[match.route.id]) {
            result = results[match.route.id];
            break;
          }
        }
      }
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace2;
      if (opts && opts.replace != null) {
        replace2 = opts.replace;
      } else {
        let location2 = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
        replace2 = location2 === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, true, {
        submission,
        replace: replace2
      });
      return {
        shortCircuited: true
      };
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = "PUSH" /* Push */;
      }
      return {
        matches,
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      matches,
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  async function handleLoaders(request, location, matches, scopedContext, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace2, initialHydration, flushSync, pendingActionResult) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let shouldUpdateNavigationState = !isUninterruptedRevalidation && !initialHydration;
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult);
        updateState({
          navigation: loadingNavigation,
          ...(actionData !== void 0 ? {
            actionData
          } : {})
        }, {
          flushSync
        });
      }
      let discoverResult = await discoverRoutes(matches, location.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: {
            [boundaryId]: discoverResult.error
          }
        };
      } else if (!discoverResult.matches) {
        let {
          error,
          notFoundMatches,
          route
        } = handleNavigational404(location.pathname);
        return {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, initialHydration === true, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(location, {
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null,
        ...getActionDataForCommit(pendingActionResult),
        ...(updatedFetchers2 ? {
          fetchers: new Map(state.fetchers)
        } : {})
      }, {
        flushSync
      });
      return {
        shortCircuited: true
      };
    }
    if (shouldUpdateNavigationState) {
      let updates = {};
      if (!isFogOfWar) {
        updates.navigation = loadingNavigation;
        let actionData = getUpdatedActionData(pendingActionResult);
        if (actionData !== void 0) {
          updates.actionData = actionData;
        }
      }
      if (revalidatingFetchers.length > 0) {
        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
      }
      updateState(updates, {
        flushSync
      });
    }
    revalidatingFetchers.forEach(rf => {
      abortFetcher(rf.key);
      if (rf.controller) {
        fetchControllers.set(rf.key, rf.controller);
      }
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(matches, matchesToLoad, revalidatingFetchers, request, scopedContext);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace2
      });
      return {
        shortCircuited: true
      };
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      await startRedirectNavigation(request, redirect2.result, true, {
        replace: replace2
      });
      return {
        shortCircuited: true
      };
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults);
    if (initialHydration && state.errors) {
      errors = {
        ...state.errors,
        ...errors
      };
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return {
      matches,
      loaderData,
      errors,
      ...(shouldUpdateFetchers ? {
        fetchers: new Map(state.fetchers)
      } : {})
    };
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
      return {
        [pendingActionResult[0]]: pendingActionResult[1].data
      };
    } else if (state.actionData) {
      if (Object.keys(state.actionData).length === 0) {
        return null;
      } else {
        return state.actionData;
      }
    }
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    revalidatingFetchers.forEach(rf => {
      let fetcher = state.fetchers.get(rf.key);
      let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
      state.fetchers.set(rf.key, revalidatingFetcher);
    });
    return new Map(state.fetchers);
  }
  async function fetch2(key, routeId, href2, opts) {
    abortFetcher(key);
    let flushSync = (opts && opts.flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, href2, routeId, opts?.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match = getTargetMatch(matches, path);
    let scopedContext = new unstable_RouterContextProvider(init.unstable_getContext ? await init.unstable_getContext() : void 0);
    let preventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      await handleFetcherAction(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);
      return;
    }
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    await handleFetcherLoader(key, routeId, path, match, matches, scopedContext, fogOfWar.active, flushSync, preventScrollReset, submission);
  }
  async function handleFetcherAction(key, routeId, path, match, requestMatches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    function detectAndHandle405Error(m) {
      if (!m.route.action && !m.route.lazy) {
        let error = getInternalRouterError(405, {
          method: submission.formMethod,
          pathname: path,
          routeId
        });
        setFetcherError(key, routeId, error, {
          flushSync
        });
        return true;
      }
      return false;
    }
    if (!isFogOfWar && detectAndHandle405Error(match)) {
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(requestMatches, path, fetchRequest.signal, key);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      } else {
        requestMatches = discoverResult.matches;
        match = getTargetMatch(requestMatches, path);
        if (detectAndHandle405Error(match)) {
          return;
        }
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy("action", fetchRequest, [match], requestMatches, scopedContext, key);
    let actionResult = actionResults[match.route.id];
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (fetchersQueuedForDeletion.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, false, {
            fetcherSubmission: submission,
            preventScrollReset
          });
        }
      }
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match.route.id, actionResult]);
    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {
      let staleKey = rf.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
      state.fetchers.set(staleKey, revalidatingFetcher);
      abortFetcher(staleKey);
      if (rf.controller) {
        fetchControllers.set(staleKey, rf.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(matches, matchesToLoad, revalidatingFetchers, revalidationRequest, scopedContext);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));
    let redirect2 = findRedirect(loaderResults);
    if (redirect2) {
      return startRedirectNavigation(revalidationRequest, redirect2.result, false, {
        preventScrollReset
      });
    }
    redirect2 = findRedirect(fetcherResults);
    if (redirect2) {
      fetchRedirectIds.add(redirect2.key);
      return startRedirectNavigation(revalidationRequest, redirect2.result, false, {
        preventScrollReset
      });
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults);
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match, matches, scopedContext, isFogOfWar, flushSync, preventScrollReset, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, path, fetchRequest.signal, key);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      } else {
        matches = discoverResult.matches;
        match = getTargetMatch(matches, path);
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy("loader", fetchRequest, [match], matches, scopedContext, key);
    let result = results[match.route.id];
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (fetchersQueuedForDeletion.has(key)) {
      updateFetcherState(key, getDoneFetcher(void 0));
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result, false, {
          preventScrollReset
        });
        return;
      }
    }
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  async function startRedirectNavigation(request, redirect2, isNavigation, {
    submission,
    fetcherSubmission,
    preventScrollReset,
    replace: replace2
  } = {}) {
    if (redirect2.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location = redirect2.response.headers.get("Location");
    invariant(location, "Expected a Location header on the redirect Response");
    location = normalizeRedirectLocation(location, new URL(request.url), basename);
    let redirectLocation = createLocation(state.location, location, {
      _isRedirect: true
    });
    if (isBrowser2) {
      let isDocumentReload = false;
      if (redirect2.response.headers.has("X-Remix-Reload-Document")) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX.test(location)) {
        const url = init.history.createURL(location);
        isDocumentReload =
        // Hard reload if it's an absolute URL to a new origin
        url.origin !== routerWindow.location.origin ||
        // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace2) {
          routerWindow.location.replace(location);
        } else {
          routerWindow.location.assign(location);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectNavigationType = replace2 === true || redirect2.response.headers.has("X-Remix-Replace") ? "REPLACE" /* Replace */ : "PUSH" /* Push */;
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect2.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectNavigationType, redirectLocation, {
        submission: {
          ...activeSubmission,
          formAction: location
        },
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    } else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectNavigationType, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    }
  }
  async function callDataStrategy(type, request, matchesToLoad, matches, scopedContext, fetcherKey) {
    let results;
    let dataResults = {};
    try {
      results = await callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, scopedContext, future.unstable_middleware);
    } catch (e) {
      matchesToLoad.forEach(m => {
        dataResults[m.route.id] = {
          type: "error" /* error */,
          error: e
        };
      });
      return dataResults;
    }
    for (let [routeId, result] of Object.entries(results)) {
      if (isRedirectDataStrategyResult(result)) {
        let response = result.result;
        dataResults[routeId] = {
          type: "redirect" /* redirect */,
          response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename)
        };
      } else {
        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);
      }
    }
    return dataResults;
  }
  async function callLoadersAndMaybeResolveData(matches, matchesToLoad, fetchersToLoad, request, scopedContext) {
    let loaderResultsPromise = callDataStrategy("loader", request, matchesToLoad, matches, scopedContext, null);
    let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async f => {
      if (f.matches && f.match && f.controller) {
        let results = await callDataStrategy("loader", createClientSideRequest(init.history, f.path, f.controller.signal), [f.match], f.matches, scopedContext, f.key);
        let result = results[f.match.route.id];
        return {
          [f.key]: result
        };
      } else {
        return Promise.resolve({
          [f.key]: {
            type: "error" /* error */,
            error: getInternalRouterError(404, {
              pathname: f.path
            })
          }
        });
      }
    }));
    let loaderResults = await loaderResultsPromise;
    let fetcherResults = (await fetcherResultsPromise).reduce((acc, r) => Object.assign(acc, r), {});
    return {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    fetchLoadMatches.forEach((_, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.add(key);
      }
      abortFetcher(key);
    });
  }
  function updateFetcherState(key, fetcher, opts = {}) {
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function setFetcherError(key, routeId, error, opts = {}) {
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function getFetcher(key) {
    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
    if (fetchersQueuedForDeletion.has(key)) {
      fetchersQueuedForDeletion.delete(key);
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    fetchersQueuedForDeletion.delete(key);
    cancelledFetcherLoads.delete(key);
    state.fetchers.delete(key);
  }
  function queueFetcherForDeletion(key) {
    let count = (activeFetchers.get(key) || 0) - 1;
    if (count <= 0) {
      activeFetchers.delete(key);
      fetchersQueuedForDeletion.add(key);
    } else {
      activeFetchers.set(key, count);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    if (controller) {
      controller.abort();
      fetchControllers.delete(key);
    }
  }
  function markFetchersDone(keys) {
    for (let key of keys) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, `Expected fetcher: ${key}`);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", `Invalid blocker state transition: ${blocker.state} -> ${newBlocker.state}`);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation({
    currentLocation,
    nextLocation,
    historyAction
  }) {
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function handleNavigational404(pathname) {
    let error = getInternalRouterError(404, {
      pathname
    });
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let {
      matches,
      route
    } = getShortCircuitMatches(routesToUse);
    return {
      notFoundMatches: matches,
      route,
      error
    };
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions2 = positions;
    getScrollPosition = getPosition;
    getScrollRestorationKey2 = getKey || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y = getSavedScrollPosition(state.location, state.matches);
      if (y != null) {
        updateState({
          restoreScrollPosition: y
        });
      }
    }
    return () => {
      savedScrollPositions2 = null;
      getScrollPosition = null;
      getScrollRestorationKey2 = null;
    };
  }
  function getScrollKey(location, matches) {
    if (getScrollRestorationKey2) {
      let key = getScrollRestorationKey2(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));
      return key || location.key;
    }
    return location.key;
  }
  function saveScrollPosition(location, matches) {
    if (savedScrollPositions2 && getScrollPosition) {
      let key = getScrollKey(location, matches);
      savedScrollPositions2[key] = getScrollPosition();
    }
  }
  function getSavedScrollPosition(location, matches) {
    if (savedScrollPositions2) {
      let key = getScrollKey(location, matches);
      let y = savedScrollPositions2[key];
      if (typeof y === "number") {
        return y;
      }
    }
    return null;
  }
  function checkFogOfWar(matches, routesToUse, pathname) {
    if (init.patchRoutesOnNavigation) {
      if (!matches) {
        let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
        return {
          active: true,
          matches: fogMatches || []
        };
      } else {
        if (Object.keys(matches[0].params).length > 0) {
          let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
          return {
            active: true,
            matches: partialMatches
          };
        }
      }
    }
    return {
      active: false,
      matches: null
    };
  }
  async function discoverRoutes(matches, pathname, signal, fetcherKey) {
    if (!init.patchRoutesOnNavigation) {
      return {
        type: "success",
        matches
      };
    }
    let partialMatches = matches;
    while (true) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let localManifest = manifest;
      try {
        await init.patchRoutesOnNavigation({
          signal,
          path: pathname,
          matches: partialMatches,
          fetcherKey,
          patch: (routeId, children) => {
            if (signal.aborted) return;
            patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);
          }
        });
      } catch (e) {
        return {
          type: "error",
          error: e,
          partialMatches
        };
      } finally {
        if (isNonHMR && !signal.aborted) {
          dataRoutes = [...dataRoutes];
        }
      }
      if (signal.aborted) {
        return {
          type: "aborted"
        };
      }
      let newMatches = matchRoutes(routesToUse, pathname, basename);
      if (newMatches) {
        return {
          type: "success",
          matches: newMatches
        };
      }
      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m, i) => m.route.id === newPartialMatches[i].route.id)) {
        return {
          type: "success",
          matches: null
        };
      }
      partialMatches = newPartialMatches;
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
  }
  function patchRoutes(routeId, children) {
    let isNonHMR = inFlightDataRoutes == null;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);
    if (isNonHMR) {
      dataRoutes = [...dataRoutes];
      updateState({});
    }
  }
  router = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe,
    enableScrollRestoration,
    navigate,
    fetch: fetch2,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: to => init.history.createHref(to),
    encodeLocation: to => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: queueFetcherForDeletion,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router;
}
function createStaticHandler(routes, opts) {
  invariant(routes.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let manifest = {};
  let basename = (opts ? opts.basename : null) || "/";
  let mapRouteProperties2 = opts?.mapRouteProperties || defaultMapRouteProperties;
  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties2, void 0, manifest);
  async function query(request, {
    requestContext,
    filterMatchesToLoad,
    skipLoaderErrorBubbling,
    skipRevalidation,
    dataStrategy,
    unstable_respond: respond
  } = {}) {
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();
    if (!isValidMethod(method) && method !== "HEAD") {
      let error = getInternalRouterError(405, {
        method
      });
      let {
        matches: methodNotAllowedMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      let staticContext = {
        basename,
        location,
        matches: methodNotAllowedMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
      return respond ? respond(staticContext) : staticContext;
    } else if (!matches) {
      let error = getInternalRouterError(404, {
        pathname: location.pathname
      });
      let {
        matches: notFoundMatches,
        route
      } = getShortCircuitMatches(dataRoutes);
      let staticContext = {
        basename,
        location,
        matches: notFoundMatches,
        loaderData: {},
        actionData: null,
        errors: {
          [route.id]: error
        },
        statusCode: error.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
      return respond ? respond(staticContext) : staticContext;
    }
    if (respond && matches.some(m => m.route.unstable_middleware)) {
      invariant(requestContext instanceof unstable_RouterContextProvider, "When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`");
      try {
        let renderedStaticContext;
        let response = await runMiddlewarePipeline({
          request,
          matches,
          params: matches[0].params,
          // If we're calling middleware then it must be enabled so we can cast
          // this to the proper type knowing it's not an `AppLoadContext`
          context: requestContext
        }, true, async () => {
          let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);
          if (isResponse(result2)) {
            return result2;
          }
          renderedStaticContext = {
            location,
            basename,
            ...result2
          };
          let res = await respond(renderedStaticContext);
          return res;
        }, async (error, routeId) => {
          if (isResponse(error)) {
            return error;
          }
          if (renderedStaticContext) {
            if (routeId in renderedStaticContext.loaderData) {
              renderedStaticContext.loaderData[routeId] = void 0;
            }
            return respond(getStaticContextFromError(dataRoutes, renderedStaticContext, error, findNearestBoundary(matches, routeId).route.id));
          } else {
            let loaderIdx = matches.findIndex(m => m.route.loader);
            let boundary = loaderIdx >= 0 ? findNearestBoundary(matches, matches[loaderIdx].route.id) : findNearestBoundary(matches);
            return respond({
              matches,
              location,
              basename,
              loaderData: {},
              actionData: null,
              errors: {
                [boundary.route.id]: error
              },
              statusCode: isRouteErrorResponse(error) ? error.status : 500,
              actionHeaders: {},
              loaderHeaders: {}
            });
          }
        });
        invariant(isResponse(response), "Expected a response in query()");
        return response;
      } catch (e) {
        if (isResponse(e)) {
          return e;
        }
        throw e;
      }
    }
    let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, skipLoaderErrorBubbling === true, null, filterMatchesToLoad || null, skipRevalidation === true);
    if (isResponse(result)) {
      return result;
    }
    return {
      location,
      basename,
      ...result
    };
  }
  async function queryRoute(request, {
    routeId,
    requestContext,
    dataStrategy,
    unstable_respond: respond
  } = {}) {
    let url = new URL(request.url);
    let method = request.method;
    let location = createLocation("", createPath(url), null, "default");
    let matches = matchRoutes(dataRoutes, location, basename);
    requestContext = requestContext != null ? requestContext : new unstable_RouterContextProvider();
    if (!isValidMethod(method) && method !== "HEAD" && method !== "OPTIONS") {
      throw getInternalRouterError(405, {
        method
      });
    } else if (!matches) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);
    if (routeId && !match) {
      throw getInternalRouterError(403, {
        pathname: location.pathname,
        routeId
      });
    } else if (!match) {
      throw getInternalRouterError(404, {
        pathname: location.pathname
      });
    }
    if (respond && matches.some(m => m.route.unstable_middleware)) {
      invariant(requestContext instanceof unstable_RouterContextProvider, "When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`");
      let response = await runMiddlewarePipeline({
        request,
        matches,
        params: matches[0].params,
        // If we're calling middleware then it must be enabled so we can cast
        // this to the proper type knowing it's not an `AppLoadContext`
        context: requestContext
      }, true, async () => {
        let result2 = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);
        if (isResponse(result2)) {
          return respond(result2);
        }
        let error2 = result2.errors ? Object.values(result2.errors)[0] : void 0;
        if (error2 !== void 0) {
          throw error2;
        }
        let value = result2.actionData ? Object.values(result2.actionData)[0] : Object.values(result2.loaderData)[0];
        return typeof value === "string" ? new Response(value) : Response.json(value);
      }, error2 => {
        if (isResponse(error2)) {
          return respond(error2);
        }
        return new Response(String(error2), {
          status: 500,
          statusText: "Unexpected Server Error"
        });
      });
      return response;
    }
    let result = await queryImpl(request, location, matches, requestContext, dataStrategy || null, false, match, null, false);
    if (isResponse(result)) {
      return result;
    }
    let error = result.errors ? Object.values(result.errors)[0] : void 0;
    if (error !== void 0) {
      throw error;
    }
    if (result.actionData) {
      return Object.values(result.actionData)[0];
    }
    if (result.loaderData) {
      return Object.values(result.loaderData)[0];
    }
    return void 0;
  }
  async function queryImpl(request, location, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, skipRevalidation) {
    invariant(request.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (isMutationMethod(request.method)) {
        let result2 = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch != null, filterMatchesToLoad, skipRevalidation);
        return result2;
      }
      let result = await loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad);
      return isResponse(result) ? result : {
        ...result,
        actionData: null,
        actionHeaders: {}
      };
    } catch (e) {
      if (isDataStrategyResult(e) && isResponse(e.result)) {
        if (e.type === "error" /* error */) {
          throw e.result;
        }
        return e.result;
      }
      if (isRedirectResponse(e)) {
        return e;
      }
      throw e;
    }
  }
  async function submit(request, matches, actionMatch, requestContext, dataStrategy, skipLoaderErrorBubbling, isRouteRequest, filterMatchesToLoad, skipRevalidation) {
    let result;
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      let error = getInternalRouterError(405, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: actionMatch.route.id
      });
      if (isRouteRequest) {
        throw error;
      }
      result = {
        type: "error" /* error */,
        error
      };
    } else {
      let results = await callDataStrategy("action", request, [actionMatch], matches, isRouteRequest, requestContext, dataStrategy);
      result = results[actionMatch.route.id];
      if (request.signal.aborted) {
        throwStaticHandlerAbortedError(request, isRouteRequest);
      }
    }
    if (isRedirectResult(result)) {
      throw new Response(null, {
        status: result.response.status,
        headers: {
          Location: result.response.headers.get("Location")
        }
      });
    }
    if (isRouteRequest) {
      if (isErrorResult(result)) {
        throw result.error;
      }
      return {
        matches: [actionMatch],
        loaderData: {},
        actionData: {
          [actionMatch.route.id]: result.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }
    if (skipRevalidation) {
      if (isErrorResult(result)) {
        let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
        return {
          statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
          actionData: null,
          actionHeaders: {
            ...(result.headers ? {
              [actionMatch.route.id]: result.headers
            } : {})
          },
          matches,
          loaderData: {},
          errors: {
            [boundaryMatch.route.id]: result.error
          },
          loaderHeaders: {}
        };
      } else {
        return {
          actionData: {
            [actionMatch.route.id]: result.data
          },
          actionHeaders: result.headers ? {
            [actionMatch.route.id]: result.headers
          } : {},
          matches,
          loaderData: {},
          errors: null,
          statusCode: result.statusCode || 200,
          loaderHeaders: {}
        };
      }
    }
    let loaderRequest = new Request(request.url, {
      headers: request.headers,
      redirect: request.redirect,
      signal: request.signal
    });
    if (isErrorResult(result)) {
      let boundaryMatch = skipLoaderErrorBubbling ? actionMatch : findNearestBoundary(matches, actionMatch.route.id);
      let handlerContext2 = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad, [boundaryMatch.route.id, result]);
      return {
        ...handlerContext2,
        statusCode: isRouteErrorResponse(result.error) ? result.error.status : result.statusCode != null ? result.statusCode : 500,
        actionData: null,
        actionHeaders: {
          ...(result.headers ? {
            [actionMatch.route.id]: result.headers
          } : {})
        }
      };
    }
    let handlerContext = await loadRouteData(loaderRequest, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, null, filterMatchesToLoad);
    return {
      ...handlerContext,
      actionData: {
        [actionMatch.route.id]: result.data
      },
      // action status codes take precedence over loader status codes
      ...(result.statusCode ? {
        statusCode: result.statusCode
      } : {}),
      actionHeaders: result.headers ? {
        [actionMatch.route.id]: result.headers
      } : {}
    };
  }
  async function loadRouteData(request, matches, requestContext, dataStrategy, skipLoaderErrorBubbling, routeMatch, filterMatchesToLoad, pendingActionResult) {
    let isRouteRequest = routeMatch != null;
    if (isRouteRequest && !routeMatch?.route.loader && !routeMatch?.route.lazy) {
      throw getInternalRouterError(400, {
        method: request.method,
        pathname: new URL(request.url).pathname,
        routeId: routeMatch?.route.id
      });
    }
    let requestMatches = routeMatch ? [routeMatch] : pendingActionResult && isErrorResult(pendingActionResult[1]) ? getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]) : matches;
    let matchesToLoad = requestMatches.filter(m => (m.route.loader || m.route.lazy) && (!filterMatchesToLoad || filterMatchesToLoad(m)));
    if (matchesToLoad.length === 0) {
      return {
        matches,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: matches.reduce((acc, m) => Object.assign(acc, {
          [m.route.id]: null
        }), {}),
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {}
      };
    }
    let results = await callDataStrategy("loader", request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy);
    if (request.signal.aborted) {
      throwStaticHandlerAbortedError(request, isRouteRequest);
    }
    let handlerContext = processRouteLoaderData(matches, results, pendingActionResult, true, skipLoaderErrorBubbling);
    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));
    matches.forEach(match => {
      if (!executedLoaders.has(match.route.id)) {
        handlerContext.loaderData[match.route.id] = null;
      }
    });
    return {
      ...handlerContext,
      matches
    };
  }
  async function callDataStrategy(type, request, matchesToLoad, matches, isRouteRequest, requestContext, dataStrategy) {
    let results = await callDataStrategyImpl(dataStrategy || defaultDataStrategy, type, request, matchesToLoad, matches, null, manifest, mapRouteProperties2, requestContext, false
    // middleware not done via dataStrategy in the static handler
    );
    let dataResults = {};
    await Promise.all(matches.map(async match => {
      if (!(match.route.id in results)) {
        return;
      }
      let result = results[match.route.id];
      if (isRedirectDataStrategyResult(result)) {
        let response = result.result;
        throw normalizeRelativeRoutingRedirectResponse(response, request, match.route.id, matches, basename);
      }
      if (isResponse(result.result) && isRouteRequest) {
        throw result;
      }
      dataResults[match.route.id] = await convertDataStrategyResultToDataResult(result);
    }));
    return dataResults;
  }
  return {
    dataRoutes,
    query,
    queryRoute
  };
}
function getStaticContextFromError(routes, handlerContext, error, boundaryId) {
  let errorBoundaryId = boundaryId || handlerContext._deepestRenderedBoundaryId || routes[0].id;
  return {
    ...handlerContext,
    statusCode: isRouteErrorResponse(error) ? error.status : 500,
    errors: {
      [errorBoundaryId]: error
    }
  };
}
function throwStaticHandlerAbortedError(request, isRouteRequest) {
  if (request.signal.reason !== void 0) {
    throw request.signal.reason;
  }
  let method = isRouteRequest ? "queryRoute" : "query";
  throw new Error(`${method}() call aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`);
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location, matches, basename, to, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    contextualMatches = [];
    for (let match of matches) {
      contextualMatches.push(match);
      if (match.route.id === fromRouteId) {
        activeRouteMatch = match;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches), stripBasename(location.pathname, basename) || location.pathname, relative === "path");
  if (to == null) {
    path.search = location.search;
    path.hash = location.hash;
  }
  if ((to == null || to === "" || to === ".") && activeRouteMatch) {
    let nakedIndex = hasNakedIndexQuery(path.search);
    if (activeRouteMatch.route.index && !nakedIndex) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    } else if (!activeRouteMatch.route.index && nakedIndex) {
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      params.delete("index");
      indexValues.filter(v => v).forEach(v => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function normalizeNavigateOptions(isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = rawFormMethod.toUpperCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?
      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
      Array.from(opts.body.entries()).reduce((acc, [name, value]) => `${acc}${name}=${value}
`, "") : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json,
            text: void 0
          }
        };
      } catch (e) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = `?${searchParams}`;
  return {
    path: createPath(parsedPath),
    submission
  };
}
function getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary = false) {
  let index = matches.findIndex(m => m.route.id === boundaryId);
  if (index >= 0) {
    return matches.slice(0, includeBoundary ? index + 1 : index);
  }
  return matches;
}
function getMatchesToLoad(history, state, matches, submission, location, initialHydration, isRevalidationRequired, cancelledFetcherLoads, fetchersQueuedForDeletion, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location);
  let boundaryMatches = matches;
  if (initialHydration && state.errors) {
    boundaryMatches = getLoaderMatchesUntilBoundary(matches, Object.keys(state.errors)[0], true);
  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
    boundaryMatches = getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]);
  }
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
  let shouldSkipRevalidation = actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match, index) => {
    let {
      route
    } = match;
    if (route.lazy) {
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (initialHydration) {
      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
    }
    if (isNewLoader(state.loaderData, state.matches[index], match)) {
      return true;
    }
    let currentRouteMatch = state.matches[index];
    let nextRouteMatch = match;
    return shouldRevalidateLoader(match, {
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params,
      ...submission,
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false :
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||
      // Search params affect all loaders
      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
    });
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f, key) => {
    if (initialHydration || !matches.some(m => m.route.id === f.routeId) || fetchersQueuedForDeletion.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.has(key)) {
      cancelledFetcherLoads.delete(key);
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, {
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params,
        ...submission,
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      });
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f.routeId,
        path: f.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function shouldLoadRouteOnHydration(route, loaderData, errors) {
  if (route.lazy) {
    return true;
  }
  if (!route.loader) {
    return false;
  }
  let hasData = loaderData != null && loaderData[route.id] !== void 0;
  let hasError = errors != null && errors[route.id] !== void 0;
  if (!hasData && hasError) {
    return false;
  }
  if (typeof route.loader === "function" && route.loader.hydrate === true) {
    return true;
  }
  return !hasData && !hasError;
}
function isNewLoader(currentLoaderData, currentMatch, match) {
  let isNew =
  // [a] -> [a, b]
  !currentMatch ||
  // [a, b] -> [a, c]
  match.route.id !== currentMatch.route.id;
  let isMissingData = !currentLoaderData.hasOwnProperty(match.route.id);
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match.pathname ||
    // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
  let childrenToPatch;
  if (routeId) {
    let route = manifest[routeId];
    invariant(route, `No route found to patch children into: routeId = ${routeId}`);
    if (!route.children) {
      route.children = [];
    }
    childrenToPatch = route.children;
  } else {
    childrenToPatch = routesToUse;
  }
  let uniqueChildren = children.filter(newRoute => !childrenToPatch.some(existingRoute => isSameRoute(newRoute, existingRoute)));
  let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [routeId || "_", "patch", String(childrenToPatch?.length || "0")], manifest);
  childrenToPatch.push(...newRoutes);
}
function isSameRoute(newRoute, existingRoute) {
  if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
    return true;
  }
  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
    return false;
  }
  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
    return true;
  }
  return newRoute.children.every((aChild, i) => existingRoute.children?.some(bChild => isSameRoute(aChild, bChild)));
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 &&
    // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, `Route "${routeToUpdate.id}" has a static property "${lazyRouteProperty}" defined but its lazy function is also returning a value for this property. The lazy route property "${lazyRouteProperty}" will be ignored.`);
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, {
    // To keep things framework agnostic, we use the provided `mapRouteProperties`
    // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
    // since the logic will differ between frameworks.
    ...mapRouteProperties2(routeToUpdate),
    lazy: void 0
  });
}
async function defaultDataStrategy(args) {
  let matchesToLoad = args.matches.filter(m => m.shouldLoad);
  let keyedResults = {};
  let results = await Promise.all(matchesToLoad.map(m => m.resolve()));
  results.forEach((result, i) => {
    keyedResults[matchesToLoad[i].route.id] = result;
  });
  return keyedResults;
}
async function defaultDataStrategyWithMiddleware(args) {
  if (!args.matches.some(m => m.route.unstable_middleware)) {
    return defaultDataStrategy(args);
  }
  return runMiddlewarePipeline(args, false, () => defaultDataStrategy(args), (error, routeId) => ({
    [routeId]: {
      type: "error",
      result: error
    }
  }));
}
async function runMiddlewarePipeline(args, propagateResult, handler, errorHandler) {
  let {
    matches,
    request,
    params,
    context
  } = args;
  let middlewareState = {
    handlerResult: void 0
  };
  try {
    let tuples = matches.flatMap(m => m.route.unstable_middleware ? m.route.unstable_middleware.map(fn => [m.route.id, fn]) : []);
    let result = await callRouteMiddleware({
      request,
      params,
      context
    }, tuples, propagateResult, middlewareState, handler);
    return propagateResult ? result : middlewareState.handlerResult;
  } catch (e) {
    if (!middlewareState.middlewareError) {
      throw e;
    }
    let result = await errorHandler(middlewareState.middlewareError.error, middlewareState.middlewareError.routeId);
    if (propagateResult || !middlewareState.handlerResult) {
      return result;
    }
    return Object.assign(middlewareState.handlerResult, result);
  }
}
async function callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx = 0) {
  let {
    request
  } = args;
  if (request.signal.aborted) {
    if (request.signal.reason) {
      throw request.signal.reason;
    }
    throw new Error(`Request aborted without an \`AbortSignal.reason\`: ${request.method} ${request.url}`);
  }
  let tuple = middlewares[idx];
  if (!tuple) {
    middlewareState.handlerResult = await handler();
    return middlewareState.handlerResult;
  }
  let [routeId, middleware] = tuple;
  let nextCalled = false;
  let nextResult = void 0;
  let next = async () => {
    if (nextCalled) {
      throw new Error("You may only call `next()` once per middleware");
    }
    nextCalled = true;
    let result = await callRouteMiddleware(args, middlewares, propagateResult, middlewareState, handler, idx + 1);
    if (propagateResult) {
      nextResult = result;
      return nextResult;
    }
  };
  try {
    let result = await middleware({
      request: args.request,
      params: args.params,
      context: args.context
    }, next);
    if (nextCalled) {
      if (result === void 0) {
        return nextResult;
      } else {
        return result;
      }
    } else {
      return next();
    }
  } catch (error) {
    if (!middlewareState.middlewareError) {
      middlewareState.middlewareError = {
        routeId,
        error
      };
    } else if (middlewareState.middlewareError.error !== error) {
      middlewareState.middlewareError = {
        routeId,
        error
      };
    }
    throw error;
  }
}
async function callDataStrategyImpl(dataStrategyImpl, type, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, scopedContext, enableMiddleware) {
  let loadRouteDefinitionsPromises = matches.map(m => m.route.lazy ? loadLazyRouteModule(m.route, mapRouteProperties2, manifest) : void 0);
  if (enableMiddleware) {
    await Promise.all(loadRouteDefinitionsPromises);
  }
  let dsMatches = matches.map((match, i) => {
    let loadRoutePromise = loadRouteDefinitionsPromises[i];
    let shouldLoad = matchesToLoad.some(m => m.route.id === match.route.id);
    let resolve = async handlerOverride => {
      if (handlerOverride && request.method === "GET" && (match.route.lazy || match.route.loader)) {
        shouldLoad = true;
      }
      return shouldLoad ? callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, scopedContext) : Promise.resolve({
        type: "data" /* data */,
        result: void 0
      });
    };
    return {
      ...match,
      shouldLoad,
      resolve
    };
  });
  let results = await dataStrategyImpl({
    matches: dsMatches,
    request,
    params: matches[0].params,
    fetcherKey,
    context: scopedContext
  });
  try {
    await Promise.all(loadRouteDefinitionsPromises);
  } catch (e) {}
  return results;
}
async function callLoaderOrAction(type, request, match, loadRoutePromise, handlerOverride, scopedContext) {
  let result;
  let onReject;
  let runHandler = handler => {
    let reject;
    let abortPromise = new Promise((_, r) => reject = r);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    let actualHandler = ctx => {
      if (typeof handler !== "function") {
        return Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean "${type}" [routeId: ${match.route.id}]`));
      }
      return handler({
        request,
        params: match.params,
        context: scopedContext
      }, ...(ctx !== void 0 ? [ctx] : []));
    };
    let handlerPromise = (async () => {
      try {
        let val = await (handlerOverride ? handlerOverride(ctx => actualHandler(ctx)) : actualHandler());
        return {
          type: "data",
          result: val
        };
      } catch (e) {
        return {
          type: "error",
          result: e
        };
      }
    })();
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match.route[type];
    if (loadRoutePromise) {
      if (handler) {
        let handlerError;
        let [value] = await Promise.all([
        // If the handler throws, don't let it immediately bubble out,
        // since we need to let the lazy() execution finish so we know if this
        // route has a boundary that can handle the error
        runHandler(handler).catch(e => {
          handlerError = e;
        }), loadRoutePromise]);
        if (handlerError !== void 0) {
          throw handlerError;
        }
        result = value;
      } else {
        await loadRoutePromise;
        handler = match.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url = new URL(request.url);
          let pathname = url.pathname + url.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match.route.id
          });
        } else {
          return {
            type: "data" /* data */,
            result: void 0
          };
        }
      }
    } else if (!handler) {
      let url = new URL(request.url);
      let pathname = url.pathname + url.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
  } catch (e) {
    return {
      type: "error" /* error */,
      result: e
    };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
async function convertDataStrategyResultToDataResult(dataStrategyResult) {
  let {
    result,
    type
  } = dataStrategyResult;
  if (isResponse(result)) {
    let data2;
    try {
      let contentType = result.headers.get("Content-Type");
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data2 = null;
        } else {
          data2 = await result.json();
        }
      } else {
        data2 = await result.text();
      }
    } catch (e) {
      return {
        type: "error" /* error */,
        error: e
      };
    }
    if (type === "error" /* error */) {
      return {
        type: "error" /* error */,
        error: new ErrorResponseImpl(result.status, result.statusText, data2),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: "data" /* data */,
      data: data2,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === "error" /* error */) {
    if (isDataWithResponseInit(result)) {
      if (result.data instanceof Error) {
        return {
          type: "error" /* error */,
          error: result.data,
          statusCode: result.init?.status,
          headers: result.init?.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: "error" /* error */,
        error: new ErrorResponseImpl(result.init?.status || 500, void 0, result.data),
        statusCode: isRouteErrorResponse(result) ? result.status : void 0,
        headers: result.init?.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return {
      type: "error" /* error */,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : void 0
    };
  }
  if (isDataWithResponseInit(result)) {
    return {
      type: "data" /* data */,
      data: result.data,
      statusCode: result.init?.status,
      headers: result.init?.headers ? new Headers(result.init.headers) : void 0
    };
  }
  return {
    type: "data" /* data */,
    data: result
  };
}
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename) {
  let location = response.headers.get("Location");
  invariant(location, "Redirects returned/thrown from loaders/actions must have a Location header");
  if (!ABSOLUTE_URL_REGEX.test(location)) {
    let trimmedMatches = matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1);
    location = normalizeTo(new URL(request.url), trimmedMatches, basename, location);
    response.headers.set("Location", location);
  }
  return response;
}
function normalizeRedirectLocation(location, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX.test(location)) {
    let normalizedLocation = location;
    let url = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = stripBasename(url.pathname, basename) != null;
    if (url.origin === currentUrl.origin && isSameBasename) {
      return url.pathname + url.search + url.hash;
    }
  }
  return location;
}
function createClientSideRequest(history, location, signal, submission) {
  let url = history.createURL(stripHashFromPath(location)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({
        "Content-Type": formEncType
      });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init.body = submission.formData;
    }
  }
  return new Request(url, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, results, pendingActionResult, isStaticHandler = false, skipLoaderErrorBubbling = false) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
  matches.forEach(match => {
    if (!(match.route.id in results)) {
      return;
    }
    let id = match.route.id;
    let result = results[id];
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let error = result.error;
      if (pendingError !== void 0) {
        error = pendingError;
        pendingError = void 0;
      }
      errors = errors || {};
      if (skipLoaderErrorBubbling) {
        errors[id] = error;
      } else {
        let boundaryMatch = findNearestBoundary(matches, id);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error;
        }
      }
      if (!isStaticHandler) {
        loaderData[id] = ResetLoaderDataSymbol;
      }
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    } else {
      loaderData[id] = result.data;
      if (result.statusCode && result.statusCode !== 200 && !foundError) {
        statusCode = result.statusCode;
      }
      if (result.headers) {
        loaderHeaders[id] = result.headers;
      }
    }
  });
  if (pendingError !== void 0 && pendingActionResult) {
    errors = {
      [pendingActionResult[0]]: pendingError
    };
    loaderData[pendingActionResult[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, results, pendingActionResult);
  revalidatingFetchers.forEach(rf => {
    let {
      key,
      match,
      controller
    } = rf;
    let result = fetcherResults[key];
    invariant(result, "Did not find corresponding fetcher result");
    if (controller && controller.signal.aborted) {
      return;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match?.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = {
          ...errors,
          [boundaryMatch.route.id]: result.error
        };
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  });
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = Object.entries(newLoaderData).filter(([, v]) => v !== ResetLoaderDataSymbol).reduce((merged, [k, v]) => {
    merged[k] = v;
    return merged;
  }, {});
  for (let match of matches) {
    let id = match.route.id;
    if (!newLoaderData.hasOwnProperty(id) && loaderData.hasOwnProperty(id) && match.route.loader) {
      mergedLoaderData[id] = loaderData[id];
    }
    if (errors && errors.hasOwnProperty(id)) {
      break;
    }
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === "/") || {
    id: `__shim-error-route__`
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, {
  pathname,
  routeId,
  method,
  type,
  message
} = {}) {
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = `You made a ${method} request to "${pathname}" but did not provide a \`loader\` for route "${routeId}", so there is no way to handle the request.`;
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = `Route "${routeId}" does not match URL "${pathname}"`;
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = `No route matches URL "${pathname}"`;
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = `You made a ${method.toUpperCase()} request to "${pathname}" but did not provide an \`action\` for route "${routeId}", so there is no way to handle the request.`;
    } else if (method) {
      errorMessage = `Invalid request method "${method.toUpperCase()}"`;
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}
function findRedirect(results) {
  let entries = Object.entries(results);
  for (let i = entries.length - 1; i >= 0; i--) {
    let [key, result] = entries[i];
    if (isRedirectResult(result)) {
      return {
        key,
        result
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath({
    ...parsedPath,
    hash: ""
  });
}
function isHashChangeOnly(a, b) {
  if (a.pathname !== b.pathname || a.search !== b.search) {
    return false;
  }
  if (a.hash === "") {
    return b.hash !== "";
  } else if (a.hash === b.hash) {
    return true;
  } else if (b.hash !== "") {
    return true;
  }
  return false;
}
function isDataStrategyResult(result) {
  return result != null && typeof result === "object" && "type" in result && "result" in result && (result.type === "data" /* data */ || result.type === "error" /* error */);
}
function isRedirectDataStrategyResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isErrorResult(result) {
  return result.type === "error" /* error */;
}
function isRedirectResult(result) {
  return (result && result.type) === "redirect" /* redirect */;
}
function isDataWithResponseInit(value) {
  return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isRedirectStatusCode(statusCode) {
  return redirectStatusCodes.has(statusCode);
}
function isRedirectResponse(result) {
  return isResponse(result) && isRedirectStatusCode(result.status) && result.headers.has("Location");
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toUpperCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toUpperCase());
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some(v => v === "");
}
function getTargetMatch(matches, location) {
  let search = typeof location === "string" ? parsePath(location).search : location.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json,
      text: void 0
    };
  }
}
function getLoadingNavigation(location, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
function getSubmittingNavigation(location, submission) {
  let navigation = {
    state: "submitting",
    location,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data2) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data: data2
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data: data2
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0
  };
  return fetcher;
}
function getDoneFetcher(data2) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: data2
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k, v] of Object.entries(json || {})) {
        if (v && Array.isArray(v)) {
          transitions.set(k, new Set(v || []));
        }
      }
    }
  } catch (e) {}
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k, v] of transitions) {
      json[k] = [...v];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
    } catch (error) {
      warning(false, `Failed to save applied view transitions in sessionStorage (${error}).`);
    }
  }
}
function createDeferred() {
  let resolve;
  let reject;
  let promise = new Promise((res, rej) => {
    resolve = async val => {
      res(val);
      try {
        await promise;
      } catch (e) {}
    };
    reject = async error => {
      rej(error);
      try {
        await promise;
      } catch (e) {}
    };
  });
  return {
    promise,
    //@ts-ignore
    resolve,
    //@ts-ignore
    reject
  };
}

// lib/components.tsx


// lib/context.ts

var DataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var ViewTransitionContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(/* @__PURE__ */new Map());
FetchersContext.displayName = "Fetchers";
var AwaitContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
NavigationContext.displayName = "Navigation";
var LocationContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
LocationContext.displayName = "Location";
var RouteContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
RouteErrorContext.displayName = "RouteError";

// lib/hooks.tsx

var ENABLE_DEV_WARNINGS = true;
function useHref(to, {
  relative
} = {}) {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useHref() may be used only in the context of a <Router> component.`);
  let {
    basename,
    navigator: navigator2
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useLocation() may be used only in the context of a <Router> component.`);
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;
}
function useNavigationType() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;
}
function useMatch(pattern) {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useMatch() may be used only in the context of a <Router> component.`);
  let {
    pathname
  } = useLocation();
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => matchPath(pattern, decodePath(pathname)), [pathname, pattern]);
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;
  if (!isStatic) {
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useNavigate() may be used only in the context of a <Router> component.`);
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  let {
    basename,
    navigator: navigator2
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((to, options = {}) => {
    warning(activeRef.current, navigateEffectWarning);
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
var OutletContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);
function useOutletContext() {
  return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);
}
function useOutlet(context) {
  let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useParams() {
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, {
  relative
} = {}) {
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of the
  // router loaded. We can help them understand how to avoid that.
  `useRoutes() may be used only in the context of a <Router> component.`);
  let {
    navigator: navigator2,
    static: isStatic
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (ENABLE_DEV_WARNINGS) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`);
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`);
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes, {
    pathname: remainingPathname
  });
  if (ENABLE_DEV_WARNINGS) {
    warning(parentRoute || matches != null, `No routes matched location "${location.pathname}${location.search}${location.hash}" `);
    warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0, `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
  }
  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase,
    // Re-encode pathnames that were decoded inside matchRoutes
    navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {
      value: {
        location: {
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...location
        },
        navigationType: "POP" /* Pop */
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? `${error.status} ${error.statusText}` : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (ENABLE_DEV_WARNINGS) {
    console.error("Error handled by React Router default ErrorBoundary:", error);
    devInfo = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("code", {
      style: codeStyles
    }, "ErrorBoundary"), " or", " ", /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("code", {
      style: codeStyles
    }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
function RenderedRoute({
  routeContext,
  match,
  children
}) {
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(m => m.route.id && errors?.[m.route.id] !== void 0);
    invariant(errorIndex >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(errors).join(",")}`);
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i = 0; i < renderedMatches.length; i++) {
      let match = renderedMatches[i];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i;
      }
      if (match.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match.route.id ? errors[match.route.id] : void 0;
      errorElement = match.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index === 0) {
          warningOnce("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match.route.Component) {
        children = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(thisRoute.route.id, `${hookName} can only be used on routes that contain a unique "id"`);
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId("useRouteId" /* UseRouteId */);
}
function useNavigation() {
  let state = useDataRouterState("useNavigation" /* UseNavigation */);
  return state.navigation;
}
function useRevalidator() {
  let dataRouterContext = useDataRouterContext("useRevalidator" /* UseRevalidator */);
  let state = useDataRouterState("useRevalidator" /* UseRevalidator */);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    async revalidate() {
      await dataRouterContext.router.revalidate();
    },
    state: state.revalidation
  }), [dataRouterContext.router, state.revalidation]);
}
function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState("useMatches" /* UseMatches */);
  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => matches.map(m => convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);
}
function useLoaderData() {
  let state = useDataRouterState("useLoaderData" /* UseLoaderData */);
  let routeId = useCurrentRouteId("useLoaderData" /* UseLoaderData */);
  return state.loaderData[routeId];
}
function useRouteLoaderData(routeId) {
  let state = useDataRouterState("useRouteLoaderData" /* UseRouteLoaderData */);
  return state.loaderData[routeId];
}
function useActionData() {
  let state = useDataRouterState("useActionData" /* UseActionData */);
  let routeId = useCurrentRouteId("useLoaderData" /* UseLoaderData */);
  return state.actionData ? state.actionData[routeId] : void 0;
}
function useRouteError() {
  let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);
  let state = useDataRouterState("useRouteError" /* UseRouteError */);
  let routeId = useCurrentRouteId("useRouteError" /* UseRouteError */);
  if (error !== void 0) {
    return error;
  }
  return state.errors?.[routeId];
}
function useAsyncValue() {
  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);
  return value?._data;
}
function useAsyncError() {
  let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);
  return value?._error;
}
var blockerId = 0;
function useBlocker(shouldBlock) {
  let {
    router,
    basename
  } = useDataRouterContext("useBlocker" /* UseBlocker */);
  let state = useDataRouterState("useBlocker" /* UseBlocker */);
  let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState("");
  let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(arg => {
    if (typeof shouldBlock !== "function") {
      return !!shouldBlock;
    }
    if (basename === "/") {
      return shouldBlock(arg);
    }
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = arg;
    return shouldBlock({
      currentLocation: {
        ...currentLocation,
        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname
      },
      nextLocation: {
        ...nextLocation,
        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname
      },
      historyAction
    });
  }, [basename, shouldBlock]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let key = String(++blockerId);
    setBlockerKey(key);
    return () => router.deleteBlocker(key);
  }, [router]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blockerKey !== "") {
      router.getBlocker(blockerKey, blockerFunction);
    }
  }, [router, blockerKey, blockerFunction]);
  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext("useNavigate" /* UseNavigateStable */);
  let id = useCurrentRouteId("useNavigate" /* UseNavigateStable */);
  let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (to, options = {}) => {
    warning(activeRef.current, navigateEffectWarning);
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      await router.navigate(to, {
        fromRouteId: id,
        ...options
      });
    }
  }, [router, id]);
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}

// lib/server-runtime/warnings.ts
var alreadyWarned2 = {};
function warnOnce(condition, message) {
  if (!condition && !alreadyWarned2[message]) {
    alreadyWarned2[message] = true;
    console.warn(message);
  }
}

// lib/components.tsx
var ENABLE_DEV_WARNINGS2 = true;
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.hasErrorBoundary || route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.element) {
        warning(false, "You should not include both `Component` and `element` on your route - `Component` will be used.");
      }
    }
    Object.assign(updates, {
      element: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.HydrateFallback) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.hydrateFallbackElement) {
        warning(false, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used.");
      }
    }
    Object.assign(updates, {
      hydrateFallbackElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.HydrateFallback),
      HydrateFallback: void 0
    });
  }
  if (route.ErrorBoundary) {
    if (ENABLE_DEV_WARNINGS2) {
      if (route.errorElement) {
        warning(false, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used.");
      }
    }
    Object.assign(updates, {
      errorElement: react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}
function createMemoryRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    unstable_getContext: opts?.unstable_getContext,
    future: opts?.future,
    history: createMemoryHistory({
      initialEntries: opts?.initialEntries,
      initialIndex: opts?.initialIndex
    }),
    hydrationData: opts?.hydrationData,
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation
  }).initialize();
}
var Deferred = class {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = value => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = reason => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
};
function RouterProvider({
  router,
  flushSync: reactDomFlushSyncImpl
}) {
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);
  let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();
  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(/* @__PURE__ */new Map());
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState, {
    deletedFetchers,
    flushSync,
    viewTransitionOpts
  }) => {
    newState.fetchers.forEach((fetcher, key) => {
      if (fetcher.data !== void 0) {
        fetcherData.current.set(key, fetcher.data);
      }
    });
    deletedFetchers.forEach(key => fetcherData.current.delete(key));
    warnOnce(flushSync === false || reactDomFlushSyncImpl != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');
    let isViewTransitionAvailable = router.window != null && router.window.document != null && typeof router.window.document.startViewTransition === "function";
    warnOnce(viewTransitionOpts == null || isViewTransitionAvailable, "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available.");
    if (!viewTransitionOpts || !isViewTransitionAvailable) {
      if (reactDomFlushSyncImpl && flushSync) {
        reactDomFlushSyncImpl(() => setStateImpl(newState));
      } else {
        react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
      }
      return;
    }
    if (reactDomFlushSyncImpl && flushSync) {
      reactDomFlushSyncImpl(() => {
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
        }
        setVtContext({
          isTransitioning: true,
          flushSync: true,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      });
      let t = router.window.document.startViewTransition(() => {
        reactDomFlushSyncImpl(() => setStateImpl(newState));
      });
      t.finished.finally(() => {
        reactDomFlushSyncImpl(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({
            isTransitioning: false
          });
        });
      });
      reactDomFlushSyncImpl(() => setTransition(t));
      return;
    }
    if (transition) {
      renderDfd && renderDfd.resolve();
      transition.skipTransition();
      setInterruption({
        state: newState,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    } else {
      setPendingState(newState);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    }
  }, [router.window, reactDomFlushSyncImpl, transition, renderDfd]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => router.subscribe(setState), [router, setState]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (renderDfd && pendingState && router.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition2 = router.window.document.startViewTransition(async () => {
        react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition2.finished.finally(() => {
        setRenderDfd(void 0);
        setTransition(void 0);
        setPendingState(void 0);
        setVtContext({
          isTransitioning: false
        });
      });
      setTransition(transition2);
    }
  }, [pendingState, renderDfd, router.window]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(void 0);
    }
  }, [vtContext.isTransitioning, interruption]);
  let navigator2 = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    return {
      createHref: router.createHref,
      encodeLocation: router.encodeLocation,
      go: n => router.navigate(n),
      push: (to, state2, opts) => router.navigate(to, {
        state: state2,
        preventScrollReset: opts?.preventScrollReset
      }),
      replace: (to, state2, opts) => router.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts?.preventScrollReset
      })
    };
  }, [router]);
  let basename = router.basename || "/";
  let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    router,
    navigator: navigator2,
    static: false,
    basename
  }), [router, navigator2, basename]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {
    value: fetcherData.current
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {
    value: vtContext
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(MemoizedDataRoutes, {
    routes: router.routes,
    future: router.future,
    state
  })))))), null);
}
var MemoizedDataRoutes = react__WEBPACK_IMPORTED_MODULE_0__.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function MemoryRouter({
  basename,
  children,
  initialEntries,
  initialIndex
}) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createMemoryHistory({
      initialEntries,
      initialIndex,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {
    react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
  }, [setStateImpl]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function Navigate({
  to,
  replace: replace2,
  state,
  relative
}) {
  invariant(useInRouterContext(),
  // TODO: This error is probably because they somehow have 2 versions of
  // the router loaded. We can help them understand how to avoid that.
  `<Navigate> may be used only in the context of a <Router> component.`);
  let {
    static: isStatic
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  warning(!isStatic, `<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.`);
  let {
    matches
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(to, getResolveToMatches(matches), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    navigate(JSON.parse(jsonPath), {
      replace: replace2,
      state,
      relative
    });
  }, [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Route(_props) {
  invariant(false, `A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.`);
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP" /* Pop */,
  navigator: navigator2,
  static: staticProp = false
}) {
  invariant(!useInRouterContext(), `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`);
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: {}
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(locationContext != null, `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes({
  children,
  location
}) {
  return useRoutes(createRoutesFromChildren(children), location);
}
function Await({
  children,
  errorElement,
  resolve
}) {
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {
    resolve,
    errorElement
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));
}
var AwaitErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("<Await> caught the following error during render", error, errorInfo);
  }
  render() {
    let {
      children,
      errorElement,
      resolve
    } = this.props;
    let promise = null;
    let status = 0 /* pending */;
    if (!(resolve instanceof Promise)) {
      status = 1 /* success */;
      promise = Promise.resolve();
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_data", {
        get: () => resolve
      });
    } else if (this.state.error) {
      status = 2 /* error */;
      let renderError = this.state.error;
      promise = Promise.reject().catch(() => {});
      Object.defineProperty(promise, "_tracked", {
        get: () => true
      });
      Object.defineProperty(promise, "_error", {
        get: () => renderError
      });
    } else if (resolve._tracked) {
      promise = resolve;
      status = "_error" in promise ? 2 /* error */ : "_data" in promise ? 1 /* success */ : 0 /* pending */;
    } else {
      status = 0 /* pending */;
      Object.defineProperty(resolve, "_tracked", {
        get: () => true
      });
      promise = resolve.then(data2 => Object.defineProperty(resolve, "_data", {
        get: () => data2
      }), error => Object.defineProperty(resolve, "_error", {
        get: () => error
      }));
    }
    if (status === 2 /* error */ && !errorElement) {
      throw promise._error;
    }
    if (status === 2 /* error */) {
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {
        value: promise,
        children: errorElement
      });
    }
    if (status === 1 /* success */) {
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {
        value: promise,
        children
      });
    }
    throw promise;
  }
};
function ResolveAwait({
  children
}) {
  let data2 = useAsyncValue();
  let toRender = typeof children === "function" ? children(data2) : children;
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);
}
function createRoutesFromChildren(children, parentPath = []) {
  let routes = [];
  react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index) => {
    if (!react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    invariant(element.type === Route, `[${typeof element.type === "string" ? element.type : element.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`);
    invariant(!element.props.index || !element.props.children, "An index route cannot have child routes.");
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      hydrateFallbackElement: element.props.hydrateFallbackElement,
      HydrateFallback: element.props.HydrateFallback,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.hasErrorBoundary === true || element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
var createRoutesFromElements = createRoutesFromChildren;
function renderMatches(matches) {
  return _renderMatches(matches);
}

// lib/dom/lib.tsx


// lib/dom/dom.ts
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (
  // Ignore everything but left clicks
  !target || target === "_self") &&
  // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init = "") {
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
    let value = init[key];
    return memo2.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach(value => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(document.createElement("form"),
      // @ts-expect-error if FormData supports the submitter parameter, this will throw
      0);
      _formDataSupportsSubmitter = false;
    } catch (e) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(false, `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`);
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(`Cannot submit a <button> or <input type="submit"> without a <form>`);
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`);
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData,
    body
  };
}

// lib/dom/ssr/components.tsx


// lib/dom/ssr/invariant.ts
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// lib/dom/ssr/routeModules.ts
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(/* @vite-ignore */
    /* webpackIgnore: true */
    route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    console.error(`Error loading route module \`${route.module}\`, reloading page...`);
    console.error(error);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode &&
    // @ts-expect-error
    /* unsupported import.meta.hot */ undefined) {}
    window.location.reload();
    return new Promise(() => {});
  }
}

// lib/dom/ssr/links.ts
function getKeyedLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map(match => {
    let module = routeModules[match.route.id];
    let route = manifest.routes[match.route.id];
    return [route && route.css ? route.css.map(href2 => ({
      rel: "stylesheet",
      href: href2
    })) : [], module?.links?.() || []];
  }).flat(2);
  let preloads = getModuleLinkHrefs(matches, manifest);
  return dedupeLinkDescriptors(descriptors, preloads);
}
function getRouteCssDescriptors(route) {
  if (!route.css) return [];
  return route.css.map(href2 => ({
    rel: "stylesheet",
    href: href2
  }));
}
async function prefetchRouteCss(route) {
  if (!route.css) return;
  let descriptors = getRouteCssDescriptors(route);
  await Promise.all(descriptors.map(prefetchStyleLink));
}
async function prefetchStyleLinks(route, routeModule) {
  if (!route.css && !routeModule.links || !isPreloadSupported()) return;
  let descriptors = [];
  if (route.css) {
    descriptors.push(...getRouteCssDescriptors(route));
  }
  if (routeModule.links) {
    descriptors.push(...routeModule.links());
  }
  if (descriptors.length === 0) return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push({
        ...descriptor,
        rel: "preload",
        as: "style"
      });
    }
  }
  await Promise.all(styleLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise(resolve => {
    if (descriptor.media && !window.matchMedia(descriptor.media).matches || document.querySelector(`link[rel="stylesheet"][href="${descriptor.href}"]`)) {
      return resolve();
    }
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(matches.map(async match => {
    let route = manifest.routes[match.route.id];
    if (route) {
      let mod = await loadRouteModule(route, routeModules);
      return mod.links ? mod.links() : [];
    }
    return [];
  }));
  return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter(link => link.rel === "stylesheet" || link.rel === "preload").map(link => link.rel === "stylesheet" ? {
    ...link,
    rel: "prefetch",
    as: "style"
  } : {
    ...link,
    rel: "prefetch"
  }));
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname ||
      // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter((match, index) => isNew(match, index) || matchPathChanged(match, index));
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, {
  includeHydrateFallback
} = {}) {
  return dedupeHrefs(matches.map(match => {
    let route = manifest.routes[match.route.id];
    if (!route) return [];
    let hrefs = [route.module];
    if (route.clientActionModule) {
      hrefs = hrefs.concat(route.clientActionModule);
    }
    if (route.clientLoaderModule) {
      hrefs = hrefs.concat(route.clientLoaderModule);
    }
    if (includeHydrateFallback && route.hydrateFallbackModule) {
      hrefs = hrefs.concat(route.hydrateFallbackModule);
    }
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({
        key,
        link: descriptor
      });
    }
    return deduped;
  }, []);
}
var _isPreloadSupported;
function isPreloadSupported() {
  if (_isPreloadSupported !== void 0) {
    return _isPreloadSupported;
  }
  let el = document.createElement("link");
  _isPreloadSupported = el.relList.supports("preload");
  el = null;
  return _isPreloadSupported;
}

// lib/dom/ssr/markup.ts
var ESCAPE_LOOKUP = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);
}
function createHtml(html) {
  return {
    __html: html
  };
}

// lib/dom/ssr/single-fetch.tsx



// lib/dom/ssr/data.ts
async function createRequestInit(request) {
  let init = {
    signal: request.signal
  };
  if (request.method !== "GET") {
    init.method = request.method;
    let contentType = request.headers.get("Content-Type");
    if (contentType && /\bapplication\/json\b/.test(contentType)) {
      init.headers = {
        "Content-Type": contentType
      };
      init.body = JSON.stringify(await request.json());
    } else if (contentType && /\btext\/plain\b/.test(contentType)) {
      init.headers = {
        "Content-Type": contentType
      };
      init.body = await request.text();
    } else if (contentType && /\bapplication\/x-www-form-urlencoded\b/.test(contentType)) {
      init.body = new URLSearchParams(await request.text());
    } else {
      init.body = await request.formData();
    }
  }
  return init;
}

// lib/dom/ssr/single-fetch.tsx
var SingleFetchRedirectSymbol = Symbol("SingleFetchRedirect");
function StreamTransfer({
  context,
  identifier,
  reader,
  textDecoder,
  nonce
}) {
  if (!context.renderMeta || !context.renderMeta.didRenderScripts) {
    return null;
  }
  if (!context.renderMeta.streamCache) {
    context.renderMeta.streamCache = {};
  }
  let {
    streamCache
  } = context.renderMeta;
  let promise = streamCache[identifier];
  if (!promise) {
    promise = streamCache[identifier] = reader.read().then(result => {
      streamCache[identifier].result = {
        done: result.done,
        value: textDecoder.decode(result.value, {
          stream: true
        })
      };
    }).catch(e => {
      streamCache[identifier].error = e;
    });
  }
  if (promise.error) {
    throw promise.error;
  }
  if (promise.result === void 0) {
    throw promise;
  }
  let {
    done,
    value
  } = promise.result;
  let scriptTag = value ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
    nonce,
    dangerouslySetInnerHTML: {
      __html: `window.__reactRouterContext.streamController.enqueue(${escapeHtml(JSON.stringify(value))});`
    }
  }) : null;
  if (done) {
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
      nonce,
      dangerouslySetInnerHTML: {
        __html: `window.__reactRouterContext.streamController.close();`
      }
    }));
  } else {
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, scriptTag, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(StreamTransfer, {
      context,
      identifier: identifier + 1,
      reader,
      textDecoder,
      nonce
    })));
  }
}
function handleMiddlewareError(error, routeId) {
  return {
    [routeId]: {
      type: "error",
      result: error
    }
  };
}
function getSingleFetchDataStrategy(manifest, routeModules, ssr, basename, getRouter) {
  return async args => {
    let {
      request,
      matches,
      fetcherKey
    } = args;
    if (request.method !== "GET") {
      return runMiddlewarePipeline(args, false, () => singleFetchActionStrategy(request, matches, basename), handleMiddlewareError);
    }
    if (!ssr) {
      let foundRevalidatingServerLoader = matches.some(m => m.shouldLoad && manifest.routes[m.route.id]?.hasLoader && !manifest.routes[m.route.id]?.hasClientLoader);
      if (!foundRevalidatingServerLoader) {
        return runMiddlewarePipeline(args, false, () => nonSsrStrategy(manifest, request, matches, basename), handleMiddlewareError);
      }
    }
    if (fetcherKey) {
      return runMiddlewarePipeline(args, false, () => singleFetchLoaderFetcherStrategy(request, matches, basename), handleMiddlewareError);
    }
    return runMiddlewarePipeline(args, false, () => singleFetchLoaderNavigationStrategy(manifest, routeModules, ssr, getRouter(), request, matches, basename), handleMiddlewareError);
  };
}
async function singleFetchActionStrategy(request, matches, basename) {
  let actionMatch = matches.find(m => m.shouldLoad);
  invariant2(actionMatch, "No action match found");
  let actionStatus = void 0;
  let result = await actionMatch.resolve(async handler => {
    let result2 = await handler(async () => {
      let url = singleFetchUrl(request.url, basename);
      let init = await createRequestInit(request);
      let {
        data: data2,
        status
      } = await fetchAndDecode(url, init);
      actionStatus = status;
      return unwrapSingleFetchResult(data2, actionMatch.route.id);
    });
    return result2;
  });
  if (isResponse(result.result) || isRouteErrorResponse(result.result)) {
    return {
      [actionMatch.route.id]: result
    };
  }
  return {
    [actionMatch.route.id]: {
      type: result.type,
      result: data(result.result, actionStatus)
    }
  };
}
async function nonSsrStrategy(manifest, request, matches, basename) {
  let matchesToLoad = matches.filter(m => m.shouldLoad);
  let url = stripIndexParam(singleFetchUrl(request.url, basename));
  let init = await createRequestInit(request);
  let results = {};
  await Promise.all(matchesToLoad.map(m => m.resolve(async handler => {
    try {
      let result = manifest.routes[m.route.id]?.hasClientLoader ? await fetchSingleLoader(handler, url, init, m.route.id) : await handler();
      results[m.route.id] = {
        type: "data",
        result
      };
    } catch (e) {
      results[m.route.id] = {
        type: "error",
        result: e
      };
    }
  })));
  return results;
}
async function singleFetchLoaderNavigationStrategy(manifest, routeModules, ssr, router, request, matches, basename) {
  let routesParams = /* @__PURE__ */new Set();
  let foundOptOutRoute = false;
  let routeDfds = matches.map(() => createDeferred2());
  let routesLoadedPromise = Promise.all(routeDfds.map(d => d.promise));
  let singleFetchDfd = createDeferred2();
  let url = stripIndexParam(singleFetchUrl(request.url, basename));
  let init = await createRequestInit(request);
  let results = {};
  let resolvePromise = Promise.all(matches.map(async (m, i) => m.resolve(async handler => {
    routeDfds[i].resolve();
    let manifestRoute = manifest.routes[m.route.id];
    if (!m.shouldLoad) {
      if (!router.state.initialized) {
        return;
      }
      if (m.route.id in router.state.loaderData && manifestRoute && m.route.shouldRevalidate) {
        if (manifestRoute.hasLoader) {
          foundOptOutRoute = true;
        }
        return;
      }
    }
    if (manifestRoute && manifestRoute.hasClientLoader) {
      if (manifestRoute.hasLoader) {
        foundOptOutRoute = true;
      }
      try {
        let result = await fetchSingleLoader(handler, url, init, m.route.id);
        results[m.route.id] = {
          type: "data",
          result
        };
      } catch (e) {
        results[m.route.id] = {
          type: "error",
          result: e
        };
      }
      return;
    }
    if (manifestRoute && manifestRoute.hasLoader) {
      routesParams.add(m.route.id);
    }
    try {
      let result = await handler(async () => {
        let data2 = await singleFetchDfd.promise;
        return unwrapSingleFetchResults(data2, m.route.id);
      });
      results[m.route.id] = {
        type: "data",
        result
      };
    } catch (e) {
      results[m.route.id] = {
        type: "error",
        result: e
      };
    }
  })));
  await routesLoadedPromise;
  if ((!router.state.initialized || routesParams.size === 0) && !window.__reactRouterHdrActive) {
    singleFetchDfd.resolve({});
  } else {
    try {
      if (ssr && foundOptOutRoute && routesParams.size > 0) {
        url.searchParams.set("_routes", matches.filter(m => routesParams.has(m.route.id)).map(m => m.route.id).join(","));
      }
      let data2 = await fetchAndDecode(url, init);
      singleFetchDfd.resolve(data2.data);
    } catch (e) {
      singleFetchDfd.reject(e);
    }
  }
  await resolvePromise;
  return results;
}
async function singleFetchLoaderFetcherStrategy(request, matches, basename) {
  let fetcherMatch = matches.find(m => m.shouldLoad);
  invariant2(fetcherMatch, "No fetcher match found");
  let result = await fetcherMatch.resolve(async handler => {
    let url = stripIndexParam(singleFetchUrl(request.url, basename));
    let init = await createRequestInit(request);
    return fetchSingleLoader(handler, url, init, fetcherMatch.route.id);
  });
  return {
    [fetcherMatch.route.id]: result
  };
}
function fetchSingleLoader(handler, url, init, routeId) {
  return handler(async () => {
    let singleLoaderUrl = new URL(url);
    singleLoaderUrl.searchParams.set("_routes", routeId);
    let {
      data: data2
    } = await fetchAndDecode(singleLoaderUrl, init);
    return unwrapSingleFetchResults(data2, routeId);
  });
}
function stripIndexParam(url) {
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return url;
}
function singleFetchUrl(reqUrl, basename) {
  let url = typeof reqUrl === "string" ? new URL(reqUrl,
  // This can be called during the SSR flow via PrefetchPageLinksImpl so
  // don't assume window is available
  typeof window === "undefined" ? "server://singlefetch/" : window.location.origin) : reqUrl;
  if (url.pathname === "/") {
    url.pathname = "_root.data";
  } else if (basename && stripBasename(url.pathname, basename) === "/") {
    url.pathname = `${basename.replace(/\/$/, "")}/_root.data`;
  } else {
    url.pathname = `${url.pathname.replace(/\/$/, "")}.data`;
  }
  return url;
}
async function fetchAndDecode(url, init) {
  let res = await fetch(url, init);
  if (res.status === 404 && !res.headers.has("X-Remix-Response")) {
    throw new ErrorResponseImpl(404, "Not Found", true);
  }
  const NO_BODY_STATUS_CODES2 = /* @__PURE__ */new Set([100, 101, 204, 205]);
  if (NO_BODY_STATUS_CODES2.has(res.status)) {
    if (!init.method || init.method === "GET") {
      return {
        status: res.status,
        data: {}
      };
    } else {
      return {
        status: res.status,
        data: {
          data: void 0
        }
      };
    }
  }
  invariant2(res.body, "No response body to decode");
  try {
    let decoded = await decodeViaTurboStream(res.body, window);
    return {
      status: res.status,
      data: decoded.value
    };
  } catch (e) {
    throw new Error("Unable to decode turbo-stream response");
  }
}
function decodeViaTurboStream(body, global2) {
  return (0,turbo_stream__WEBPACK_IMPORTED_MODULE_1__.decode)(body, {
    plugins: [(type, ...rest) => {
      if (type === "SanitizedError") {
        let [name, message, stack] = rest;
        let Constructor = Error;
        if (name && name in global2 && typeof global2[name] === "function") {
          Constructor = global2[name];
        }
        let error = new Constructor(message);
        error.stack = stack;
        return {
          value: error
        };
      }
      if (type === "ErrorResponse") {
        let [data2, status, statusText] = rest;
        return {
          value: new ErrorResponseImpl(status, statusText, data2)
        };
      }
      if (type === "SingleFetchRedirect") {
        return {
          value: {
            [SingleFetchRedirectSymbol]: rest[0]
          }
        };
      }
      if (type === "SingleFetchClassInstance") {
        return {
          value: rest[0]
        };
      }
      if (type === "SingleFetchFallback") {
        return {
          value: void 0
        };
      }
    }]
  });
}
function unwrapSingleFetchResults(results, routeId) {
  let redirect2 = results[SingleFetchRedirectSymbol];
  if (redirect2) {
    return unwrapSingleFetchResult(redirect2, routeId);
  }
  return results[routeId] !== void 0 ? unwrapSingleFetchResult(results[routeId], routeId) : null;
}
function unwrapSingleFetchResult(result, routeId) {
  if ("error" in result) {
    throw result.error;
  } else if ("redirect" in result) {
    let headers = {};
    if (result.revalidate) {
      headers["X-Remix-Revalidate"] = "yes";
    }
    if (result.reload) {
      headers["X-Remix-Reload-Document"] = "yes";
    }
    if (result.replace) {
      headers["X-Remix-Replace"] = "yes";
    }
    throw redirect(result.redirect, {
      status: result.status,
      headers
    });
  } else if ("data" in result) {
    return result.data;
  } else {
    throw new Error(`No response found for routeId "${routeId}"`);
  }
}
function createDeferred2() {
  let resolve;
  let reject;
  let promise = new Promise((res, rej) => {
    resolve = async val => {
      res(val);
      try {
        await promise;
      } catch (e) {}
    };
    reject = async error => {
      rej(error);
      try {
        await promise;
      } catch (e) {}
    };
  });
  return {
    promise,
    //@ts-ignore
    resolve,
    //@ts-ignore
    reject
  };
}

// lib/dom/ssr/fog-of-war.ts


// lib/dom/ssr/routes.tsx


// lib/dom/ssr/errorBoundaries.tsx

var RemixErrorBoundary = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixRootDefaultErrorBoundary, {
        error: this.state.error,
        isOutsideRemixApp: true
      });
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error,
  isOutsideRemixApp
}) {
  console.error(error);
  let heyDeveloper = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
        console.log(
          "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
        );
      `
    }
  });
  if (isRouteErrorResponse(error)) {
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, {
      title: "Unhandled Thrown Response!"
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", {
      style: {
        fontSize: "24px"
      }
    }, error.status, " ", error.statusText), heyDeveloper);
  }
  let errorInstance;
  if (error instanceof Error) {
    errorInstance = error;
  } else {
    let errorString = error == null ? "Unknown Error" : typeof error === "object" && "toString" in error ? error.toString() : JSON.stringify(error);
    errorInstance = new Error(errorString);
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, {
    title: "Application Error!",
    isOutsideRemixApp
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, errorInstance.stack), heyDeveloper);
}
function BoundaryShell({
  title,
  renderScripts,
  isOutsideRemixApp,
  children
}) {
  let {
    routeModules
  } = useFrameworkContext();
  if (routeModules.root?.Layout && !isOutsideRemixApp) {
    return children;
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("head", null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("title", null, title)), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("body", null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, children, renderScripts ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Scripts, null) : null)));
}

// lib/dom/ssr/fallback.tsx

function RemixRootDefaultHydrateFallback() {
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(BoundaryShell, {
    title: "Loading...",
    renderScripts: true
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer \u{1F44B}. You can provide a way better UX than this " +
                "when your app is loading JS modules and/or running \`clientLoader\` " +
                "functions. Check out https://remix.run/route/hydrate-fallback " +
                "for more information."
              );
            `
    }
  }));
}

// lib/dom/ssr/routes.tsx
function groupRoutesByParentId(manifest) {
  let routes = {};
  Object.values(manifest).forEach(route => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
}
function getRouteComponents(route, routeModule, isSpaMode) {
  let Component4 = getRouteModuleComponent(routeModule);
  let HydrateFallback = routeModule.HydrateFallback && (!isSpaMode || route.id === "root") ? routeModule.HydrateFallback : route.id === "root" ? RemixRootDefaultHydrateFallback : void 0;
  let ErrorBoundary = routeModule.ErrorBoundary ? routeModule.ErrorBoundary : route.id === "root" ? () => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixRootDefaultErrorBoundary, {
    error: useRouteError()
  }) : void 0;
  if (route.id === "root" && routeModule.Layout) {
    return {
      ...(Component4 ? {
        element: /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component4, null))
      } : {
        Component: Component4
      }),
      ...(ErrorBoundary ? {
        errorElement: /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorBoundary, null))
      } : {
        ErrorBoundary
      }),
      ...(HydrateFallback ? {
        hydrateFallbackElement: /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(routeModule.Layout, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(HydrateFallback, null))
      } : {
        HydrateFallback
      })
    };
  }
  return {
    Component: Component4,
    ErrorBoundary,
    HydrateFallback
  };
}
function createServerRoutes(manifest, routeModules, future, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), spaModeLazyPromise = Promise.resolve({
  Component: () => null
})) {
  return (routesByParentId[parentId] || []).map(route => {
    let routeModule = routeModules[route.id];
    invariant2(routeModule, "No `routeModule` available to create server routes");
    let dataRoute = {
      ...getRouteComponents(route, routeModule, isSpaMode),
      caseSensitive: route.caseSensitive,
      id: route.id,
      index: route.index,
      path: route.path,
      handle: routeModule.handle,
      // For SPA Mode, all routes are lazy except root.  However we tell the
      // router root is also lazy here too since we don't need a full
      // implementation - we just need a `lazy` prop to tell the RR rendering
      // where to stop which is always at the root route in SPA mode
      lazy: isSpaMode ? () => spaModeLazyPromise : void 0,
      // For partial hydration rendering, we need to indicate when the route
      // has a loader/clientLoader, but it won't ever be called during the static
      // render, so just give it a no-op function so we can render down to the
      // proper fallback
      loader: route.hasLoader || route.hasClientLoader ? () => null : void 0
      // We don't need middleware/action/shouldRevalidate on these routes since
      // they're for a static render
    };
    let children = createServerRoutes(manifest, routeModules, future, isSpaMode, route.id, routesByParentId, spaModeLazyPromise);
    if (children.length > 0) dataRoute.children = children;
    return dataRoute;
  });
}
function createClientRoutesWithHMRRevalidationOptOut(needsRevalidation, manifest, routeModulesCache, initialState, ssr, isSpaMode) {
  return createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, "", groupRoutesByParentId(manifest), needsRevalidation);
}
function preventInvalidServerHandlerCall(type, route) {
  if (type === "loader" && !route.hasLoader || type === "action" && !route.hasAction) {
    let fn = type === "action" ? "serverAction()" : "serverLoader()";
    let msg = `You are trying to call ${fn} on a route that does not have a server ${type} (routeId: "${route.id}")`;
    console.error(msg);
    throw new ErrorResponseImpl(400, "Bad Request", new Error(msg), true);
  }
}
function noActionDefinedError(type, routeId) {
  let article = type === "clientAction" ? "a" : "an";
  let msg = `Route "${routeId}" does not have ${article} ${type}, but you are trying to submit to it. To fix this, please add ${article} \`${type}\` function to the route`;
  console.error(msg);
  throw new ErrorResponseImpl(405, "Method Not Allowed", new Error(msg), true);
}
function createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, parentId = "", routesByParentId = groupRoutesByParentId(manifest), needsRevalidation) {
  return (routesByParentId[parentId] || []).map(route => {
    let routeModule = routeModulesCache[route.id];
    function fetchServerHandler(singleFetch) {
      invariant2(typeof singleFetch === "function", "No single fetch function available for route handler");
      return singleFetch();
    }
    function fetchServerLoader(singleFetch) {
      if (!route.hasLoader) return Promise.resolve(null);
      return fetchServerHandler(singleFetch);
    }
    function fetchServerAction(singleFetch) {
      if (!route.hasAction) {
        throw noActionDefinedError("action", route.id);
      }
      return fetchServerHandler(singleFetch);
    }
    function prefetchModule(modulePath) {
      import(/* @vite-ignore */
      /* webpackIgnore: true */
      modulePath);
    }
    function prefetchRouteModuleChunks(route2) {
      if (route2.clientActionModule) {
        prefetchModule(route2.clientActionModule);
      }
      if (route2.clientLoaderModule) {
        prefetchModule(route2.clientLoaderModule);
      }
    }
    async function prefetchStylesAndCallHandler(handler) {
      let cachedModule = routeModulesCache[route.id];
      let linkPrefetchPromise = cachedModule ? prefetchStyleLinks(route, cachedModule) : Promise.resolve();
      try {
        return handler();
      } finally {
        await linkPrefetchPromise;
      }
    }
    let dataRoute = {
      id: route.id,
      index: route.index,
      path: route.path
    };
    if (routeModule) {
      Object.assign(dataRoute, {
        ...dataRoute,
        ...getRouteComponents(route, routeModule, isSpaMode),
        unstable_middleware: routeModule.unstable_clientMiddleware,
        handle: routeModule.handle,
        shouldRevalidate: getShouldRevalidateFunction(routeModule, route, ssr, needsRevalidation)
      });
      let hasInitialData = initialState && initialState.loaderData && route.id in initialState.loaderData;
      let initialData = hasInitialData ? initialState?.loaderData?.[route.id] : void 0;
      let hasInitialError = initialState && initialState.errors && route.id in initialState.errors;
      let initialError = hasInitialError ? initialState?.errors?.[route.id] : void 0;
      let isHydrationRequest = needsRevalidation == null && (routeModule.clientLoader?.hydrate === true || !route.hasLoader);
      dataRoute.loader = async ({
        request,
        params,
        context
      }, singleFetch) => {
        try {
          let result = await prefetchStylesAndCallHandler(async () => {
            invariant2(routeModule, "No `routeModule` available for critical-route loader");
            if (!routeModule.clientLoader) {
              return fetchServerLoader(singleFetch);
            }
            return routeModule.clientLoader({
              request,
              params,
              context,
              async serverLoader() {
                preventInvalidServerHandlerCall("loader", route);
                if (isHydrationRequest) {
                  if (hasInitialData) {
                    return initialData;
                  }
                  if (hasInitialError) {
                    throw initialError;
                  }
                }
                return fetchServerLoader(singleFetch);
              }
            });
          });
          return result;
        } finally {
          isHydrationRequest = false;
        }
      };
      dataRoute.loader.hydrate = shouldHydrateRouteLoader(route, routeModule, isSpaMode);
      dataRoute.action = ({
        request,
        params,
        context
      }, singleFetch) => {
        return prefetchStylesAndCallHandler(async () => {
          invariant2(routeModule, "No `routeModule` available for critical-route action");
          if (!routeModule.clientAction) {
            if (isSpaMode) {
              throw noActionDefinedError("clientAction", route.id);
            }
            return fetchServerAction(singleFetch);
          }
          return routeModule.clientAction({
            request,
            params,
            context,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route);
              return fetchServerAction(singleFetch);
            }
          });
        });
      };
    } else {
      if (!route.hasClientLoader) {
        dataRoute.loader = (_, singleFetch) => prefetchStylesAndCallHandler(() => {
          return fetchServerLoader(singleFetch);
        });
      } else if (route.clientLoaderModule) {
        dataRoute.loader = async (args, singleFetch) => {
          invariant2(route.clientLoaderModule);
          let {
            clientLoader
          } = await import(/* @vite-ignore */
          /* webpackIgnore: true */
          route.clientLoaderModule);
          return clientLoader({
            ...args,
            async serverLoader() {
              preventInvalidServerHandlerCall("loader", route);
              return fetchServerLoader(singleFetch);
            }
          });
        };
      }
      if (!route.hasClientAction) {
        dataRoute.action = (_, singleFetch) => prefetchStylesAndCallHandler(() => {
          if (isSpaMode) {
            throw noActionDefinedError("clientAction", route.id);
          }
          return fetchServerAction(singleFetch);
        });
      } else if (route.clientActionModule) {
        dataRoute.action = async (args, singleFetch) => {
          invariant2(route.clientActionModule);
          prefetchRouteModuleChunks(route);
          let {
            clientAction
          } = await import(/* @vite-ignore */
          /* webpackIgnore: true */
          route.clientActionModule);
          return clientAction({
            ...args,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route);
              return fetchServerAction(singleFetch);
            }
          });
        };
      }
      dataRoute.lazy = async () => {
        if (route.clientLoaderModule || route.clientActionModule) {
          await new Promise(resolve => setTimeout(resolve, 0));
        }
        let modPromise = loadRouteModuleWithBlockingLinks(route, routeModulesCache);
        prefetchRouteModuleChunks(route);
        let mod = await modPromise;
        let lazyRoute = {
          ...mod
        };
        if (mod.clientLoader) {
          let clientLoader = mod.clientLoader;
          lazyRoute.loader = (args, singleFetch) => clientLoader({
            ...args,
            async serverLoader() {
              preventInvalidServerHandlerCall("loader", route);
              return fetchServerLoader(singleFetch);
            }
          });
        }
        if (mod.clientAction) {
          let clientAction = mod.clientAction;
          lazyRoute.action = (args, singleFetch) => clientAction({
            ...args,
            async serverAction() {
              preventInvalidServerHandlerCall("action", route);
              return fetchServerAction(singleFetch);
            }
          });
        }
        return {
          ...(lazyRoute.loader ? {
            loader: lazyRoute.loader
          } : {}),
          ...(lazyRoute.action ? {
            action: lazyRoute.action
          } : {}),
          unstable_middleware: mod.unstable_clientMiddleware,
          hasErrorBoundary: lazyRoute.hasErrorBoundary,
          shouldRevalidate: getShouldRevalidateFunction(lazyRoute, route, ssr, needsRevalidation),
          handle: lazyRoute.handle,
          // No need to wrap these in layout since the root route is never
          // loaded via route.lazy()
          Component: lazyRoute.Component,
          ErrorBoundary: lazyRoute.ErrorBoundary
        };
      };
    }
    let children = createClientRoutes(manifest, routeModulesCache, initialState, ssr, isSpaMode, route.id, routesByParentId, needsRevalidation);
    if (children.length > 0) dataRoute.children = children;
    return dataRoute;
  });
}
function getShouldRevalidateFunction(route, manifestRoute, ssr, needsRevalidation) {
  if (needsRevalidation) {
    return wrapShouldRevalidateForHdr(manifestRoute.id, route.shouldRevalidate, needsRevalidation);
  }
  if (!ssr && manifestRoute.hasLoader && !manifestRoute.hasClientLoader) {
    if (route.shouldRevalidate) {
      let fn = route.shouldRevalidate;
      return opts => fn({
        ...opts,
        defaultShouldRevalidate: false
      });
    } else {
      return () => false;
    }
  }
  if (ssr && route.shouldRevalidate) {
    let fn = route.shouldRevalidate;
    return opts => fn({
      ...opts,
      defaultShouldRevalidate: true
    });
  }
  return route.shouldRevalidate;
}
function wrapShouldRevalidateForHdr(routeId, routeShouldRevalidate, needsRevalidation) {
  let handledRevalidation = false;
  return arg => {
    if (!handledRevalidation) {
      handledRevalidation = true;
      return needsRevalidation.has(routeId);
    }
    return routeShouldRevalidate ? routeShouldRevalidate(arg) : arg.defaultShouldRevalidate;
  };
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModulePromise = loadRouteModule(route, routeModules);
  let prefetchRouteCssPromise = prefetchRouteCss(route);
  let routeModule = await routeModulePromise;
  await Promise.all([prefetchRouteCssPromise, prefetchStyleLinks(route, routeModule)]);
  return {
    Component: getRouteModuleComponent(routeModule),
    ErrorBoundary: routeModule.ErrorBoundary,
    unstable_clientMiddleware: routeModule.unstable_clientMiddleware,
    clientAction: routeModule.clientAction,
    clientLoader: routeModule.clientLoader,
    handle: routeModule.handle,
    links: routeModule.links,
    meta: routeModule.meta,
    shouldRevalidate: routeModule.shouldRevalidate
  };
}
function getRouteModuleComponent(routeModule) {
  if (routeModule.default == null) return void 0;
  let isEmptyObject = typeof routeModule.default === "object" && Object.keys(routeModule.default).length === 0;
  if (!isEmptyObject) {
    return routeModule.default;
  }
}
function shouldHydrateRouteLoader(route, routeModule, isSpaMode) {
  return isSpaMode && route.id !== "root" || routeModule.clientLoader != null && (routeModule.clientLoader.hydrate === true || route.hasLoader !== true);
}

// lib/dom/ssr/fog-of-war.ts
var nextPaths = /* @__PURE__ */new Set();
var discoveredPathsMaxSize = 1e3;
var discoveredPaths = /* @__PURE__ */new Set();
var URL_LIMIT = 7680;
function isFogOfWarEnabled(ssr) {
  return ssr === true;
}
function getPartialManifest(manifest, router) {
  let routeIds = new Set(router.state.matches.map(m => m.route.id));
  let segments = router.state.location.pathname.split("/").filter(Boolean);
  let paths = ["/"];
  segments.pop();
  while (segments.length > 0) {
    paths.push(`/${segments.join("/")}`);
    segments.pop();
  }
  paths.forEach(path => {
    let matches = matchRoutes(router.routes, path, router.basename);
    if (matches) {
      matches.forEach(m => routeIds.add(m.route.id));
    }
  });
  let initialRoutes = [...routeIds].reduce((acc, id) => Object.assign(acc, {
    [id]: manifest.routes[id]
  }), {});
  return {
    ...manifest,
    routes: initialRoutes
  };
}
function getPatchRoutesOnNavigationFunction(manifest, routeModules, ssr, isSpaMode, basename) {
  if (!isFogOfWarEnabled(ssr)) {
    return void 0;
  }
  return async ({
    path,
    patch,
    signal,
    fetcherKey
  }) => {
    if (discoveredPaths.has(path)) {
      return;
    }
    await fetchAndApplyManifestPatches([path], fetcherKey ? window.location.href : path, manifest, routeModules, ssr, isSpaMode, basename, patch, signal);
  };
}
function useFogOFWarDiscovery(router, manifest, routeModules, ssr, isSpaMode) {
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (!isFogOfWarEnabled(ssr) || navigator.connection?.saveData === true) {
      return;
    }
    function registerElement(el) {
      let path = el.tagName === "FORM" ? el.getAttribute("action") : el.getAttribute("href");
      if (!path) {
        return;
      }
      let pathname = el.tagName === "A" ? el.pathname : new URL(path, window.location.origin).pathname;
      if (!discoveredPaths.has(pathname)) {
        nextPaths.add(pathname);
      }
    }
    async function fetchPatches() {
      document.querySelectorAll("a[data-discover], form[data-discover]").forEach(registerElement);
      let lazyPaths = Array.from(nextPaths.keys()).filter(path => {
        if (discoveredPaths.has(path)) {
          nextPaths.delete(path);
          return false;
        }
        return true;
      });
      if (lazyPaths.length === 0) {
        return;
      }
      try {
        await fetchAndApplyManifestPatches(lazyPaths, null, manifest, routeModules, ssr, isSpaMode, router.basename, router.patchRoutes);
      } catch (e) {
        console.error("Failed to fetch manifest patches", e);
      }
    }
    let debouncedFetchPatches = debounce(fetchPatches, 100);
    fetchPatches();
    let observer = new MutationObserver(() => debouncedFetchPatches());
    observer.observe(document.documentElement, {
      subtree: true,
      childList: true,
      attributes: true,
      attributeFilter: ["data-discover", "href", "action"]
    });
    return () => observer.disconnect();
  }, [ssr, isSpaMode, manifest, routeModules, router]);
}
var MANIFEST_VERSION_STORAGE_KEY = "react-router-manifest-version";
async function fetchAndApplyManifestPatches(paths, errorReloadPath, manifest, routeModules, ssr, isSpaMode, basename, patchRoutes, signal) {
  let manifestPath = `${basename != null ? basename : "/"}/__manifest`.replace(/\/+/g, "/");
  let url = new URL(manifestPath, window.location.origin);
  paths.sort().forEach(path => url.searchParams.append("p", path));
  url.searchParams.set("version", manifest.version);
  if (url.toString().length > URL_LIMIT) {
    nextPaths.clear();
    return;
  }
  let serverPatches;
  try {
    let res = await fetch(url, {
      signal
    });
    if (!res.ok) {
      throw new Error(`${res.status} ${res.statusText}`);
    } else if (res.status === 204 && res.headers.has("X-Remix-Reload-Document")) {
      if (!errorReloadPath) {
        console.warn("Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest.");
        return;
      }
      if (sessionStorage.getItem(MANIFEST_VERSION_STORAGE_KEY) === manifest.version) {
        console.error("Unable to discover routes due to manifest version mismatch.");
        return;
      }
      sessionStorage.setItem(MANIFEST_VERSION_STORAGE_KEY, manifest.version);
      window.location.href = errorReloadPath;
      throw new Error("Detected manifest version mismatch, reloading...");
    } else if (res.status >= 400) {
      throw new Error(await res.text());
    }
    sessionStorage.removeItem(MANIFEST_VERSION_STORAGE_KEY);
    serverPatches = await res.json();
  } catch (e) {
    if (signal?.aborted) return;
    throw e;
  }
  let knownRoutes = new Set(Object.keys(manifest.routes));
  let patches = Object.values(serverPatches).reduce((acc, route) => {
    if (route && !knownRoutes.has(route.id)) {
      acc[route.id] = route;
    }
    return acc;
  }, {});
  Object.assign(manifest.routes, patches);
  paths.forEach(p => addToFifoQueue(p, discoveredPaths));
  let parentIds = /* @__PURE__ */new Set();
  Object.values(patches).forEach(patch => {
    if (patch && (!patch.parentId || !patches[patch.parentId])) {
      parentIds.add(patch.parentId);
    }
  });
  parentIds.forEach(parentId => patchRoutes(parentId || null, createClientRoutes(patches, routeModules, null, ssr, isSpaMode, parentId)));
}
function addToFifoQueue(path, queue) {
  if (queue.size >= discoveredPathsMaxSize) {
    let first = queue.values().next().value;
    queue.delete(first);
  }
  queue.add(path);
}
function debounce(callback, wait) {
  let timeoutId;
  return (...args) => {
    window.clearTimeout(timeoutId);
    timeoutId = window.setTimeout(() => callback(...args), wait);
  };
}

// lib/dom/ssr/components.tsx
function useDataRouterContext2() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant2(context, "You must render this element inside a <DataRouterContext.Provider> element");
  return context;
}
function useDataRouterStateContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant2(context, "You must render this element inside a <DataRouterStateContext.Provider> element");
  return context;
}
var FrameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  invariant2(context, "You must render this element inside a <HydratedRouter> element");
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);
  let {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  let ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = entries => {
        entries.forEach(entry => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, {
        threshold: 0.5
      });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [shouldPrefetch, ref, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return event => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function getActiveMatches(matches, errors, isSpaMode) {
  if (isSpaMode && !isHydrated) {
    return [matches[0]];
  }
  if (errors) {
    let errorIdx = matches.findIndex(m => errors[m.route.id] !== void 0);
    return matches.slice(0, errorIdx + 1);
  }
  return matches;
}
function Links() {
  let {
    isSpaMode,
    manifest,
    routeModules,
    criticalCss
  } = useFrameworkContext();
  let {
    errors,
    matches: routerMatches
  } = useDataRouterStateContext();
  let matches = getActiveMatches(routerMatches, errors, isSpaMode);
  let keyedLinks = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => getKeyedLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, typeof criticalCss === "string" ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("style", {
    dangerouslySetInnerHTML: {
      __html: criticalCss
    }
  }) : null, typeof criticalCss === "object" ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    rel: "stylesheet",
    href: criticalCss.href
  }) : null, keyedLinks.map(({
    key,
    link
  }) => isPageLinkDescriptor(link) ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, {
    key,
    ...link
  }) : /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    key,
    ...link
  })));
}
function PrefetchPageLinks({
  page,
  ...dataLinkProps
}) {
  let {
    router
  } = useDataRouterContext2();
  let matches = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => matchRoutes(router.routes, page, router.basename), [router.routes, page, router.basename]);
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinksImpl, {
    page,
    matches,
    ...dataLinkProps
  });
}
function useKeyedPrefetchLinks(matches) {
  let {
    manifest,
    routeModules
  } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(links => {
      if (!interrupted) {
        setKeyedPrefetchLinks(links);
      }
    });
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let {
    manifest,
    routeModules
  } = useFrameworkContext();
  let {
    basename
  } = useDataRouterContext2();
  let {
    loaderData,
    matches
  } = useDataRouterStateContext();
  let newMatchesForData = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "data"), [page, nextMatches, matches, manifest, location]);
  let newMatchesForAssets = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, "assets"), [page, nextMatches, matches, manifest, location]);
  let dataHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach(m => {
      let manifestRoute = manifest.routes[m.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some(m2 => m2.route.id === m.route.id) && m.route.id in loaderData && routeModules[m.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(page, basename);
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set("_routes", nextMatches.filter(m => routesParams.has(m.route.id)).map(m => m.route.id).join(","));
    }
    return [url.pathname + url.search];
  }, [basename, loaderData, location, manifest, newMatchesForData, nextMatches, page, routeModules]);
  let moduleHrefs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, dataHrefs.map(href2 => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    key: href2,
    rel: "prefetch",
    as: "fetch",
    href: href2,
    ...linkProps
  })), moduleHrefs.map(href2 => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    key: href2,
    rel: "modulepreload",
    href: href2,
    ...linkProps
  })), keyedPrefetchLinks.map(({
    key,
    link
  }) =>
  // these don't spread `linkProps` because they are full link descriptors
  // already with their own props
  /* @__PURE__ */
  react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    key,
    ...link
  })));
}
function Meta() {
  let {
    isSpaMode,
    routeModules
  } = useFrameworkContext();
  let {
    errors,
    matches: routerMatches,
    loaderData
  } = useDataRouterStateContext();
  let location = useLocation();
  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);
  let error = null;
  if (errors) {
    error = errors[_matches[_matches.length - 1].route.id];
  }
  let meta = [];
  let leafMeta = null;
  let matches = [];
  for (let i = 0; i < _matches.length; i++) {
    let _match = _matches[i];
    let routeId = _match.route.id;
    let data2 = loaderData[routeId];
    let params = _match.params;
    let routeModule = routeModules[routeId];
    let routeMeta = [];
    let match = {
      id: routeId,
      data: data2,
      meta: [],
      params: _match.params,
      pathname: _match.pathname,
      handle: _match.route.handle,
      error
    };
    matches[i] = match;
    if (routeModule?.meta) {
      routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data: data2,
        params,
        location,
        matches,
        error
      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;
    } else if (leafMeta) {
      routeMeta = [...leafMeta];
    }
    routeMeta = routeMeta || [];
    if (!Array.isArray(routeMeta)) {
      throw new Error("The route at " + _match.route.path + " returns an invalid value. All route meta functions must return an array of meta objects.\n\nTo reference the meta function API, see https://remix.run/route/meta");
    }
    match.meta = routeMeta;
    matches[i] = match;
    meta = [...routeMeta];
    leafMeta = meta;
  }
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, meta.flat().map(metaProps => {
    if (!metaProps) {
      return null;
    }
    if ("tagName" in metaProps) {
      let {
        tagName,
        ...rest
      } = metaProps;
      if (!isValidMetaTag(tagName)) {
        console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);
        return null;
      }
      let Comp = tagName;
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Comp, {
        key: JSON.stringify(rest),
        ...rest
      });
    }
    if ("title" in metaProps) {
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("title", {
        key: "title"
      }, String(metaProps.title));
    }
    if ("charset" in metaProps) {
      metaProps.charSet ?? (metaProps.charSet = metaProps.charset);
      delete metaProps.charset;
    }
    if ("charSet" in metaProps && metaProps.charSet != null) {
      return typeof metaProps.charSet === "string" ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
        key: "charSet",
        charSet: metaProps.charSet
      }) : null;
    }
    if ("script:ld+json" in metaProps) {
      try {
        let json = JSON.stringify(metaProps["script:ld+json"]);
        return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
          key: `script:ld+json:${json}`,
          type: "application/ld+json",
          dangerouslySetInnerHTML: {
            __html: json
          }
        });
      } catch (err) {
        return null;
      }
    }
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("meta", {
      key: JSON.stringify(metaProps),
      ...metaProps
    });
  }));
}
function isValidMetaTag(tagName) {
  return typeof tagName === "string" && /^(meta|link)$/.test(tagName);
}
var isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    serverHandoffString,
    isSpaMode,
    ssr,
    renderMeta
  } = useFrameworkContext();
  let {
    router,
    static: isStatic,
    staticContext
  } = useDataRouterContext2();
  let {
    matches: routerMatches
  } = useDataRouterStateContext();
  let enableFogOfWar = isFogOfWarEnabled(ssr);
  if (renderMeta) {
    renderMeta.didRenderScripts = true;
  }
  let matches = getActiveMatches(routerMatches, null, isSpaMode);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let streamScript = "window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());";
    let contextScript = staticContext ? `window.__reactRouterContext = ${serverHandoffString};${streamScript}` : " ";
    let routeModulesScript = !isStatic ? " " : `${manifest.hmr?.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : ""}${!enableFogOfWar ? `import ${JSON.stringify(manifest.url)}` : ""};
${matches.map((match, routeIndex) => {
      let routeVarName = `route${routeIndex}`;
      let manifestEntry = manifest.routes[match.route.id];
      invariant2(manifestEntry, `Route ${match.route.id} not found in manifest`);
      let {
        clientActionModule,
        clientLoaderModule,
        hydrateFallbackModule,
        module
      } = manifestEntry;
      let chunks = [...(clientActionModule ? [{
        module: clientActionModule,
        varName: `${routeVarName}_clientAction`
      }] : []), ...(clientLoaderModule ? [{
        module: clientLoaderModule,
        varName: `${routeVarName}_clientLoader`
      }] : []), ...(hydrateFallbackModule ? [{
        module: hydrateFallbackModule,
        varName: `${routeVarName}_HydrateFallback`
      }] : []), {
        module,
        varName: `${routeVarName}_main`
      }];
      if (chunks.length === 1) {
        return `import * as ${routeVarName} from ${JSON.stringify(module)};`;
      }
      let chunkImportsSnippet = chunks.map(chunk => `import * as ${chunk.varName} from "${chunk.module}";`).join("\n");
      let mergedChunksSnippet = `const ${routeVarName} = {${chunks.map(chunk => `...${chunk.varName}`).join(",")}};`;
      return [chunkImportsSnippet, mergedChunksSnippet].join("\n");
    }).join("\n")}
  ${enableFogOfWar ?
    // Inline a minimal manifest with the SSR matches
    `window.__reactRouterManifest = ${JSON.stringify(getPartialManifest(manifest, router), null, 2)};` : ""}
  window.__reactRouterRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(",")}};

import(${JSON.stringify(manifest.entry.module)});`;
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
      ...props,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(contextScript),
      type: void 0
    }), /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
      ...props,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module",
      async: true
    }));
  }, []);
  let preloads = isHydrated ? [] : manifest.entry.imports.concat(getModuleLinkHrefs(matches, manifest, {
    includeHydrateFallback: true
  }));
  return isHydrated ? null : /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, !enableFogOfWar ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    rel: "modulepreload",
    href: manifest.url,
    crossOrigin: props.crossOrigin
  }) : null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    rel: "modulepreload",
    href: manifest.entry.module,
    crossOrigin: props.crossOrigin
  }), dedupe(preloads).map(path => /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), initialScripts);
}
function dedupe(array) {
  return [...new Set(array)];
}
function mergeRefs(...refs) {
  return value => {
    refs.forEach(ref => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

// lib/dom/lib.tsx
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser) {
    window.__reactRouterVersion = "7.4.0";
  }
} catch (e) {}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    unstable_getContext: opts?.unstable_getContext,
    future: opts?.future,
    history: createBrowserHistory({
      window: opts?.window
    }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function createHashRouter(routes, opts) {
  return createRouter({
    basename: opts?.basename,
    unstable_getContext: opts?.unstable_getContext,
    future: opts?.future,
    history: createHashHistory({
      window: opts?.window
    }),
    hydrationData: opts?.hydrationData || parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: opts?.dataStrategy,
    patchRoutesOnNavigation: opts?.patchRoutesOnNavigation,
    window: opts?.window
  }).initialize();
}
function parseHydrationData() {
  let state = window?.__staticRouterHydrationData;
  if (state && state.errors) {
    state = {
      ...state,
      errors: deserializeErrors(state.errors)
    };
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "";
            serialized[key] = error;
          } catch (e) {}
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function BrowserRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {
    react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
  }, [setStateImpl]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HashRouter({
  basename,
  children,
  window: window2
}) {
  let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {
    react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
  }, [setStateImpl]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HistoryRouter({
  basename,
  children,
  history
}) {
  let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({
    action: history.action,
    location: history.location
  });
  let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newState => {
    react__WEBPACK_IMPORTED_MODULE_0__.startTransition(() => setStateImpl(newState));
  }, [setStateImpl]);
  react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
HistoryRouter.displayName = "unstable_HistoryRouter";
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef({
  onClick,
  discover = "render",
  prefetch = "none",
  relative,
  reloadDocument,
  replace: replace2,
  state,
  target,
  to,
  preventScrollReset,
  viewTransition,
  ...rest
}, forwardedRef) {
  let {
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let isAbsolute = typeof to === "string" && ABSOLUTE_URL_REGEX2.test(to);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && isAbsolute) {
    absoluteHref = to;
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e) {
        warning(false, `<Link to="${to}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`);
      }
    }
  }
  let href2 = useHref(to, {
    relative
  });
  let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(prefetch, rest);
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  let link =
  // eslint-disable-next-line jsx-a11y/anchor-has-content
  /* @__PURE__ */
  react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    ...rest,
    ...prefetchHandlers,
    href: absoluteHref || href2,
    onClick: isExternal || reloadDocument ? onClick : handleClick,
    ref: mergeRefs(forwardedRef, prefetchRef),
    target,
    "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
  });
  return shouldPrefetch && !isAbsolute ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, link, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(PrefetchPageLinks, {
    page: href2
  })) : link;
});
Link.displayName = "Link";
var NavLink = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef({
  "aria-current": ariaCurrentProp = "page",
  caseSensitive = false,
  className: classNameProp = "",
  end = false,
  style: styleProp,
  to,
  viewTransition,
  children,
  ...rest
}, ref) {
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  let {
    navigator: navigator2,
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let isTransitioning = routerState != null &&
  // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  useViewTransitionState(path) && viewTransition === true;
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  if (nextLocationPathname && basename) {
    nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
  }
  const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let renderProps = {
    isActive,
    isPending,
    isTransitioning
  };
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp(renderProps);
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, {
    ...rest,
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to,
    viewTransition
  }, typeof children === "function" ? children(renderProps) : children);
});
NavLink.displayName = "NavLink";
var Form = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(({
  discover = "render",
  fetcherKey,
  navigate,
  reloadDocument,
  replace: replace2,
  state,
  method = defaultMethod,
  action,
  onSubmit,
  relative,
  preventScrollReset,
  viewTransition,
  ...props
}, forwardedRef) => {
  let submit = useSubmit();
  let formAction = useFormAction(action, {
    relative
  });
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
  let submitHandler = event => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented) return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = submitter?.getAttribute("formmethod") || method;
    submit(submitter || event.currentTarget, {
      fetcherKey,
      method: submitMethod,
      navigate,
      replace: replace2,
      state,
      relative,
      preventScrollReset,
      viewTransition
    });
  };
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("form", {
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler,
    ...props,
    "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
  });
});
Form.displayName = "Form";
function ScrollRestoration({
  getKey,
  storageKey,
  ...props
}) {
  let remixContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FrameworkContext);
  let {
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  useScrollRestoration({
    getKey,
    storageKey
  });
  let ssrKey = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    if (!remixContext || !getKey) return null;
    let userKey = getScrollRestorationKey(location, matches, basename, getKey);
    return userKey !== location.key ? userKey : null;
  },
  // Nah, we only need this the first time for the SSR render
  // eslint-disable-next-line react-hooks/exhaustive-deps
  []);
  if (!remixContext || remixContext.isSpaMode) {
    return null;
  }
  let restoreScroll = ((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({
        key
      }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(storageKey2);
    }
  }).toString();
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
    ...props,
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)}, ${JSON.stringify(ssrKey)})`
    }
  });
}
ScrollRestoration.displayName = "ScrollRestoration";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError2(hookName));
  return state;
}
function useLinkClickHandler(to, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(event => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
function useSearchParams(defaultInit) {
  warning(typeof URLSearchParams !== "undefined", `You cannot use the \`useSearchParams\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`);
  let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);
  let location = useLocation();
  let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() =>
  // Only merge in the defaults if we haven't yet called setSearchParams.
  // Once we call that we want those to take precedence, otherwise you can't
  // remove a param with setSearchParams({}) if it has an initial value
  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let {
    router
  } = useDataRouterContext3("useSubmit" /* UseSubmit */);
  let {
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (target, options = {}) => {
    let {
      action,
      method,
      encType,
      formData,
      body
    } = getFormSubmissionInfo(target, basename);
    if (options.navigate === false) {
      let key = options.fetcherKey || getUniqueFetcherId();
      await router.fetch(key, currentRouteId, options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        flushSync: options.flushSync
      });
    } else {
      await router.navigate(options.action || action, {
        preventScrollReset: options.preventScrollReset,
        formData,
        body,
        formMethod: options.method || method,
        formEncType: options.encType || encType,
        replace: options.replace,
        state: options.state,
        fromRouteId: currentRouteId,
        flushSync: options.flushSync,
        viewTransition: options.viewTransition
      });
    }
  }, [router, basename, currentRouteId]);
}
function useFormAction(action, {
  relative
} = {}) {
  let {
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = {
    ...useResolvedPath(action ? action : ".", {
      relative
    })
  };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some(v => v === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter(v => v).forEach(v => params.append("index", v));
      let qs = params.toString();
      path.search = qs ? `?${qs}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function useFetcher({
  key
} = {}) {
  let {
    router
  } = useDataRouterContext3("useFetcher" /* UseFetcher */);
  let state = useDataRouterState2("useFetcher" /* UseFetcher */);
  let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);
  let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);
  let routeId = route.matches[route.matches.length - 1]?.route.id;
  invariant(fetcherData, `useFetcher must be used inside a FetchersContext`);
  invariant(route, `useFetcher must be used inside a RouteContext`);
  invariant(routeId != null, `useFetcher can only be used on routes that contain a unique "id"`);
  let defaultKey = react__WEBPACK_IMPORTED_MODULE_0__.useId();
  let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || defaultKey);
  if (key && key !== fetcherKey) {
    setFetcherKey(key);
  }
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    router.getFetcher(fetcherKey);
    return () => router.deleteFetcher(fetcherKey);
  }, [router, fetcherKey]);
  let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (href2, opts) => {
    invariant(routeId, "No routeId available for fetcher.load()");
    await router.fetch(fetcherKey, routeId, href2, opts);
  }, [fetcherKey, routeId, router]);
  let submitImpl = useSubmit();
  let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(async (target, opts) => {
    await submitImpl(target, {
      ...opts,
      navigate: false,
      fetcherKey
    });
  }, [fetcherKey, submitImpl]);
  let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {
    let FetcherForm2 = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {
      return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, {
        ...props,
        navigate: false,
        fetcherKey,
        ref
      });
    });
    FetcherForm2.displayName = "fetcher.Form";
    return FetcherForm2;
  }, [fetcherKey]);
  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;
  let data2 = fetcherData.get(fetcherKey);
  let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({
    Form: FetcherForm,
    submit,
    load,
    ...fetcher,
    data: data2
  }), [FetcherForm, submit, load, fetcher, data2]);
  return fetcherWithComponents;
}
function useFetchers() {
  let state = useDataRouterState2("useFetchers" /* UseFetchers */);
  return Array.from(state.fetchers.entries()).map(([key, fetcher]) => ({
    ...fetcher,
    key
  }));
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function getScrollRestorationKey(location, matches, basename, getKey) {
  let key = null;
  if (getKey) {
    if (basename !== "/") {
      key = getKey({
        ...location,
        pathname: stripBasename(location.pathname, basename) || location.pathname
      }, matches);
    } else {
      key = getKey(location, matches);
    }
  }
  if (key == null) {
    key = location.key;
  }
  return key;
}
function useScrollRestoration({
  getKey,
  storageKey
} = {}) {
  let {
    router
  } = useDataRouterContext3("useScrollRestoration" /* UseScrollRestoration */);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState2("useScrollRestoration" /* UseScrollRestoration */);
  let {
    basename
  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {
    if (navigation.state === "idle") {
      let key = getScrollRestorationKey(location, matches, basename, getKey);
      savedScrollPositions[key] = window.scrollY;
    }
    try {
      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    } catch (error) {
      warning(false, `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error}).`);
    }
    window.history.scrollRestoration = "auto";
  }, [navigation.state, getKey, basename, location, matches, storageKey]));
  if (typeof document !== "undefined") {
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e) {}
    }, [storageKey]);
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      let disableScrollRestoration = router?.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function useBeforeUnload(callback, options) {
  let {
    capture
  } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
function usePrompt({
  when,
  message
}) {
  let blocker = useBlocker(when);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked") {
      let proceed = window.confirm(message);
      if (proceed) {
        setTimeout(blocker.proceed, 0);
      } else {
        blocker.reset();
      }
    }
  }, [blocker, message]);
  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
    if (blocker.state === "blocked" && !when) {
      blocker.reset();
    }
  }, [blocker, when]);
}
function useViewTransitionState(to, opts = {}) {
  let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);
  invariant(vtContext != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
  let {
    basename
  } = useDataRouterContext3("useViewTransitionState" /* useViewTransitionState */);
  let path = useResolvedPath(to, {
    relative: opts.relative
  });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}

// lib/dom/server.tsx

function StaticRouter({
  basename,
  children,
  location: locationProp = "/"
}) {
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let action = "POP" /* Pop */;
  let location = {
    pathname: locationProp.pathname || "/",
    search: locationProp.search || "",
    hash: locationProp.hash || "",
    state: locationProp.state != null ? locationProp.state : null,
    key: locationProp.key || "default"
  };
  let staticNavigator = getStatelessNavigator();
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename,
    children,
    location,
    navigationType: action,
    navigator: staticNavigator,
    static: true
  });
}
function StaticRouterProvider({
  context,
  router,
  hydrate = true,
  nonce
}) {
  invariant(router && context, "You must provide `router` and `context` to <StaticRouterProvider>");
  let dataRouterContext = {
    router,
    navigator: getStatelessNavigator(),
    static: true,
    staticContext: context,
    basename: context.basename || "/"
  };
  let fetchersContext = /* @__PURE__ */new Map();
  let hydrateScript = "";
  if (hydrate !== false) {
    let data2 = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors(context.errors)
    };
    let json = htmlEscape(JSON.stringify(JSON.stringify(data2)));
    hydrateScript = `window.__staticRouterHydrationData = JSON.parse(${json});`;
  }
  let {
    state
  } = dataRouterContext.router;
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {
    value: fetchersContext
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {
    value: {
      isTransitioning: false
    }
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {
    basename: dataRouterContext.basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: dataRouterContext.navigator,
    static: dataRouterContext.static
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes2, {
    routes: router.routes,
    future: router.future,
    state
  })))))), hydrateScript ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement("script", {
    suppressHydrationWarning: true,
    nonce,
    dangerouslySetInnerHTML: {
      __html: hydrateScript
    }
  }) : null);
}
function DataRoutes2({
  routes,
  future,
  state
}) {
  return useRoutesImpl(routes, void 0, state, future);
}
function serializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (isRouteErrorResponse(val)) {
      serialized[key] = {
        ...val,
        __type: "RouteErrorResponse"
      };
    } else if (val instanceof Error) {
      serialized[key] = {
        message: val.message,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.
        ...(val.name !== "Error" ? {
          __subType: val.name
        } : {})
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
function getStatelessNavigator() {
  return {
    createHref,
    encodeLocation,
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    }
  };
}
function createStaticHandler2(routes, opts) {
  return createStaticHandler(routes, {
    ...opts,
    mapRouteProperties
  });
}
function createStaticRouter(routes, context, opts = {}) {
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, void 0, manifest);
  let matches = context.matches.map(match => {
    let route = manifest[match.route.id] || match.route;
    return {
      ...match,
      route
    };
  });
  let msg = method => `You cannot use router.${method}() on the server because it is a stateless environment`;
  return {
    get basename() {
      return context.basename;
    },
    get future() {
      return {
        unstable_middleware: false,
        ...opts?.future
      };
    },
    get state() {
      return {
        historyAction: "POP" /* Pop */,
        location: context.location,
        matches,
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: context.errors,
        initialized: true,
        navigation: IDLE_NAVIGATION,
        restoreScrollPosition: null,
        preventScrollReset: false,
        revalidation: "idle",
        fetchers: /* @__PURE__ */new Map(),
        blockers: /* @__PURE__ */new Map()
      };
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return void 0;
    },
    initialize() {
      throw msg("initialize");
    },
    subscribe() {
      throw msg("subscribe");
    },
    enableScrollRestoration() {
      throw msg("enableScrollRestoration");
    },
    navigate() {
      throw msg("navigate");
    },
    fetch() {
      throw msg("fetch");
    },
    revalidate() {
      throw msg("revalidate");
    },
    createHref,
    encodeLocation,
    getFetcher() {
      return IDLE_FETCHER;
    },
    deleteFetcher() {
      throw msg("deleteFetcher");
    },
    dispose() {
      throw msg("dispose");
    },
    getBlocker() {
      return IDLE_BLOCKER;
    },
    deleteBlocker() {
      throw msg("deleteBlocker");
    },
    patchRoutes() {
      throw msg("patchRoutes");
    },
    _internalFetchControllers: /* @__PURE__ */new Map(),
    _internalSetRoutes() {
      throw msg("_internalSetRoutes");
    }
  };
}
function createHref(to) {
  return typeof to === "string" ? to : createPath(to);
}
function encodeLocation(to) {
  let href2 = typeof to === "string" ? to : createPath(to);
  href2 = href2.replace(/ $/, "%20");
  let encoded = ABSOLUTE_URL_REGEX3.test(href2) ? new URL(href2) : new URL(href2, "http://localhost");
  return {
    pathname: encoded.pathname,
    search: encoded.search,
    hash: encoded.hash
  };
}
var ABSOLUTE_URL_REGEX3 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var ESCAPE_LOOKUP2 = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX2 = /[&><\u2028\u2029]/g;
function htmlEscape(str) {
  return str.replace(ESCAPE_REGEX2, match => ESCAPE_LOOKUP2[match]);
}

// lib/dom/ssr/server.tsx

function ServerRouter({
  context,
  url,
  nonce
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let {
    manifest,
    routeModules,
    criticalCss,
    serverHandoffString
  } = context;
  let routes = createServerRoutes(manifest.routes, routeModules, context.future, context.isSpaMode);
  context.staticHandlerContext.loaderData = {
    ...context.staticHandlerContext.loaderData
  };
  for (let match of context.staticHandlerContext.matches) {
    let routeId = match.route.id;
    let route = routeModules[routeId];
    let manifestRoute = context.manifest.routes[routeId];
    if (route && manifestRoute && shouldHydrateRouteLoader(manifestRoute, route, context.isSpaMode) && (route.HydrateFallback || !manifestRoute.hasLoader)) {
      delete context.staticHandlerContext.loaderData[routeId];
    }
  }
  let router = createStaticRouter(routes, context.staticHandlerContext);
  return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(FrameworkContext.Provider, {
    value: {
      manifest,
      routeModules,
      criticalCss,
      serverHandoffString,
      future: context.future,
      ssr: context.ssr,
      isSpaMode: context.isSpaMode,
      serializeError: context.serializeError,
      renderMeta: context.renderMeta
    }
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RemixErrorBoundary, {
    location: router.state.location
  }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(StaticRouterProvider, {
    router,
    context: context.staticHandlerContext,
    hydrate: false
  }))), context.serverHandoffStream ? /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, null, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(StreamTransfer, {
    context,
    identifier: 0,
    reader: context.serverHandoffStream.getReader(),
    textDecoder: new TextDecoder(),
    nonce
  })) : null);
}

// lib/dom/ssr/routes-test-stub.tsx

function createRoutesStub(routes, unstable_getContext) {
  return function RoutesTestStub({
    initialEntries,
    initialIndex,
    hydrationData,
    future
  }) {
    let routerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    let remixContextRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();
    if (routerRef.current == null) {
      remixContextRef.current = {
        future: {
          unstable_middleware: future?.unstable_middleware === true
        },
        manifest: {
          routes: {},
          entry: {
            imports: [],
            module: ""
          },
          url: "",
          version: ""
        },
        routeModules: {},
        ssr: false,
        isSpaMode: false
      };
      let patched = processRoutes(
      // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`
      // types compared to `AgnosticRouteObject`
      convertRoutesToDataRoutes(routes, r => r), remixContextRef.current.manifest, remixContextRef.current.routeModules);
      routerRef.current = createMemoryRouter(patched, {
        unstable_getContext,
        initialEntries,
        initialIndex,
        hydrationData
      });
    }
    return /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(FrameworkContext.Provider, {
      value: remixContextRef.current
    }, /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouterProvider, {
      router: routerRef.current
    }));
  };
}
function processRoutes(routes, manifest, routeModules, parentId) {
  return routes.map(route => {
    if (!route.id) {
      throw new Error("Expected a route.id in @remix-run/testing processRoutes() function");
    }
    let newRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      Component: route.Component,
      HydrateFallback: route.HydrateFallback,
      ErrorBoundary: route.ErrorBoundary,
      action: route.action,
      loader: route.loader,
      handle: route.handle,
      shouldRevalidate: route.shouldRevalidate
    };
    let entryRoute = {
      id: route.id,
      path: route.path,
      index: route.index,
      parentId,
      hasAction: route.action != null,
      hasLoader: route.loader != null,
      // When testing routes, you should just be stubbing loader/action, not
      // trying to re-implement the full loader/clientLoader/SSR/hydration flow.
      // That is better tested via E2E tests.
      hasClientAction: false,
      hasClientLoader: false,
      hasErrorBoundary: route.ErrorBoundary != null,
      // any need for these?
      module: "build/stub-path-to-module.js",
      clientActionModule: void 0,
      clientLoaderModule: void 0,
      hydrateFallbackModule: void 0
    };
    manifest.routes[newRoute.id] = entryRoute;
    routeModules[route.id] = {
      default: route.Component || Outlet,
      ErrorBoundary: route.ErrorBoundary || void 0,
      handle: route.handle,
      links: route.links,
      meta: route.meta,
      shouldRevalidate: route.shouldRevalidate
    };
    if (route.children) {
      newRoute.children = processRoutes(route.children, manifest, routeModules, newRoute.id);
    }
    return newRoute;
  });
}

// lib/server-runtime/cookies.ts


// lib/server-runtime/crypto.ts
var encoder = new TextEncoder();
var sign = async (value, secret) => {
  let data2 = encoder.encode(value);
  let key = await createKey2(secret, ["sign"]);
  let signature = await crypto.subtle.sign("HMAC", key, data2);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
  return value + "." + hash;
};
var unsign = async (cookie, secret) => {
  let index = cookie.lastIndexOf(".");
  let value = cookie.slice(0, index);
  let hash = cookie.slice(index + 1);
  let data2 = encoder.encode(value);
  let key = await createKey2(secret, ["verify"]);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data2);
  return valid ? value : false;
};
var createKey2 = async (secret, usages) => crypto.subtle.importKey("raw", encoder.encode(secret), {
  name: "HMAC",
  hash: "SHA-256"
}, false, usages);
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// lib/server-runtime/cookies.ts
var createCookie = (name, cookieOptions = {}) => {
  let {
    secrets = [],
    ...options
  } = {
    path: "/",
    sameSite: "lax",
    ...cookieOptions
  };
  warnOnceAboutExpiresCookie(name, options.expires);
  return {
    get name() {
      return name;
    },
    get isSigned() {
      return secrets.length > 0;
    },
    get expires() {
      return typeof options.maxAge !== "undefined" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
    },
    async parse(cookieHeader, parseOptions) {
      if (!cookieHeader) return null;
      let cookies = (0,cookie__WEBPACK_IMPORTED_MODULE_2__.parse)(cookieHeader, {
        ...options,
        ...parseOptions
      });
      if (name in cookies) {
        let value = cookies[name];
        if (typeof value === "string" && value !== "") {
          let decoded = await decodeCookieValue(value, secrets);
          return decoded;
        } else {
          return "";
        }
      } else {
        return null;
      }
    },
    async serialize(value, serializeOptions) {
      return (0,cookie__WEBPACK_IMPORTED_MODULE_2__.serialize)(name, value === "" ? "" : await encodeCookieValue(value, secrets), {
        ...options,
        ...serializeOptions
      });
    }
  };
};
var isCookie = object => {
  return object != null && typeof object.name === "string" && typeof object.isSigned === "boolean" && typeof object.parse === "function" && typeof object.serialize === "function";
};
async function encodeCookieValue(value, secrets) {
  let encoded = encodeData(value);
  if (secrets.length > 0) {
    encoded = await sign(encoded, secrets[0]);
  }
  return encoded;
}
async function decodeCookieValue(value, secrets) {
  if (secrets.length > 0) {
    for (let secret of secrets) {
      let unsignedValue = await unsign(value, secret);
      if (unsignedValue !== false) {
        return decodeData(unsignedValue);
      }
    }
    return null;
  }
  return decodeData(value);
}
function encodeData(value) {
  return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
}
function decodeData(value) {
  try {
    return JSON.parse(decodeURIComponent(myEscape(atob(value))));
  } catch (error) {
    return {};
  }
}
function myEscape(value) {
  let str = value.toString();
  let result = "";
  let index = 0;
  let chr, code;
  while (index < str.length) {
    chr = str.charAt(index++);
    if (/[\w*+\-./@]/.exec(chr)) {
      result += chr;
    } else {
      code = chr.charCodeAt(0);
      if (code < 256) {
        result += "%" + hex(code, 2);
      } else {
        result += "%u" + hex(code, 4).toUpperCase();
      }
    }
  }
  return result;
}
function hex(code, length) {
  let result = code.toString(16);
  while (result.length < length) result = "0" + result;
  return result;
}
function myUnescape(value) {
  let str = value.toString();
  let result = "";
  let index = 0;
  let chr, part;
  while (index < str.length) {
    chr = str.charAt(index++);
    if (chr === "%") {
      if (str.charAt(index) === "u") {
        part = str.slice(index + 1, index + 5);
        if (/^[\da-f]{4}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16));
          index += 5;
          continue;
        }
      } else {
        part = str.slice(index, index + 2);
        if (/^[\da-f]{2}$/i.exec(part)) {
          result += String.fromCharCode(parseInt(part, 16));
          index += 2;
          continue;
        }
      }
    }
    result += chr;
  }
  return result;
}
function warnOnceAboutExpiresCookie(name, expires) {
  warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
}

// lib/server-runtime/entry.ts
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo2, routeId) => {
    let route = manifest[routeId];
    if (route) {
      memo2[routeId] = route.module;
    }
    return memo2;
  }, {});
}

// lib/server-runtime/mode.ts
var ServerMode = /* @__PURE__ */(ServerMode2 => {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
  return ServerMode2;
})(ServerMode || {});
function isServerMode(value) {
  return value === "development" /* Development */ || value === "production" /* Production */ || value === "test" /* Test */;
}

// lib/server-runtime/errors.ts
function sanitizeError(error, serverMode) {
  if (error instanceof Error && serverMode !== "development" /* Development */) {
    let sanitized = new Error("Unexpected Server Error");
    sanitized.stack = void 0;
    return sanitized;
  }
  return error;
}
function sanitizeErrors(errors, serverMode) {
  return Object.entries(errors).reduce((acc, [routeId, error]) => {
    return Object.assign(acc, {
      [routeId]: sanitizeError(error, serverMode)
    });
  }, {});
}
function serializeError(error, serverMode) {
  let sanitized = sanitizeError(error, serverMode);
  return {
    message: sanitized.message,
    stack: sanitized.stack
  };
}
function serializeErrors2(errors, serverMode) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (isRouteErrorResponse(val)) {
      serialized[key] = {
        ...val,
        __type: "RouteErrorResponse"
      };
    } else if (val instanceof Error) {
      let sanitized = sanitizeError(val, serverMode);
      serialized[key] = {
        message: sanitized.message,
        stack: sanitized.stack,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.  This will only apply
        // in dev mode since all production errors are sanitized to normal
        // Error instances
        ...(sanitized.name !== "Error" ? {
          __subType: sanitized.name
        } : {})
      };
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}

// lib/server-runtime/routeMatching.ts
function matchServerRoutes(routes, pathname, basename) {
  let matches = matchRoutes(routes, pathname, basename);
  if (!matches) return null;
  return matches.map(match => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// lib/server-runtime/data.ts
async function callRouteHandler(handler, args) {
  let result = await handler({
    request: stripRoutesParam(stripIndexParam2(args.request)),
    params: args.params,
    context: args.context
  });
  if (isDataWithResponseInit(result) && result.init && result.init.status && isRedirectStatusCode(result.init.status)) {
    throw new Response(null, result.init);
  }
  return result;
}
function stripIndexParam2(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  let init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}
function stripRoutesParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_routes");
  let init = {
    method: request.method,
    body: request.body,
    headers: request.headers,
    signal: request.signal
  };
  if (init.body) {
    init.duplex = "half";
  }
  return new Request(url.href, init);
}

// lib/server-runtime/invariant.ts
function invariant3(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    console.error("The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose");
    throw new Error(message);
  }
}

// lib/server-runtime/routes.ts
function groupRoutesByParentId2(manifest) {
  let routes = {};
  Object.values(manifest).forEach(route => {
    if (route) {
      let parentId = route.parentId || "";
      if (!routes[parentId]) {
        routes[parentId] = [];
      }
      routes[parentId].push(route);
    }
  });
  return routes;
}
function createRoutes(manifest, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map(route => ({
    ...route,
    children: createRoutes(manifest, route.id, routesByParentId)
  }));
}
function createStaticHandlerDataRoutes(manifest, future, parentId = "", routesByParentId = groupRoutesByParentId2(manifest)) {
  return (routesByParentId[parentId] || []).map(route => {
    let commonRoute = {
      // Always include root due to default boundaries
      hasErrorBoundary: route.id === "root" || route.module.ErrorBoundary != null,
      id: route.id,
      path: route.path,
      unstable_middleware: route.module.unstable_middleware,
      // Need to use RR's version in the param typed here to permit the optional
      // context even though we know it'll always be provided in remix
      loader: route.module.loader ? async args => {
        if (args.request.headers.has("X-React-Router-Prerender-Data")) {
          const preRenderedData = args.request.headers.get("X-React-Router-Prerender-Data");
          let encoded = preRenderedData ? decodeURI(preRenderedData) : preRenderedData;
          invariant3(encoded, "Missing prerendered data for route");
          let uint8array = new TextEncoder().encode(encoded);
          let stream = new ReadableStream({
            start(controller) {
              controller.enqueue(uint8array);
              controller.close();
            }
          });
          let decoded = await decodeViaTurboStream(stream, global);
          let data2 = decoded.value;
          invariant3(data2 && route.id in data2, "Unable to decode prerendered data");
          let result = data2[route.id];
          invariant3("data" in result, "Unable to process prerendered data");
          return result.data;
        }
        let val = await callRouteHandler(route.module.loader, args);
        return val;
      } : void 0,
      action: route.module.action ? args => callRouteHandler(route.module.action, args) : void 0,
      handle: route.module.handle
    };
    return route.index ? {
      index: true,
      ...commonRoute
    } : {
      caseSensitive: route.caseSensitive,
      children: createStaticHandlerDataRoutes(manifest, future, route.id, routesByParentId),
      ...commonRoute
    };
  });
}

// lib/server-runtime/markup.ts
var ESCAPE_LOOKUP3 = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX3 = /[&><\u2028\u2029]/g;
function escapeHtml2(html) {
  return html.replace(ESCAPE_REGEX3, match => ESCAPE_LOOKUP3[match]);
}

// lib/server-runtime/serverHandoff.ts
function createServerHandoffString(serverHandoff) {
  return escapeHtml2(JSON.stringify(serverHandoff));
}

// lib/server-runtime/dev.ts
var globalDevServerHooksKey = "__reactRouterDevServerHooks";
function setDevServerHooks(devServerHooks) {
  globalThis[globalDevServerHooksKey] = devServerHooks;
}
function getDevServerHooks() {
  return globalThis[globalDevServerHooksKey];
}

// lib/server-runtime/single-fetch.ts


// lib/server-runtime/headers.ts

function getDocumentHeaders(build, context) {
  let boundaryIdx = context.errors ? context.matches.findIndex(m => context.errors[m.route.id]) : -1;
  let matches = boundaryIdx >= 0 ? context.matches.slice(0, boundaryIdx + 1) : context.matches;
  let errorHeaders;
  if (boundaryIdx >= 0) {
    let {
      actionHeaders,
      actionData,
      loaderHeaders,
      loaderData
    } = context;
    context.matches.slice(boundaryIdx).some(match => {
      let id = match.route.id;
      if (actionHeaders[id] && (!actionData || !actionData.hasOwnProperty(id))) {
        errorHeaders = actionHeaders[id];
      } else if (loaderHeaders[id] && !loaderData.hasOwnProperty(id)) {
        errorHeaders = loaderHeaders[id];
      }
      return errorHeaders != null;
    });
  }
  return matches.reduce((parentHeaders, match, idx) => {
    let {
      id
    } = match.route;
    let route = build.routes[id];
    invariant3(route, `Route with id "${id}" not found in build`);
    let routeModule = route.module;
    let loaderHeaders = context.loaderHeaders[id] || new Headers();
    let actionHeaders = context.actionHeaders[id] || new Headers();
    let includeErrorHeaders = errorHeaders != null && idx === matches.length - 1;
    let includeErrorCookies = includeErrorHeaders && errorHeaders !== loaderHeaders && errorHeaders !== actionHeaders;
    if (routeModule.headers == null) {
      let headers2 = new Headers(parentHeaders);
      if (includeErrorCookies) {
        prependCookies(errorHeaders, headers2);
      }
      prependCookies(actionHeaders, headers2);
      prependCookies(loaderHeaders, headers2);
      return headers2;
    }
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders,
      errorHeaders: includeErrorHeaders ? errorHeaders : void 0
    }) : routeModule.headers : void 0);
    if (includeErrorCookies) {
      prependCookies(errorHeaders, headers);
    }
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0,set_cookie_parser__WEBPACK_IMPORTED_MODULE_3__.splitCookiesString)(parentSetCookieString);
    let childCookies = new Set(childHeaders.getSetCookie());
    cookies.forEach(cookie => {
      if (!childCookies.has(cookie)) {
        childHeaders.append("Set-Cookie", cookie);
      }
    });
  }
}

// lib/server-runtime/single-fetch.ts
var NO_BODY_STATUS_CODES = /* @__PURE__ */new Set([100, 101, 204, 205, 304]);
var SINGLE_FETCH_REDIRECT_STATUS = 202;
async function singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
  try {
    let respond2 = function (context) {
      let headers = getDocumentHeaders(build, context);
      if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
        return generateSingleFetchResponse(request, build, serverMode, {
          result: getSingleFetchRedirect(context.statusCode, headers, build.basename),
          headers,
          status: SINGLE_FETCH_REDIRECT_STATUS
        });
      }
      if (context.errors) {
        Object.values(context.errors).forEach(err => {
          if (!isRouteErrorResponse(err) || err.error) {
            handleError(err);
          }
        });
        context.errors = sanitizeErrors(context.errors, serverMode);
      }
      let singleFetchResult;
      if (context.errors) {
        singleFetchResult = {
          error: Object.values(context.errors)[0]
        };
      } else {
        singleFetchResult = {
          data: Object.values(context.actionData || {})[0]
        };
      }
      return generateSingleFetchResponse(request, build, serverMode, {
        result: singleFetchResult,
        headers,
        status: context.statusCode
      });
    };
    var respond = respond2;
    let handlerRequest = new Request(handlerUrl, {
      method: request.method,
      body: request.body,
      headers: request.headers,
      signal: request.signal,
      ...(request.body ? {
        duplex: "half"
      } : void 0)
    });
    let result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      skipLoaderErrorBubbling: true,
      skipRevalidation: true,
      unstable_respond: respond2
    });
    if (!isResponse(result)) {
      result = respond2(result);
    }
    if (isRedirectResponse(result)) {
      return generateSingleFetchResponse(request, build, serverMode, {
        result: getSingleFetchRedirect(result.status, result.headers, build.basename),
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      });
    }
    return result;
  } catch (error) {
    handleError(error);
    return generateSingleFetchResponse(request, build, serverMode, {
      result: {
        error
      },
      headers: new Headers(),
      status: 500
    });
  }
}
async function singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) {
  try {
    let respond2 = function (context) {
      let headers = getDocumentHeaders(build, context);
      if (isRedirectStatusCode(context.statusCode) && headers.has("Location")) {
        return generateSingleFetchResponse(request, build, serverMode, {
          result: {
            [SingleFetchRedirectSymbol]: getSingleFetchRedirect(context.statusCode, headers, build.basename)
          },
          headers,
          status: SINGLE_FETCH_REDIRECT_STATUS
        });
      }
      if (context.errors) {
        Object.values(context.errors).forEach(err => {
          if (!isRouteErrorResponse(err) || err.error) {
            handleError(err);
          }
        });
        context.errors = sanitizeErrors(context.errors, serverMode);
      }
      let results = {};
      let loadedMatches = new Set(context.matches.filter(m => loadRouteIds ? loadRouteIds.has(m.route.id) : m.route.loader != null).map(m => m.route.id));
      if (context.errors) {
        for (let [id, error] of Object.entries(context.errors)) {
          results[id] = {
            error
          };
        }
      }
      for (let [id, data2] of Object.entries(context.loaderData)) {
        if (!(id in results) && loadedMatches.has(id)) {
          results[id] = {
            data: data2
          };
        }
      }
      return generateSingleFetchResponse(request, build, serverMode, {
        result: results,
        headers,
        status: context.statusCode
      });
    };
    var respond = respond2;
    let handlerRequest = new Request(handlerUrl, {
      headers: request.headers,
      signal: request.signal
    });
    let routesParam = new URL(request.url).searchParams.get("_routes");
    let loadRouteIds = routesParam ? new Set(routesParam.split(",")) : null;
    let result = await staticHandler.query(handlerRequest, {
      requestContext: loadContext,
      filterMatchesToLoad: m => !loadRouteIds || loadRouteIds.has(m.route.id),
      skipLoaderErrorBubbling: true,
      unstable_respond: respond2
    });
    if (!isResponse(result)) {
      result = respond2(result);
    }
    if (isRedirectResponse(result)) {
      return generateSingleFetchResponse(request, build, serverMode, {
        result: {
          [SingleFetchRedirectSymbol]: getSingleFetchRedirect(result.status, result.headers, build.basename)
        },
        headers: result.headers,
        status: SINGLE_FETCH_REDIRECT_STATUS
      });
    }
    return result;
  } catch (error) {
    handleError(error);
    return generateSingleFetchResponse(request, build, serverMode, {
      result: {
        root: {
          error
        }
      },
      headers: new Headers(),
      status: 500
    });
  }
}
function generateSingleFetchResponse(request, build, serverMode, {
  result,
  headers,
  status
}) {
  let resultHeaders = new Headers(headers);
  resultHeaders.set("X-Remix-Response", "yes");
  if (NO_BODY_STATUS_CODES.has(status)) {
    return new Response(null, {
      status,
      headers: resultHeaders
    });
  }
  resultHeaders.set("Content-Type", "text/x-script");
  return new Response(encodeViaTurboStream(result, request.signal, build.entry.module.streamTimeout, serverMode), {
    status: status || 200,
    headers: resultHeaders
  });
}
function getSingleFetchRedirect(status, headers, basename) {
  let redirect2 = headers.get("Location");
  if (basename) {
    redirect2 = stripBasename(redirect2, basename) || redirect2;
  }
  return {
    redirect: redirect2,
    status,
    revalidate:
    // Technically X-Remix-Revalidate isn't needed here - that was an implementation
    // detail of ?_data requests as our way to tell the front end to revalidate when
    // we didn't have a response body to include that information in.
    // With single fetch, we tell the front end via this revalidate boolean field.
    // However, we're respecting it for now because it may be something folks have
    // used in their own responses
    // TODO(v3): Consider removing or making this official public API
    headers.has("X-Remix-Revalidate") || headers.has("Set-Cookie"),
    reload: headers.has("X-Remix-Reload-Document"),
    replace: headers.has("X-Remix-Replace")
  };
}
function encodeViaTurboStream(data2, requestSignal, streamTimeout, serverMode) {
  let controller = new AbortController();
  let timeoutId = setTimeout(() => controller.abort(new Error("Server Timeout")), typeof streamTimeout === "number" ? streamTimeout : 4950);
  requestSignal.addEventListener("abort", () => clearTimeout(timeoutId));
  return (0,turbo_stream__WEBPACK_IMPORTED_MODULE_1__.encode)(data2, {
    signal: controller.signal,
    plugins: [value => {
      if (value instanceof Error) {
        let {
          name,
          message,
          stack
        } = serverMode === "production" /* Production */ ? sanitizeError(value, serverMode) : value;
        return ["SanitizedError", name, message, stack];
      }
      if (value instanceof ErrorResponseImpl) {
        let {
          data: data3,
          status,
          statusText
        } = value;
        return ["ErrorResponse", data3, status, statusText];
      }
      if (value && typeof value === "object" && SingleFetchRedirectSymbol in value) {
        return ["SingleFetchRedirect", value[SingleFetchRedirectSymbol]];
      }
    }],
    postPlugins: [value => {
      if (!value) return;
      if (typeof value !== "object") return;
      return ["SingleFetchClassInstance", Object.fromEntries(Object.entries(value))];
    }, () => ["SingleFetchFallback"]]
  });
}

// lib/server-runtime/server.ts
function derive(build, mode) {
  let routes = createRoutes(build.routes);
  let dataRoutes = createStaticHandlerDataRoutes(build.routes, build.future);
  let serverMode = isServerMode(mode) ? mode : "production" /* Production */;
  let staticHandler = createStaticHandler(dataRoutes, {
    basename: build.basename
  });
  let errorHandler = build.entry.module.handleError || ((error, {
    request
  }) => {
    if (serverMode !== "test" /* Test */ && !request.signal.aborted) {
      console.error(
      // @ts-expect-error This is "private" from users but intended for internal use
      isRouteErrorResponse(error) && error.error ? error.error : error);
    }
  });
  return {
    routes,
    dataRoutes,
    serverMode,
    staticHandler,
    errorHandler
  };
}
var createRequestHandler = (build, mode) => {
  let _build;
  let routes;
  let serverMode;
  let staticHandler;
  let errorHandler;
  return async function requestHandler(request, initialContext) {
    _build = typeof build === "function" ? await build() : build;
    let loadContext = _build.future.unstable_middleware ? new unstable_RouterContextProvider(initialContext) : initialContext || {};
    if (typeof build === "function") {
      let derived = derive(_build, mode);
      routes = derived.routes;
      serverMode = derived.serverMode;
      staticHandler = derived.staticHandler;
      errorHandler = derived.errorHandler;
    } else if (!routes || !serverMode || !staticHandler || !errorHandler) {
      let derived = derive(_build, mode);
      routes = derived.routes;
      serverMode = derived.serverMode;
      staticHandler = derived.staticHandler;
      errorHandler = derived.errorHandler;
    }
    let url = new URL(request.url);
    let normalizedBasename = _build.basename || "/";
    let normalizedPath = url.pathname;
    if (stripBasename(normalizedPath, normalizedBasename) === "/_root.data") {
      normalizedPath = normalizedBasename;
    } else if (normalizedPath.endsWith(".data")) {
      normalizedPath = normalizedPath.replace(/\.data$/, "");
    }
    if (stripBasename(normalizedPath, normalizedBasename) !== "/" && normalizedPath.endsWith("/")) {
      normalizedPath = normalizedPath.slice(0, -1);
    }
    let params = {};
    let handleError = error => {
      if (mode === "development" /* Development */) {
        getDevServerHooks()?.processRequestError?.(error);
      }
      errorHandler(error, {
        context: loadContext,
        params,
        request
      });
    };
    if (!_build.ssr) {
      if (_build.prerender.length === 0) {
        request.headers.set("X-React-Router-SPA-Mode", "yes");
      } else if (!_build.prerender.includes(normalizedPath) && !_build.prerender.includes(normalizedPath + "/")) {
        if (url.pathname.endsWith(".data")) {
          errorHandler(new ErrorResponseImpl(404, "Not Found", `Refusing to SSR the path \`${normalizedPath}\` because \`ssr:false\` is set and the path is not included in the \`prerender\` config, so in production the path will be a 404.`), {
            context: loadContext,
            params,
            request
          });
          return new Response("Not Found", {
            status: 404,
            statusText: "Not Found"
          });
        } else {
          request.headers.set("X-React-Router-SPA-Mode", "yes");
        }
      }
    }
    let manifestUrl = `${normalizedBasename}/__manifest`.replace(/\/+/g, "/");
    if (url.pathname === manifestUrl) {
      try {
        let res = await handleManifestRequest(_build, routes, url);
        return res;
      } catch (e) {
        handleError(e);
        return new Response("Unknown Server Error", {
          status: 500
        });
      }
    }
    let matches = matchServerRoutes(routes, url.pathname, _build.basename);
    if (matches && matches.length > 0) {
      Object.assign(params, matches[0].params);
    }
    let response;
    if (url.pathname.endsWith(".data")) {
      let handlerUrl = new URL(request.url);
      handlerUrl.pathname = normalizedPath;
      let singleFetchMatches = matchServerRoutes(routes, handlerUrl.pathname, _build.basename);
      response = await handleSingleFetchRequest(serverMode, _build, staticHandler, request, handlerUrl, loadContext, handleError);
      if (_build.entry.module.handleDataRequest) {
        response = await _build.entry.module.handleDataRequest(response, {
          context: loadContext,
          params: singleFetchMatches ? singleFetchMatches[0].params : {},
          request
        });
        if (isRedirectResponse(response)) {
          let result = getSingleFetchRedirect(response.status, response.headers, _build.basename);
          if (request.method === "GET") {
            result = {
              [SingleFetchRedirectSymbol]: result
            };
          }
          let headers = new Headers(response.headers);
          headers.set("Content-Type", "text/x-script");
          return new Response(encodeViaTurboStream(result, request.signal, _build.entry.module.streamTimeout, serverMode), {
            status: SINGLE_FETCH_REDIRECT_STATUS,
            headers
          });
        }
      }
    } else if (!request.headers.has("X-React-Router-SPA-Mode") && matches && matches[matches.length - 1].route.module.default == null && matches[matches.length - 1].route.module.ErrorBoundary == null) {
      response = await handleResourceRequest(serverMode, _build, staticHandler, matches.slice(-1)[0].route.id, request, loadContext, handleError);
    } else {
      let {
        pathname
      } = url;
      let criticalCss = void 0;
      if (_build.unstable_getCriticalCss) {
        criticalCss = await _build.unstable_getCriticalCss({
          pathname
        });
      } else if (mode === "development" /* Development */ && getDevServerHooks()?.getCriticalCss) {
        criticalCss = await getDevServerHooks()?.getCriticalCss?.(pathname);
      }
      response = await handleDocumentRequest(serverMode, _build, staticHandler, request, loadContext, handleError, criticalCss);
    }
    if (request.method === "HEAD") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
};
async function handleManifestRequest(build, routes, url) {
  if (build.assets.version !== url.searchParams.get("version")) {
    return new Response(null, {
      status: 204,
      headers: {
        "X-Remix-Reload-Document": "true"
      }
    });
  }
  let patches = {};
  if (url.searchParams.has("p")) {
    let paths = /* @__PURE__ */new Set();
    url.searchParams.getAll("p").forEach(path => {
      if (!path.startsWith("/")) {
        path = `/${path}`;
      }
      let segments = path.split("/").slice(1);
      segments.forEach((_, i) => {
        let partialPath = segments.slice(0, i + 1).join("/");
        paths.add(`/${partialPath}`);
      });
    });
    for (let path of paths) {
      let matches = matchServerRoutes(routes, path, build.basename);
      if (matches) {
        for (let match of matches) {
          let routeId = match.route.id;
          let route = build.assets.routes[routeId];
          if (route) {
            patches[routeId] = route;
          }
        }
      }
    }
    return Response.json(patches, {
      headers: {
        "Cache-Control": "public, max-age=31536000, immutable"
      }
    });
  }
  return new Response("Invalid Request", {
    status: 400
  });
}
async function handleSingleFetchRequest(serverMode, build, staticHandler, request, handlerUrl, loadContext, handleError) {
  let response = request.method !== "GET" ? await singleFetchAction(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError) : await singleFetchLoaders(build, serverMode, staticHandler, request, handlerUrl, loadContext, handleError);
  return response;
}
async function handleDocumentRequest(serverMode, build, staticHandler, request, loadContext, handleError, criticalCss) {
  let isSpaMode = request.headers.has("X-React-Router-SPA-Mode");
  try {
    let response = await staticHandler.query(request, {
      requestContext: loadContext,
      unstable_respond: build.future.unstable_middleware ? ctx => renderHtml(ctx, isSpaMode) : void 0
    });
    return isResponse(response) ? response : renderHtml(response, isSpaMode);
  } catch (error) {
    handleError(error);
    return new Response(null, {
      status: 500
    });
  }
  async function renderHtml(context, isSpaMode2) {
    if (isResponse(context)) {
      return context;
    }
    let headers = getDocumentHeaders(build, context);
    if (NO_BODY_STATUS_CODES.has(context.statusCode)) {
      return new Response(null, {
        status: context.statusCode,
        headers
      });
    }
    if (context.errors) {
      Object.values(context.errors).forEach(err => {
        if (!isRouteErrorResponse(err) || err.error) {
          handleError(err);
        }
      });
      context.errors = sanitizeErrors(context.errors, serverMode);
    }
    let state = {
      loaderData: context.loaderData,
      actionData: context.actionData,
      errors: serializeErrors2(context.errors, serverMode)
    };
    let entryContext = {
      manifest: build.assets,
      routeModules: createEntryRouteModules(build.routes),
      staticHandlerContext: context,
      criticalCss,
      serverHandoffString: createServerHandoffString({
        basename: build.basename,
        criticalCss,
        future: build.future,
        ssr: build.ssr,
        isSpaMode: isSpaMode2
      }),
      serverHandoffStream: encodeViaTurboStream(state, request.signal, build.entry.module.streamTimeout, serverMode),
      renderMeta: {},
      future: build.future,
      ssr: build.ssr,
      isSpaMode: isSpaMode2,
      serializeError: err => serializeError(err, serverMode)
    };
    let handleDocumentRequestFunction = build.entry.module.default;
    try {
      return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);
    } catch (error) {
      handleError(error);
      let errorForSecondRender = error;
      if (isResponse(error)) {
        try {
          let data2 = await unwrapResponse(error);
          errorForSecondRender = new ErrorResponseImpl(error.status, error.statusText, data2);
        } catch (e) {}
      }
      context = getStaticContextFromError(staticHandler.dataRoutes, context, errorForSecondRender);
      if (context.errors) {
        context.errors = sanitizeErrors(context.errors, serverMode);
      }
      let state2 = {
        loaderData: context.loaderData,
        actionData: context.actionData,
        errors: serializeErrors2(context.errors, serverMode)
      };
      entryContext = {
        ...entryContext,
        staticHandlerContext: context,
        serverHandoffString: createServerHandoffString({
          basename: build.basename,
          future: build.future,
          ssr: build.ssr,
          isSpaMode: isSpaMode2
        }),
        serverHandoffStream: encodeViaTurboStream(state2, request.signal, build.entry.module.streamTimeout, serverMode),
        renderMeta: {}
      };
      try {
        return await handleDocumentRequestFunction(request, context.statusCode, headers, entryContext, loadContext);
      } catch (error2) {
        handleError(error2);
        return returnLastResortErrorResponse(error2, serverMode);
      }
    }
  }
}
async function handleResourceRequest(serverMode, build, staticHandler, routeId, request, loadContext, handleError) {
  try {
    let response = await staticHandler.queryRoute(request, {
      routeId,
      requestContext: loadContext,
      unstable_respond: build.future.unstable_middleware ? ctx => ctx : void 0
    });
    if (isResponse(response)) {
      return response;
    }
    if (typeof response === "string") {
      return new Response(response);
    }
    return Response.json(response);
  } catch (error) {
    if (isResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
      return error;
    }
    if (isRouteErrorResponse(error)) {
      if (error) {
        handleError(error);
      }
      return errorResponseToJson(error, serverMode);
    }
    if (error instanceof Error && error.message === "Expected a response from queryRoute") {
      let newError = new Error("Expected a Response to be returned from resource route handler");
      handleError(newError);
      return returnLastResortErrorResponse(newError, serverMode);
    }
    handleError(error);
    return returnLastResortErrorResponse(error, serverMode);
  }
}
function errorResponseToJson(errorResponse, serverMode) {
  return Response.json(serializeError(
  // @ts-expect-error This is "private" from users but intended for internal use
  errorResponse.error || new Error("Unexpected Server Error"), serverMode), {
    status: errorResponse.status,
    statusText: errorResponse.statusText,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function returnLastResortErrorResponse(error, serverMode) {
  let message = "Unexpected Server Error";
  if (serverMode !== "production" /* Production */) {
    message += `

${String(error)}`;
  }
  return new Response(message, {
    status: 500,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
function unwrapResponse(response) {
  let contentType = response.headers.get("Content-Type");
  return contentType && /\bapplication\/json\b/.test(contentType) ? response.body == null ? null : response.json() : response.text();
}

// lib/server-runtime/sessions.ts
function flash(name) {
  return `__flash_${name}__`;
}
var createSession = (initialData = {}, id = "") => {
  let map = new Map(Object.entries(initialData));
  return {
    get id() {
      return id;
    },
    get data() {
      return Object.fromEntries(map);
    },
    has(name) {
      return map.has(name) || map.has(flash(name));
    },
    get(name) {
      if (map.has(name)) return map.get(name);
      let flashName = flash(name);
      if (map.has(flashName)) {
        let value = map.get(flashName);
        map.delete(flashName);
        return value;
      }
      return void 0;
    },
    set(name, value) {
      map.set(name, value);
    },
    flash(name, value) {
      map.set(flash(name), value);
    },
    unset(name) {
      map.delete(name);
    }
  };
};
var isSession = object => {
  return object != null && typeof object.id === "string" && typeof object.data !== "undefined" && typeof object.has === "function" && typeof object.get === "function" && typeof object.set === "function" && typeof object.flash === "function" && typeof object.unset === "function";
};
function createSessionStorage({
  cookie: cookieArg,
  createData,
  readData,
  updateData,
  deleteData
}) {
  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
  warnOnceAboutSigningSessionCookie(cookie);
  return {
    async getSession(cookieHeader, options) {
      let id = cookieHeader && (await cookie.parse(cookieHeader, options));
      let data2 = id && (await readData(id));
      return createSession(data2 || {}, id || "");
    },
    async commitSession(session, options) {
      let {
        id,
        data: data2
      } = session;
      let expires = options?.maxAge != null ? new Date(Date.now() + options.maxAge * 1e3) : options?.expires != null ? options.expires : cookie.expires;
      if (id) {
        await updateData(id, data2, expires);
      } else {
        id = await createData(data2, expires);
      }
      return cookie.serialize(id, options);
    },
    async destroySession(session, options) {
      await deleteData(session.id);
      return cookie.serialize("", {
        ...options,
        maxAge: void 0,
        expires: /* @__PURE__ */new Date(0)
      });
    }
  };
}
function warnOnceAboutSigningSessionCookie(cookie) {
  warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/utils/cookies#signing-cookies for more information.`);
}

// lib/server-runtime/sessions/cookieStorage.ts
function createCookieSessionStorage({
  cookie: cookieArg
} = {}) {
  let cookie = isCookie(cookieArg) ? cookieArg : createCookie(cookieArg?.name || "__session", cookieArg);
  warnOnceAboutSigningSessionCookie(cookie);
  return {
    async getSession(cookieHeader, options) {
      return createSession(cookieHeader && (await cookie.parse(cookieHeader, options)) || {});
    },
    async commitSession(session, options) {
      let serializedCookie = await cookie.serialize(session.data, options);
      if (serializedCookie.length > 4096) {
        throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
      }
      return serializedCookie;
    },
    async destroySession(_session, options) {
      return cookie.serialize("", {
        ...options,
        maxAge: void 0,
        expires: /* @__PURE__ */new Date(0)
      });
    }
  };
}

// lib/server-runtime/sessions/memoryStorage.ts
function createMemorySessionStorage({
  cookie
} = {}) {
  let map = /* @__PURE__ */new Map();
  return createSessionStorage({
    cookie,
    async createData(data2, expires) {
      let id = Math.random().toString(36).substring(2, 10);
      map.set(id, {
        data: data2,
        expires
      });
      return id;
    },
    async readData(id) {
      if (map.has(id)) {
        let {
          data: data2,
          expires
        } = map.get(id);
        if (!expires || expires > /* @__PURE__ */new Date()) {
          return data2;
        }
        if (expires) map.delete(id);
      }
      return null;
    },
    async updateData(id, data2, expires) {
      map.set(id, {
        data: data2,
        expires
      });
    },
    async deleteData(id) {
      map.delete(id);
    }
  });
}

// lib/href.ts
function href(path, ...args) {
  let params = args[0];
  return path.split("/").map(segment => {
    const match = segment.match(/^:([\w-]+)(\?)?/);
    if (!match) return segment;
    const param = match[1];
    const value = params ? params[param] : void 0;
    const isRequired = match[2] === void 0;
    if (isRequired && value === void 0) {
      throw Error(`Path '${path}' requires param '${param}' but it was not provided`);
    }
    return value;
  }).filter(segment => segment !== void 0).join("/");
}

// lib/dom/ssr/errors.ts
function deserializeErrors2(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = val.stack;
            serialized[key] = error;
          } catch (e) {}
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = val.stack;
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}


/***/ }),

/***/ "./node_modules/react-router/node_modules/cookie/dist/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-router/node_modules/cookie/dist/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parse = parse;
exports.serialize = serialize;
/**
 * RegExp to match cookie-name in RFC 6265 sec 4.1.1
 * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
 * which has been replaced by the token definition in RFC 7230 appendix B.
 *
 * cookie-name       = token
 * token             = 1*tchar
 * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
 *                     "*" / "+" / "-" / "." / "^" / "_" /
 *                     "`" / "|" / "~" / DIGIT / ALPHA
 *
 * Note: Allowing more characters - https://github.com/jshttp/cookie/issues/191
 * Allow same range as cookie value, except `=`, which delimits end of name.
 */
const cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
/**
 * RegExp to match cookie-value in RFC 6265 sec 4.1.1
 *
 * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
 * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
 *                     ; US-ASCII characters excluding CTLs,
 *                     ; whitespace DQUOTE, comma, semicolon,
 *                     ; and backslash
 *
 * Allowing more characters: https://github.com/jshttp/cookie/issues/191
 * Comma, backslash, and DQUOTE are not part of the parsing algorithm.
 */
const cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
/**
 * RegExp to match domain-value in RFC 6265 sec 4.1.1
 *
 * domain-value      = <subdomain>
 *                     ; defined in [RFC1034], Section 3.5, as
 *                     ; enhanced by [RFC1123], Section 2.1
 * <subdomain>       = <label> | <subdomain> "." <label>
 * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
 *                     Labels must be 63 characters or less.
 *                     'let-dig' not 'letter' in the first char, per RFC1123
 * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
 * <let-dig-hyp>     = <let-dig> | "-"
 * <let-dig>         = <letter> | <digit>
 * <letter>          = any one of the 52 alphabetic characters A through Z in
 *                     upper case and a through z in lower case
 * <digit>           = any one of the ten digits 0 through 9
 *
 * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
 *
 * > (Note that a leading %x2E ("."), if present, is ignored even though that
 * character is not permitted, but a trailing %x2E ("."), if present, will
 * cause the user agent to ignore the attribute.)
 */
const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
/**
 * RegExp to match path-value in RFC 6265 sec 4.1.1
 *
 * path-value        = <any CHAR except CTLs or ";">
 * CHAR              = %x01-7F
 *                     ; defined in RFC 5234 appendix B.1
 */
const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
const __toString = Object.prototype.toString;
const NullObject = /* @__PURE__ */(() => {
  const C = function () {};
  C.prototype = Object.create(null);
  return C;
})();
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 */
function parse(str, options) {
  const obj = new NullObject();
  const len = str.length;
  // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
  if (len < 2) return obj;
  const dec = options?.decode || decode;
  let index = 0;
  do {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) break; // No more cookie pairs.
    const colonIdx = str.indexOf(";", index);
    const endIdx = colonIdx === -1 ? len : colonIdx;
    if (eqIdx > endIdx) {
      // backtrack on prior semicolon
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const keyStartIdx = startIndex(str, index, eqIdx);
    const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
    const key = str.slice(keyStartIdx, keyEndIdx);
    // only assign once
    if (obj[key] === undefined) {
      let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
      let valEndIdx = endIndex(str, endIdx, valStartIdx);
      const value = dec(str.slice(valStartIdx, valEndIdx));
      obj[key] = value;
    }
    index = endIdx + 1;
  } while (index < len);
  return obj;
}
function startIndex(str, index, max) {
  do {
    const code = str.charCodeAt(index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
  } while (++index < max);
  return max;
}
function endIndex(str, index, min) {
  while (index > min) {
    const code = str.charCodeAt(--index);
    if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
  }
  return min;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize a name value pair into a cookie string suitable for
 * http headers. An optional options object specifies cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 */
function serialize(name, val, options) {
  const enc = options?.encode || encodeURIComponent;
  if (!cookieNameRegExp.test(name)) {
    throw new TypeError(`argument name is invalid: ${name}`);
  }
  const value = enc(val);
  if (!cookieValueRegExp.test(value)) {
    throw new TypeError(`argument val is invalid: ${val}`);
  }
  let str = name + "=" + value;
  if (!options) return str;
  if (options.maxAge !== undefined) {
    if (!Number.isInteger(options.maxAge)) {
      throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
    }
    str += "; Max-Age=" + options.maxAge;
  }
  if (options.domain) {
    if (!domainValueRegExp.test(options.domain)) {
      throw new TypeError(`option domain is invalid: ${options.domain}`);
    }
    str += "; Domain=" + options.domain;
  }
  if (options.path) {
    if (!pathValueRegExp.test(options.path)) {
      throw new TypeError(`option path is invalid: ${options.path}`);
    }
    str += "; Path=" + options.path;
  }
  if (options.expires) {
    if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
      throw new TypeError(`option expires is invalid: ${options.expires}`);
    }
    str += "; Expires=" + options.expires.toUTCString();
  }
  if (options.httpOnly) {
    str += "; HttpOnly";
  }
  if (options.secure) {
    str += "; Secure";
  }
  if (options.partitioned) {
    str += "; Partitioned";
  }
  if (options.priority) {
    const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError(`option priority is invalid: ${options.priority}`);
    }
  }
  if (options.sameSite) {
    const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
    switch (sameSite) {
      case true:
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
    }
  }
  return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 */
function decode(str) {
  if (str.indexOf("%") === -1) return str;
  try {
    return decodeURIComponent(str);
  } catch (e) {
    return str;
  }
}
/**
 * Determine if value is a Date.
 */
function isDate(val) {
  return __toString.call(val) === "[object Date]";
}

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



 true && function () {
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
    }
    if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
    return null;
  }
  function testStringCoercion(value) {
    return "" + value;
  }
  function checkKeyStringCoercion(value) {
    try {
      testStringCoercion(value);
      var JSCompiler_inline_result = !1;
    } catch (e) {
      JSCompiler_inline_result = !0;
    }
    if (JSCompiler_inline_result) {
      JSCompiler_inline_result = console;
      var JSCompiler_temp_const = JSCompiler_inline_result.error;
      var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
      return testStringCoercion(value);
    }
  }
  function disabledLog() {}
  function disableLogs() {
    if (0 === disabledDepth) {
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd;
      var props = {
        configurable: !0,
        enumerable: !0,
        value: disabledLog,
        writable: !0
      };
      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
    }
    disabledDepth++;
  }
  function reenableLogs() {
    disabledDepth--;
    if (0 === disabledDepth) {
      var props = {
        configurable: !0,
        enumerable: !0,
        writable: !0
      };
      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
    }
    0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
  }
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix) try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + prefix + name + suffix;
  }
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    var frame = componentFrameCache.get(fn);
    if (void 0 !== frame) return frame;
    reentry = !0;
    frame = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    var previousDispatcher = null;
    previousDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = null;
    disableLogs();
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: function () {
          try {
            if (construct) {
              var Fake = function () {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function () {
                  throw Error();
                }
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  var control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$0) {
                  control = x$0;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$1) {
                control = x$1;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
          }
          return [null, null];
        }
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
        value: "DetermineComponentFrameRoot"
      });
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
        sampleStack = _RunInRootFrame$Deter[0],
        controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"),
          controlLines = controlStack.split("\n");
        for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
        for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
        if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
        for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
          if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
            do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
              fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
              "function" === typeof fn && componentFrameCache.set(fn, _frame);
              return _frame;
            } while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
          }
          break;
        }
      }
    } finally {
      reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
    }
    sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
    "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
    return sampleLines;
  }
  function describeUnknownElementTypeFrameInDEV(type) {
    if (null == type) return "";
    if ("function" === typeof type) {
      var prototype = type.prototype;
      return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
    }
    if ("string" === typeof type) return describeBuiltInComponentFrame(type);
    switch (type) {
      case REACT_SUSPENSE_TYPE:
        return describeBuiltInComponentFrame("Suspense");
      case REACT_SUSPENSE_LIST_TYPE:
        return describeBuiltInComponentFrame("SuspenseList");
    }
    if ("object" === typeof type) switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return type = describeNativeComponentFrame(type.render, !1), type;
      case REACT_MEMO_TYPE:
        return describeUnknownElementTypeFrameInDEV(type.type);
      case REACT_LAZY_TYPE:
        prototype = type._payload;
        type = type._init;
        try {
          return describeUnknownElementTypeFrameInDEV(type(prototype));
        } catch (x) {}
    }
    return "";
  }
  function getOwner() {
    var dispatcher = ReactSharedInternals.A;
    return null === dispatcher ? null : dispatcher.getOwner();
  }
  function hasValidKey(config) {
    if (hasOwnProperty.call(config, "key")) {
      var getter = Object.getOwnPropertyDescriptor(config, "key").get;
      if (getter && getter.isReactWarning) return !1;
    }
    return void 0 !== config.key;
  }
  function defineKeyPropWarningGetter(props, displayName) {
    function warnAboutAccessingKey() {
      specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
    }
    warnAboutAccessingKey.isReactWarning = !0;
    Object.defineProperty(props, "key", {
      get: warnAboutAccessingKey,
      configurable: !0
    });
  }
  function elementRefGetterWithDeprecationWarning() {
    var componentName = getComponentNameFromType(this.type);
    didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
    componentName = this.props.ref;
    return void 0 !== componentName ? componentName : null;
  }
  function ReactElement(type, key, self, source, owner, props) {
    self = props.ref;
    type = {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key,
      props: props,
      _owner: owner
    };
    null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
      enumerable: !1,
      get: elementRefGetterWithDeprecationWarning
    }) : Object.defineProperty(type, "ref", {
      enumerable: !1,
      value: null
    });
    type._store = {};
    Object.defineProperty(type._store, "validated", {
      configurable: !1,
      enumerable: !1,
      writable: !0,
      value: 0
    });
    Object.defineProperty(type, "_debugInfo", {
      configurable: !1,
      enumerable: !1,
      writable: !0,
      value: null
    });
    Object.freeze && (Object.freeze(type.props), Object.freeze(type));
    return type;
  }
  function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self) {
    if ("string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId)) {
      var children = config.children;
      if (void 0 !== children) if (isStaticChildren) {
        if (isArrayImpl(children)) {
          for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++) validateChildKeys(children[isStaticChildren], type);
          Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
      } else validateChildKeys(children, type);
    } else {
      children = "";
      if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) children += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
      null === type ? isStaticChildren = "null" : isArrayImpl(type) ? isStaticChildren = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (isStaticChildren = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", children = " Did you accidentally export a JSX literal instead of a component?") : isStaticChildren = typeof type;
      console.error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", isStaticChildren, children);
    }
    if (hasOwnProperty.call(config, "key")) {
      children = getComponentNameFromType(type);
      var keys = Object.keys(config).filter(function (k) {
        return "key" !== k;
      });
      isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
      didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
    }
    children = null;
    void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
    hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config) "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
    return ReactElement(type, children, self, source, getOwner(), maybeKey);
  }
  function validateChildKeys(node, parentType) {
    if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) if (isArrayImpl(node)) for (var i = 0; i < node.length; i++) {
      var child = node[i];
      isValidElement(child) && validateExplicitKey(child, parentType);
    } else if (isValidElement(node)) node._store && (node._store.validated = 1);else if (null === node || "object" !== typeof node ? i = null : (i = MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL] || node["@@iterator"], i = "function" === typeof i ? i : null), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for (; !(node = i.next()).done;) isValidElement(node.value) && validateExplicitKey(node.value, parentType);
  }
  function isValidElement(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function validateExplicitKey(element, parentType) {
    if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
      ownerHasKeyUseWarning[parentType] = !0;
      var childOwner = "";
      element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
      var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
      ReactSharedInternals.getCurrentStack = function () {
        var stack = describeUnknownElementTypeFrameInDEV(element.type);
        prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
        return stack;
      };
      console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
      ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
    }
  }
  function getCurrentComponentErrorInfo(parentType) {
    var info = "",
      owner = getOwner();
    owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
    info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
    return info;
  }
  var React = __webpack_require__(/*! react */ "./node_modules/react/index.js"),
    REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  Symbol.for("react.provider");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy"),
    REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
    MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
    REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"),
    ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    hasOwnProperty = Object.prototype.hasOwnProperty,
    assign = Object.assign,
    REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"),
    isArrayImpl = Array.isArray,
    disabledDepth = 0,
    prevLog,
    prevInfo,
    prevWarn,
    prevError,
    prevGroup,
    prevGroupCollapsed,
    prevGroupEnd;
  disabledLog.__reactDisabledLog = !0;
  var prefix,
    suffix,
    reentry = !1;
  var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
  var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
    specialPropKeyWarningShown;
  var didWarnAboutElementRef = {};
  var didWarnAboutKeySpread = {},
    ownerHasKeyUseWarning = {};
  exports.Fragment = REACT_FRAGMENT_TYPE;
  exports.jsxDEV = function (type, config, maybeKey, isStaticChildren, source, self) {
    return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);
  };
}();

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



 true && function () {
  function defineDeprecationWarning(methodName, info) {
    Object.defineProperty(Component.prototype, methodName, {
      get: function () {
        console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
      }
    });
  }
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  function warnNoop(publicInstance, callerName) {
    publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
    var warningKey = publicInstance + "." + callerName;
    didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, publicInstance), didWarnStateUpdateForUnmountedComponent[warningKey] = !0);
  }
  function Component(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  function ComponentDummy() {}
  function PureComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  function testStringCoercion(value) {
    return "" + value;
  }
  function checkKeyStringCoercion(value) {
    try {
      testStringCoercion(value);
      var JSCompiler_inline_result = !1;
    } catch (e) {
      JSCompiler_inline_result = !0;
    }
    if (JSCompiler_inline_result) {
      JSCompiler_inline_result = console;
      var JSCompiler_temp_const = JSCompiler_inline_result.error;
      var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
      JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
      return testStringCoercion(value);
    }
  }
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE$2 ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PORTAL_TYPE:
        return "Portal";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
    }
    if ("object" === typeof type) switch ("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof) {
      case REACT_CONTEXT_TYPE:
        return (type.displayName || "Context") + ".Provider";
      case REACT_CONSUMER_TYPE:
        return (type._context.displayName || "Context") + ".Consumer";
      case REACT_FORWARD_REF_TYPE:
        var innerType = type.render;
        type = type.displayName;
        type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
        return type;
      case REACT_MEMO_TYPE:
        return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
      case REACT_LAZY_TYPE:
        innerType = type._payload;
        type = type._init;
        try {
          return getComponentNameFromType(type(innerType));
        } catch (x) {}
    }
    return null;
  }
  function isValidElementType(type) {
    return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_OFFSCREEN_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE$1 || void 0 !== type.getModuleId) ? !0 : !1;
  }
  function disabledLog() {}
  function disableLogs() {
    if (0 === disabledDepth) {
      prevLog = console.log;
      prevInfo = console.info;
      prevWarn = console.warn;
      prevError = console.error;
      prevGroup = console.group;
      prevGroupCollapsed = console.groupCollapsed;
      prevGroupEnd = console.groupEnd;
      var props = {
        configurable: !0,
        enumerable: !0,
        value: disabledLog,
        writable: !0
      };
      Object.defineProperties(console, {
        info: props,
        log: props,
        warn: props,
        error: props,
        group: props,
        groupCollapsed: props,
        groupEnd: props
      });
    }
    disabledDepth++;
  }
  function reenableLogs() {
    disabledDepth--;
    if (0 === disabledDepth) {
      var props = {
        configurable: !0,
        enumerable: !0,
        writable: !0
      };
      Object.defineProperties(console, {
        log: assign({}, props, {
          value: prevLog
        }),
        info: assign({}, props, {
          value: prevInfo
        }),
        warn: assign({}, props, {
          value: prevWarn
        }),
        error: assign({}, props, {
          value: prevError
        }),
        group: assign({}, props, {
          value: prevGroup
        }),
        groupCollapsed: assign({}, props, {
          value: prevGroupCollapsed
        }),
        groupEnd: assign({}, props, {
          value: prevGroupEnd
        })
      });
    }
    0 > disabledDepth && console.error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
  }
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix) try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || "";
      suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
    }
    return "\n" + prefix + name + suffix;
  }
  function describeNativeComponentFrame(fn, construct) {
    if (!fn || reentry) return "";
    var frame = componentFrameCache.get(fn);
    if (void 0 !== frame) return frame;
    reentry = !0;
    frame = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    var previousDispatcher = null;
    previousDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = null;
    disableLogs();
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: function () {
          try {
            if (construct) {
              var Fake = function () {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function () {
                  throw Error();
                }
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  var control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$0) {
                  control = x$0;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$1) {
                control = x$1;
              }
              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function () {});
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack) return [sample.stack, control.stack];
          }
          return [null, null];
        }
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, "name");
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, "name", {
        value: "DetermineComponentFrameRoot"
      });
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),
        sampleStack = _RunInRootFrame$Deter[0],
        controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"),
          controlLines = controlStack.split("\n");
        for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes("DetermineComponentFrameRoot");) namePropDescriptor++;
        for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes("DetermineComponentFrameRoot");) _RunInRootFrame$Deter++;
        if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length) for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter];) _RunInRootFrame$Deter--;
        for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--) if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
          if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
            do if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
              var _frame = "\n" + sampleLines[namePropDescriptor].replace(" at new ", " at ");
              fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
              "function" === typeof fn && componentFrameCache.set(fn, _frame);
              return _frame;
            } while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
          }
          break;
        }
      }
    } finally {
      reentry = !1, ReactSharedInternals.H = previousDispatcher, reenableLogs(), Error.prepareStackTrace = frame;
    }
    sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
    "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
    return sampleLines;
  }
  function describeUnknownElementTypeFrameInDEV(type) {
    if (null == type) return "";
    if ("function" === typeof type) {
      var prototype = type.prototype;
      return describeNativeComponentFrame(type, !(!prototype || !prototype.isReactComponent));
    }
    if ("string" === typeof type) return describeBuiltInComponentFrame(type);
    switch (type) {
      case REACT_SUSPENSE_TYPE:
        return describeBuiltInComponentFrame("Suspense");
      case REACT_SUSPENSE_LIST_TYPE:
        return describeBuiltInComponentFrame("SuspenseList");
    }
    if ("object" === typeof type) switch (type.$$typeof) {
      case REACT_FORWARD_REF_TYPE:
        return type = describeNativeComponentFrame(type.render, !1), type;
      case REACT_MEMO_TYPE:
        return describeUnknownElementTypeFrameInDEV(type.type);
      case REACT_LAZY_TYPE:
        prototype = type._payload;
        type = type._init;
        try {
          return describeUnknownElementTypeFrameInDEV(type(prototype));
        } catch (x) {}
    }
    return "";
  }
  function getOwner() {
    var dispatcher = ReactSharedInternals.A;
    return null === dispatcher ? null : dispatcher.getOwner();
  }
  function hasValidKey(config) {
    if (hasOwnProperty.call(config, "key")) {
      var getter = Object.getOwnPropertyDescriptor(config, "key").get;
      if (getter && getter.isReactWarning) return !1;
    }
    return void 0 !== config.key;
  }
  function defineKeyPropWarningGetter(props, displayName) {
    function warnAboutAccessingKey() {
      specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
    }
    warnAboutAccessingKey.isReactWarning = !0;
    Object.defineProperty(props, "key", {
      get: warnAboutAccessingKey,
      configurable: !0
    });
  }
  function elementRefGetterWithDeprecationWarning() {
    var componentName = getComponentNameFromType(this.type);
    didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
    componentName = this.props.ref;
    return void 0 !== componentName ? componentName : null;
  }
  function ReactElement(type, key, self, source, owner, props) {
    self = props.ref;
    type = {
      $$typeof: REACT_ELEMENT_TYPE,
      type: type,
      key: key,
      props: props,
      _owner: owner
    };
    null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
      enumerable: !1,
      get: elementRefGetterWithDeprecationWarning
    }) : Object.defineProperty(type, "ref", {
      enumerable: !1,
      value: null
    });
    type._store = {};
    Object.defineProperty(type._store, "validated", {
      configurable: !1,
      enumerable: !1,
      writable: !0,
      value: 0
    });
    Object.defineProperty(type, "_debugInfo", {
      configurable: !1,
      enumerable: !1,
      writable: !0,
      value: null
    });
    Object.freeze && (Object.freeze(type.props), Object.freeze(type));
    return type;
  }
  function cloneAndReplaceKey(oldElement, newKey) {
    newKey = ReactElement(oldElement.type, newKey, void 0, void 0, oldElement._owner, oldElement.props);
    newKey._store.validated = oldElement._store.validated;
    return newKey;
  }
  function validateChildKeys(node, parentType) {
    if ("object" === typeof node && node && node.$$typeof !== REACT_CLIENT_REFERENCE) if (isArrayImpl(node)) for (var i = 0; i < node.length; i++) {
      var child = node[i];
      isValidElement(child) && validateExplicitKey(child, parentType);
    } else if (isValidElement(node)) node._store && (node._store.validated = 1);else if (i = getIteratorFn(node), "function" === typeof i && i !== node.entries && (i = i.call(node), i !== node)) for (; !(node = i.next()).done;) isValidElement(node.value) && validateExplicitKey(node.value, parentType);
  }
  function isValidElement(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function validateExplicitKey(element, parentType) {
    if (element._store && !element._store.validated && null == element.key && (element._store.validated = 1, parentType = getCurrentComponentErrorInfo(parentType), !ownerHasKeyUseWarning[parentType])) {
      ownerHasKeyUseWarning[parentType] = !0;
      var childOwner = "";
      element && null != element._owner && element._owner !== getOwner() && (childOwner = null, "number" === typeof element._owner.tag ? childOwner = getComponentNameFromType(element._owner.type) : "string" === typeof element._owner.name && (childOwner = element._owner.name), childOwner = " It was passed a child from " + childOwner + ".");
      var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;
      ReactSharedInternals.getCurrentStack = function () {
        var stack = describeUnknownElementTypeFrameInDEV(element.type);
        prevGetCurrentStack && (stack += prevGetCurrentStack() || "");
        return stack;
      };
      console.error('Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.', parentType, childOwner);
      ReactSharedInternals.getCurrentStack = prevGetCurrentStack;
    }
  }
  function getCurrentComponentErrorInfo(parentType) {
    var info = "",
      owner = getOwner();
    owner && (owner = getComponentNameFromType(owner.type)) && (info = "\n\nCheck the render method of `" + owner + "`.");
    info || (parentType = getComponentNameFromType(parentType)) && (info = "\n\nCheck the top-level render call using <" + parentType + ">.");
    return info;
  }
  function escape(key) {
    var escaperLookup = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + key.replace(/[=:]/g, function (match) {
      return escaperLookup[match];
    });
  }
  function getElementKey(element, index) {
    return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
  }
  function noop$1() {}
  function resolveThenable(thenable) {
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function (fulfilledValue) {
          "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
        }, function (error) {
          "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
        })), thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
    }
    throw thenable;
  }
  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
    var type = typeof children;
    if ("undefined" === type || "boolean" === type) children = null;
    var invokeCallback = !1;
    if (null === children) invokeCallback = !0;else switch (type) {
      case "bigint":
      case "string":
      case "number":
        invokeCallback = !0;
        break;
      case "object":
        switch (children.$$typeof) {
          case REACT_ELEMENT_TYPE:
          case REACT_PORTAL_TYPE:
            invokeCallback = !0;
            break;
          case REACT_LAZY_TYPE:
            return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
        }
    }
    if (invokeCallback) {
      invokeCallback = children;
      callback = callback(invokeCallback);
      var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
      isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function (c) {
        return c;
      })) : null != callback && (isValidElement(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + childKey), "" !== nameSoFar && null != invokeCallback && isValidElement(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
      return 1;
    }
    invokeCallback = 0;
    childKey = "" === nameSoFar ? "." : nameSoFar + ":";
    if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) nameSoFar = children[i], type = childKey + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if (i = getIteratorFn(children), "function" === typeof i) for (i === children.entries && (didWarnAboutMaps || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0), children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);else if ("object" === type) {
      if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
      array = String(children);
      throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
    }
    return invokeCallback;
  }
  function mapChildren(children, func, context) {
    if (null == children) return children;
    var result = [],
      count = 0;
    mapIntoArray(children, result, "", "", function (child) {
      return func.call(context, child, count++);
    });
    return result;
  }
  function lazyInitializer(payload) {
    if (-1 === payload._status) {
      var ctor = payload._result;
      ctor = ctor();
      ctor.then(function (moduleObject) {
        if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
      }, function (error) {
        if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
      });
      -1 === payload._status && (payload._status = 0, payload._result = ctor);
    }
    if (1 === payload._status) return ctor = payload._result, void 0 === ctor && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", ctor), "default" in ctor || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", ctor), ctor.default;
    throw payload._result;
  }
  function resolveDispatcher() {
    var dispatcher = ReactSharedInternals.H;
    null === dispatcher && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.");
    return dispatcher;
  }
  function noop() {}
  function enqueueTask(task) {
    if (null === enqueueTaskImpl) try {
      var requireString = ("require" + Math.random()).slice(0, 7);
      enqueueTaskImpl = (module && module[requireString]).call(module, "timers").setImmediate;
    } catch (_err) {
      enqueueTaskImpl = function (callback) {
        !1 === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = !0, "undefined" === typeof MessageChannel && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
        var channel = new MessageChannel();
        channel.port1.onmessage = callback;
        channel.port2.postMessage(void 0);
      };
    }
    return enqueueTaskImpl(task);
  }
  function aggregateErrors(errors) {
    return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
  }
  function popActScope(prevActQueue, prevActScopeDepth) {
    prevActScopeDepth !== actScopeDepth - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
    actScopeDepth = prevActScopeDepth;
  }
  function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
    var queue = ReactSharedInternals.actQueue;
    if (null !== queue) if (0 !== queue.length) try {
      flushActQueue(queue);
      enqueueTask(function () {
        return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
      });
      return;
    } catch (error) {
      ReactSharedInternals.thrownErrors.push(error);
    } else ReactSharedInternals.actQueue = null;
    0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
  }
  function flushActQueue(queue) {
    if (!isFlushing) {
      isFlushing = !0;
      var i = 0;
      try {
        for (; i < queue.length; i++) {
          var callback = queue[i];
          do {
            ReactSharedInternals.didUsePromise = !1;
            var continuation = callback(!1);
            if (null !== continuation) {
              if (ReactSharedInternals.didUsePromise) {
                queue[i] = callback;
                queue.splice(0, i);
                return;
              }
              callback = continuation;
            } else break;
          } while (1);
        }
        queue.length = 0;
      } catch (error) {
        queue.splice(0, i + 1), ReactSharedInternals.thrownErrors.push(error);
      } finally {
        isFlushing = !1;
      }
    }
  }
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler");
  Symbol.for("react.provider");
  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy"),
    REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
    MAYBE_ITERATOR_SYMBOL = Symbol.iterator,
    didWarnStateUpdateForUnmountedComponent = {},
    ReactNoopUpdateQueue = {
      isMounted: function () {
        return !1;
      },
      enqueueForceUpdate: function (publicInstance) {
        warnNoop(publicInstance, "forceUpdate");
      },
      enqueueReplaceState: function (publicInstance) {
        warnNoop(publicInstance, "replaceState");
      },
      enqueueSetState: function (publicInstance) {
        warnNoop(publicInstance, "setState");
      }
    },
    assign = Object.assign,
    emptyObject = {};
  Object.freeze(emptyObject);
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function (partialState, callback) {
    if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function (callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  var deprecatedAPIs = {
      isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
      replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
    },
    fnName;
  for (fnName in deprecatedAPIs) deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
  ComponentDummy.prototype = Component.prototype;
  deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
  deprecatedAPIs.constructor = PureComponent;
  assign(deprecatedAPIs, Component.prototype);
  deprecatedAPIs.isPureReactComponent = !0;
  var isArrayImpl = Array.isArray,
    REACT_CLIENT_REFERENCE$2 = Symbol.for("react.client.reference"),
    ReactSharedInternals = {
      H: null,
      A: null,
      T: null,
      S: null,
      actQueue: null,
      isBatchingLegacy: !1,
      didScheduleLegacyUpdate: !1,
      didUsePromise: !1,
      thrownErrors: [],
      getCurrentStack: null
    },
    hasOwnProperty = Object.prototype.hasOwnProperty,
    REACT_CLIENT_REFERENCE$1 = Symbol.for("react.client.reference"),
    disabledDepth = 0,
    prevLog,
    prevInfo,
    prevWarn,
    prevError,
    prevGroup,
    prevGroupCollapsed,
    prevGroupEnd;
  disabledLog.__reactDisabledLog = !0;
  var prefix,
    suffix,
    reentry = !1;
  var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
  var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"),
    specialPropKeyWarningShown,
    didWarnAboutOldJSXRuntime;
  var didWarnAboutElementRef = {};
  var ownerHasKeyUseWarning = {},
    didWarnAboutMaps = !1,
    userProvidedKeyEscapeRegex = /\/+/g,
    reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error: error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    },
    didWarnAboutMessageChannel = !1,
    enqueueTaskImpl = null,
    actScopeDepth = 0,
    didWarnNoAwaitAct = !1,
    isFlushing = !1,
    queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function (callback) {
      queueMicrotask(function () {
        return queueMicrotask(callback);
      });
    } : enqueueTask;
  exports.Children = {
    map: mapChildren,
    forEach: function (children, forEachFunc, forEachContext) {
      mapChildren(children, function () {
        forEachFunc.apply(this, arguments);
      }, forEachContext);
    },
    count: function (children) {
      var n = 0;
      mapChildren(children, function () {
        n++;
      });
      return n;
    },
    toArray: function (children) {
      return mapChildren(children, function (child) {
        return child;
      }) || [];
    },
    only: function (children) {
      if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
      return children;
    }
  };
  exports.Component = Component;
  exports.Fragment = REACT_FRAGMENT_TYPE;
  exports.Profiler = REACT_PROFILER_TYPE;
  exports.PureComponent = PureComponent;
  exports.StrictMode = REACT_STRICT_MODE_TYPE;
  exports.Suspense = REACT_SUSPENSE_TYPE;
  exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
  exports.act = function (callback) {
    var prevActQueue = ReactSharedInternals.actQueue,
      prevActScopeDepth = actScopeDepth;
    actScopeDepth++;
    var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [],
      didAwaitActCall = !1;
    try {
      var result = callback();
    } catch (error) {
      ReactSharedInternals.thrownErrors.push(error);
    }
    if (0 < ReactSharedInternals.thrownErrors.length) throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
    if (null !== result && "object" === typeof result && "function" === typeof result.then) {
      var thenable = result;
      queueSeveralMicrotasks(function () {
        didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
      });
      return {
        then: function (resolve, reject) {
          didAwaitActCall = !0;
          thenable.then(function (returnValue) {
            popActScope(prevActQueue, prevActScopeDepth);
            if (0 === prevActScopeDepth) {
              try {
                flushActQueue(queue), enqueueTask(function () {
                  return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                });
              } catch (error$2) {
                ReactSharedInternals.thrownErrors.push(error$2);
              }
              if (0 < ReactSharedInternals.thrownErrors.length) {
                var _thrownError = aggregateErrors(ReactSharedInternals.thrownErrors);
                ReactSharedInternals.thrownErrors.length = 0;
                reject(_thrownError);
              }
            } else resolve(returnValue);
          }, function (error) {
            popActScope(prevActQueue, prevActScopeDepth);
            0 < ReactSharedInternals.thrownErrors.length ? (error = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(error)) : reject(error);
          });
        }
      };
    }
    var returnValue$jscomp$0 = result;
    popActScope(prevActQueue, prevActScopeDepth);
    0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function () {
      didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = !0, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
    }), ReactSharedInternals.actQueue = null);
    if (0 < ReactSharedInternals.thrownErrors.length) throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
    return {
      then: function (resolve, reject) {
        didAwaitActCall = !0;
        0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function () {
          return recursivelyFlushAsyncActWork(returnValue$jscomp$0, resolve, reject);
        })) : resolve(returnValue$jscomp$0);
      }
    };
  };
  exports.cache = function (fn) {
    return function () {
      return fn.apply(null, arguments);
    };
  };
  exports.cloneElement = function (element, config, children) {
    if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
    var props = assign({}, element.props),
      key = element.key,
      owner = element._owner;
    if (null != config) {
      var JSCompiler_inline_result;
      a: {
        if (hasOwnProperty.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(config, "ref").get) && JSCompiler_inline_result.isReactWarning) {
          JSCompiler_inline_result = !1;
          break a;
        }
        JSCompiler_inline_result = void 0 !== config.ref;
      }
      JSCompiler_inline_result && (owner = getOwner());
      hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
      for (propName in config) !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
    }
    var propName = arguments.length - 2;
    if (1 === propName) props.children = children;else if (1 < propName) {
      JSCompiler_inline_result = Array(propName);
      for (var i = 0; i < propName; i++) JSCompiler_inline_result[i] = arguments[i + 2];
      props.children = JSCompiler_inline_result;
    }
    props = ReactElement(element.type, key, void 0, void 0, owner, props);
    for (key = 2; key < arguments.length; key++) validateChildKeys(arguments[key], props.type);
    return props;
  };
  exports.createContext = function (defaultValue) {
    defaultValue = {
      $$typeof: REACT_CONTEXT_TYPE,
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    defaultValue.Provider = defaultValue;
    defaultValue.Consumer = {
      $$typeof: REACT_CONSUMER_TYPE,
      _context: defaultValue
    };
    defaultValue._currentRenderer = null;
    defaultValue._currentRenderer2 = null;
    return defaultValue;
  };
  exports.createElement = function (type, config, children) {
    if (isValidElementType(type)) for (var i = 2; i < arguments.length; i++) validateChildKeys(arguments[i], type);else {
      i = "";
      if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length) i += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
      if (null === type) var typeString = "null";else isArrayImpl(type) ? typeString = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", i = " Did you accidentally export a JSX literal instead of a component?") : typeString = typeof type;
      console.error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, i);
    }
    var propName;
    i = {};
    typeString = null;
    if (null != config) for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = !0, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), hasValidKey(config) && (checkKeyStringCoercion(config.key), typeString = "" + config.key), config) hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i[propName] = config[propName]);
    var childrenLength = arguments.length - 2;
    if (1 === childrenLength) i.children = children;else if (1 < childrenLength) {
      for (var childArray = Array(childrenLength), _i = 0; _i < childrenLength; _i++) childArray[_i] = arguments[_i + 2];
      Object.freeze && Object.freeze(childArray);
      i.children = childArray;
    }
    if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) void 0 === i[propName] && (i[propName] = childrenLength[propName]);
    typeString && defineKeyPropWarningGetter(i, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
    return ReactElement(type, typeString, void 0, void 0, getOwner(), i);
  };
  exports.createRef = function () {
    var refObject = {
      current: null
    };
    Object.seal(refObject);
    return refObject;
  };
  exports.forwardRef = function (render) {
    null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : "function" !== typeof render ? console.error("forwardRef requires a render function but was given %s.", null === render ? "null" : typeof render) : 0 !== render.length && 2 !== render.length && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", 1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
    null != render && null != render.defaultProps && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
    var elementType = {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render: render
      },
      ownName;
    Object.defineProperty(elementType, "displayName", {
      enumerable: !1,
      configurable: !0,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;
        render.name || render.displayName || (Object.defineProperty(render, "name", {
          value: name
        }), render.displayName = name);
      }
    });
    return elementType;
  };
  exports.isValidElement = isValidElement;
  exports.lazy = function (ctor) {
    return {
      $$typeof: REACT_LAZY_TYPE,
      _payload: {
        _status: -1,
        _result: ctor
      },
      _init: lazyInitializer
    };
  };
  exports.memo = function (type, compare) {
    isValidElementType(type) || console.error("memo: The first argument must be a component. Instead received: %s", null === type ? "null" : typeof type);
    compare = {
      $$typeof: REACT_MEMO_TYPE,
      type: type,
      compare: void 0 === compare ? null : compare
    };
    var ownName;
    Object.defineProperty(compare, "displayName", {
      enumerable: !1,
      configurable: !0,
      get: function () {
        return ownName;
      },
      set: function (name) {
        ownName = name;
        type.name || type.displayName || (Object.defineProperty(type, "name", {
          value: name
        }), type.displayName = name);
      }
    });
    return compare;
  };
  exports.startTransition = function (scope) {
    var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    currentTransition._updatedFibers = new Set();
    try {
      var returnValue = scope(),
        onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
    } catch (error) {
      reportGlobalError(error);
    } finally {
      null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), ReactSharedInternals.T = prevTransition;
    }
  };
  exports.unstable_useCacheRefresh = function () {
    return resolveDispatcher().useCacheRefresh();
  };
  exports.use = function (usable) {
    return resolveDispatcher().use(usable);
  };
  exports.useActionState = function (action, initialState, permalink) {
    return resolveDispatcher().useActionState(action, initialState, permalink);
  };
  exports.useCallback = function (callback, deps) {
    return resolveDispatcher().useCallback(callback, deps);
  };
  exports.useContext = function (Context) {
    var dispatcher = resolveDispatcher();
    Context.$$typeof === REACT_CONSUMER_TYPE && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?");
    return dispatcher.useContext(Context);
  };
  exports.useDebugValue = function (value, formatterFn) {
    return resolveDispatcher().useDebugValue(value, formatterFn);
  };
  exports.useDeferredValue = function (value, initialValue) {
    return resolveDispatcher().useDeferredValue(value, initialValue);
  };
  exports.useEffect = function (create, deps) {
    return resolveDispatcher().useEffect(create, deps);
  };
  exports.useId = function () {
    return resolveDispatcher().useId();
  };
  exports.useImperativeHandle = function (ref, create, deps) {
    return resolveDispatcher().useImperativeHandle(ref, create, deps);
  };
  exports.useInsertionEffect = function (create, deps) {
    return resolveDispatcher().useInsertionEffect(create, deps);
  };
  exports.useLayoutEffect = function (create, deps) {
    return resolveDispatcher().useLayoutEffect(create, deps);
  };
  exports.useMemo = function (create, deps) {
    return resolveDispatcher().useMemo(create, deps);
  };
  exports.useOptimistic = function (passthrough, reducer) {
    return resolveDispatcher().useOptimistic(passthrough, reducer);
  };
  exports.useReducer = function (reducer, initialArg, init) {
    return resolveDispatcher().useReducer(reducer, initialArg, init);
  };
  exports.useRef = function (initialValue) {
    return resolveDispatcher().useRef(initialValue);
  };
  exports.useState = function (initialState) {
    return resolveDispatcher().useState(initialState);
  };
  exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
    return resolveDispatcher().useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  };
  exports.useTransition = function () {
    return resolveDispatcher().useTransition();
  };
  exports.version = "19.0.0";
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js");
}

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



 true && function () {
  function performWorkUntilDeadline() {
    if (isMessageLoopRunning) {
      var currentTime = exports.unstable_now();
      startTime = currentTime;
      var hasMoreWork = !0;
      try {
        a: {
          isHostCallbackScheduled = !1;
          isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
          isPerformingWork = !0;
          var previousPriorityLevel = currentPriorityLevel;
          try {
            b: {
              advanceTimers(currentTime);
              for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost());) {
                var callback = currentTask.callback;
                if ("function" === typeof callback) {
                  currentTask.callback = null;
                  currentPriorityLevel = currentTask.priorityLevel;
                  var continuationCallback = callback(currentTask.expirationTime <= currentTime);
                  currentTime = exports.unstable_now();
                  if ("function" === typeof continuationCallback) {
                    currentTask.callback = continuationCallback;
                    advanceTimers(currentTime);
                    hasMoreWork = !0;
                    break b;
                  }
                  currentTask === peek(taskQueue) && pop(taskQueue);
                  advanceTimers(currentTime);
                } else pop(taskQueue);
                currentTask = peek(taskQueue);
              }
              if (null !== currentTask) hasMoreWork = !0;else {
                var firstTimer = peek(timerQueue);
                null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                hasMoreWork = !1;
              }
            }
            break a;
          } finally {
            currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
          }
          hasMoreWork = void 0;
        }
      } finally {
        hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = !1;
      }
    }
  }
  function push(heap, node) {
    var index = heap.length;
    heap.push(node);
    a: for (; 0 < index;) {
      var parentIndex = index - 1 >>> 1,
        parent = heap[parentIndex];
      if (0 < compare(parent, node)) heap[parentIndex] = node, heap[index] = parent, index = parentIndex;else break a;
    }
  }
  function peek(heap) {
    return 0 === heap.length ? null : heap[0];
  }
  function pop(heap) {
    if (0 === heap.length) return null;
    var first = heap[0],
      last = heap.pop();
    if (last !== first) {
      heap[0] = last;
      a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength;) {
        var leftIndex = 2 * (index + 1) - 1,
          left = heap[leftIndex],
          rightIndex = leftIndex + 1,
          right = heap[rightIndex];
        if (0 > compare(left, last)) rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);else if (rightIndex < length && 0 > compare(right, last)) heap[index] = right, heap[rightIndex] = last, index = rightIndex;else break a;
      }
    }
    return first;
  }
  function compare(a, b) {
    var diff = a.sortIndex - b.sortIndex;
    return 0 !== diff ? diff : a.id - b.id;
  }
  function advanceTimers(currentTime) {
    for (var timer = peek(timerQueue); null !== timer;) {
      if (null === timer.callback) pop(timerQueue);else if (timer.startTime <= currentTime) pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);else break;
      timer = peek(timerQueue);
    }
  }
  function handleTimeout(currentTime) {
    isHostTimeoutScheduled = !1;
    advanceTimers(currentTime);
    if (!isHostCallbackScheduled) if (null !== peek(taskQueue)) isHostCallbackScheduled = !0, requestHostCallback();else {
      var firstTimer = peek(timerQueue);
      null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
    }
  }
  function shouldYieldToHost() {
    return exports.unstable_now() - startTime < frameInterval ? !1 : !0;
  }
  function requestHostCallback() {
    isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
  }
  function requestHostTimeout(callback, ms) {
    taskTimeoutID = localSetTimeout(function () {
      callback(exports.unstable_now());
    }, ms);
  }
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
  exports.unstable_now = void 0;
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var localPerformance = performance;
    exports.unstable_now = function () {
      return localPerformance.now();
    };
  } else {
    var localDate = Date,
      initialTime = localDate.now();
    exports.unstable_now = function () {
      return localDate.now() - initialTime;
    };
  }
  var taskQueue = [],
    timerQueue = [],
    taskIdCounter = 1,
    currentTask = null,
    currentPriorityLevel = 3,
    isPerformingWork = !1,
    isHostCallbackScheduled = !1,
    isHostTimeoutScheduled = !1,
    localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,
    localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,
    localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null,
    isMessageLoopRunning = !1,
    taskTimeoutID = -1,
    frameInterval = 5,
    startTime = -1;
  if ("function" === typeof localSetImmediate) var schedulePerformWorkUntilDeadline = function () {
    localSetImmediate(performWorkUntilDeadline);
  };else if ("undefined" !== typeof MessageChannel) {
    var channel = new MessageChannel(),
      port = channel.port2;
    channel.port1.onmessage = performWorkUntilDeadline;
    schedulePerformWorkUntilDeadline = function () {
      port.postMessage(null);
    };
  } else schedulePerformWorkUntilDeadline = function () {
    localSetTimeout(performWorkUntilDeadline, 0);
  };
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function (task) {
    task.callback = null;
  };
  exports.unstable_continueExecution = function () {
    isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback());
  };
  exports.unstable_forceFrameRate = function (fps) {
    0 > fps || 125 < fps ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function () {
    return currentPriorityLevel;
  };
  exports.unstable_getFirstCallbackNode = function () {
    return peek(taskQueue);
  };
  exports.unstable_next = function (eventHandler) {
    switch (currentPriorityLevel) {
      case 1:
      case 2:
      case 3:
        var priorityLevel = 3;
        break;
      default:
        priorityLevel = currentPriorityLevel;
    }
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
  exports.unstable_pauseExecution = function () {};
  exports.unstable_requestPaint = function () {};
  exports.unstable_runWithPriority = function (priorityLevel, eventHandler) {
    switch (priorityLevel) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        priorityLevel = 3;
    }
    var previousPriorityLevel = currentPriorityLevel;
    currentPriorityLevel = priorityLevel;
    try {
      return eventHandler();
    } finally {
      currentPriorityLevel = previousPriorityLevel;
    }
  };
  exports.unstable_scheduleCallback = function (priorityLevel, callback, options) {
    var currentTime = exports.unstable_now();
    "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
    switch (priorityLevel) {
      case 1:
        var timeout = -1;
        break;
      case 2:
        timeout = 250;
        break;
      case 5:
        timeout = 1073741823;
        break;
      case 4:
        timeout = 1e4;
        break;
      default:
        timeout = 5e3;
    }
    timeout = options + timeout;
    priorityLevel = {
      id: taskIdCounter++,
      callback: callback,
      priorityLevel: priorityLevel,
      startTime: options,
      expirationTime: timeout,
      sortIndex: -1
    };
    options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = !0, requestHostCallback()));
    return priorityLevel;
  };
  exports.unstable_shouldYield = shouldYieldToHost;
  exports.unstable_wrapCallback = function (callback) {
    var parentPriorityLevel = currentPriorityLevel;
    return function () {
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = parentPriorityLevel;
      try {
        return callback.apply(this, arguments);
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
  };
  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
}();

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}

/***/ }),

/***/ "./node_modules/set-cookie-parser/lib/set-cookie.js":
/*!**********************************************************!*\
  !*** ./node_modules/set-cookie-parser/lib/set-cookie.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


var defaultParseOptions = {
  decodeValues: true,
  map: false,
  silent: false
};
function isNonEmptyString(str) {
  return typeof str === "string" && !!str.trim();
}
function parseString(setCookieValue, options) {
  var parts = setCookieValue.split(";").filter(isNonEmptyString);
  var nameValuePairStr = parts.shift();
  var parsed = parseNameValuePair(nameValuePairStr);
  var name = parsed.name;
  var value = parsed.value;
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  try {
    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value
  } catch (e) {
    console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
  }
  var cookie = {
    name: name,
    value: value
  };
  parts.forEach(function (part) {
    var sides = part.split("=");
    var key = sides.shift().trimLeft().toLowerCase();
    var value = sides.join("=");
    if (key === "expires") {
      cookie.expires = new Date(value);
    } else if (key === "max-age") {
      cookie.maxAge = parseInt(value, 10);
    } else if (key === "secure") {
      cookie.secure = true;
    } else if (key === "httponly") {
      cookie.httpOnly = true;
    } else if (key === "samesite") {
      cookie.sameSite = value;
    } else if (key === "partitioned") {
      cookie.partitioned = true;
    } else {
      cookie[key] = value;
    }
  });
  return cookie;
}
function parseNameValuePair(nameValuePairStr) {
  // Parses name-value-pair according to rfc6265bis draft

  var name = "";
  var value = "";
  var nameValueArr = nameValuePairStr.split("=");
  if (nameValueArr.length > 1) {
    name = nameValueArr.shift();
    value = nameValueArr.join("="); // everything after the first =, joined by a "=" if there was more than one part
  } else {
    value = nameValuePairStr;
  }
  return {
    name: name,
    value: value
  };
}
function parse(input, options) {
  options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
  if (!input) {
    if (!options.map) {
      return [];
    } else {
      return {};
    }
  }
  if (input.headers) {
    if (typeof input.headers.getSetCookie === "function") {
      // for fetch responses - they combine headers of the same type in the headers array,
      // but getSetCookie returns an uncombined array
      input = input.headers.getSetCookie();
    } else if (input.headers["set-cookie"]) {
      // fast-path for node.js (which automatically normalizes header names to lower-case
      input = input.headers["set-cookie"];
    } else {
      // slow-path for other environments - see #25
      var sch = input.headers[Object.keys(input.headers).find(function (key) {
        return key.toLowerCase() === "set-cookie";
      })];
      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36
      if (!sch && input.headers.cookie && !options.silent) {
        console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
      }
      input = sch;
    }
  }
  if (!Array.isArray(input)) {
    input = [input];
  }
  if (!options.map) {
    return input.filter(isNonEmptyString).map(function (str) {
      return parseString(str, options);
    });
  } else {
    var cookies = {};
    return input.filter(isNonEmptyString).reduce(function (cookies, str) {
      var cookie = parseString(str, options);
      cookies[cookie.name] = cookie;
      return cookies;
    }, cookies);
  }
}

/*
  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas
  that are within a single set-cookie field-value, such as in the Expires portion.

  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2
  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128
  React Native's fetch does this for *every* header, including set-cookie.

  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25
  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation
*/
function splitCookiesString(cookiesString) {
  if (Array.isArray(cookiesString)) {
    return cookiesString;
  }
  if (typeof cookiesString !== "string") {
    return [];
  }
  var cookiesStrings = [];
  var pos = 0;
  var start;
  var ch;
  var lastComma;
  var nextStart;
  var cookiesSeparatorFound;
  function skipWhitespace() {
    while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
      pos += 1;
    }
    return pos < cookiesString.length;
  }
  function notSpecialChar() {
    ch = cookiesString.charAt(pos);
    return ch !== "=" && ch !== ";" && ch !== ",";
  }
  while (pos < cookiesString.length) {
    start = pos;
    cookiesSeparatorFound = false;
    while (skipWhitespace()) {
      ch = cookiesString.charAt(pos);
      if (ch === ",") {
        // ',' is a cookie separator if we have later first '=', not ';' or ','
        lastComma = pos;
        pos += 1;
        skipWhitespace();
        nextStart = pos;
        while (pos < cookiesString.length && notSpecialChar()) {
          pos += 1;
        }

        // currently special character
        if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
          // we found cookies separator
          cookiesSeparatorFound = true;
          // pos is inside the next cookie, so back up and return it.
          pos = nextStart;
          cookiesStrings.push(cookiesString.substring(start, lastComma));
          start = pos;
        } else {
          // in param ',' or param separator ';',
          // we continue from that comma
          pos = lastComma + 1;
        }
      } else {
        pos += 1;
      }
    }
    if (!cookiesSeparatorFound || pos >= cookiesString.length) {
      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
    }
  }
  return cookiesStrings;
}
module.exports = parse;
module.exports.parse = parse;
module.exports.parseString = parseString;
module.exports.splitCookiesString = splitCookiesString;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./node_modules/turbo-stream/dist/turbo-stream.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/turbo-stream/dist/turbo-stream.mjs ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   decode: () => (/* binding */ decode),
/* harmony export */   encode: () => (/* binding */ encode)
/* harmony export */ });
// src/utils.ts
var HOLE = -1;
var NAN = -2;
var NEGATIVE_INFINITY = -3;
var NEGATIVE_ZERO = -4;
var NULL = -5;
var POSITIVE_INFINITY = -6;
var UNDEFINED = -7;
var TYPE_BIGINT = "B";
var TYPE_DATE = "D";
var TYPE_ERROR = "E";
var TYPE_MAP = "M";
var TYPE_NULL_OBJECT = "N";
var TYPE_PROMISE = "P";
var TYPE_REGEXP = "R";
var TYPE_SET = "S";
var TYPE_SYMBOL = "Y";
var TYPE_URL = "U";
var TYPE_PREVIOUS_RESOLVED = "Z";
var Deferred = class {
  promise;
  resolve;
  reject;
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
function createLineSplittingTransform() {
  const decoder = new TextDecoder();
  let leftover = "";
  return new TransformStream({
    transform(chunk, controller) {
      const str = decoder.decode(chunk, {
        stream: true
      });
      const parts = (leftover + str).split("\n");
      leftover = parts.pop() || "";
      for (const part of parts) {
        controller.enqueue(part);
      }
    },
    flush(controller) {
      if (leftover) {
        controller.enqueue(leftover);
      }
    }
  });
}

// src/flatten.ts
function flatten(input) {
  const {
    indices
  } = this;
  const existing = indices.get(input);
  if (existing) return [existing];
  if (input === void 0) return UNDEFINED;
  if (input === null) return NULL;
  if (Number.isNaN(input)) return NAN;
  if (input === Number.POSITIVE_INFINITY) return POSITIVE_INFINITY;
  if (input === Number.NEGATIVE_INFINITY) return NEGATIVE_INFINITY;
  if (input === 0 && 1 / input < 0) return NEGATIVE_ZERO;
  const index = this.index++;
  indices.set(input, index);
  stringify.call(this, input, index);
  return index;
}
function stringify(input, index) {
  const {
    deferred,
    plugins,
    postPlugins
  } = this;
  const str = this.stringified;
  const stack = [[input, index]];
  while (stack.length > 0) {
    const [input2, index2] = stack.pop();
    const partsForObj = obj => Object.keys(obj).map(k => `"_${flatten.call(this, k)}":${flatten.call(this, obj[k])}`).join(",");
    let error = null;
    switch (typeof input2) {
      case "boolean":
      case "number":
      case "string":
        str[index2] = JSON.stringify(input2);
        break;
      case "bigint":
        str[index2] = `["${TYPE_BIGINT}","${input2}"]`;
        break;
      case "symbol":
        {
          const keyFor = Symbol.keyFor(input2);
          if (!keyFor) {
            error = new Error("Cannot encode symbol unless created with Symbol.for()");
          } else {
            str[index2] = `["${TYPE_SYMBOL}",${JSON.stringify(keyFor)}]`;
          }
          break;
        }
      case "object":
        {
          if (!input2) {
            str[index2] = `${NULL}`;
            break;
          }
          const isArray = Array.isArray(input2);
          let pluginHandled = false;
          if (!isArray && plugins) {
            for (const plugin of plugins) {
              const pluginResult = plugin(input2);
              if (Array.isArray(pluginResult)) {
                pluginHandled = true;
                const [pluginIdentifier, ...rest] = pluginResult;
                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
                if (rest.length > 0) {
                  str[index2] += `,${rest.map(v => flatten.call(this, v)).join(",")}`;
                }
                str[index2] += "]";
                break;
              }
            }
          }
          if (!pluginHandled) {
            let result = isArray ? "[" : "{";
            if (isArray) {
              for (let i = 0; i < input2.length; i++) result += (i ? "," : "") + (i in input2 ? flatten.call(this, input2[i]) : HOLE);
              str[index2] = `${result}]`;
            } else if (input2 instanceof Date) {
              str[index2] = `["${TYPE_DATE}",${input2.getTime()}]`;
            } else if (input2 instanceof URL) {
              str[index2] = `["${TYPE_URL}",${JSON.stringify(input2.href)}]`;
            } else if (input2 instanceof RegExp) {
              str[index2] = `["${TYPE_REGEXP}",${JSON.stringify(input2.source)},${JSON.stringify(input2.flags)}]`;
            } else if (input2 instanceof Set) {
              if (input2.size > 0) {
                str[index2] = `["${TYPE_SET}",${[...input2].map(val => flatten.call(this, val)).join(",")}]`;
              } else {
                str[index2] = `["${TYPE_SET}"]`;
              }
            } else if (input2 instanceof Map) {
              if (input2.size > 0) {
                str[index2] = `["${TYPE_MAP}",${[...input2].flatMap(([k, v]) => [flatten.call(this, k), flatten.call(this, v)]).join(",")}]`;
              } else {
                str[index2] = `["${TYPE_MAP}"]`;
              }
            } else if (input2 instanceof Promise) {
              str[index2] = `["${TYPE_PROMISE}",${index2}]`;
              deferred[index2] = input2;
            } else if (input2 instanceof Error) {
              str[index2] = `["${TYPE_ERROR}",${JSON.stringify(input2.message)}`;
              if (input2.name !== "Error") {
                str[index2] += `,${JSON.stringify(input2.name)}`;
              }
              str[index2] += "]";
            } else if (Object.getPrototypeOf(input2) === null) {
              str[index2] = `["${TYPE_NULL_OBJECT}",{${partsForObj(input2)}}]`;
            } else if (isPlainObject(input2)) {
              str[index2] = `{${partsForObj(input2)}}`;
            } else {
              error = new Error("Cannot encode object with prototype");
            }
          }
          break;
        }
      default:
        {
          const isArray = Array.isArray(input2);
          let pluginHandled = false;
          if (!isArray && plugins) {
            for (const plugin of plugins) {
              const pluginResult = plugin(input2);
              if (Array.isArray(pluginResult)) {
                pluginHandled = true;
                const [pluginIdentifier, ...rest] = pluginResult;
                str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
                if (rest.length > 0) {
                  str[index2] += `,${rest.map(v => flatten.call(this, v)).join(",")}`;
                }
                str[index2] += "]";
                break;
              }
            }
          }
          if (!pluginHandled) {
            error = new Error("Cannot encode function or unexpected type");
          }
        }
    }
    if (error) {
      let pluginHandled = false;
      if (postPlugins) {
        for (const plugin of postPlugins) {
          const pluginResult = plugin(input2);
          if (Array.isArray(pluginResult)) {
            pluginHandled = true;
            const [pluginIdentifier, ...rest] = pluginResult;
            str[index2] = `[${JSON.stringify(pluginIdentifier)}`;
            if (rest.length > 0) {
              str[index2] += `,${rest.map(v => flatten.call(this, v)).join(",")}`;
            }
            str[index2] += "]";
            break;
          }
        }
      }
      if (!pluginHandled) {
        throw error;
      }
    }
  }
}
var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function isPlainObject(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === objectProtoNames;
}

// src/unflatten.ts
var globalObj = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : void 0;
function unflatten(parsed) {
  const {
    hydrated,
    values
  } = this;
  if (typeof parsed === "number") return hydrate.call(this, parsed);
  if (!Array.isArray(parsed) || !parsed.length) throw new SyntaxError();
  const startIndex = values.length;
  for (const value of parsed) {
    values.push(value);
  }
  hydrated.length = values.length;
  return hydrate.call(this, startIndex);
}
function hydrate(index) {
  const {
    hydrated,
    values,
    deferred,
    plugins
  } = this;
  let result;
  const stack = [[index, v => {
    result = v;
  }]];
  let postRun = [];
  while (stack.length > 0) {
    const [index2, set] = stack.pop();
    switch (index2) {
      case UNDEFINED:
        set(void 0);
        continue;
      case NULL:
        set(null);
        continue;
      case NAN:
        set(NaN);
        continue;
      case POSITIVE_INFINITY:
        set(Infinity);
        continue;
      case NEGATIVE_INFINITY:
        set(-Infinity);
        continue;
      case NEGATIVE_ZERO:
        set(-0);
        continue;
    }
    if (hydrated[index2]) {
      set(hydrated[index2]);
      continue;
    }
    const value = values[index2];
    if (!value || typeof value !== "object") {
      hydrated[index2] = value;
      set(value);
      continue;
    }
    if (Array.isArray(value)) {
      if (typeof value[0] === "string") {
        const [type, b, c] = value;
        switch (type) {
          case TYPE_DATE:
            set(hydrated[index2] = new Date(b));
            continue;
          case TYPE_URL:
            set(hydrated[index2] = new URL(b));
            continue;
          case TYPE_BIGINT:
            set(hydrated[index2] = BigInt(b));
            continue;
          case TYPE_REGEXP:
            set(hydrated[index2] = new RegExp(b, c));
            continue;
          case TYPE_SYMBOL:
            set(hydrated[index2] = Symbol.for(b));
            continue;
          case TYPE_SET:
            const newSet = /* @__PURE__ */new Set();
            hydrated[index2] = newSet;
            for (let i = 1; i < value.length; i++) stack.push([value[i], v => {
              newSet.add(v);
            }]);
            set(newSet);
            continue;
          case TYPE_MAP:
            const map = /* @__PURE__ */new Map();
            hydrated[index2] = map;
            for (let i = 1; i < value.length; i += 2) {
              const r = [];
              stack.push([value[i + 1], v => {
                r[1] = v;
              }]);
              stack.push([value[i], k => {
                r[0] = k;
              }]);
              postRun.push(() => {
                map.set(r[0], r[1]);
              });
            }
            set(map);
            continue;
          case TYPE_NULL_OBJECT:
            const obj = /* @__PURE__ */Object.create(null);
            hydrated[index2] = obj;
            for (const key of Object.keys(b).reverse()) {
              const r = [];
              stack.push([b[key], v => {
                r[1] = v;
              }]);
              stack.push([Number(key.slice(1)), k => {
                r[0] = k;
              }]);
              postRun.push(() => {
                obj[r[0]] = r[1];
              });
            }
            set(obj);
            continue;
          case TYPE_PROMISE:
            if (hydrated[b]) {
              set(hydrated[index2] = hydrated[b]);
            } else {
              const d = new Deferred();
              deferred[b] = d;
              set(hydrated[index2] = d.promise);
            }
            continue;
          case TYPE_ERROR:
            const [, message, errorType] = value;
            let error = errorType && globalObj && globalObj[errorType] ? new globalObj[errorType](message) : new Error(message);
            hydrated[index2] = error;
            set(error);
            continue;
          case TYPE_PREVIOUS_RESOLVED:
            set(hydrated[index2] = hydrated[b]);
            continue;
          default:
            if (Array.isArray(plugins)) {
              const r = [];
              const vals = value.slice(1);
              for (let i = 0; i < vals.length; i++) {
                const v = vals[i];
                stack.push([v, v2 => {
                  r[i] = v2;
                }]);
              }
              postRun.push(() => {
                for (const plugin of plugins) {
                  const result2 = plugin(value[0], ...r);
                  if (result2) {
                    set(hydrated[index2] = result2.value);
                    return;
                  }
                }
                throw new SyntaxError();
              });
              continue;
            }
            throw new SyntaxError();
        }
      } else {
        const array = [];
        hydrated[index2] = array;
        for (let i = 0; i < value.length; i++) {
          const n = value[i];
          if (n !== HOLE) {
            stack.push([n, v => {
              array[i] = v;
            }]);
          }
        }
        set(array);
        continue;
      }
    } else {
      const object = {};
      hydrated[index2] = object;
      for (const key of Object.keys(value).reverse()) {
        const r = [];
        stack.push([value[key], v => {
          r[1] = v;
        }]);
        stack.push([Number(key.slice(1)), k => {
          r[0] = k;
        }]);
        postRun.push(() => {
          object[r[0]] = r[1];
        });
      }
      set(object);
      continue;
    }
  }
  while (postRun.length > 0) {
    postRun.pop()();
  }
  return result;
}

// src/turbo-stream.ts
async function decode(readable, options) {
  const {
    plugins
  } = options ?? {};
  const done = new Deferred();
  const reader = readable.pipeThrough(createLineSplittingTransform()).getReader();
  const decoder = {
    values: [],
    hydrated: [],
    deferred: {},
    plugins
  };
  const decoded = await decodeInitial.call(decoder, reader);
  let donePromise = done.promise;
  if (decoded.done) {
    done.resolve();
  } else {
    donePromise = decodeDeferred.call(decoder, reader).then(done.resolve).catch(reason => {
      for (const deferred of Object.values(decoder.deferred)) {
        deferred.reject(reason);
      }
      done.reject(reason);
    });
  }
  return {
    done: donePromise.then(() => reader.closed),
    value: decoded.value
  };
}
async function decodeInitial(reader) {
  const read = await reader.read();
  if (!read.value) {
    throw new SyntaxError();
  }
  let line;
  try {
    line = JSON.parse(read.value);
  } catch (reason) {
    throw new SyntaxError();
  }
  return {
    done: read.done,
    value: unflatten.call(this, line)
  };
}
async function decodeDeferred(reader) {
  let read = await reader.read();
  while (!read.done) {
    if (!read.value) continue;
    const line = read.value;
    switch (line[0]) {
      case TYPE_PROMISE:
        {
          const colonIndex = line.indexOf(":");
          const deferredId = Number(line.slice(1, colonIndex));
          const deferred = this.deferred[deferredId];
          if (!deferred) {
            throw new Error(`Deferred ID ${deferredId} not found in stream`);
          }
          const lineData = line.slice(colonIndex + 1);
          let jsonLine;
          try {
            jsonLine = JSON.parse(lineData);
          } catch (reason) {
            throw new SyntaxError();
          }
          const value = unflatten.call(this, jsonLine);
          deferred.resolve(value);
          break;
        }
      case TYPE_ERROR:
        {
          const colonIndex = line.indexOf(":");
          const deferredId = Number(line.slice(1, colonIndex));
          const deferred = this.deferred[deferredId];
          if (!deferred) {
            throw new Error(`Deferred ID ${deferredId} not found in stream`);
          }
          const lineData = line.slice(colonIndex + 1);
          let jsonLine;
          try {
            jsonLine = JSON.parse(lineData);
          } catch (reason) {
            throw new SyntaxError();
          }
          const value = unflatten.call(this, jsonLine);
          deferred.reject(value);
          break;
        }
      default:
        throw new SyntaxError();
    }
    read = await reader.read();
  }
}
function encode(input, options) {
  const {
    plugins,
    postPlugins,
    signal
  } = options ?? {};
  const encoder = {
    deferred: {},
    index: 0,
    indices: /* @__PURE__ */new Map(),
    stringified: [],
    plugins,
    postPlugins,
    signal
  };
  const textEncoder = new TextEncoder();
  let lastSentIndex = 0;
  const readable = new ReadableStream({
    async start(controller) {
      const id = flatten.call(encoder, input);
      if (Array.isArray(id)) {
        throw new Error("This should never happen");
      }
      if (id < 0) {
        controller.enqueue(textEncoder.encode(`${id}
`));
      } else {
        controller.enqueue(textEncoder.encode(`[${encoder.stringified.join(",")}]
`));
        lastSentIndex = encoder.stringified.length - 1;
      }
      const seenPromises = /* @__PURE__ */new WeakSet();
      while (Object.keys(encoder.deferred).length > 0) {
        for (const [deferredId, deferred] of Object.entries(encoder.deferred)) {
          if (seenPromises.has(deferred)) continue;
          seenPromises.add(encoder.deferred[Number(deferredId)] = raceSignal(deferred, encoder.signal).then(resolved => {
            const id2 = flatten.call(encoder, resolved);
            if (Array.isArray(id2)) {
              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`));
              encoder.index++;
              lastSentIndex++;
            } else if (id2 < 0) {
              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:${id2}
`));
            } else {
              const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
              controller.enqueue(textEncoder.encode(`${TYPE_PROMISE}${deferredId}:[${values}]
`));
              lastSentIndex = encoder.stringified.length - 1;
            }
          }, reason => {
            if (!reason || typeof reason !== "object" || !(reason instanceof Error)) {
              reason = new Error("An unknown error occurred");
            }
            const id2 = flatten.call(encoder, reason);
            if (Array.isArray(id2)) {
              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[["${TYPE_PREVIOUS_RESOLVED}",${id2[0]}]]
`));
              encoder.index++;
              lastSentIndex++;
            } else if (id2 < 0) {
              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:${id2}
`));
            } else {
              const values = encoder.stringified.slice(lastSentIndex + 1).join(",");
              controller.enqueue(textEncoder.encode(`${TYPE_ERROR}${deferredId}:[${values}]
`));
              lastSentIndex = encoder.stringified.length - 1;
            }
          }).finally(() => {
            delete encoder.deferred[Number(deferredId)];
          }));
        }
        await Promise.race(Object.values(encoder.deferred));
      }
      await Promise.all(Object.values(encoder.deferred));
      controller.close();
    }
  });
  return readable;
}
function raceSignal(promise, signal) {
  if (!signal) return promise;
  if (signal.aborted) return Promise.reject(signal.reason || new Error("Signal was aborted."));
  const abort = new Promise((resolve, reject) => {
    signal.addEventListener("abort", event => {
      reject(signal.reason || new Error("Signal was aborted."));
    });
    promise.then(resolve).catch(reject);
  });
  abort.catch(() => {});
  return Promise.race([abort, promise]);
}


/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function get() {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function get() {
    return _parse.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function get() {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function get() {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function get() {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function get() {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function get() {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function get() {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function get() {
    return _version.default;
  }
}));
var _v = _interopRequireDefault(__webpack_require__(/*! ./v1.js */ "./node_modules/uuid/dist/commonjs-browser/v1.js"));
var _v2 = _interopRequireDefault(__webpack_require__(/*! ./v3.js */ "./node_modules/uuid/dist/commonjs-browser/v3.js"));
var _v3 = _interopRequireDefault(__webpack_require__(/*! ./v4.js */ "./node_modules/uuid/dist/commonjs-browser/v4.js"));
var _v4 = _interopRequireDefault(__webpack_require__(/*! ./v5.js */ "./node_modules/uuid/dist/commonjs-browser/v5.js"));
var _nil = _interopRequireDefault(__webpack_require__(/*! ./nil.js */ "./node_modules/uuid/dist/commonjs-browser/nil.js"));
var _version = _interopRequireDefault(__webpack_require__(/*! ./version.js */ "./node_modules/uuid/dist/commonjs-browser/version.js"));
var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));
var _stringify = _interopRequireDefault(__webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js"));
var _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/commonjs-browser/parse.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/md5.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/md5.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */
function md5(bytes) {
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = new Uint8Array(msg.length);
    for (let i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */

function md5ToHexEncodedArray(input) {
  const output = [];
  const length32 = input.length * 32;
  const hexTab = '0123456789abcdef';
  for (let i = 0; i < length32; i += 8) {
    const x = input[i >> 5] >>> i % 32 & 0xff;
    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
    output.push(hex);
  }
  return output;
}
/**
 * Calculate output length with padding and bit length
 */

function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */

function wordsToMd5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[getOutputLength(len) - 1] = len;
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */

function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  const length8 = input.length * 8;
  const output = new Uint32Array(getOutputLength(length8));
  for (let i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
  }
  return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */

function safeAdd(x, y) {
  const lsw = (x & 0xffff) + (y & 0xffff);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */

function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */

function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/native.js":
/*!***********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/native.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var _default = {
  randomUUID
};
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/nil.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/nil.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/parse.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/parse.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}
var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/regex.js":
/*!**********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/regex.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/rng.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/rng.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }
  return getRandomValues(rnds8);
}

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/sha1.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/sha1.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  if (typeof bytes === 'string') {
    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

    bytes = [];
    for (let i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(0x80);
  const l = bytes.length / 4 + 2;
  const N = Math.ceil(l / 16);
  const M = new Array(N);
  for (let i = 0; i < N; ++i) {
    const arr = new Uint32Array(16);
    for (let j = 0; j < 16; ++j) {
      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
    }
    M[i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
  for (let i = 0; i < N; ++i) {
    const W = new Uint32Array(80);
    for (let t = 0; t < 16; ++t) {
      W[t] = M[i][t];
    }
    for (let t = 16; t < 80; ++t) {
      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    for (let t = 0; t < 80; ++t) {
      const s = Math.floor(t / 20);
      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
}
var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/stringify.js":
/*!**************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/stringify.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
exports.unsafeStringify = unsafeStringify;
var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }
  return uuid;
}
var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v1.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v1.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/commonjs-browser/rng.js"));
var _stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time

let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.

  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval

  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested

  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || (0, _stringify.unsafeStringify)(b);
}
var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v3.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v3.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/commonjs-browser/v35.js"));
var _md = _interopRequireDefault(__webpack_require__(/*! ./md5.js */ "./node_modules/uuid/dist/commonjs-browser/md5.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v35.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v35.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.URL = exports.DNS = void 0;
exports["default"] = v35;
var _stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js");
var _parse = _interopRequireDefault(__webpack_require__(/*! ./parse.js */ "./node_modules/uuid/dist/commonjs-browser/parse.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }
    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`

    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(bytes);
  } // Function#name is not settable on some platforms (#270)

  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support

  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v4.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v4.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _native = _interopRequireDefault(__webpack_require__(/*! ./native.js */ "./node_modules/uuid/dist/commonjs-browser/native.js"));
var _rng = _interopRequireDefault(__webpack_require__(/*! ./rng.js */ "./node_modules/uuid/dist/commonjs-browser/rng.js"));
var _stringify = __webpack_require__(/*! ./stringify.js */ "./node_modules/uuid/dist/commonjs-browser/stringify.js");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function v4(options, buf, offset) {
  if (_native.default.randomUUID && !buf && !options) {
    return _native.default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return (0, _stringify.unsafeStringify)(rnds);
}
var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/v5.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/v5.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _v = _interopRequireDefault(__webpack_require__(/*! ./v35.js */ "./node_modules/uuid/dist/commonjs-browser/v35.js"));
var _sha = _interopRequireDefault(__webpack_require__(/*! ./sha1.js */ "./node_modules/uuid/dist/commonjs-browser/sha1.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/validate.js":
/*!*************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/validate.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _regex = _interopRequireDefault(__webpack_require__(/*! ./regex.js */ "./node_modules/uuid/dist/commonjs-browser/regex.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}
var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/uuid/dist/commonjs-browser/version.js":
/*!************************************************************!*\
  !*** ./node_modules/uuid/dist/commonjs-browser/version.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _validate = _interopRequireDefault(__webpack_require__(/*! ./validate.js */ "./node_modules/uuid/dist/commonjs-browser/validate.js"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var _default = version;
exports["default"] = _default;

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js":
/*!***************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WebSocketClient)
/* harmony export */ });
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

var WebSocketClient = /*#__PURE__*/function () {
  /**
   * @param {string} url
   */
  function WebSocketClient(url) {
    _classCallCheck(this, WebSocketClient);
    this.client = new WebSocket(url);
    this.client.onerror = function (error) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_0__.log.error(error);
    };
  }

  /**
   * @param {(...args: any[]) => void} f
   */
  _createClass(WebSocketClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.client.onopen = f;
    }

    /**
     * @param {(...args: any[]) => void} f
     */
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.client.onclose = f;
    }

    // call f with the message string as the first argument
    /**
     * @param {(...args: any[]) => void} f
     */
  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.client.onmessage = function (e) {
        f(e.data);
      };
    }
  }]);
  return WebSocketClient;
}();


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=%7B%22errors%22%3Atrue%2C%22warnings%22%3Afalse%7D&reconnect=10&hot=true&live-reload=true":
/*!*********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=%7B%22errors%22%3Atrue%2C%22warnings%22%3Afalse%7D&reconnect=10&hot=true&live-reload=true ***!
  \*********************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
var __resourceQuery = "?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=%7B%22errors%22%3Atrue%2C%22warnings%22%3Afalse%7D&reconnect=10&hot=true&live-reload=true";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/log.js */ "./node_modules/webpack/hot/log.js");
/* harmony import */ var webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/stripAnsi.js */ "./node_modules/webpack-dev-server/client/utils/stripAnsi.js");
/* harmony import */ var _utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/parseURL.js */ "./node_modules/webpack-dev-server/client/utils/parseURL.js");
/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./socket.js */ "./node_modules/webpack-dev-server/client/socket.js");
/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./overlay.js */ "./node_modules/webpack-dev-server/client/overlay.js");
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
/* harmony import */ var _utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/sendMessage.js */ "./node_modules/webpack-dev-server/client/utils/sendMessage.js");
/* harmony import */ var _utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/reloadApp.js */ "./node_modules/webpack-dev-server/client/utils/reloadApp.js");
/* harmony import */ var _utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/createSocketURL.js */ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js");
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
/* global __resourceQuery, __webpack_hash__ */
/// <reference types="webpack/module" />










/**
 * @typedef {Object} OverlayOptions
 * @property {boolean | (error: Error) => boolean} [warnings]
 * @property {boolean | (error: Error) => boolean} [errors]
 * @property {boolean | (error: Error) => boolean} [runtimeErrors]
 * @property {string} [trustedTypesPolicyName]
 */

/**
 * @typedef {Object} Options
 * @property {boolean} hot
 * @property {boolean} liveReload
 * @property {boolean} progress
 * @property {boolean | OverlayOptions} overlay
 * @property {string} [logging]
 * @property {number} [reconnect]
 */

/**
 * @typedef {Object} Status
 * @property {boolean} isUnloading
 * @property {string} currentHash
 * @property {string} [previousHash]
 */

/**
 * @param {boolean | { warnings?: boolean | string; errors?: boolean | string; runtimeErrors?: boolean | string; }} overlayOptions
 */
var decodeOverlayOptions = function decodeOverlayOptions(overlayOptions) {
  if (typeof overlayOptions === "object") {
    ["warnings", "errors", "runtimeErrors"].forEach(function (property) {
      if (typeof overlayOptions[property] === "string") {
        var overlayFilterFunctionString = decodeURIComponent(overlayOptions[property]);

        // eslint-disable-next-line no-new-func
        var overlayFilterFunction = new Function("message", "var callback = ".concat(overlayFilterFunctionString, "\n        return callback(message)"));
        overlayOptions[property] = overlayFilterFunction;
      }
    });
  }
};

/**
 * @type {Status}
 */
var status = {
  isUnloading: false,
  // TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement
  // eslint-disable-next-line camelcase
  currentHash:  true ? __webpack_require__.h() : 0
};

/** @type {Options} */
var options = {
  hot: false,
  liveReload: false,
  progress: false,
  overlay: false
};
var parsedResourceQuery = (0,_utils_parseURL_js__WEBPACK_IMPORTED_MODULE_2__["default"])(__resourceQuery);
var enabledFeatures = {
  "Hot Module Replacement": false,
  "Live Reloading": false,
  Progress: false,
  Overlay: false
};
if (parsedResourceQuery.hot === "true") {
  options.hot = true;
  enabledFeatures["Hot Module Replacement"] = true;
}
if (parsedResourceQuery["live-reload"] === "true") {
  options.liveReload = true;
  enabledFeatures["Live Reloading"] = true;
}
if (parsedResourceQuery.progress === "true") {
  options.progress = true;
  enabledFeatures.Progress = true;
}
if (parsedResourceQuery.overlay) {
  try {
    options.overlay = JSON.parse(parsedResourceQuery.overlay);
  } catch (e) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error("Error parsing overlay options from resource query:", e);
  }

  // Fill in default "true" params for partially-specified objects.
  if (typeof options.overlay === "object") {
    options.overlay = _objectSpread({
      errors: true,
      warnings: true,
      runtimeErrors: true
    }, options.overlay);
    decodeOverlayOptions(options.overlay);
  }
  enabledFeatures.Overlay = true;
}
if (parsedResourceQuery.logging) {
  options.logging = parsedResourceQuery.logging;
}
if (typeof parsedResourceQuery.reconnect !== "undefined") {
  options.reconnect = Number(parsedResourceQuery.reconnect);
}

/**
 * @param {string} level
 */
function setAllLogLevel(level) {
  // This is needed because the HMR logger operate separately from dev server logger
  webpack_hot_log_js__WEBPACK_IMPORTED_MODULE_0___default().setLogLevel(level === "verbose" || level === "log" ? "info" : level);
  (0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.setLogLevel)(level);
}
if (options.logging) {
  setAllLogLevel(options.logging);
}
(0,_utils_log_js__WEBPACK_IMPORTED_MODULE_5__.logEnabledFeatures)(enabledFeatures);
self.addEventListener("beforeunload", function () {
  status.isUnloading = true;
});
var overlay = typeof window !== "undefined" ? (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.createOverlay)(typeof options.overlay === "object" ? {
  trustedTypesPolicyName: options.overlay.trustedTypesPolicyName,
  catchRuntimeError: options.overlay.runtimeErrors
} : {
  trustedTypesPolicyName: false,
  catchRuntimeError: options.overlay
}) : {
  send: function send() {}
};
var onSocketMessage = {
  hot: function hot() {
    if (parsedResourceQuery.hot === "false") {
      return;
    }
    options.hot = true;
  },
  liveReload: function liveReload() {
    if (parsedResourceQuery["live-reload"] === "false") {
      return;
    }
    options.liveReload = true;
  },
  invalid: function invalid() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("App updated. Recompiling...");

    // Fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      });
    }
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Invalid");
  },
  /**
   * @param {string} hash
   */
  hash: function hash(_hash) {
    status.previousHash = status.currentHash;
    status.currentHash = _hash;
  },
  logging: setAllLogLevel,
  /**
   * @param {boolean} value
   */
  overlay: function overlay(value) {
    if (typeof document === "undefined") {
      return;
    }
    options.overlay = value;
    decodeOverlayOptions(options.overlay);
  },
  /**
   * @param {number} value
   */
  reconnect: function reconnect(value) {
    if (parsedResourceQuery.reconnect === "false") {
      return;
    }
    options.reconnect = value;
  },
  /**
   * @param {boolean} value
   */
  progress: function progress(value) {
    options.progress = value;
  },
  /**
   * @param {{ pluginName?: string, percent: number, msg: string }} data
   */
  "progress-update": function progressUpdate(data) {
    if (options.progress) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(data.pluginName ? "[".concat(data.pluginName, "] ") : "").concat(data.percent, "% - ").concat(data.msg, "."));
    }
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Progress", data);
  },
  "still-ok": function stillOk() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Nothing changed.");
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      });
    }
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("StillOk");
  },
  ok: function ok() {
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Ok");
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      });
    }
    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, status);
  },
  // TODO: remove in v5 in favor of 'static-changed'
  /**
   * @param {string} file
   */
  "content-changed": function contentChanged(file) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  },
  /**
   * @param {string} file
   */
  "static-changed": function staticChanged(file) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  },
  /**
   * @param {Error[]} warnings
   * @param {any} params
   */
  warnings: function warnings(_warnings, params) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn("Warnings while compiling.");
    var printableWarnings = _warnings.map(function (error) {
      var _formatProblem = (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.formatProblem)("warning", error),
        header = _formatProblem.header,
        body = _formatProblem.body;
      return "".concat(header, "\n").concat((0,_utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__["default"])(body));
    });
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Warnings", printableWarnings);
    for (var i = 0; i < printableWarnings.length; i++) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.warn(printableWarnings[i]);
    }
    var overlayWarningsSetting = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.warnings;
    if (overlayWarningsSetting) {
      var warningsToDisplay = typeof overlayWarningsSetting === "function" ? _warnings.filter(overlayWarningsSetting) : _warnings;
      if (warningsToDisplay.length) {
        overlay.send({
          type: "BUILD_ERROR",
          level: "warning",
          messages: _warnings
        });
      }
    }
    if (params && params.preventReloading) {
      return;
    }
    (0,_utils_reloadApp_js__WEBPACK_IMPORTED_MODULE_7__["default"])(options, status);
  },
  /**
   * @param {Error[]} errors
   */
  errors: function errors(_errors) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error("Errors while compiling. Reload prevented.");
    var printableErrors = _errors.map(function (error) {
      var _formatProblem2 = (0,_overlay_js__WEBPACK_IMPORTED_MODULE_4__.formatProblem)("error", error),
        header = _formatProblem2.header,
        body = _formatProblem2.body;
      return "".concat(header, "\n").concat((0,_utils_stripAnsi_js__WEBPACK_IMPORTED_MODULE_1__["default"])(body));
    });
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Errors", printableErrors);
    for (var i = 0; i < printableErrors.length; i++) {
      _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(printableErrors[i]);
    }
    var overlayErrorsSettings = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.errors;
    if (overlayErrorsSettings) {
      var errorsToDisplay = typeof overlayErrorsSettings === "function" ? _errors.filter(overlayErrorsSettings) : _errors;
      if (errorsToDisplay.length) {
        overlay.send({
          type: "BUILD_ERROR",
          level: "error",
          messages: _errors
        });
      }
    }
  },
  /**
   * @param {Error} error
   */
  error: function error(_error) {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.error(_error);
  },
  close: function close() {
    _utils_log_js__WEBPACK_IMPORTED_MODULE_5__.log.info("Disconnected!");
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      });
    }
    (0,_utils_sendMessage_js__WEBPACK_IMPORTED_MODULE_6__["default"])("Close");
  }
};
var socketURL = (0,_utils_createSocketURL_js__WEBPACK_IMPORTED_MODULE_8__["default"])(parsedResourceQuery);
(0,_socket_js__WEBPACK_IMPORTED_MODULE_3__["default"])(socketURL, onSocketMessage, options.reconnect);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/modules/logger/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/modules/logger/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/******/(function () {
  // webpackBootstrap
  /******/
  "use strict";

  /******/
  var __webpack_modules__ = {
    /***/"./client-src/modules/logger/SyncBailHookFake.js": (
    /*!*******************************************************!*\
      !*** ./client-src/modules/logger/SyncBailHookFake.js ***!
      \*******************************************************/
    /***/
    function (module) {
      /**
       * Client stub for tapable SyncBailHook
       */
      module.exports = function clientTapableSyncBailHook() {
        return {
          call: function call() {}
        };
      };

      /***/
    }),
    /***/"./node_modules/webpack/lib/logging/Logger.js": (
    /*!****************************************************!*\
      !*** ./node_modules/webpack/lib/logging/Logger.js ***!
      \****************************************************/
    /***/
    function (__unused_webpack_module, exports) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _iterableToArray(iter) {
        if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _toPropertyKey(arg) {
        var key = _toPrimitive(arg, "string");
        return typeof key === "symbol" ? key : String(key);
      }
      function _toPrimitive(input, hint) {
        if (typeof input !== "object" || input === null) return input;
        var prim = input[(typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }).toPrimitive];
        if (prim !== undefined) {
          var res = prim.call(input, hint || "default");
          if (typeof res !== "object") return res;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (hint === "string" ? String : Number)(input);
      }
      var LogType = Object.freeze({
        error: /** @type {"error"} */"error",
        // message, c style arguments
        warn: /** @type {"warn"} */"warn",
        // message, c style arguments
        info: /** @type {"info"} */"info",
        // message, c style arguments
        log: /** @type {"log"} */"log",
        // message, c style arguments
        debug: /** @type {"debug"} */"debug",
        // message, c style arguments

        trace: /** @type {"trace"} */"trace",
        // no arguments

        group: /** @type {"group"} */"group",
        // [label]
        groupCollapsed: /** @type {"groupCollapsed"} */"groupCollapsed",
        // [label]
        groupEnd: /** @type {"groupEnd"} */"groupEnd",
        // [label]

        profile: /** @type {"profile"} */"profile",
        // [profileName]
        profileEnd: /** @type {"profileEnd"} */"profileEnd",
        // [profileName]

        time: /** @type {"time"} */"time",
        // name, time as [seconds, nanoseconds]

        clear: /** @type {"clear"} */"clear",
        // no arguments
        status: /** @type {"status"} */"status" // message, arguments
      });
      exports.LogType = LogType;

      /** @typedef {typeof LogType[keyof typeof LogType]} LogTypeEnum */

      var LOG_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger raw log method");
      var TIMERS_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger times");
      var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) {
        return i;
      })("webpack logger aggregated times");
      var WebpackLogger = /*#__PURE__*/function () {
        /**
         * @param {function(LogTypeEnum, any[]=): void} log log function
         * @param {function(string | function(): string): WebpackLogger} getChildLogger function to create child logger
         */
        function WebpackLogger(log, getChildLogger) {
          _classCallCheck(this, WebpackLogger);
          this[LOG_SYMBOL] = log;
          this.getChildLogger = getChildLogger;
        }
        _createClass(WebpackLogger, [{
          key: "error",
          value: function error() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            this[LOG_SYMBOL](LogType.error, args);
          }
        }, {
          key: "warn",
          value: function warn() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            this[LOG_SYMBOL](LogType.warn, args);
          }
        }, {
          key: "info",
          value: function info() {
            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }
            this[LOG_SYMBOL](LogType.info, args);
          }
        }, {
          key: "log",
          value: function log() {
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            this[LOG_SYMBOL](LogType.log, args);
          }
        }, {
          key: "debug",
          value: function debug() {
            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }
            this[LOG_SYMBOL](LogType.debug, args);
          }
        }, {
          key: "assert",
          value: function assert(assertion) {
            if (!assertion) {
              for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
                args[_key6 - 1] = arguments[_key6];
              }
              this[LOG_SYMBOL](LogType.error, args);
            }
          }
        }, {
          key: "trace",
          value: function trace() {
            this[LOG_SYMBOL](LogType.trace, ["Trace"]);
          }
        }, {
          key: "clear",
          value: function clear() {
            this[LOG_SYMBOL](LogType.clear);
          }
        }, {
          key: "status",
          value: function status() {
            for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
              args[_key7] = arguments[_key7];
            }
            this[LOG_SYMBOL](LogType.status, args);
          }
        }, {
          key: "group",
          value: function group() {
            for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
              args[_key8] = arguments[_key8];
            }
            this[LOG_SYMBOL](LogType.group, args);
          }
        }, {
          key: "groupCollapsed",
          value: function groupCollapsed() {
            for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
              args[_key9] = arguments[_key9];
            }
            this[LOG_SYMBOL](LogType.groupCollapsed, args);
          }
        }, {
          key: "groupEnd",
          value: function groupEnd() {
            for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
              args[_key10] = arguments[_key10];
            }
            this[LOG_SYMBOL](LogType.groupEnd, args);
          }
        }, {
          key: "profile",
          value: function profile(label) {
            this[LOG_SYMBOL](LogType.profile, [label]);
          }
        }, {
          key: "profileEnd",
          value: function profileEnd(label) {
            this[LOG_SYMBOL](LogType.profileEnd, [label]);
          }
        }, {
          key: "time",
          value: function time(label) {
            this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();
            this[TIMERS_SYMBOL].set(label, process.hrtime());
          }
        }, {
          key: "timeLog",
          value: function timeLog(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeLog()"));
            }
            var time = process.hrtime(prev);
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }, {
          key: "timeEnd",
          value: function timeEnd(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeEnd()"));
            }
            var time = process.hrtime(prev);
            this[TIMERS_SYMBOL].delete(label);
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }, {
          key: "timeAggregate",
          value: function timeAggregate(label) {
            var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
            if (!prev) {
              throw new Error("No such label '".concat(label, "' for WebpackLogger.timeAggregate()"));
            }
            var time = process.hrtime(prev);
            this[TIMERS_SYMBOL].delete(label);
            this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();
            var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);
            if (current !== undefined) {
              if (time[1] + current[1] > 1e9) {
                time[0] += current[0] + 1;
                time[1] = time[1] - 1e9 + current[1];
              } else {
                time[0] += current[0];
                time[1] += current[1];
              }
            }
            this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
          }
        }, {
          key: "timeAggregateEnd",
          value: function timeAggregateEnd(label) {
            if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;
            var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
            if (time === undefined) return;
            this[TIMERS_AGGREGATES_SYMBOL].delete(label);
            this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
          }
        }]);
        return WebpackLogger;
      }();
      exports.Logger = WebpackLogger;

      /***/
    }),
    /***/"./node_modules/webpack/lib/logging/createConsoleLogger.js": (
    /*!*****************************************************************!*\
      !*** ./node_modules/webpack/lib/logging/createConsoleLogger.js ***!
      \*****************************************************************/
    /***/
    function (module, __unused_webpack_exports, __nested_webpack_require_13160__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }
      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _iterableToArray(iter) {
        if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) {
          return i;
        }).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }
      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      var _require = __nested_webpack_require_13160__(/*! ./Logger */"./node_modules/webpack/lib/logging/Logger.js"),
        LogType = _require.LogType;

      /** @typedef {import("../../declarations/WebpackOptions").FilterItemTypes} FilterItemTypes */
      /** @typedef {import("../../declarations/WebpackOptions").FilterTypes} FilterTypes */
      /** @typedef {import("./Logger").LogTypeEnum} LogTypeEnum */

      /** @typedef {function(string): boolean} FilterFunction */

      /**
       * @typedef {Object} LoggerConsole
       * @property {function(): void} clear
       * @property {function(): void} trace
       * @property {(...args: any[]) => void} info
       * @property {(...args: any[]) => void} log
       * @property {(...args: any[]) => void} warn
       * @property {(...args: any[]) => void} error
       * @property {(...args: any[]) => void=} debug
       * @property {(...args: any[]) => void=} group
       * @property {(...args: any[]) => void=} groupCollapsed
       * @property {(...args: any[]) => void=} groupEnd
       * @property {(...args: any[]) => void=} status
       * @property {(...args: any[]) => void=} profile
       * @property {(...args: any[]) => void=} profileEnd
       * @property {(...args: any[]) => void=} logTime
       */

      /**
       * @typedef {Object} LoggerOptions
       * @property {false|true|"none"|"error"|"warn"|"info"|"log"|"verbose"} level loglevel
       * @property {FilterTypes|boolean} debug filter for debug logging
       * @property {LoggerConsole} console the console to log to
       */

      /**
       * @param {FilterItemTypes} item an input item
       * @returns {FilterFunction} filter function
       */
      var filterToFunction = function filterToFunction(item) {
        if (typeof item === "string") {
          var regExp = new RegExp("[\\\\/]".concat(item.replace(
          // eslint-disable-next-line no-useless-escape
          /[-[\]{}()*+?.\\^$|]/g, "\\$&"), "([\\\\/]|$|!|\\?)"));
          return function (ident) {
            return regExp.test(ident);
          };
        }
        if (item && typeof item === "object" && typeof item.test === "function") {
          return function (ident) {
            return item.test(ident);
          };
        }
        if (typeof item === "function") {
          return item;
        }
        if (typeof item === "boolean") {
          return function () {
            return item;
          };
        }
      };

      /**
       * @enum {number}
       */
      var LogLevel = {
        none: 6,
        false: 6,
        error: 5,
        warn: 4,
        info: 3,
        log: 2,
        true: 2,
        verbose: 1
      };

      /**
       * @param {LoggerOptions} options options object
       * @returns {function(string, LogTypeEnum, any[]): void} logging function
       */
      module.exports = function (_ref) {
        var _ref$level = _ref.level,
          level = _ref$level === void 0 ? "info" : _ref$level,
          _ref$debug = _ref.debug,
          debug = _ref$debug === void 0 ? false : _ref$debug,
          console = _ref.console;
        var debugFilters = typeof debug === "boolean" ? [function () {
          return debug;
        }] : /** @type {FilterItemTypes[]} */[].concat(debug).map(filterToFunction);
        /** @type {number} */
        var loglevel = LogLevel["".concat(level)] || 0;

        /**
         * @param {string} name name of the logger
         * @param {LogTypeEnum} type type of the log entry
         * @param {any[]} args arguments of the log entry
         * @returns {void}
         */
        var logger = function logger(name, type, args) {
          var labeledArgs = function labeledArgs() {
            if (Array.isArray(args)) {
              if (args.length > 0 && typeof args[0] === "string") {
                return ["[".concat(name, "] ").concat(args[0])].concat(_toConsumableArray(args.slice(1)));
              } else {
                return ["[".concat(name, "]")].concat(_toConsumableArray(args));
              }
            } else {
              return [];
            }
          };
          var debug = debugFilters.some(function (f) {
            return f(name);
          });
          switch (type) {
            case LogType.debug:
              if (!debug) return;
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.debug === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.debug.apply(console, _toConsumableArray(labeledArgs()));
              } else {
                console.log.apply(console, _toConsumableArray(labeledArgs()));
              }
              break;
            case LogType.log:
              if (!debug && loglevel > LogLevel.log) return;
              console.log.apply(console, _toConsumableArray(labeledArgs()));
              break;
            case LogType.info:
              if (!debug && loglevel > LogLevel.info) return;
              console.info.apply(console, _toConsumableArray(labeledArgs()));
              break;
            case LogType.warn:
              if (!debug && loglevel > LogLevel.warn) return;
              console.warn.apply(console, _toConsumableArray(labeledArgs()));
              break;
            case LogType.error:
              if (!debug && loglevel > LogLevel.error) return;
              console.error.apply(console, _toConsumableArray(labeledArgs()));
              break;
            case LogType.trace:
              if (!debug) return;
              console.trace();
              break;
            case LogType.groupCollapsed:
              if (!debug && loglevel > LogLevel.log) return;
              if (!debug && loglevel > LogLevel.verbose) {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                if (typeof console.groupCollapsed === "function") {
                  // eslint-disable-next-line node/no-unsupported-features/node-builtins
                  console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));
                } else {
                  console.log.apply(console, _toConsumableArray(labeledArgs()));
                }
                break;
              }
            // falls through
            case LogType.group:
              if (!debug && loglevel > LogLevel.log) return;
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.group === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.group.apply(console, _toConsumableArray(labeledArgs()));
              } else {
                console.log.apply(console, _toConsumableArray(labeledArgs()));
              }
              break;
            case LogType.groupEnd:
              if (!debug && loglevel > LogLevel.log) return;
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.groupEnd === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.groupEnd();
              }
              break;
            case LogType.time:
              {
                if (!debug && loglevel > LogLevel.log) return;
                var ms = args[1] * 1000 + args[2] / 1000000;
                var msg = "[".concat(name, "] ").concat(args[0], ": ").concat(ms, " ms");
                if (typeof console.logTime === "function") {
                  console.logTime(msg);
                } else {
                  console.log(msg);
                }
                break;
              }
            case LogType.profile:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.profile === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.profile.apply(console, _toConsumableArray(labeledArgs()));
              }
              break;
            case LogType.profileEnd:
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.profileEnd === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));
              }
              break;
            case LogType.clear:
              if (!debug && loglevel > LogLevel.log) return;
              // eslint-disable-next-line node/no-unsupported-features/node-builtins
              if (typeof console.clear === "function") {
                // eslint-disable-next-line node/no-unsupported-features/node-builtins
                console.clear();
              }
              break;
            case LogType.status:
              if (!debug && loglevel > LogLevel.info) return;
              if (typeof console.status === "function") {
                if (args.length === 0) {
                  console.status();
                } else {
                  console.status.apply(console, _toConsumableArray(labeledArgs()));
                }
              } else {
                if (args.length !== 0) {
                  console.info.apply(console, _toConsumableArray(labeledArgs()));
                }
              }
              break;
            default:
              throw new Error("Unexpected LogType ".concat(type));
          }
        };
        return logger;
      };

      /***/
    }),
    /***/"./node_modules/webpack/lib/logging/runtime.js": (
    /*!*****************************************************!*\
      !*** ./node_modules/webpack/lib/logging/runtime.js ***!
      \*****************************************************/
    /***/
    function (__unused_webpack_module, exports, __nested_webpack_require_24775__) {
      /*
      	MIT License http://www.opensource.org/licenses/mit-license.php
      	Author Tobias Koppers @sokra
      */

      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      var SyncBailHook = __nested_webpack_require_24775__(/*! tapable/lib/SyncBailHook */"./client-src/modules/logger/SyncBailHookFake.js");
      var _require = __nested_webpack_require_24775__(/*! ./Logger */"./node_modules/webpack/lib/logging/Logger.js"),
        Logger = _require.Logger;
      var createConsoleLogger = __nested_webpack_require_24775__(/*! ./createConsoleLogger */"./node_modules/webpack/lib/logging/createConsoleLogger.js");

      /** @type {createConsoleLogger.LoggerOptions} */
      var currentDefaultLoggerOptions = {
        level: "info",
        debug: false,
        console: console
      };
      var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);

      /**
       * @param {string} name name of the logger
       * @returns {Logger} a logger
       */
      exports.getLogger = function (name) {
        return new Logger(function (type, args) {
          if (exports.hooks.log.call(name, type, args) === undefined) {
            currentDefaultLogger(name, type, args);
          }
        }, function (childName) {
          return exports.getLogger("".concat(name, "/").concat(childName));
        });
      };

      /**
       * @param {createConsoleLogger.LoggerOptions} options new options, merge with old options
       * @returns {void}
       */
      exports.configureDefaultLogger = function (options) {
        _extends(currentDefaultLoggerOptions, options);
        currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);
      };
      exports.hooks = {
        log: new SyncBailHook(["origin", "type", "args"])
      };

      /***/
    })

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/
  var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/
  function __nested_webpack_require_27238__(moduleId) {
    /******/ // Check if module is in cache
    /******/var cachedModule = __webpack_module_cache__[moduleId];
    /******/
    if (cachedModule !== undefined) {
      /******/return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = __webpack_module_cache__[moduleId] = {
      /******/ // no module.id needed
      /******/ // no module.loaded needed
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_27238__);
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/define property getters */
  /******/
  !function () {
    /******/ // define getter functions for harmony exports
    /******/__nested_webpack_require_27238__.d = function (exports, definition) {
      /******/for (var key in definition) {
        /******/if (__nested_webpack_require_27238__.o(definition, key) && !__nested_webpack_require_27238__.o(exports, key)) {
          /******/Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  }();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/
  !function () {
    /******/__nested_webpack_require_27238__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/
  }();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/
  !function () {
    /******/ // define __esModule on exports
    /******/__nested_webpack_require_27238__.r = function (exports) {
      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/
  }();
  /******/
  /************************************************************************/
  var __nested_webpack_exports__ = {};
  // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
  !function () {
    /*!********************************************!*\
      !*** ./client-src/modules/logger/index.js ***!
      \********************************************/
    __nested_webpack_require_27238__.r(__nested_webpack_exports__);
    /* harmony export */
    __nested_webpack_require_27238__.d(__nested_webpack_exports__, {
      /* harmony export */"default": function () {
        return /* reexport default export from named module */webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__;
      }
      /* harmony export */
    });
    /* harmony import */
    var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_27238__(/*! webpack/lib/logging/runtime.js */"./node_modules/webpack/lib/logging/runtime.js");
  }();
  var __webpack_export_target__ = exports;
  for (var i in __nested_webpack_exports__) __webpack_export_target__[i] = __nested_webpack_exports__[i];
  if (__nested_webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", {
    value: true
  });
  /******/
})();

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay.js":
/*!***********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createOverlay: () => (/* binding */ createOverlay),
/* harmony export */   formatProblem: () => (/* binding */ formatProblem)
/* harmony export */ });
/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ansi-html-community */ "./node_modules/ansi-html-community/index.js");
/* harmony import */ var ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ansi_html_community__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! html-entities */ "./node_modules/html-entities/lib/index.js");
/* harmony import */ var html_entities__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(html_entities__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./overlay/runtime-error.js */ "./node_modules/webpack-dev-server/client/overlay/runtime-error.js");
/* harmony import */ var _overlay_state_machine_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overlay/state-machine.js */ "./node_modules/webpack-dev-server/client/overlay/state-machine.js");
/* harmony import */ var _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overlay/styles.js */ "./node_modules/webpack-dev-server/client/overlay/styles.js");
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).






var colors = {
  reset: ["transparent", "transparent"],
  black: "181818",
  red: "E36049",
  green: "B3CB74",
  yellow: "FFD080",
  blue: "7CAFC2",
  magenta: "7FACCA",
  cyan: "C3C2EF",
  lightgrey: "EBE7E3",
  darkgrey: "6D7891"
};
ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default().setColors(colors);

/**
 * @param {string} type
 * @param {string  | { file?: string, moduleName?: string, loc?: string, message?: string; stack?: string[] }} item
 * @returns {{ header: string, body: string }}
 */
function formatProblem(type, item) {
  var header = type === "warning" ? "WARNING" : "ERROR";
  var body = "";
  if (typeof item === "string") {
    body += item;
  } else {
    var file = item.file || "";
    // eslint-disable-next-line no-nested-ternary
    var moduleName = item.moduleName ? item.moduleName.indexOf("!") !== -1 ? "".concat(item.moduleName.replace(/^(\s|\S)*!/, ""), " (").concat(item.moduleName, ")") : "".concat(item.moduleName) : "";
    var loc = item.loc;
    header += "".concat(moduleName || file ? " in ".concat(moduleName ? "".concat(moduleName).concat(file ? " (".concat(file, ")") : "") : file).concat(loc ? " ".concat(loc) : "") : "");
    body += item.message || "";
  }
  if (Array.isArray(item.stack)) {
    item.stack.forEach(function (stack) {
      if (typeof stack === "string") {
        body += "\r\n".concat(stack);
      }
    });
  }
  return {
    header: header,
    body: body
  };
}

/**
 * @typedef {Object} CreateOverlayOptions
 * @property {string | null} trustedTypesPolicyName
 * @property {boolean | (error: Error) => void} [catchRuntimeError]
 */

/**
 *
 * @param {CreateOverlayOptions} options
 */
var createOverlay = function createOverlay(options) {
  /** @type {HTMLIFrameElement | null | undefined} */
  var iframeContainerElement;
  /** @type {HTMLDivElement | null | undefined} */
  var containerElement;
  /** @type {HTMLDivElement | null | undefined} */
  var headerElement;
  /** @type {Array<(element: HTMLDivElement) => void>} */
  var onLoadQueue = [];
  /** @type {TrustedTypePolicy | undefined} */
  var overlayTrustedTypesPolicy;

  /**
   *
   * @param {HTMLElement} element
   * @param {CSSStyleDeclaration} style
   */
  function applyStyle(element, style) {
    Object.keys(style).forEach(function (prop) {
      element.style[prop] = style[prop];
    });
  }

  /**
   * @param {string | null} trustedTypesPolicyName
   */
  function createContainer(trustedTypesPolicyName) {
    // Enable Trusted Types if they are available in the current browser.
    if (window.trustedTypes) {
      overlayTrustedTypesPolicy = window.trustedTypes.createPolicy(trustedTypesPolicyName || "webpack-dev-server#overlay", {
        createHTML: function createHTML(value) {
          return value;
        }
      });
    }
    iframeContainerElement = document.createElement("iframe");
    iframeContainerElement.id = "webpack-dev-server-client-overlay";
    iframeContainerElement.src = "about:blank";
    applyStyle(iframeContainerElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.iframeStyle);
    iframeContainerElement.onload = function () {
      var contentElement = /** @type {Document} */
      /** @type {HTMLIFrameElement} */
      iframeContainerElement.contentDocument.createElement("div");
      containerElement = /** @type {Document} */
      /** @type {HTMLIFrameElement} */
      iframeContainerElement.contentDocument.createElement("div");
      contentElement.id = "webpack-dev-server-client-overlay-div";
      applyStyle(contentElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.containerStyle);
      headerElement = document.createElement("div");
      headerElement.innerText = "Compiled with problems:";
      applyStyle(headerElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.headerStyle);
      var closeButtonElement = document.createElement("button");
      applyStyle(closeButtonElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.dismissButtonStyle);
      closeButtonElement.innerText = "×";
      closeButtonElement.ariaLabel = "Dismiss";
      closeButtonElement.addEventListener("click", function () {
        // eslint-disable-next-line no-use-before-define
        overlayService.send({
          type: "DISMISS"
        });
      });
      contentElement.appendChild(headerElement);
      contentElement.appendChild(closeButtonElement);
      contentElement.appendChild(containerElement);

      /** @type {Document} */
      /** @type {HTMLIFrameElement} */
      iframeContainerElement.contentDocument.body.appendChild(contentElement);
      onLoadQueue.forEach(function (onLoad) {
        onLoad(/** @type {HTMLDivElement} */contentElement);
      });
      onLoadQueue = [];

      /** @type {HTMLIFrameElement} */
      iframeContainerElement.onload = null;
    };
    document.body.appendChild(iframeContainerElement);
  }

  /**
   * @param {(element: HTMLDivElement) => void} callback
   * @param {string | null} trustedTypesPolicyName
   */
  function ensureOverlayExists(callback, trustedTypesPolicyName) {
    if (containerElement) {
      containerElement.innerHTML = "";
      // Everything is ready, call the callback right away.
      callback(containerElement);
      return;
    }
    onLoadQueue.push(callback);
    if (iframeContainerElement) {
      return;
    }
    createContainer(trustedTypesPolicyName);
  }

  // Successful compilation.
  function hide() {
    if (!iframeContainerElement) {
      return;
    }

    // Clean up and reset internal state.
    document.body.removeChild(iframeContainerElement);
    iframeContainerElement = null;
    containerElement = null;
  }

  // Compilation with errors (e.g. syntax error or missing modules).
  /**
   * @param {string} type
   * @param {Array<string  | { moduleIdentifier?: string, moduleName?: string, loc?: string, message?: string }>} messages
   * @param {string | null} trustedTypesPolicyName
   * @param {'build' | 'runtime'} messageSource
   */
  function show(type, messages, trustedTypesPolicyName, messageSource) {
    ensureOverlayExists(function () {
      headerElement.innerText = messageSource === "runtime" ? "Uncaught runtime errors:" : "Compiled with problems:";
      messages.forEach(function (message) {
        var entryElement = document.createElement("div");
        var msgStyle = type === "warning" ? _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgStyles.warning : _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgStyles.error;
        applyStyle(entryElement, _objectSpread(_objectSpread({}, msgStyle), {}, {
          padding: "1rem 1rem 1.5rem 1rem"
        }));
        var typeElement = document.createElement("div");
        var _formatProblem = formatProblem(type, message),
          header = _formatProblem.header,
          body = _formatProblem.body;
        typeElement.innerText = header;
        applyStyle(typeElement, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgTypeStyle);
        if (message.moduleIdentifier) {
          applyStyle(typeElement, {
            cursor: "pointer"
          });
          // element.dataset not supported in IE
          typeElement.setAttribute("data-can-open", true);
          typeElement.addEventListener("click", function () {
            fetch("/webpack-dev-server/open-editor?fileName=".concat(message.moduleIdentifier));
          });
        }

        // Make it look similar to our terminal.
        var text = ansi_html_community__WEBPACK_IMPORTED_MODULE_0___default()((0,html_entities__WEBPACK_IMPORTED_MODULE_4__.encode)(body));
        var messageTextNode = document.createElement("div");
        applyStyle(messageTextNode, _overlay_styles_js__WEBPACK_IMPORTED_MODULE_3__.msgTextStyle);
        messageTextNode.innerHTML = overlayTrustedTypesPolicy ? overlayTrustedTypesPolicy.createHTML(text) : text;
        entryElement.appendChild(typeElement);
        entryElement.appendChild(messageTextNode);

        /** @type {HTMLDivElement} */
        containerElement.appendChild(entryElement);
      });
    }, trustedTypesPolicyName);
  }
  var overlayService = (0,_overlay_state_machine_js__WEBPACK_IMPORTED_MODULE_2__["default"])({
    showOverlay: function showOverlay(_ref) {
      var _ref$level = _ref.level,
        level = _ref$level === void 0 ? "error" : _ref$level,
        messages = _ref.messages,
        messageSource = _ref.messageSource;
      return show(level, messages, options.trustedTypesPolicyName, messageSource);
    },
    hideOverlay: hide
  });
  if (options.catchRuntimeError) {
    /**
     * @param {Error | undefined} error
     * @param {string} fallbackMessage
     */
    var handleError = function handleError(error, fallbackMessage) {
      var errorObject = error instanceof Error ? error : new Error(error || fallbackMessage);
      var shouldDisplay = typeof options.catchRuntimeError === "function" ? options.catchRuntimeError(errorObject) : true;
      if (shouldDisplay) {
        overlayService.send({
          type: "RUNTIME_ERROR",
          messages: [{
            message: errorObject.message,
            stack: (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.parseErrorToStacks)(errorObject)
          }]
        });
      }
    };
    (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.listenToRuntimeError)(function (errorEvent) {
      // error property may be empty in older browser like IE
      var error = errorEvent.error,
        message = errorEvent.message;
      if (!error && !message) {
        return;
      }
      handleError(error, message);
    });
    (0,_overlay_runtime_error_js__WEBPACK_IMPORTED_MODULE_1__.listenToUnhandledRejection)(function (promiseRejectionEvent) {
      var reason = promiseRejectionEvent.reason;
      handleError(reason, "Unknown promise rejection reason");
    });
  }
  return overlayService;
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/fsm.js":
/*!***************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/fsm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
/**
 * @typedef {Object} StateDefinitions
 * @property {{[event: string]: { target: string; actions?: Array<string> }}} [on]
 */

/**
 * @typedef {Object} Options
 * @property {{[state: string]: StateDefinitions}} states
 * @property {object} context;
 * @property {string} initial
 */

/**
 * @typedef {Object} Implementation
 * @property {{[actionName: string]: (ctx: object, event: any) => object}} actions
 */

/**
 * A simplified `createMachine` from `@xstate/fsm` with the following differences:
 *
 *  - the returned machine is technically a "service". No `interpret(machine).start()` is needed.
 *  - the state definition only support `on` and target must be declared with { target: 'nextState', actions: [] } explicitly.
 *  - event passed to `send` must be an object with `type` property.
 *  - actions implementation will be [assign action](https://xstate.js.org/docs/guides/context.html#assign-action) if you return any value.
 *  Do not return anything if you just want to invoke side effect.
 *
 * The goal of this custom function is to avoid installing the entire `'xstate/fsm'` package, while enabling modeling using
 * state machine. You can copy the first parameter into the editor at https://stately.ai/viz to visualize the state machine.
 *
 * @param {Options} options
 * @param {Implementation} implementation
 */
function createMachine(_ref, _ref2) {
  var states = _ref.states,
    context = _ref.context,
    initial = _ref.initial;
  var actions = _ref2.actions;
  var currentState = initial;
  var currentContext = context;
  return {
    send: function send(event) {
      var currentStateOn = states[currentState].on;
      var transitionConfig = currentStateOn && currentStateOn[event.type];
      if (transitionConfig) {
        currentState = transitionConfig.target;
        if (transitionConfig.actions) {
          transitionConfig.actions.forEach(function (actName) {
            var actionImpl = actions[actName];
            var nextContextValue = actionImpl && actionImpl(currentContext, event);
            if (nextContextValue) {
              currentContext = _objectSpread(_objectSpread({}, currentContext), nextContextValue);
            }
          });
        }
      }
    }
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createMachine);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/runtime-error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/runtime-error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   listenToRuntimeError: () => (/* binding */ listenToRuntimeError),
/* harmony export */   listenToUnhandledRejection: () => (/* binding */ listenToUnhandledRejection),
/* harmony export */   parseErrorToStacks: () => (/* binding */ parseErrorToStacks)
/* harmony export */ });
/**
 *
 * @param {Error} error
 */
function parseErrorToStacks(error) {
  if (!error || !(error instanceof Error)) {
    throw new Error("parseErrorToStacks expects Error object");
  }
  if (typeof error.stack === "string") {
    return error.stack.split("\n").filter(function (stack) {
      return stack !== "Error: ".concat(error.message);
    });
  }
}

/**
 * @callback ErrorCallback
 * @param {ErrorEvent} error
 * @returns {void}
 */

/**
 * @param {ErrorCallback} callback
 */
function listenToRuntimeError(callback) {
  window.addEventListener("error", callback);
  return function cleanup() {
    window.removeEventListener("error", callback);
  };
}

/**
 * @callback UnhandledRejectionCallback
 * @param {PromiseRejectionEvent} rejectionEvent
 * @returns {void}
 */

/**
 * @param {UnhandledRejectionCallback} callback
 */
function listenToUnhandledRejection(callback) {
  window.addEventListener("unhandledrejection", callback);
  return function cleanup() {
    window.removeEventListener("unhandledrejection", callback);
  };
}


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/state-machine.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/state-machine.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _fsm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fsm.js */ "./node_modules/webpack-dev-server/client/overlay/fsm.js");


/**
 * @typedef {Object} ShowOverlayData
 * @property {'warning' | 'error'} level
 * @property {Array<string  | { moduleIdentifier?: string, moduleName?: string, loc?: string, message?: string }>} messages
 * @property {'build' | 'runtime'} messageSource
 */

/**
 * @typedef {Object} CreateOverlayMachineOptions
 * @property {(data: ShowOverlayData) => void} showOverlay
 * @property {() => void} hideOverlay
 */

/**
 * @param {CreateOverlayMachineOptions} options
 */
var createOverlayMachine = function createOverlayMachine(options) {
  var hideOverlay = options.hideOverlay,
    showOverlay = options.showOverlay;
  var overlayMachine = (0,_fsm_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    initial: "hidden",
    context: {
      level: "error",
      messages: [],
      messageSource: "build"
    },
    states: {
      hidden: {
        on: {
          BUILD_ERROR: {
            target: "displayBuildError",
            actions: ["setMessages", "showOverlay"]
          },
          RUNTIME_ERROR: {
            target: "displayRuntimeError",
            actions: ["setMessages", "showOverlay"]
          }
        }
      },
      displayBuildError: {
        on: {
          DISMISS: {
            target: "hidden",
            actions: ["dismissMessages", "hideOverlay"]
          },
          BUILD_ERROR: {
            target: "displayBuildError",
            actions: ["appendMessages", "showOverlay"]
          }
        }
      },
      displayRuntimeError: {
        on: {
          DISMISS: {
            target: "hidden",
            actions: ["dismissMessages", "hideOverlay"]
          },
          RUNTIME_ERROR: {
            target: "displayRuntimeError",
            actions: ["appendMessages", "showOverlay"]
          },
          BUILD_ERROR: {
            target: "displayBuildError",
            actions: ["setMessages", "showOverlay"]
          }
        }
      }
    }
  }, {
    actions: {
      dismissMessages: function dismissMessages() {
        return {
          messages: [],
          level: "error",
          messageSource: "build"
        };
      },
      appendMessages: function appendMessages(context, event) {
        return {
          messages: context.messages.concat(event.messages),
          level: event.level || context.level,
          messageSource: event.type === "RUNTIME_ERROR" ? "runtime" : "build"
        };
      },
      setMessages: function setMessages(context, event) {
        return {
          messages: event.messages,
          level: event.level || context.level,
          messageSource: event.type === "RUNTIME_ERROR" ? "runtime" : "build"
        };
      },
      hideOverlay: hideOverlay,
      showOverlay: showOverlay
    }
  });
  return overlayMachine;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createOverlayMachine);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/overlay/styles.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/overlay/styles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   containerStyle: () => (/* binding */ containerStyle),
/* harmony export */   dismissButtonStyle: () => (/* binding */ dismissButtonStyle),
/* harmony export */   headerStyle: () => (/* binding */ headerStyle),
/* harmony export */   iframeStyle: () => (/* binding */ iframeStyle),
/* harmony export */   msgStyles: () => (/* binding */ msgStyles),
/* harmony export */   msgTextStyle: () => (/* binding */ msgTextStyle),
/* harmony export */   msgTypeStyle: () => (/* binding */ msgTypeStyle)
/* harmony export */ });
// styles are inspired by `react-error-overlay`

var msgStyles = {
  error: {
    backgroundColor: "rgba(206, 17, 38, 0.1)",
    color: "#fccfcf"
  },
  warning: {
    backgroundColor: "rgba(251, 245, 180, 0.1)",
    color: "#fbf5b4"
  }
};
var iframeStyle = {
  position: "fixed",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  width: "100vw",
  height: "100vh",
  border: "none",
  "z-index": 9999999999
};
var containerStyle = {
  position: "fixed",
  boxSizing: "border-box",
  left: 0,
  top: 0,
  right: 0,
  bottom: 0,
  width: "100vw",
  height: "100vh",
  fontSize: "large",
  padding: "2rem 2rem 4rem 2rem",
  lineHeight: "1.2",
  whiteSpace: "pre-wrap",
  overflow: "auto",
  backgroundColor: "rgba(0, 0, 0, 0.9)",
  color: "white"
};
var headerStyle = {
  color: "#e83b46",
  fontSize: "2em",
  whiteSpace: "pre-wrap",
  fontFamily: "sans-serif",
  margin: "0 2rem 2rem 0",
  flex: "0 0 auto",
  maxHeight: "50%",
  overflow: "auto"
};
var dismissButtonStyle = {
  color: "#ffffff",
  lineHeight: "1rem",
  fontSize: "1.5rem",
  padding: "1rem",
  cursor: "pointer",
  position: "absolute",
  right: 0,
  top: 0,
  backgroundColor: "transparent",
  border: "none"
};
var msgTypeStyle = {
  color: "#e83b46",
  fontSize: "1.2em",
  marginBottom: "1rem",
  fontFamily: "sans-serif"
};
var msgTextStyle = {
  lineHeight: "1.5",
  fontSize: "1rem",
  fontFamily: "Menlo, Consolas, monospace"
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/socket.js":
/*!**********************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/socket.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   client: () => (/* binding */ client),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clients/WebSocketClient.js */ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js");
/* harmony import */ var _utils_log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");
/* provided dependency */ var __webpack_dev_server_client__ = __webpack_require__(/*! ./node_modules/webpack-dev-server/client/clients/WebSocketClient.js */ "./node_modules/webpack-dev-server/client/clients/WebSocketClient.js");
/* global __webpack_dev_server_client__ */




// this WebsocketClient is here as a default fallback, in case the client is not injected
/* eslint-disable camelcase */
var Client =
// eslint-disable-next-line no-nested-ternary
typeof __webpack_dev_server_client__ !== "undefined" ? typeof __webpack_dev_server_client__.default !== "undefined" ? __webpack_dev_server_client__.default : __webpack_dev_server_client__ : _clients_WebSocketClient_js__WEBPACK_IMPORTED_MODULE_0__["default"];
/* eslint-enable camelcase */

var retries = 0;
var maxRetries = 10;

// Initialized client is exported so external consumers can utilize the same instance
// It is mutable to enforce singleton
// eslint-disable-next-line import/no-mutable-exports
var client = null;

/**
 * @param {string} url
 * @param {{ [handler: string]: (data?: any, params?: any) => any }} handlers
 * @param {number} [reconnect]
 */
var socket = function initSocket(url, handlers, reconnect) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
    if (typeof reconnect !== "undefined") {
      maxRetries = reconnect;
    }
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    }

    // Try to reconnect.
    client = null;

    // After 10 retries stop trying, to prevent logspam.
    if (retries < maxRetries) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      _utils_log_js__WEBPACK_IMPORTED_MODULE_1__.log.info("Trying to reconnect...");
      setTimeout(function () {
        socket(url, handlers, reconnect);
      }, retryInMs);
    }
  });
  client.onMessage(
  /**
   * @param {any} data
   */
  function (data) {
    var message = JSON.parse(data);
    if (handlers[message.type]) {
      handlers[message.type](message.data, message.params);
    }
  });
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socket);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/createSocketURL.js":
/*!*************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/createSocketURL.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @param {{ protocol?: string, auth?: string, hostname?: string, port?: string, pathname?: string, search?: string, hash?: string, slashes?: boolean }} objURL
 * @returns {string}
 */
function format(objURL) {
  var protocol = objURL.protocol || "";
  if (protocol && protocol.substr(-1) !== ":") {
    protocol += ":";
  }
  var auth = objURL.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var host = "";
  if (objURL.hostname) {
    host = auth + (objURL.hostname.indexOf(":") === -1 ? objURL.hostname : "[".concat(objURL.hostname, "]"));
    if (objURL.port) {
      host += ":".concat(objURL.port);
    }
  }
  var pathname = objURL.pathname || "";
  if (objURL.slashes) {
    host = "//".concat(host || "");
    if (pathname && pathname.charAt(0) !== "/") {
      pathname = "/".concat(pathname);
    }
  } else if (!host) {
    host = "";
  }
  var search = objURL.search || "";
  if (search && search.charAt(0) !== "?") {
    search = "?".concat(search);
  }
  var hash = objURL.hash || "";
  if (hash && hash.charAt(0) !== "#") {
    hash = "#".concat(hash);
  }
  pathname = pathname.replace(/[?#]/g,
  /**
   * @param {string} match
   * @returns {string}
   */
  function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace("#", "%23");
  return "".concat(protocol).concat(host).concat(pathname).concat(search).concat(hash);
}

/**
 * @param {URL & { fromCurrentScript?: boolean }} parsedURL
 * @returns {string}
 */
function createSocketURL(parsedURL) {
  var hostname = parsedURL.hostname;

  // Node.js module parses it as `::`
  // `new URL(urlString, [baseURLString])` parses it as '[::]'
  var isInAddrAny = hostname === "0.0.0.0" || hostname === "::" || hostname === "[::]";

  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384
  if (isInAddrAny && self.location.hostname && self.location.protocol.indexOf("http") === 0) {
    hostname = self.location.hostname;
  }
  var socketURLProtocol = parsedURL.protocol || self.location.protocol;

  // When https is used in the app, secure web sockets are always necessary because the browser doesn't accept non-secure web sockets.
  if (socketURLProtocol === "auto:" || hostname && isInAddrAny && self.location.protocol === "https:") {
    socketURLProtocol = self.location.protocol;
  }
  socketURLProtocol = socketURLProtocol.replace(/^(?:http|.+-extension|file)/i, "ws");
  var socketURLAuth = "";

  // `new URL(urlString, [baseURLstring])` doesn't have `auth` property
  // Parse authentication credentials in case we need them
  if (parsedURL.username) {
    socketURLAuth = parsedURL.username;

    // Since HTTP basic authentication does not allow empty username,
    // we only include password if the username is not empty.
    if (parsedURL.password) {
      // Result: <username>:<password>
      socketURLAuth = socketURLAuth.concat(":", parsedURL.password);
    }
  }

  // In case the host is a raw IPv6 address, it can be enclosed in
  // the brackets as the brackets are needed in the final URL string.
  // Need to remove those as url.format blindly adds its own set of brackets
  // if the host string contains colons. That would lead to non-working
  // double brackets (e.g. [[::]]) host
  //
  // All of these web socket url params are optionally passed in through resourceQuery,
  // so we need to fall back to the default if they are not provided
  var socketURLHostname = (hostname || self.location.hostname || "localhost").replace(/^\[(.*)\]$/, "$1");
  var socketURLPort = parsedURL.port;
  if (!socketURLPort || socketURLPort === "0") {
    socketURLPort = self.location.port;
  }

  // If path is provided it'll be passed in via the resourceQuery as a
  // query param so it has to be parsed out of the querystring in order for the
  // client to open the socket to the correct location.
  var socketURLPathname = "/ws";
  if (parsedURL.pathname && !parsedURL.fromCurrentScript) {
    socketURLPathname = parsedURL.pathname;
  }
  return format({
    protocol: socketURLProtocol,
    auth: socketURLAuth,
    hostname: socketURLHostname,
    port: socketURLPort,
    pathname: socketURLPathname,
    slashes: true
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createSocketURL);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @returns {string}
 */
function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute("src");
  }

  // Fallback to getting all scripts running in the document.
  var scriptElements = document.scripts || [];
  var scriptElementsWithSrc = Array.prototype.filter.call(scriptElements, function (element) {
    return element.getAttribute("src");
  });
  if (scriptElementsWithSrc.length > 0) {
    var currentScript = scriptElementsWithSrc[scriptElementsWithSrc.length - 1];
    return currentScript.getAttribute("src");
  }

  // Fail as there was no script to use.
  throw new Error("[webpack-dev-server] Failed to get current script source.");
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (getCurrentScriptSource);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/log.js":
/*!*************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/log.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   logEnabledFeatures: () => (/* binding */ logEnabledFeatures),
/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel)
/* harmony export */ });
/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/logger/index.js */ "./node_modules/webpack-dev-server/client/modules/logger/index.js");
/* harmony import */ var _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0__);

var name = "webpack-dev-server";
// default level is set on the client side, so it does not need
// to be set by the CLI or API
var defaultLevel = "info";

// options new options, merge with old options
/**
 * @param {false | true | "none" | "error" | "warn" | "info" | "log" | "verbose"} level
 * @returns {void}
 */
function setLogLevel(level) {
  _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().configureDefaultLogger({
    level: level
  });
}
setLogLevel(defaultLevel);
var log = _modules_logger_index_js__WEBPACK_IMPORTED_MODULE_0___default().getLogger(name);
var logEnabledFeatures = function logEnabledFeatures(features) {
  var enabledFeatures = Object.keys(features);
  if (!features || enabledFeatures.length === 0) {
    return;
  }
  var logString = "Server started:";

  // Server started: Hot Module Replacement enabled, Live Reloading enabled, Overlay disabled.
  for (var i = 0; i < enabledFeatures.length; i++) {
    var key = enabledFeatures[i];
    logString += " ".concat(key, " ").concat(features[key] ? "enabled" : "disabled", ",");
  }
  // replace last comma with a period
  logString = logString.slice(0, -1).concat(".");
  log.info(logString);
};


/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/parseURL.js":
/*!******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/parseURL.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getCurrentScriptSource.js */ "./node_modules/webpack-dev-server/client/utils/getCurrentScriptSource.js");


/**
 * @param {string} resourceQuery
 * @returns {{ [key: string]: string | boolean }}
 */
function parseURL(resourceQuery) {
  /** @type {{ [key: string]: string }} */
  var options = {};
  if (typeof resourceQuery === "string" && resourceQuery !== "") {
    var searchParams = resourceQuery.slice(1).split("&");
    for (var i = 0; i < searchParams.length; i++) {
      var pair = searchParams[i].split("=");
      options[pair[0]] = decodeURIComponent(pair[1]);
    }
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptSource = (0,_getCurrentScriptSource_js__WEBPACK_IMPORTED_MODULE_0__["default"])();
    var scriptSourceURL;
    try {
      // The placeholder `baseURL` with `window.location.href`,
      // is to allow parsing of path-relative or protocol-relative URLs,
      // and will have no effect if `scriptSource` is a fully valid URL.
      scriptSourceURL = new URL(scriptSource, self.location.href);
    } catch (error) {
      // URL parsing failed, do nothing.
      // We will still proceed to see if we can recover using `resourceQuery`
    }
    if (scriptSourceURL) {
      options = scriptSourceURL;
      options.fromCurrentScript = true;
    }
  }
  return options;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseURL);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/reloadApp.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/reloadApp.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/hot/emitter.js */ "./node_modules/webpack/hot/emitter.js");
/* harmony import */ var webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log.js */ "./node_modules/webpack-dev-server/client/utils/log.js");



/** @typedef {import("../index").Options} Options
/** @typedef {import("../index").Status} Status

/**
 * @param {Options} options
 * @param {Status} status
 */
function reloadApp(_ref, status) {
  var hot = _ref.hot,
    liveReload = _ref.liveReload;
  if (status.isUnloading) {
    return;
  }
  var currentHash = status.currentHash,
    previousHash = status.previousHash;
  var isInitial = currentHash.indexOf(/** @type {string} */previousHash) >= 0;
  if (isInitial) {
    return;
  }

  /**
   * @param {Window} rootWindow
   * @param {number} intervalId
   */
  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info("App updated. Reloading...");
    rootWindow.location.reload();
  }
  var search = self.location.search.toLowerCase();
  var allowToHot = search.indexOf("webpack-dev-server-hot=false") === -1;
  var allowToLiveReload = search.indexOf("webpack-dev-server-live-reload=false") === -1;
  if (hot && allowToHot) {
    _log_js__WEBPACK_IMPORTED_MODULE_1__.log.info("App hot update...");
    webpack_hot_emitter_js__WEBPACK_IMPORTED_MODULE_0___default().emit("webpackHotUpdate", status.currentHash);
    if (typeof self !== "undefined" && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(status.currentHash), "*");
    }
  }
  // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload && allowToLiveReload) {
    var rootWindow = self;

    // use parent window for reload (in case we're in an iframe with no valid src)
    var intervalId = self.setInterval(function () {
      if (rootWindow.location.protocol !== "about:") {
        // reload immediately if protocol is valid
        applyReload(rootWindow, intervalId);
      } else {
        rootWindow = rootWindow.parent;
        if (rootWindow.parent === rootWindow) {
          // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
          applyReload(rootWindow, intervalId);
        }
      }
    });
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reloadApp);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/sendMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/sendMessage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* global __resourceQuery WorkerGlobalScope */

// Send messages to the outside, so plugins can consume it.
/**
 * @param {string} type
 * @param {any} [data]
 */
function sendMsg(type, data) {
  if (typeof self !== "undefined" && (typeof WorkerGlobalScope === "undefined" || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, "*");
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sendMsg);

/***/ }),

/***/ "./node_modules/webpack-dev-server/client/utils/stripAnsi.js":
/*!*******************************************************************!*\
  !*** ./node_modules/webpack-dev-server/client/utils/stripAnsi.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var ansiRegex = new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|"), "g");

/**
 *
 * Strip [ANSI escape codes](https://en.wikipedia.org/wiki/ANSI_escape_code) from a string.
 * Adapted from code originally released by Sindre Sorhus
 * Licensed the MIT License
 *
 * @param {string} string
 * @return {string}
 */
function stripAnsi(string) {
  if (typeof string !== "string") {
    throw new TypeError("Expected a `string`, got `".concat(typeof string, "`"));
  }
  return string.replace(ansiRegex, "");
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stripAnsi);

/***/ }),

/***/ "./node_modules/webpack/hot/dev-server.js":
/*!************************************************!*\
  !*** ./node_modules/webpack/hot/dev-server.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
/* globals __webpack_hash__ */
if (true) {
  /** @type {undefined|string} */
  var lastHash;
  var upToDate = function upToDate() {
    return /** @type {string} */lastHash.indexOf(__webpack_require__.h()) >= 0;
  };
  var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");
  var check = function check() {
    module.hot.check(true).then(function (updatedModules) {
      if (!updatedModules) {
        log("warning", "[HMR] Cannot find update. " + (typeof window !== "undefined" ? "Need to do a full reload!" : "Please reload manually!"));
        log("warning", "[HMR] (Probably because of restarting the webpack-dev-server)");
        if (typeof window !== "undefined") {
          window.location.reload();
        }
        return;
      }
      if (!upToDate()) {
        check();
      }
      __webpack_require__(/*! ./log-apply-result */ "./node_modules/webpack/hot/log-apply-result.js")(updatedModules, updatedModules);
      if (upToDate()) {
        log("info", "[HMR] App is up to date.");
      }
    }).catch(function (err) {
      var status = module.hot.status();
      if (["abort", "fail"].indexOf(status) >= 0) {
        log("warning", "[HMR] Cannot apply update. " + (typeof window !== "undefined" ? "Need to do a full reload!" : "Please reload manually!"));
        log("warning", "[HMR] " + log.formatError(err));
        if (typeof window !== "undefined") {
          window.location.reload();
        }
      } else {
        log("warning", "[HMR] Update failed: " + log.formatError(err));
      }
    });
  };
  var hotEmitter = __webpack_require__(/*! ./emitter */ "./node_modules/webpack/hot/emitter.js");
  hotEmitter.on("webpackHotUpdate", function (currentHash) {
    lastHash = currentHash;
    if (!upToDate() && module.hot.status() === "idle") {
      log("info", "[HMR] Checking for updates on the server...");
      check();
    }
  });
  log("info", "[HMR] Waiting for update signal from WDS...");
} else {}

/***/ }),

/***/ "./node_modules/webpack/hot/emitter.js":
/*!*********************************************!*\
  !*** ./node_modules/webpack/hot/emitter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
module.exports = new EventEmitter();

/***/ }),

/***/ "./node_modules/webpack/hot/log-apply-result.js":
/*!******************************************************!*\
  !*** ./node_modules/webpack/hot/log-apply-result.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

/**
 * @param {(string | number)[]} updatedModules updated modules
 * @param {(string | number)[] | null} renewedModules renewed modules
 */
module.exports = function (updatedModules, renewedModules) {
  var unacceptedModules = updatedModules.filter(function (moduleId) {
    return renewedModules && renewedModules.indexOf(moduleId) < 0;
  });
  var log = __webpack_require__(/*! ./log */ "./node_modules/webpack/hot/log.js");
  if (unacceptedModules.length > 0) {
    log("warning", "[HMR] The following modules couldn't be hot updated: (They would need a full reload!)");
    unacceptedModules.forEach(function (moduleId) {
      log("warning", "[HMR]  - " + moduleId);
    });
  }
  if (!renewedModules || renewedModules.length === 0) {
    log("info", "[HMR] Nothing hot updated.");
  } else {
    log("info", "[HMR] Updated modules:");
    renewedModules.forEach(function (moduleId) {
      if (typeof moduleId === "string" && moduleId.indexOf("!") !== -1) {
        var parts = moduleId.split("!");
        log.groupCollapsed("info", "[HMR]  - " + parts.pop());
        log("info", "[HMR]  - " + moduleId);
        log.groupEnd("info");
      } else {
        log("info", "[HMR]  - " + moduleId);
      }
    });
    var numberIds = renewedModules.every(function (moduleId) {
      return typeof moduleId === "number";
    });
    if (numberIds) log("info", '[HMR] Consider using the optimization.moduleIds: "named" for module names.');
  }
};

/***/ }),

/***/ "./node_modules/webpack/hot/log.js":
/*!*****************************************!*\
  !*** ./node_modules/webpack/hot/log.js ***!
  \*****************************************/
/***/ ((module) => {

/** @typedef {"info" | "warning" | "error"} LogLevel */

/** @type {LogLevel} */
var logLevel = "info";
function dummy() {}

/**
 * @param {LogLevel} level log level
 * @returns {boolean} true, if should log
 */
function shouldLog(level) {
  var shouldLog = logLevel === "info" && level === "info" || ["info", "warning"].indexOf(logLevel) >= 0 && level === "warning" || ["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error";
  return shouldLog;
}

/**
 * @param {(msg?: string) => void} logFn log function
 * @returns {(level: LogLevel, msg?: string) => void} function that logs when log level is sufficient
 */
function logGroup(logFn) {
  return function (level, msg) {
    if (shouldLog(level)) {
      logFn(msg);
    }
  };
}

/**
 * @param {LogLevel} level log level
 * @param {string|Error} msg message
 */
module.exports = function (level, msg) {
  if (shouldLog(level)) {
    if (level === "info") {
      console.log(msg);
    } else if (level === "warning") {
      console.warn(msg);
    } else if (level === "error") {
      console.error(msg);
    }
  }
};
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
module.exports.group = logGroup(group);
module.exports.groupCollapsed = logGroup(groupCollapsed);
module.exports.groupEnd = logGroup(groupEnd);

/**
 * @param {LogLevel} level log level
 */
module.exports.setLogLevel = function (level) {
  logLevel = level;
};

/**
 * @param {Error} err error
 * @returns {string} formatted error
 */
module.exports.formatError = function (err) {
  var message = err.message;
  var stack = err.stack;
  if (!stack) {
    return message;
  } else if (stack.indexOf(message) < 0) {
    return message + "\n" + stack;
  }
  return stack;
};

/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-GNGMS2XR.mjs");
/* harmony import */ var _components_HomePage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/HomePage */ "./src/components/HomePage.js");
/* harmony import */ var _components_ChatPage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/ChatPage */ "./src/components/ChatPage.js");
/* harmony import */ var _components_FeedbackPage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/FeedbackPage */ "./src/components/FeedbackPage.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

var _jsxFileName = "/Users/shakers/Desktop/Multi Agent/multi-agent/frontend-react/src/App.js";






function App() {
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.BrowserRouter, {
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Routes, {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
        path: "/",
        element: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(_components_HomePage__WEBPACK_IMPORTED_MODULE_1__["default"], {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 11,
          columnNumber: 34
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 11,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
        path: "/chat",
        element: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(_components_ChatPage__WEBPACK_IMPORTED_MODULE_2__["default"], {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 12,
          columnNumber: 38
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 12,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(react_router_dom__WEBPACK_IMPORTED_MODULE_5__.Route, {
        path: "/feedback",
        element: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(_components_FeedbackPage__WEBPACK_IMPORTED_MODULE_3__["default"], {}, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 13,
          columnNumber: 42
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 13,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 9,
    columnNumber: 5
  }, this);
}
_c = App;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (App);
var _c;
__webpack_require__.$Refresh$.register(_c, "App");

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/GIG+.png":
/*!**********************!*\
  !*** ./src/GIG+.png ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "static/media/GIG+.1250e93deeaddef48a11.png";

/***/ }),

/***/ "./src/background.png":
/*!****************************!*\
  !*** ./src/background.png ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,AAAAHGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZgAAAOptZXRhAAAAAAAAACFoZGxyAAAAAAAAAABwaWN0AAAAAAAAAAAAAAAAAAAAAA5waXRtAAAAAAABAAAAImlsb2MAAAAAREAAAQABAAAAAAEOAAEAAAAAAAADSwAAACNpaW5mAAAAAAABAAAAFWluZmUCAAAAAAEAAGF2MDEAAAAAamlwcnAAAABLaXBjbwAAABNjb2xybmNseAABAA0ABoAAAAAMYXYxQ4EEDAAAAAAUaXNwZQAAAAAAAAJyAAABygAAABBwaXhpAAAAAAMICAgAAAAXaXBtYQAAAAAAAAABAAEEAYIDBAAAA1NtZGF0EgAKChkmJx5LBAQ0GhAyugZEUABBBBBAtMkZo9P9pw75k/BvBVickl7Iu0Y3CB3P6JWujL6r0ZxNxTOb5LUg/AFuRuiMk1z5Is5awUt0oZ3mCkmQul2Vp9R9d4HN6LsvuSXJy+2X6Lj4yfJJWv2zBjFHxLb65AcozxhzxrlTtKSAdPOQbTfMuE/5nuwlZvV6z5cN2ht8K+ZFeCCYOSCAa8JRYKTvYi7YTY4Z28MygcSFiQGkKH7mtXSyHEf1VCnsCCVGUhVy+6L4uezlMpjzAAwSrtUypQ3pAoNCfOkpTekxfKhJD9IBVasDMFwJNCA/F80GVPNMz6ceHfiMwqr99EjgUz8aBKAZZW1zWPP7BqSdx9I1WevskkeKPY0LaSqU+87gb/wAulGyce+LplqDbvT13LNMTEObFli8GN59iZhniJpX9PsAuS3NyiNKL53f+jgdlI4Cd4Q6swo5L30ZnRpfTzxRz4G0O7QS/9OOfj9991fceMbsFXdL4vCEsLIndZLGNzhSzkzfPJYBL9+AIip2SDVs4z5erA4ltwtQonqmgyNPynVf8rqHHFdrFvZ9qxIRp0Urc/u9ekarF/lA1wwpiRYeqluUwjr7bgzBHaZtfd4+I+1nRAHCircxmJ2y8UtawtnWnUZP6zFITqoz3zJhwVXMCYODf1olYiL+nYeY2Ggu2g3cr4dWLDEvXNPjmrVH8COVIYRKvBsd97RQPyddlfF0WCsLDn8555x+ffOc05jqA2wQbHHqf5pJiV0FolLPnghe67JscaiG5a0pT9Peykm2jYj+U4LuG91QChdSrXBq81/RPc6H/IdFMFEHsRi/NbNI+RN1JNc3Ew/7P++yhq7txV9pBZHjBtvHR/Kjwc+CYinCbD6q42/fvTaDFpzR1UBAtTfGc8RsgDK4FQX3KfVdaMZzj1tPgw/wi5/oZJY/mTzPzYbG/9CU/+OnfEcWoPQIcc03wNmn6iIbJjbcUe0SzwEAv3vScw2Y7DZLIaIB7dX/2VKZxBA3xDD222WEJxfhLuJ0HiQx13CuqRvtjam4wTIKvAnF7nseD9wTFq5u5eDo+Gi3xKDblf6anCBu95w2xDal/pXJumZt/TA6Jh3CHLzzhN2w";

/***/ }),

/***/ "./src/components/ChatPage.css":
/*!*************************************!*\
  !*** ./src/components/ChatPage.css ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./ChatPage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/ChatPage.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./ChatPage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/ChatPage.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./ChatPage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/ChatPage.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_ChatPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/components/ChatPage.js":
/*!************************************!*\
  !*** ./src/components/ChatPage.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ChatPage)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! microsoft-cognitiveservices-speech-sdk */ "./node_modules/microsoft-cognitiveservices-speech-sdk/distrib/lib/microsoft.cognitiveservices.speech.sdk.js");
/* harmony import */ var microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-GNGMS2XR.mjs");
/* harmony import */ var _ChatPage_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ChatPage.css */ "./src/components/ChatPage.css");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

var _jsxFileName = "/Users/shakers/Desktop/Multi Agent/multi-agent/frontend-react/src/components/ChatPage.js",
  _s = __webpack_require__.$Refresh$.signature();





const speechKey = "758a23a13b3f4233b91ab0b69af6af01";
const speechRegion = "westus";
const typingPhrases = ["Thinking", "Looking into it", "Formulating a response", "Just a second"];
function ChatPage() {
  _s();
  const initialMessages = JSON.parse(localStorage.getItem("chatMessages")) || [];
  const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialMessages);
  const [userInput, setUserInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("");
  const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [listening, setListening] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [showInfo, setShowInfo] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [showCopilotInfo, setShowCopilotInfo] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [scenario, setScenario] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
  const [isMuted, setIsMuted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [showTooltip, setShowTooltip] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [showWelcome, setShowWelcome] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);
  const [isConversationEnded, setIsConversationEnded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {
    return localStorage.getItem("isConversationEnded") === "true";
  });
  const [lastMessageAllowed, setLastMessageAllowed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
  const [typingPhrase, setTypingPhrase] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(typingPhrases[0]);
  const [notifications, setNotifications] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
  const [isInitialPosition, setIsInitialPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(true);
  const synthesizerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  const messagesEndRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    localStorage.setItem("chatMessages", JSON.stringify(messages));
    localStorage.setItem("isConversationEnded", isConversationEnded);
    scrollToBottom();
  }, [messages, isConversationEnded]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const storedScenario = localStorage.getItem("scenario");
    if (storedScenario) {
      setScenario(JSON.parse(storedScenario));
    } else {
      fetch("http://localhost:8000/api/scenario").then(res => res.json()).then(data => setScenario(data)).catch(err => console.error("Error fetching scenario:", err));
    }

    // Add welcome message if no messages exist
    if (messages.length === 0) {
      setMessages([{
        sender: "bot",
        text: "👋 Welcome! Before you start, click the ℹ️ info button (top right) to get key instructions.",
        isWelcome: true
      }]);
    }
  }, []);

  // Show tooltip when welcome message disappears
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (!messages.some(msg => msg.isWelcome)) {
      setShowTooltip(true);
      const timer = setTimeout(() => {
        setShowTooltip(false);
      }, 5000);
      return () => clearTimeout(timer);
    }
  }, [messages]);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    let phraseInterval;
    if (loading) {
      let phraseIndex = 0;
      setTypingPhrase(typingPhrases[phraseIndex]);
      phraseInterval = setInterval(() => {
        phraseIndex = (phraseIndex + 1) % typingPhrases.length;
        setTypingPhrase(typingPhrases[phraseIndex]);
      }, 5000);
    }
    return () => {
      if (phraseInterval) {
        clearInterval(phraseInterval);
      }
    };
  }, [loading]);
  const scrollToBottom = () => {
    var _messagesEndRef$curre;
    (_messagesEndRef$curre = messagesEndRef.current) === null || _messagesEndRef$curre === void 0 ? void 0 : _messagesEndRef$curre.scrollIntoView({
      behavior: "smooth"
    });
  };
  const speakResponse = text => {
    if (isMuted || !speechKey || !speechRegion || !text) return;
    const speechConfig = microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__.SpeechConfig.fromSubscription(speechKey, speechRegion);
    speechConfig.speechSynthesisVoiceName = "en-US-JennyNeural";
    const audioConfig = microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__.AudioConfig.fromDefaultSpeakerOutput();
    const synthesizer = new microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__.SpeechSynthesizer(speechConfig, audioConfig);
    synthesizerRef.current = synthesizer;
    synthesizer.speakTextAsync(text, () => {
      synthesizer.close();
      if (synthesizerRef.current === synthesizer) {
        synthesizerRef.current = null;
      }
    }, err => {
      console.error("Speech synthesis error:", err);
      synthesizer.close();
      if (synthesizerRef.current === synthesizer) {
        synthesizerRef.current = null;
      }
    });
  };
  const toggleMute = () => {
    const newMuteState = !isMuted;
    setIsMuted(newMuteState);
    if (newMuteState && synthesizerRef.current) {
      synthesizerRef.current.stopSpeakingAsync(() => {
        synthesizerRef.current.close();
        synthesizerRef.current = null;
        console.log("Bot silenciado manualmente.");
      }, err => {
        var _synthesizerRef$curre;
        console.error("Error al detener voz:", err);
        (_synthesizerRef$curre = synthesizerRef.current) === null || _synthesizerRef$curre === void 0 ? void 0 : _synthesizerRef$curre.close();
        synthesizerRef.current = null;
      });
    }
  };
  const recognizeSpeech = async () => {
    if (!speechKey || !speechRegion) return;
    setListening(true);
    const speechConfig = microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__.SpeechConfig.fromSubscription(speechKey, speechRegion);
    speechConfig.speechRecognitionLanguage = "en-US";
    const audioConfig = microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__.AudioConfig.fromDefaultMicrophoneInput();
    const recognizer = new microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__.SpeechRecognizer(speechConfig, audioConfig);
    recognizer.recognizeOnceAsync(result => {
      setListening(false);
      if (result.reason === microsoft_cognitiveservices_speech_sdk__WEBPACK_IMPORTED_MODULE_3__.ResultReason.RecognizedSpeech) {
        setUserInput(prev => `${prev} ${result.text}`.trim());
      } else {
        console.error("Speech not recognized.");
      }
      recognizer.close();
    }, err => {
      setListening(false);
      console.error("Speech recognition error:", err);
      recognizer.close();
    });
  };
  const addNotification = (message, type = 'info') => {
    const id = Date.now();
    setNotifications(prev => [...prev, {
      id,
      message,
      type
    }]);
    setTimeout(() => {
      setNotifications(prev => prev.filter(notification => notification.id !== id));
    }, 5000);
  };
  const sendMessage = async e => {
    e.preventDefault();
    if (!userInput.trim() || loading) return;

    // Remove welcome message and move input container when sending first message
    if (messages.length === 1 && messages[0].isWelcome) {
      setMessages([]);
      setIsInitialPosition(false);
    }
    const newMessage = {
      sender: "user",
      text: userInput
    };
    setMessages(prev => [...prev, newMessage]);
    setLoading(true);
    setUserInput("");
    try {
      const res = await fetch("http://localhost:8000/api/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          text: userInput,
          phase: "exploration"
        })
      });
      const data = await res.json();

      // Check for business goals and feedback in the response
      const responseLower = data.response.toLowerCase();
      console.log("Checking response for banners:", responseLower);
      if (responseLower.includes("demo") || responseLower.includes("show me")) {
        console.log("Demo detected - showing success banner");
        addNotification("🎯 Business goal achieved: User requested a demo", "success");
      }
      if (responseLower.includes("feedback") || responseLower.includes("helpful") || responseLower.includes("using it")) {
        console.log("Feedback detected - showing info banner");
        addNotification("📝 Customer feedback noted: Product insights gathered", "info");
      }
      if (responseLower.includes("not ready") || responseLower.includes("later")) {
        console.log("Not ready detected - showing warning banner");
        addNotification("📝 Customer feedback noted: They're not ready to buy yet", "warning");
      }

      // Check if the response indicates conversation end
      if (data.phase && (data.phase.includes("closure") || data.phase === "Conversation End")) {
        if (!lastMessageAllowed) {
          setLastMessageAllowed(true);
        } else {
          setIsConversationEnded(true);
        }
      }
      setMessages(prev => [...prev, {
        sender: "bot",
        text: data.response
      }]);
      speakResponse(data.response);
    } catch (err) {
      console.error("Error connecting to backend:", err);
      setMessages(prev => [...prev, {
        sender: "bot",
        text: "Error connecting to the backend."
      }]);
    }
    setLoading(false);
  };
  const navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_4__.useNavigate)();
  const handleFeedbackClick = () => {
    navigate("/feedback");
  };
  const handleReset = () => {
    setMessages([]);
    setIsConversationEnded(false);
    setLastMessageAllowed(false);
    localStorage.removeItem("chatMessages");
    localStorage.removeItem("isConversationEnded");
  };
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
    className: "chat-container",
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
      className: "notification-container",
      children: notifications.map(notification => /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: `notification-banner ${notification.type}`,
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("span", {
          className: "notification-icon",
          children: notification.message.split(' ')[0]
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 259,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("span", {
          className: "notification-message",
          children: notification.message
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 260,
          columnNumber: 13
        }, this)]
      }, notification.id, true, {
        fileName: _jsxFileName,
        lineNumber: 258,
        columnNumber: 11
      }, this))
    }, void 0, false, {
      fileName: _jsxFileName,
      lineNumber: 256,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
      className: "chat-header",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "chat-header-left",
        children: scenario && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("h3", {
          className: "scenario-title",
          children: "Copilot Welcome"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 267,
          columnNumber: 24
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 266,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "chat-header-center",
        children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("h2", {
          className: "chat-title",
          children: "GigPlus Support Chat Simulation"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 271,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 270,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "chat-header-right",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
          className: `mute-button ${isMuted ? 'muted' : ''}`,
          onClick: toggleMute,
          title: isMuted ? "Unmute" : "Mute",
          children: isMuted ? "🔇" : "🔊"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 275,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
          className: "info-button-container",
          children: [showTooltip && !messages.some(msg => msg.isWelcome) && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
            className: "info-tooltip",
            children: "\uD83D\uDC49 Need to recall the task?"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 284,
            columnNumber: 15
          }, this), !messages.some(msg => msg.isWelcome) && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
            className: "info-button",
            onClick: () => setShowInfo(true),
            children: "i"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 289,
            columnNumber: 15
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 282,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 274,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 265,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
      className: "messages-container",
      children: [messages.map((msg, idx) => /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: `message ${msg.sender === "user" ? "user-message" : "bot-message"}`,
        "data-welcome": msg.isWelcome ? "true" : "false",
        children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
          className: "message-content",
          children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("p", {
            children: [msg.text, msg.isWelcome && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
              className: "welcome-info-button",
              onClick: () => setShowInfo(true),
              title: "Show instructions",
              children: "i"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 306,
              columnNumber: 19
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 303,
            columnNumber: 15
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 302,
          columnNumber: 13
        }, this)
      }, idx, false, {
        fileName: _jsxFileName,
        lineNumber: 297,
        columnNumber: 11
      }, this)), loading && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "message bot-message",
        children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
          className: "typing-indicator",
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("span", {
            className: "typing-text",
            children: "Typing"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 321,
            columnNumber: 15
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("span", {
            className: "typing-dots"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 322,
            columnNumber: 15
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 320,
          columnNumber: 13
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 319,
        columnNumber: 11
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        ref: messagesEndRef
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 326,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 295,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("form", {
      className: `input-container ${isInitialPosition ? 'initial-position' : 'moved'}`,
      onSubmit: sendMessage,
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "copilot-logo-container",
        children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("img", {
          src: "/copilot_logo.png",
          alt: "Copilot Logo",
          className: "copilot-logo",
          onClick: () => setShowCopilotInfo(true)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 334,
          columnNumber: 11
        }, this)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 333,
        columnNumber: 9
      }, this), !isConversationEnded ? /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("input", {
          type: "text",
          className: "message-input",
          value: userInput,
          onChange: e => setUserInput(e.target.value),
          placeholder: loading ? "Waiting for response..." : "Type your message...",
          disabled: loading
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 343,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
          type: "button",
          className: `voice-button ${listening ? 'listening' : ''}`,
          onClick: recognizeSpeech,
          disabled: loading || listening,
          children: listening ? 'Recording' : 'Speak'
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 351,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
          type: "submit",
          className: "send-button",
          disabled: loading,
          children: "Send"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 359,
          columnNumber: 13
        }, this)]
      }, void 0, true) : /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "conversation-ended-message",
        children: "Conversation ended. Thank you for your time!"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 368,
        columnNumber: 11
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
        type: "button",
        className: "feedback-button",
        onClick: handleFeedbackClick,
        children: "Feedback"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 372,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 329,
      columnNumber: 7
    }, this), showCopilotInfo && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "popup-overlay",
        onClick: () => setShowCopilotInfo(false)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 383,
        columnNumber: 11
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "popup",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("h3", {
          children: "Chat Controls"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 385,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("ul", {
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("li", {
            children: ["\uD83C\uDFA4 ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "Speak:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 387,
              columnNumber: 22
            }, this), " Write your message by voice"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 387,
            columnNumber: 15
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("li", {
            children: ["\uD83D\uDCDD ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "Send:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 388,
              columnNumber: 22
            }, this), " Send your message"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 388,
            columnNumber: 15
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("li", {
            children: ["\uD83D\uDCCA ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "Feedback:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 389,
              columnNumber: 22
            }, this), " Go to feedback page"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 389,
            columnNumber: 15
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("li", {
            children: ["\u2139\uFE0F ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "Info:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 390,
              columnNumber: 22
            }, this), " Show chat objectives"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 390,
            columnNumber: 15
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("li", {
            children: ["\uD83D\uDD0A ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "Mute:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 391,
              columnNumber: 22
            }, this), " Toggle bot voice"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 391,
            columnNumber: 15
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 386,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
          onClick: () => setShowCopilotInfo(false),
          className: "popup-close-button",
          children: "Close"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 393,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 384,
        columnNumber: 11
      }, this)]
    }, void 0, true), showInfo && scenario && /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "popup-overlay",
        onClick: () => setShowInfo(false)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 402,
        columnNumber: 11
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("div", {
        className: "popup",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("h3", {
          children: "Scenario Information"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 404,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("ul", {
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("li", {
            children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "Title:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 406,
              columnNumber: 19
            }, this), " Microsoft Copilot Satisfaction Check"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 406,
            columnNumber: 15
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("li", {
            children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "\u2022 Your role:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 407,
              columnNumber: 19
            }, this), " You are a Copilot Welcome Ambassador", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("br", {}, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 407,
              columnNumber: 85
            }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "\u2022 Case History:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 407,
              columnNumber: 91
            }, this), " You have been in touch with Rachel via email, and she agreed to a short call", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("p", {}, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 407,
              columnNumber: 200
            }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("strong", {
              children: "\u2022 Your goals:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 407,
              columnNumber: 204
            }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("br", {}, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 407,
              columnNumber: 234
            }, this), "\u2022 Have a product led growth conversation with Rachel", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("br", {}, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 407,
              columnNumber: 292
            }, this), "\u2022 Gather Copilot product insights"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 407,
            columnNumber: 15
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 405,
          columnNumber: 13
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxDEV)("button", {
          onClick: () => setShowInfo(false),
          className: "popup-close-button",
          children: "Close"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 409,
          columnNumber: 13
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 403,
        columnNumber: 11
      }, this)]
    }, void 0, true)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 255,
    columnNumber: 5
  }, this);
}
_s(ChatPage, "F/ydUSvq10a7AyrAcje88u1FlAk=", false, function () {
  return [react_router_dom__WEBPACK_IMPORTED_MODULE_4__.useNavigate];
});
_c = ChatPage;
var _c;
__webpack_require__.$Refresh$.register(_c, "ChatPage");

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/components/FeedbackPage.css":
/*!*****************************************!*\
  !*** ./src/components/FeedbackPage.css ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./FeedbackPage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/FeedbackPage.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./FeedbackPage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/FeedbackPage.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./FeedbackPage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/FeedbackPage.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_FeedbackPage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/components/FeedbackPage.js":
/*!****************************************!*\
  !*** ./src/components/FeedbackPage.js ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FeedbackPage)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-GNGMS2XR.mjs");
/* harmony import */ var _services_feedbackService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/feedbackService.js */ "./src/services/feedbackService.js");
/* harmony import */ var _services_submitConversationToSupabase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../services/submitConversationToSupabase.js */ "./src/services/submitConversationToSupabase.js");
/* harmony import */ var _FeedbackPage_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FeedbackPage.css */ "./src/components/FeedbackPage.css");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

var _jsxFileName = "/Users/shakers/Desktop/Multi Agent/multi-agent/frontend-react/src/components/FeedbackPage.js",
  _s = __webpack_require__.$Refresh$.signature();






function FeedbackPage() {
  _s();
  const [feedback, setFeedback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
  const navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useNavigate)();
  const routeLocation = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useLocation)();
  const effectRan = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    if (effectRan.current) return;
    effectRan.current = true;
    const timestamp = new Date().getTime();
    const path = routeLocation.pathname;
    const sessionId = btoa(`${path}_${timestamp}`).slice(0, 32);
    const feedbackKey = `feedback_sent_${sessionId}`;
    const conversationKey = `conversation_sent_${sessionId}`;
    const feedbackAlreadySent = localStorage.getItem(feedbackKey);
    const conversationAlreadySent = localStorage.getItem(conversationKey);
    const storedMessages = localStorage.getItem("chatMessages");
    const conversation = storedMessages ? JSON.parse(storedMessages) : [];
    if (feedbackAlreadySent && conversationAlreadySent) {
      console.log("✅ Feedback y conversación ya enviados para esta sesión");
      return;
    }
    fetch("http://localhost:8000/api/feedback/structured").then(res => res.json()).then(data => {
      console.log("Structured feedback received:", data);
      setFeedback(data);
      if (data !== null && data !== void 0 && data.metrics) {
        (0,_services_feedbackService_js__WEBPACK_IMPORTED_MODULE_1__.submitFeedbackToSupabase)({
          ...data,
          sessionId
        }).then(feedbackId => {
          localStorage.setItem(feedbackKey, "true");
          if (feedbackId && conversation.length > 0 && !conversationAlreadySent) {
            (0,_services_submitConversationToSupabase_js__WEBPACK_IMPORTED_MODULE_2__.submitConversationToSupabase)(feedbackId, conversation).then(() => {
              localStorage.setItem(conversationKey, "true");
            });
          }
        });
      }
    }).catch(err => {
      console.error("❌ Error fetching feedback:", err);
      setFeedback({
        error: "Error fetching feedback."
      });
    });
  }, [routeLocation.pathname]);
  const renderSection = (title, items, icon, colorClass) => {
    if (!Array.isArray(items) || items.length === 0) return null;
    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: `feedback-card ${colorClass}`,
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "card-header",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
          className: "card-icon",
          children: icon
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 71,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h3", {
          children: title
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 72,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 70,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("ul", {
        className: "feedback-list",
        children: items.map((item, idx) => /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("li", {
          children: item
        }, idx, false, {
          fileName: _jsxFileName,
          lineNumber: 76,
          columnNumber: 13
        }, this))
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 74,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 69,
      columnNumber: 7
    }, this);
  };
  const renderTrainingSection = () => {
    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: "feedback-card training-card",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "card-header",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
          className: "card-icon",
          children: "\uD83C\uDF93"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 87,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h3", {
          children: "Training Recommendations"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 88,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 86,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("ul", {
        className: "feedback-list",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("li", {
          children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("a", {
            href: "https://learn.microsoft.com/en-us/training/paths/get-started-with-microsoft-365-copilot/",
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Get started with Microsoft 365 Copilot"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 92,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 91,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("li", {
          children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("a", {
            href: "https://learn.microsoft.com/en-us/training/modules/get-started-microsoft-365-copilot-business-chat/",
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Get started with Microsoft 365 Copilot Chat"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 99,
            columnNumber: 13
          }, this)
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 98,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 90,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 7
    }, this);
  };
  const renderOverallScore = (metrics, customScore) => {
    // If customScore exists, use that value, otherwise use the original calculation
    if (customScore !== undefined && customScore !== null) {
      // Determine message based on score
      let scoreMessage = "";
      let emoji = "";
      if (customScore >= 90) {
        scoreMessage = "Excellent job! Your conversation was outstanding.";
        emoji = "🏆";
      } else if (customScore >= 80) {
        scoreMessage = "Great work! Your conversation skills are impressive.";
        emoji = "🌟";
      } else if (customScore >= 70) {
        scoreMessage = "Good job! You're on the right track.";
        emoji = "👍";
      } else if (customScore >= 60) {
        scoreMessage = "Not bad! With a few improvements, you'll do even better.";
        emoji = "🔍";
      } else {
        scoreMessage = "There's room for improvement. Review the suggestions below.";
        emoji = "📝";
      }

      // Render with custom score
      return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "feedback-score-card",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
          className: "score-header",
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h2", {
            children: ["Conversation Performance", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
              className: "custom-score-indicator",
              children: "*"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 140,
              columnNumber: 15
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 138,
            columnNumber: 13
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
            className: "score-emoji",
            children: emoji
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 142,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 137,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
          className: "score-content",
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
            className: "score-value",
            children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
              className: "score-number",
              children: customScore
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 146,
              columnNumber: 15
            }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
              className: "score-max",
              children: "/100"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 147,
              columnNumber: 15
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 145,
            columnNumber: 13
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
            className: "score-message",
            children: scoreMessage
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 149,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 144,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 136,
        columnNumber: 9
      }, this);
    } else {
      // Original behavior as fallback
      if (!metrics || typeof metrics !== "object") return null;
      const values = Object.values(metrics);
      if (!values.length) return null;
      const average = (values.reduce((acc, v) => acc + v, 0) / values.length).toFixed(1);

      // Determine message using the original scale
      let scoreMessage = "";
      let emoji = "";
      if (average >= 4.5) {
        scoreMessage = "Excellent job! Your conversation was outstanding.";
        emoji = "🏆";
      } else if (average >= 4.0) {
        scoreMessage = "Great work! Your conversation skills are impressive.";
        emoji = "🌟";
      } else if (average >= 3.5) {
        scoreMessage = "Good job! You're on the right track.";
        emoji = "👍";
      } else if (average >= 3.0) {
        scoreMessage = "Not bad! With a few improvements, you'll do even better.";
        emoji = "🔍";
      } else {
        scoreMessage = "There's room for improvement. Review the suggestions below.";
        emoji = "📝";
      }

      // Render with original score
      return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "feedback-score-card",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
          className: "score-header",
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h2", {
            children: "Conversation Performance"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 187,
            columnNumber: 13
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
            className: "score-emoji",
            children: emoji
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 188,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 186,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
          className: "score-content",
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
            className: "score-value",
            children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
              className: "score-number",
              children: average
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 192,
              columnNumber: 15
            }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
              className: "score-max",
              children: "/5"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 193,
              columnNumber: 15
            }, this)]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 191,
            columnNumber: 13
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
            className: "score-message",
            children: scoreMessage
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 195,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 190,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 185,
        columnNumber: 9
      }, this);
    }
  };
  if (!feedback) {
    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: "feedback-loading",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "spinner"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 205,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
        children: "Hang tight, we're analyzing your conversation to generate feedback."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 206,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "loading-facts",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h4", {
          children: "Did you know?"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 208,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
          children: "AI-powered feedback analysis can help improve your customer service skills by up to 30%!"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 209,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 207,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 204,
      columnNumber: 7
    }, this);
  }
  if (feedback.error) return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
    className: "feedback-error",
    children: feedback.error
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 215,
    columnNumber: 30
  }, this);
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
    className: "feedback-page",
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: "feedback-header",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h1", {
        children: "Your Conversation Feedback"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 220,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
        className: "feedback-intro",
        children: "Here's a detailed analysis of your conversation. Use these insights to improve your future interactions."
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 221,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 219,
      columnNumber: 7
    }, this), renderOverallScore(feedback.metrics, feedback.custom_score), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: "feedback-sections",
      children: [renderSection("Key Strengths", feedback.strength, "💪", "strength-card"), renderSection("Improvement Suggestions", feedback.suggestions, "💡", "suggestion-card"), renderSection("Issues to Address", feedback.issues, "⚠️", "issue-card"), renderTrainingSection()]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 228,
      columnNumber: 7
    }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: "feedback-actions",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
        onClick: () => navigate("/chat"),
        className: "action-button chat-button",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
          className: "button-icon",
          children: "\uD83D\uDCAC"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 237,
          columnNumber: 11
        }, this), " Back to Chat"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 236,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
        onClick: () => navigate("/"),
        className: "action-button home-button",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
          className: "button-icon",
          children: "\uD83C\uDFE0"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 240,
          columnNumber: 11
        }, this), " Back to Lobby"]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 239,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 235,
      columnNumber: 7
    }, this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 218,
    columnNumber: 5
  }, this);
}
_s(FeedbackPage, "T80YF3Sk19/uA+8XEc484A/fmtU=", false, function () {
  return [react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useNavigate, react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useLocation];
});
_c = FeedbackPage;
var _c;
__webpack_require__.$Refresh$.register(_c, "FeedbackPage");

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/components/HomePage.css":
/*!*************************************!*\
  !*** ./src/components/HomePage.css ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./HomePage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/HomePage.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./HomePage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/HomePage.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../../node_modules/source-map-loader/dist/cjs.js!./HomePage.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/components/HomePage.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_HomePage_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/components/HomePage.js":
/*!************************************!*\
  !*** ./src/components/HomePage.js ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ HomePage)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-router-dom */ "./node_modules/react-router/dist/development/chunk-GNGMS2XR.mjs");
/* harmony import */ var _background_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../background.png */ "./src/background.png");
/* harmony import */ var _HomePage_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HomePage.css */ "./src/components/HomePage.css");
/* harmony import */ var _GIG_png__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../GIG+.png */ "./src/GIG+.png");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

var _jsxFileName = "/Users/shakers/Desktop/Multi Agent/multi-agent/frontend-react/src/components/HomePage.js",
  _s = __webpack_require__.$Refresh$.signature();






function HomePage() {
  _s();
  const navigate = (0,react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useNavigate)();
  const [loadingStates, setLoadingStates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({
    welcome: false,
    copilot: false
  });
  const handleStartSimulation = scenarioType => {
    setLoadingStates(prev => ({
      ...prev,
      [scenarioType]: true
    }));
    if (scenarioType === 'copilot') {
      localStorage.setItem('scenarioType', 'copilot');
      navigate("/copilot-chat");
    } else {
      fetch("http://localhost:8000/api/reset", {
        method: "POST"
      }).then(() => {
        localStorage.removeItem("chatMessages");
        localStorage.removeItem("isConversationEnded");
        navigate("/chat");
      }).catch(err => {
        console.error("Error starting new simulation:", err);
        setLoadingStates(prev => ({
          ...prev,
          [scenarioType]: false
        }));
      });
    }
  };
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
    className: "home-background",
    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: "home-container",
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "home-title-row",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("img", {
          src: _GIG_png__WEBPACK_IMPORTED_MODULE_3__,
          alt: "GigPlus logo",
          className: "home-logo-inline"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 44,
          columnNumber: 11
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h1", {
          className: "home-title",
          children: "GigPlus Customer Simulation"
        }, void 0, false, {
          fileName: _jsxFileName,
          lineNumber: 45,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 43,
        columnNumber: 9
      }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        className: "scenarios-container",
        children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
          className: "scenario-card",
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h2", {
            children: "Copilot Welcome"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 50,
            columnNumber: 11
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
            children: "Customer is already using Microsoft 365 and wants to get the most out of Copilot."
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 51,
            columnNumber: 11
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
            children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("strong", {
              children: "Difficulty:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 52,
              columnNumber: 14
            }, this), " Intermediate"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 52,
            columnNumber: 11
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
            className: "start-button",
            onClick: () => handleStartSimulation('welcome'),
            disabled: loadingStates.welcome || loadingStates.copilot,
            style: {
              display: "flex",
              alignItems: "center",
              gap: "0.5rem"
            },
            children: loadingStates.welcome ? /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {
              children: ["Starting simulation... ", /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
                className: "spinner"
              }, void 0, false, {
                fileName: _jsxFileName,
                lineNumber: 62,
                columnNumber: 40
              }, this)]
            }, void 0, true) : "Start Simulation"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 54,
            columnNumber: 11
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 49,
          columnNumber: 9
        }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
          className: "scenario-card",
          children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("h2", {
            children: "Copilot Chat"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 71,
            columnNumber: 13
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
            children: "Interactive chat scenario with predefined responses."
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 72,
            columnNumber: 13
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("p", {
            children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("strong", {
              children: "Difficulty:"
            }, void 0, false, {
              fileName: _jsxFileName,
              lineNumber: 73,
              columnNumber: 16
            }, this), " Easy"]
          }, void 0, true, {
            fileName: _jsxFileName,
            lineNumber: 73,
            columnNumber: 13
          }, this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
            className: "start-button",
            disabled: true,
            style: {
              display: "flex",
              alignItems: "center",
              gap: "0.5rem",
              opacity: 0.5
            },
            children: "Coming Soon"
          }, void 0, false, {
            fileName: _jsxFileName,
            lineNumber: 75,
            columnNumber: 13
          }, this)]
        }, void 0, true, {
          fileName: _jsxFileName,
          lineNumber: 70,
          columnNumber: 11
        }, this)]
      }, void 0, true, {
        fileName: _jsxFileName,
        lineNumber: 48,
        columnNumber: 9
      }, this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 7
    }, this)
  }, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 41,
    columnNumber: 5
  }, this);
}
_s(HomePage, "P4P6slY1f30bbW9I+nWnStvFj3w=", false, function () {
  return [react_router_dom__WEBPACK_IMPORTED_MODULE_5__.useNavigate];
});
_c = HomePage;
var _c;
__webpack_require__.$Refresh$.register(_c, "HomePage");

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/index.css":
/*!***********************!*\
  !*** ./src/index.css ***!
  \***********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../node_modules/source-map-loader/dist/cjs.js!./index.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);


if (true) {
  if (!_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
  if (!a && b || a && !b) {
    return false;
  }
  var p;
  for (p in a) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (p in b) {
    if (isNamedExport && p === "default") {
      // eslint-disable-next-line no-continue
      continue;
    }
    if (!a[p]) {
      return false;
    }
  }
  return true;
};
    var isNamedExport = !_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;
    var oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

    module.hot.accept(
      /*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../node_modules/source-map-loader/dist/cjs.js!./index.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/index.css",
      __WEBPACK_OUTDATED_DEPENDENCIES__ => { /* harmony import */ _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!../node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!../node_modules/source-map-loader/dist/cjs.js!./index.css */ "./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[5].use[2]!./node_modules/source-map-loader/dist/cjs.js!./src/index.css");
(function () {
        if (!isEqualLocals(oldLocals, isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals, isNamedExport)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = isNamedExport ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ : _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals;

              update(_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"]);
      })(__WEBPACK_OUTDATED_DEPENDENCIES__); }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}



       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_1_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_1_oneOf_5_use_2_node_modules_source_map_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ "./node_modules/react-dom/client.js");
/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index.css */ "./src/index.css");
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./App */ "./src/App.js");
/* harmony import */ var _reportWebVitals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reportWebVitals */ "./src/reportWebVitals.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

var _jsxFileName = "/Users/shakers/Desktop/Multi Agent/multi-agent/frontend-react/src/index.js";







const root = react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot(document.getElementById('root'));
root.render(/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxDEV)((react__WEBPACK_IMPORTED_MODULE_0___default().StrictMode), {
  children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxDEV)(_App__WEBPACK_IMPORTED_MODULE_3__["default"], {}, void 0, false, {
    fileName: _jsxFileName,
    lineNumber: 12,
    columnNumber: 5
  }, undefined)
}, void 0, false, {
  fileName: _jsxFileName,
  lineNumber: 11,
  columnNumber: 3
}, undefined));

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
(0,_reportWebVitals__WEBPACK_IMPORTED_MODULE_4__["default"])();

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/lib/supabaseClient.js":
/*!***********************************!*\
  !*** ./src/lib/supabaseClient.js ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   supabase: () => (/* binding */ supabase)
/* harmony export */ });
/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ "../node_modules/@supabase/supabase-js/dist/module/index.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

// src/lib/supabaseClient.js

const supabaseUrl = "https://agqfnjfvwuxmriqahkmy.supabase.co";
const supabaseAnonKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFncWZuamZ2d3V4bXJpcWFoa215Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM2ODY1MjUsImV4cCI6MjA1OTI2MjUyNX0.jQcXTu-KOdv8RIxNJVEVt23-uehhuMkuvb7j9-De2Nk";
const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/reportWebVitals.js":
/*!********************************!*\
  !*** ./src/reportWebVitals.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    __webpack_require__.e(/*! import() */ "node_modules_web-vitals_dist_web-vitals_js").then(__webpack_require__.bind(__webpack_require__, /*! web-vitals */ "./node_modules/web-vitals/dist/web-vitals.js")).then(({
      getCLS,
      getFID,
      getFCP,
      getLCP,
      getTTFB
    }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reportWebVitals);

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/services/feedbackService.js":
/*!*****************************************!*\
  !*** ./src/services/feedbackService.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   submitFeedbackToSupabase: () => (/* binding */ submitFeedbackToSupabase)
/* harmony export */ });
/* harmony import */ var _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/supabaseClient */ "./src/lib/supabaseClient.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");


async function submitFeedbackToSupabase(feedback) {
  console.log('🔍 Iniciando submitFeedbackToSupabase...');
  const feedbackKey = `feedback_sent_${feedback.sessionId}`;
  const alreadySent = localStorage.getItem(feedbackKey);
  const vAccount = localStorage.getItem("v_account") || null;
  if (alreadySent) {
    console.log('⚠️ Feedback ya fue enviado anteriormente para esta sesión');
    return null;
  }
  const {
    data: {
      user
    }
  } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.auth.getUser();
  const rawEnv = "development";
  const isDev = rawEnv && rawEnv.toLowerCase() === 'development';
  const tableName = isDev ? 'feedback_dev' : 'feedback_prod';
  const {
    data,
    error
  } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(tableName).insert([{
    user_id: (user === null || user === void 0 ? void 0 : user.email) || null,
    v_account: vAccount,
    metrics: feedback.metrics,
    suggestions: feedback.suggestions,
    issues: feedback.issues
  }]).select('id'); // 👈 para obtener el ID del feedback insertado

  if (error || !(data !== null && data !== void 0 && data.length)) {
    console.error('❌ Error al enviar feedback:', error);
    return null;
  }
  const feedbackId = data[0].id;
  localStorage.setItem(feedbackKey, 'true');
  return feedbackId;
}

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "./src/services/submitConversationToSupabase.js":
/*!******************************************************!*\
  !*** ./src/services/submitConversationToSupabase.js ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   submitConversationToSupabase: () => (/* binding */ submitConversationToSupabase)
/* harmony export */ });
/* harmony import */ var _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/supabaseClient */ "./src/lib/supabaseClient.js");
/* provided dependency */ var __react_refresh_utils__ = __webpack_require__(/*! ./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js */ "./node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/runtime/RefreshUtils.js");
__webpack_require__.$Refresh$.runtime = __webpack_require__(/*! ./node_modules/react-refresh/runtime.js */ "./node_modules/react-refresh/runtime.js");

// src/services/submitConversationToSupabase.js

async function submitConversationToSupabase(feedbackId, messages) {
  const rawEnv = "development";
  const isDev = rawEnv && rawEnv.toLowerCase() === 'development';
  const tableName = isDev ? 'conversation_log_dev' : 'conversation_log';
  const {
    error
  } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_0__.supabase.from(tableName).insert([{
    feedback_id: feedbackId,
    messages
  }]);
  if (error) {
    console.error('❌ Error al guardar la conversación:', error);
  } else {
    console.log('✅ Conversación guardada con éxito');
  }
}

const $ReactRefreshModuleId$ = __webpack_require__.$Refresh$.moduleId;
const $ReactRefreshCurrentExports$ = __react_refresh_utils__.getModuleExports(
	$ReactRefreshModuleId$
);

function $ReactRefreshModuleRuntime$(exports) {
	if (true) {
		let errorOverlay;
		if (true) {
			errorOverlay = false;
		}
		let testMode;
		if (typeof __react_refresh_test__ !== 'undefined') {
			testMode = __react_refresh_test__;
		}
		return __react_refresh_utils__.executeRuntime(
			exports,
			$ReactRefreshModuleId$,
			module.hot,
			errorOverlay,
			testMode
		);
	}
}

if (typeof Promise !== 'undefined' && $ReactRefreshCurrentExports$ instanceof Promise) {
	$ReactRefreshCurrentExports$.then($ReactRefreshModuleRuntime$);
} else {
	$ReactRefreshModuleRuntime$($ReactRefreshCurrentExports$);
}

/***/ }),

/***/ "?3dbe":
/*!********************!*\
  !*** ws (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?540f":
/*!*********************!*\
  !*** net (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?71f6":
/*!*********************!*\
  !*** tls (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?875c":
/*!****************************!*\
  !*** agent-base (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?a523":
/*!***********************************!*\
  !*** https-proxy-agent (ignored) ***!
  \***********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?c417":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?f824":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 		__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 		module = execOptions.module;
/******/ 		execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "static/js/" + chunkId + ".chunk.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	(() => {
/******/ 		__webpack_require__.hmrF = () => ("main." + __webpack_require__.h() + ".hot-update.json");
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	(() => {
/******/ 		__webpack_require__.h = () => ("483c1995b379b222ddf3")
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "frontend-react:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	(() => {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId, fetchPriority) {
/******/ 				return trackBlockingPromise(require.e(chunkId, fetchPriority));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				// inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results).then(function () {});
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							}, [])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								}
/******/ 								return setStatus("ready").then(function () {
/******/ 									return updatedModules;
/******/ 								});
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "/";
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	(() => {
/******/ 		__webpack_require__.i.push((options) => {
/******/ 			const originalFactory = options.factory;
/******/ 			options.factory = function (moduleObject, moduleExports, webpackRequire) {
/******/ 				__webpack_require__.$Refresh$.setup(options.id);
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					if (typeof Promise !== 'undefined' && moduleObject.exports instanceof Promise) {
/******/ 						options.module.exports = options.module.exports.then(
/******/ 							(result) => {
/******/ 								__webpack_require__.$Refresh$.cleanup(options.id);
/******/ 								return result;
/******/ 							},
/******/ 							(reason) => {
/******/ 								__webpack_require__.$Refresh$.cleanup(options.id);
/******/ 								return Promise.reject(reason);
/******/ 							}
/******/ 						);
/******/ 					} else {
/******/ 						__webpack_require__.$Refresh$.cleanup(options.id)
/******/ 					}
/******/ 				}
/******/ 			};
/******/ 		})
/******/ 		
/******/ 		__webpack_require__.$Refresh$ = {
/******/ 			register: () => (undefined),
/******/ 			signature: () => ((type) => (type)),
/******/ 			runtime: {
/******/ 				createSignatureFunctionForTransform: () => ((type) => (type)),
/******/ 				register: () => (undefined)
/******/ 			},
/******/ 			setup: (currentModuleId) => {
/******/ 				const prevModuleId = __webpack_require__.$Refresh$.moduleId;
/******/ 				const prevRegister = __webpack_require__.$Refresh$.register;
/******/ 				const prevSignature = __webpack_require__.$Refresh$.signature;
/******/ 				const prevCleanup = __webpack_require__.$Refresh$.cleanup;
/******/ 		
/******/ 				__webpack_require__.$Refresh$.moduleId = currentModuleId;
/******/ 		
/******/ 				__webpack_require__.$Refresh$.register = (type, id) => {
/******/ 					const typeId = currentModuleId + " " + id;
/******/ 					__webpack_require__.$Refresh$.runtime.register(type, typeId);
/******/ 				}
/******/ 		
/******/ 				__webpack_require__.$Refresh$.signature = () => (__webpack_require__.$Refresh$.runtime.createSignatureFunctionForTransform());
/******/ 		
/******/ 				__webpack_require__.$Refresh$.cleanup = (cleanupModuleId) => {
/******/ 					if (currentModuleId === cleanupModuleId) {
/******/ 						__webpack_require__.$Refresh$.moduleId = prevModuleId;
/******/ 						__webpack_require__.$Refresh$.register = prevRegister;
/******/ 						__webpack_require__.$Refresh$.signature = prevSignature;
/******/ 						__webpack_require__.$Refresh$.cleanup = prevCleanup;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		var currentUpdatedModulesList;
/******/ 		var waitingUpdateResolves = {};
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			currentUpdatedModulesList = updatedModulesList;
/******/ 			return new Promise((resolve, reject) => {
/******/ 				waitingUpdateResolves[chunkId] = resolve;
/******/ 				// start update chunk loading
/******/ 				var url = __webpack_require__.p + __webpack_require__.hu(chunkId);
/******/ 				// create error before stack unwound to get useful stacktrace later
/******/ 				var error = new Error();
/******/ 				var loadingEnded = (event) => {
/******/ 					if(waitingUpdateResolves[chunkId]) {
/******/ 						waitingUpdateResolves[chunkId] = undefined
/******/ 						var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 						var realSrc = event && event.target && event.target.src;
/******/ 						error.message = 'Loading hot update chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 						error.name = 'ChunkLoadError';
/******/ 						error.type = errorType;
/******/ 						error.request = realSrc;
/******/ 						reject(error);
/******/ 					}
/******/ 				};
/******/ 				__webpack_require__.l(url, loadingEnded);
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		globalThis["webpackHotUpdatefrontend_react"] = (chunkId, moreModules, runtime) => {
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					currentUpdate[moduleId] = moreModules[moduleId];
/******/ 					if(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);
/******/ 				}
/******/ 			}
/******/ 			if(runtime) currentUpdateRuntime.push(runtime);
/******/ 			if(waitingUpdateResolves[chunkId]) {
/******/ 				waitingUpdateResolves[chunkId]();
/******/ 				waitingUpdateResolves[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result = newModuleFactory
/******/ 						? getAffectedModuleEffects(moduleId)
/******/ 						: {
/******/ 								type: "disposed",
/******/ 								moduleId: moduleId
/******/ 							};
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err1) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err1,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err1);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.jsonp = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.jsonpHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = () => {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = globalThis["webpackChunkfrontend_react"] = globalThis["webpackChunkfrontend_react"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	__webpack_require__("./node_modules/@pmmmwh/react-refresh-webpack-plugin/client/ReactRefreshEntry.js");
/******/ 	__webpack_require__("./node_modules/webpack-dev-server/client/index.js?protocol=ws%3A&hostname=0.0.0.0&port=3000&pathname=%2Fws&logging=none&overlay=%7B%22errors%22%3Atrue%2C%22warnings%22%3Afalse%7D&reconnect=10&hot=true&live-reload=true");
/******/ 	__webpack_require__("./node_modules/webpack/hot/dev-server.js");
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;
//# sourceMappingURL=bundle.js.map